diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux/defs.mk phoneme_advanced-mr2-dev-b122/cdc/build/linux/defs.mk
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux/defs.mk	2009-07-06 18:35:04.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux/defs.mk	2009-07-06 19:48:31.000000000 -0400
@@ -57,6 +57,9 @@
 	$(CVM_TARGETROOT)/native/java/lang \
 	$(CVM_TARGETROOT)/native/java/io \
 	$(CVM_TARGETROOT)/native/java/net \
+	$(CVM_TARGETROOT)/native/sun/nio \
+	$(CVM_TARGETROOT)/native/sun/nio/ch \
+	$(CVM_TARGETROOT)/native/java/nio
 
 CVM_INCLUDE_DIRS  += \
 	$(CVM_TOP)/src \
@@ -86,6 +89,20 @@
 	globals_md.o \
 	java_props_md.o \
 	memory_md.o \
+        FileChannelImpl.o \
+        FileDispatcher.o \
+        FileKey.o \
+        IOUtil.o \
+        MappedByteBuffer.o \
+        Net.o \
+        ServerSocketChannelImpl.o \
+        SocketChannelImpl.o \
+        SocketDispatcher.o \
+        PollArrayWrapper.o \
+        EPollArrayWrapper.o \
+        InheritedChannel.o \
+        NativeThread.o \
+        Bits.o
 
 #
 # On linux, USE_JUMP=true if and only if CVM_MTASK=true
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/buildscript.sh phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/buildscript.sh
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/buildscript.sh	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/buildscript.sh	2009-07-29 19:01:48.000000000 -0400
@@ -0,0 +1,3 @@
+make J2ME_CLASSLIB=foundation CVM_PRELOAD_LIB=true CVM_TARGET_TOOLS_PREFIX=mipsel-unknown-linux-gnu- CVM_COMPILER_INCOMPATIBLE=false CVM_DEBUG_DUMPSTACK=true 
+#USE_JSR_172=true USE_JUMP=false 
+# CVM_JVMTI=true
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/builtinsage/KeyEvent.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/builtinsage/KeyEvent.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/builtinsage/KeyEvent.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/builtinsage/KeyEvent.java	2010-05-15 14:00:05.000000000 -0400
@@ -0,0 +1,1130 @@
+/*
+ * Copyright 1996-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.event;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+
+/**
+ * An event which indicates that a keystroke occurred in a component.
+ * <p>
+ * This low-level event is generated by a component object (such as a text
+ * field) when a key is pressed, released, or typed.
+ * The event is passed to every <code>KeyListener</code>
+ * or <code>KeyAdapter</code> object which registered to receive such
+ * events using the component's <code>addKeyListener</code> method.
+ * (<code>KeyAdapter</code> objects implement the
+ * <code>KeyListener</code> interface.)  Each such listener object
+ * gets this <code>KeyEvent</code> when the event occurs.
+ * <p>
+ * <em>"Key typed" events</em> are higher-level and generally do not depend on
+ * the platform or keyboard layout.  They are generated when a Unicode character
+ * is entered, and are the preferred way to find out about character input.
+ * In the simplest case, a key typed event is produced by a single key press
+ * (e.g., 'a').  Often, however, characters are produced by series of key
+ * presses (e.g., 'shift' + 'a'), and the mapping from key pressed events to
+ * key typed events may be many-to-one or many-to-many.  Key releases are not
+ * usually necessary to generate a key typed event, but there are some cases
+ * where the key typed event is not generated until a key is released (e.g.,
+ * entering ASCII sequences via the Alt-Numpad method in Windows).
+ * No key typed events are generated for keys that don't generate Unicode
+ * characters (e.g., action keys, modifier keys, etc.).
+ * <p>
+ * The getKeyChar method always returns a valid Unicode character or
+ * CHAR_UNDEFINED.  Character input is reported by KEY_TYPED events:
+ * KEY_PRESSED and KEY_RELEASED events are not necessarily associated
+ * with character input.  Therefore, the result of the getKeyChar method
+ * is guaranteed to be meaningful only for KEY_TYPED events.
+ * <p>
+ * For key pressed and key released events, the getKeyCode method returns
+ * the event's keyCode.  For key typed events, the getKeyCode method
+ * always returns {@code VK_UNDEFINED}. The {@code getExtendedKeyCode} method
+ * may also be used with many international keyboard layouts.
+ *
+ * <p>
+ * <em>"Key pressed" and "key released" events</em> are lower-level and depend
+ * on the platform and keyboard layout. They are generated whenever a key is
+ * pressed or released, and are the only way to find out about keys that don't
+ * generate character input (e.g., action keys, modifier keys, etc.). The key
+ * being pressed or released is indicated by the {@code getKeyCode} and {@code getExtendedKeyCode}
+ * methods, which return a virtual key code.
+ *
+ * <p>
+ * <em>Virtual key codes</em> are used to report which keyboard key has
+ * been pressed, rather than a character generated by the combination
+ * of one or more keystrokes (such as "A", which comes from shift and "a").
+ *
+ * <p>
+ * For example, pressing the Shift key will cause a KEY_PRESSED event
+ * with a VK_SHIFT keyCode, while pressing the 'a' key will result in
+ * a VK_A keyCode.  After the 'a' key is released, a KEY_RELEASED event
+ * will be fired with VK_A. Separately, a KEY_TYPED event with a keyChar
+ * value of 'A' is generated.
+ *
+ * <p>
+ * Pressing and releasing a key on the keyboard results in the generating
+ * the following key events (in order):
+ * <PRE>
+ *    {@code KEY_PRESSED}
+ *    {@code KEY_TYPED} (is only generated if a valid Unicode character could be generated.)
+ *    {@code KEY_RELEASED}
+ * </PRE>
+ *
+ * But in some cases (e.g. auto-repeat or input method is activated) the order
+ * could be different (and platform dependent).
+ *
+ * <p>
+ * Notes:
+ * <ul>
+ * <li>Key combinations which do not result in Unicode characters, such as action
+ * keys like F1 and the HELP key, do not generate KEY_TYPED events.
+ * <li>Not all keyboards or systems are capable of generating all
+ * virtual key codes.  No attempt is made in Java to generate these keys
+ * artificially.
+ * <li>Virtual key codes do not identify a physical key: they depend on the
+ * platform and keyboard layout. For example, the key that generates VK_Q
+ * when using a U.S. keyboard layout will generate VK_A when using a French
+ * keyboard layout.
+ * <li>The key that generates {@code VK_Q} when using a U.S. keyboard layout also
+ * generates a unique code for Russian or Hebrew layout. There is no a
+ * {@code VK_} constant for these and many other codes in various layouts. These codes
+ * may be obtained by using {@code getExtendedKeyCode} and are used whenever
+ * a {@code VK_} constant is used.
+ * <li>Not all characters have a keycode associated with them.  For example,
+ * there is no keycode for the question mark because there is no keyboard
+ * for which it appears on the primary layer.
+ * <li>In order to support the platform-independent handling of action keys,
+ * the Java platform uses a few additional virtual key constants for functions
+ * that would otherwise have to be recognized by interpreting virtual key codes
+ * and modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES
+ * is returned instead of VK_CONVERT with the ALT modifier.
+ * <li>As specified in <a href="../doc-files/FocusSpec.html">Focus Specification</a>
+ * key events are dispatched to the focus owner by default.
+ * </ul>
+ *
+ * <p>
+ * WARNING: Aside from those keys that are defined by the Java language
+ * (VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_
+ * constants.  Sun reserves the right to change these values as needed
+ * to accomodate a wider range of keyboards in the future.
+ * <p>
+ * An unspecified behavior will be caused if the {@code id} parameter
+ * of any particular {@code KeyEvent} instance is not
+ * in the range from {@code KEY_FIRST} to {@code KEY_LAST}.
+ *
+ * @author Carl Quinn
+ * @author Amy Fowler
+ * @author Norbert Lindenberg
+ *
+ * @see KeyAdapter
+ * @see KeyListener
+ * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/keylistener.html">Tutorial: Writing a Key Listener</a>
+ *
+ * @since 1.1
+ */
+public class KeyEvent{
+
+    /**
+     * Stores the state of native event dispatching system
+     * - true, if when the event was created event proxying
+     *         mechanism was active
+     * - false, if it was inactive
+     * Used in Component.dispatchEventImpl to correctly dispatch
+     * events when proxy is active
+     */
+    private boolean isProxyActive = false;
+
+    /**
+     * The first number in the range of ids used for key events.
+     */
+    public static final int KEY_FIRST = 400;
+
+    /**
+     * The last number in the range of ids used for key events.
+     */
+    public static final int KEY_LAST  = 402;
+
+    /**
+     * The "key typed" event.  This event is generated when a character is
+     * entered.  In the simplest case, it is produced by a single key press.
+     * Often, however, characters are produced by series of key presses, and
+     * the mapping from key pressed events to key typed events may be
+     * many-to-one or many-to-many.
+     */
+    public static final int KEY_TYPED = KEY_FIRST;
+
+    /**
+     * The "key pressed" event. This event is generated when a key
+     * is pushed down.
+     */
+    public static final int KEY_PRESSED = 1 + KEY_FIRST; //Event.KEY_PRESS
+
+    /**
+     * The "key released" event. This event is generated when a key
+     * is let up.
+     */
+    public static final int KEY_RELEASED = 2 + KEY_FIRST; //Event.KEY_RELEASE
+
+    /* Virtual key codes. */
+
+    public static final int VK_ENTER          = '\n';
+    public static final int VK_BACK_SPACE     = '\b';
+    public static final int VK_TAB            = '\t';
+    public static final int VK_CANCEL         = 0x03;
+    public static final int VK_CLEAR          = 0x0C;
+    public static final int VK_SHIFT          = 0x10;
+    public static final int VK_CONTROL        = 0x11;
+    public static final int VK_ALT            = 0x12;
+    public static final int VK_PAUSE          = 0x13;
+    public static final int VK_CAPS_LOCK      = 0x14;
+    public static final int VK_ESCAPE         = 0x1B;
+    public static final int VK_SPACE          = 0x20;
+    public static final int VK_PAGE_UP        = 0x21;
+    public static final int VK_PAGE_DOWN      = 0x22;
+    public static final int VK_END            = 0x23;
+    public static final int VK_HOME           = 0x24;
+
+    /**
+     * Constant for the non-numpad <b>left</b> arrow key.
+     * @see #VK_KP_LEFT
+     */
+    public static final int VK_LEFT           = 0x25;
+
+    /**
+     * Constant for the non-numpad <b>up</b> arrow key.
+     * @see #VK_KP_UP
+     */
+    public static final int VK_UP             = 0x26;
+
+    /**
+     * Constant for the non-numpad <b>right</b> arrow key.
+     * @see #VK_KP_RIGHT
+     */
+    public static final int VK_RIGHT          = 0x27;
+
+    /**
+     * Constant for the non-numpad <b>down</b> arrow key.
+     * @see #VK_KP_DOWN
+     */
+    public static final int VK_DOWN           = 0x28;
+
+    /**
+     * Constant for the comma key, ","
+     */
+    public static final int VK_COMMA          = 0x2C;
+
+    /**
+     * Constant for the minus key, "-"
+     * @since 1.2
+     */
+    public static final int VK_MINUS          = 0x2D;
+
+    /**
+     * Constant for the period key, "."
+     */
+    public static final int VK_PERIOD         = 0x2E;
+
+    /**
+     * Constant for the forward slash key, "/"
+     */
+    public static final int VK_SLASH          = 0x2F;
+
+    /** VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
+    public static final int VK_0              = 0x30;
+    public static final int VK_1              = 0x31;
+    public static final int VK_2              = 0x32;
+    public static final int VK_3              = 0x33;
+    public static final int VK_4              = 0x34;
+    public static final int VK_5              = 0x35;
+    public static final int VK_6              = 0x36;
+    public static final int VK_7              = 0x37;
+    public static final int VK_8              = 0x38;
+    public static final int VK_9              = 0x39;
+
+    /**
+     * Constant for the semicolon key, ";"
+     */
+    public static final int VK_SEMICOLON      = 0x3B;
+
+    /**
+     * Constant for the equals key, "="
+     */
+    public static final int VK_EQUALS         = 0x3D;
+
+    /** VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */
+    public static final int VK_A              = 0x41;
+    public static final int VK_B              = 0x42;
+    public static final int VK_C              = 0x43;
+    public static final int VK_D              = 0x44;
+    public static final int VK_E              = 0x45;
+    public static final int VK_F              = 0x46;
+    public static final int VK_G              = 0x47;
+    public static final int VK_H              = 0x48;
+    public static final int VK_I              = 0x49;
+    public static final int VK_J              = 0x4A;
+    public static final int VK_K              = 0x4B;
+    public static final int VK_L              = 0x4C;
+    public static final int VK_M              = 0x4D;
+    public static final int VK_N              = 0x4E;
+    public static final int VK_O              = 0x4F;
+    public static final int VK_P              = 0x50;
+    public static final int VK_Q              = 0x51;
+    public static final int VK_R              = 0x52;
+    public static final int VK_S              = 0x53;
+    public static final int VK_T              = 0x54;
+    public static final int VK_U              = 0x55;
+    public static final int VK_V              = 0x56;
+    public static final int VK_W              = 0x57;
+    public static final int VK_X              = 0x58;
+    public static final int VK_Y              = 0x59;
+    public static final int VK_Z              = 0x5A;
+
+    /**
+     * Constant for the open bracket key, "["
+     */
+    public static final int VK_OPEN_BRACKET   = 0x5B;
+
+    /**
+     * Constant for the back slash key, "\"
+     */
+    public static final int VK_BACK_SLASH     = 0x5C;
+
+    /**
+     * Constant for the close bracket key, "]"
+     */
+    public static final int VK_CLOSE_BRACKET  = 0x5D;
+
+    public static final int VK_NUMPAD0        = 0x60;
+    public static final int VK_NUMPAD1        = 0x61;
+    public static final int VK_NUMPAD2        = 0x62;
+    public static final int VK_NUMPAD3        = 0x63;
+    public static final int VK_NUMPAD4        = 0x64;
+    public static final int VK_NUMPAD5        = 0x65;
+    public static final int VK_NUMPAD6        = 0x66;
+    public static final int VK_NUMPAD7        = 0x67;
+    public static final int VK_NUMPAD8        = 0x68;
+    public static final int VK_NUMPAD9        = 0x69;
+    public static final int VK_MULTIPLY       = 0x6A;
+    public static final int VK_ADD            = 0x6B;
+
+    /**
+     * This constant is obsolete, and is included only for backwards
+     * compatibility.
+     * @see #VK_SEPARATOR
+     */
+    public static final int VK_SEPARATER      = 0x6C;
+
+    /**
+     * Constant for the Numpad Separator key.
+     * @since 1.4
+     */
+    public static final int VK_SEPARATOR      = VK_SEPARATER;
+
+    public static final int VK_SUBTRACT       = 0x6D;
+    public static final int VK_DECIMAL        = 0x6E;
+    public static final int VK_DIVIDE         = 0x6F;
+    public static final int VK_DELETE         = 0x7F; /* ASCII DEL */
+    public static final int VK_NUM_LOCK       = 0x90;
+    public static final int VK_SCROLL_LOCK    = 0x91;
+
+    /** Constant for the F1 function key. */
+    public static final int VK_F1             = 0x70;
+
+    /** Constant for the F2 function key. */
+    public static final int VK_F2             = 0x71;
+
+    /** Constant for the F3 function key. */
+    public static final int VK_F3             = 0x72;
+
+    /** Constant for the F4 function key. */
+    public static final int VK_F4             = 0x73;
+
+    /** Constant for the F5 function key. */
+    public static final int VK_F5             = 0x74;
+
+    /** Constant for the F6 function key. */
+    public static final int VK_F6             = 0x75;
+
+    /** Constant for the F7 function key. */
+    public static final int VK_F7             = 0x76;
+
+    /** Constant for the F8 function key. */
+    public static final int VK_F8             = 0x77;
+
+    /** Constant for the F9 function key. */
+    public static final int VK_F9             = 0x78;
+
+    /** Constant for the F10 function key. */
+    public static final int VK_F10            = 0x79;
+
+    /** Constant for the F11 function key. */
+    public static final int VK_F11            = 0x7A;
+
+    /** Constant for the F12 function key. */
+    public static final int VK_F12            = 0x7B;
+
+    /**
+     * Constant for the F13 function key.
+     * @since 1.2
+     */
+    /* F13 - F24 are used on IBM 3270 keyboard; use random range for constants. */
+    public static final int VK_F13            = 0xF000;
+
+    /**
+     * Constant for the F14 function key.
+     * @since 1.2
+     */
+    public static final int VK_F14            = 0xF001;
+
+    /**
+     * Constant for the F15 function key.
+     * @since 1.2
+     */
+    public static final int VK_F15            = 0xF002;
+
+    /**
+     * Constant for the F16 function key.
+     * @since 1.2
+     */
+    public static final int VK_F16            = 0xF003;
+
+    /**
+     * Constant for the F17 function key.
+     * @since 1.2
+     */
+    public static final int VK_F17            = 0xF004;
+
+    /**
+     * Constant for the F18 function key.
+     * @since 1.2
+     */
+    public static final int VK_F18            = 0xF005;
+
+    /**
+     * Constant for the F19 function key.
+     * @since 1.2
+     */
+    public static final int VK_F19            = 0xF006;
+
+    /**
+     * Constant for the F20 function key.
+     * @since 1.2
+     */
+    public static final int VK_F20            = 0xF007;
+
+    /**
+     * Constant for the F21 function key.
+     * @since 1.2
+     */
+    public static final int VK_F21            = 0xF008;
+
+    /**
+     * Constant for the F22 function key.
+     * @since 1.2
+     */
+    public static final int VK_F22            = 0xF009;
+
+    /**
+     * Constant for the F23 function key.
+     * @since 1.2
+     */
+    public static final int VK_F23            = 0xF00A;
+
+    /**
+     * Constant for the F24 function key.
+     * @since 1.2
+     */
+    public static final int VK_F24            = 0xF00B;
+
+    public static final int VK_PRINTSCREEN    = 0x9A;
+    public static final int VK_INSERT         = 0x9B;
+    public static final int VK_HELP           = 0x9C;
+    public static final int VK_META           = 0x9D;
+
+    public static final int VK_BACK_QUOTE     = 0xC0;
+    public static final int VK_QUOTE          = 0xDE;
+
+    /**
+     * Constant for the numeric keypad <b>up</b> arrow key.
+     * @see #VK_UP
+     * @since 1.2
+     */
+    public static final int VK_KP_UP          = 0xE0;
+
+    /**
+     * Constant for the numeric keypad <b>down</b> arrow key.
+     * @see #VK_DOWN
+     * @since 1.2
+     */
+    public static final int VK_KP_DOWN        = 0xE1;
+
+    /**
+     * Constant for the numeric keypad <b>left</b> arrow key.
+     * @see #VK_LEFT
+     * @since 1.2
+     */
+    public static final int VK_KP_LEFT        = 0xE2;
+
+    /**
+     * Constant for the numeric keypad <b>right</b> arrow key.
+     * @see #VK_RIGHT
+     * @since 1.2
+     */
+    public static final int VK_KP_RIGHT       = 0xE3;
+
+    /* For European keyboards */
+    /** @since 1.2 */
+    public static final int VK_DEAD_GRAVE               = 0x80;
+    /** @since 1.2 */
+    public static final int VK_DEAD_ACUTE               = 0x81;
+    /** @since 1.2 */
+    public static final int VK_DEAD_CIRCUMFLEX          = 0x82;
+    /** @since 1.2 */
+    public static final int VK_DEAD_TILDE               = 0x83;
+    /** @since 1.2 */
+    public static final int VK_DEAD_MACRON              = 0x84;
+    /** @since 1.2 */
+    public static final int VK_DEAD_BREVE               = 0x85;
+    /** @since 1.2 */
+    public static final int VK_DEAD_ABOVEDOT            = 0x86;
+    /** @since 1.2 */
+    public static final int VK_DEAD_DIAERESIS           = 0x87;
+    /** @since 1.2 */
+    public static final int VK_DEAD_ABOVERING           = 0x88;
+    /** @since 1.2 */
+    public static final int VK_DEAD_DOUBLEACUTE         = 0x89;
+    /** @since 1.2 */
+    public static final int VK_DEAD_CARON               = 0x8a;
+    /** @since 1.2 */
+    public static final int VK_DEAD_CEDILLA             = 0x8b;
+    /** @since 1.2 */
+    public static final int VK_DEAD_OGONEK              = 0x8c;
+    /** @since 1.2 */
+    public static final int VK_DEAD_IOTA                = 0x8d;
+    /** @since 1.2 */
+    public static final int VK_DEAD_VOICED_SOUND        = 0x8e;
+    /** @since 1.2 */
+    public static final int VK_DEAD_SEMIVOICED_SOUND    = 0x8f;
+
+    /** @since 1.2 */
+    public static final int VK_AMPERSAND                = 0x96;
+    /** @since 1.2 */
+    public static final int VK_ASTERISK                 = 0x97;
+    /** @since 1.2 */
+    public static final int VK_QUOTEDBL                 = 0x98;
+    /** @since 1.2 */
+    public static final int VK_LESS                     = 0x99;
+
+    /** @since 1.2 */
+    public static final int VK_GREATER                  = 0xa0;
+    /** @since 1.2 */
+    public static final int VK_BRACELEFT                = 0xa1;
+    /** @since 1.2 */
+    public static final int VK_BRACERIGHT               = 0xa2;
+
+    /**
+     * Constant for the "@" key.
+     * @since 1.2
+     */
+    public static final int VK_AT                       = 0x0200;
+
+    /**
+     * Constant for the ":" key.
+     * @since 1.2
+     */
+    public static final int VK_COLON                    = 0x0201;
+
+    /**
+     * Constant for the "^" key.
+     * @since 1.2
+     */
+    public static final int VK_CIRCUMFLEX               = 0x0202;
+
+    /**
+     * Constant for the "$" key.
+     * @since 1.2
+     */
+    public static final int VK_DOLLAR                   = 0x0203;
+
+    /**
+     * Constant for the Euro currency sign key.
+     * @since 1.2
+     */
+    public static final int VK_EURO_SIGN                = 0x0204;
+
+    /**
+     * Constant for the "!" key.
+     * @since 1.2
+     */
+    public static final int VK_EXCLAMATION_MARK         = 0x0205;
+
+    /**
+     * Constant for the inverted exclamation mark key.
+     * @since 1.2
+     */
+    public static final int VK_INVERTED_EXCLAMATION_MARK = 0x0206;
+
+    /**
+     * Constant for the "(" key.
+     * @since 1.2
+     */
+    public static final int VK_LEFT_PARENTHESIS         = 0x0207;
+
+    /**
+     * Constant for the "#" key.
+     * @since 1.2
+     */
+    public static final int VK_NUMBER_SIGN              = 0x0208;
+
+    /**
+     * Constant for the "+" key.
+     * @since 1.2
+     */
+    public static final int VK_PLUS                     = 0x0209;
+
+    /**
+     * Constant for the ")" key.
+     * @since 1.2
+     */
+    public static final int VK_RIGHT_PARENTHESIS        = 0x020A;
+
+    /**
+     * Constant for the "_" key.
+     * @since 1.2
+     */
+    public static final int VK_UNDERSCORE               = 0x020B;
+
+    /**
+     * Constant for the Microsoft Windows "Windows" key.
+     * It is used for both the left and right version of the key.
+     * @see #getKeyLocation()
+     * @since 1.5
+     */
+    public static final int VK_WINDOWS                  = 0x020C;
+
+    /**
+     * Constant for the Microsoft Windows Context Menu key.
+     * @since 1.5
+     */
+    public static final int VK_CONTEXT_MENU             = 0x020D;
+
+    /* for input method support on Asian Keyboards */
+
+    /* not clear what this means - listed in Microsoft Windows API */
+    public static final int VK_FINAL                    = 0x0018;
+
+    /** Constant for the Convert function key. */
+    /* Japanese PC 106 keyboard, Japanese Solaris keyboard: henkan */
+    public static final int VK_CONVERT                  = 0x001C;
+
+    /** Constant for the Don't Convert function key. */
+    /* Japanese PC 106 keyboard: muhenkan */
+    public static final int VK_NONCONVERT               = 0x001D;
+
+    /** Constant for the Accept or Commit function key. */
+    /* Japanese Solaris keyboard: kakutei */
+    public static final int VK_ACCEPT                   = 0x001E;
+
+    /* not clear what this means - listed in Microsoft Windows API */
+    public static final int VK_MODECHANGE               = 0x001F;
+
+    /* replaced by VK_KANA_LOCK for Microsoft Windows and Solaris;
+       might still be used on other platforms */
+    public static final int VK_KANA                     = 0x0015;
+
+    /* replaced by VK_INPUT_METHOD_ON_OFF for Microsoft Windows and Solaris;
+       might still be used for other platforms */
+    public static final int VK_KANJI                    = 0x0019;
+
+    /**
+     * Constant for the Alphanumeric function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: eisuu */
+    public static final int VK_ALPHANUMERIC             = 0x00F0;
+
+    /**
+     * Constant for the Katakana function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: katakana */
+    public static final int VK_KATAKANA                 = 0x00F1;
+
+    /**
+     * Constant for the Hiragana function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: hiragana */
+    public static final int VK_HIRAGANA                 = 0x00F2;
+
+    /**
+     * Constant for the Full-Width Characters function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: zenkaku */
+    public static final int VK_FULL_WIDTH               = 0x00F3;
+
+    /**
+     * Constant for the Half-Width Characters function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: hankaku */
+    public static final int VK_HALF_WIDTH               = 0x00F4;
+
+    /**
+     * Constant for the Roman Characters function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: roumaji */
+    public static final int VK_ROMAN_CHARACTERS         = 0x00F5;
+
+    /**
+     * Constant for the All Candidates function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard - VK_CONVERT + ALT: zenkouho */
+    public static final int VK_ALL_CANDIDATES           = 0x0100;
+
+    /**
+     * Constant for the Previous Candidate function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard - VK_CONVERT + SHIFT: maekouho */
+    public static final int VK_PREVIOUS_CANDIDATE       = 0x0101;
+
+    /**
+     * Constant for the Code Input function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard - VK_ALPHANUMERIC + ALT: kanji bangou */
+    public static final int VK_CODE_INPUT               = 0x0102;
+
+    /**
+     * Constant for the Japanese-Katakana function key.
+     * This key switches to a Japanese input method and selects its Katakana input mode.
+     * @since 1.2
+     */
+    /* Japanese Macintosh keyboard - VK_JAPANESE_HIRAGANA + SHIFT */
+    public static final int VK_JAPANESE_KATAKANA        = 0x0103;
+
+    /**
+     * Constant for the Japanese-Hiragana function key.
+     * This key switches to a Japanese input method and selects its Hiragana input mode.
+     * @since 1.2
+     */
+    /* Japanese Macintosh keyboard */
+    public static final int VK_JAPANESE_HIRAGANA        = 0x0104;
+
+    /**
+     * Constant for the Japanese-Roman function key.
+     * This key switches to a Japanese input method and selects its Roman-Direct input mode.
+     * @since 1.2
+     */
+    /* Japanese Macintosh keyboard */
+    public static final int VK_JAPANESE_ROMAN           = 0x0105;
+
+    /**
+     * Constant for the locking Kana function key.
+     * This key locks the keyboard into a Kana layout.
+     * @since 1.3
+     */
+    /* Japanese PC 106 keyboard with special Windows driver - eisuu + Control; Japanese Solaris keyboard: kana */
+    public static final int VK_KANA_LOCK                = 0x0106;
+
+    /**
+     * Constant for the input method on/off key.
+     * @since 1.3
+     */
+    /* Japanese PC 106 keyboard: kanji. Japanese Solaris keyboard: nihongo */
+    public static final int VK_INPUT_METHOD_ON_OFF      = 0x0107;
+
+    /* for Sun keyboards */
+    /** @since 1.2 */
+    public static final int VK_CUT                      = 0xFFD1;
+    /** @since 1.2 */
+    public static final int VK_COPY                     = 0xFFCD;
+    /** @since 1.2 */
+    public static final int VK_PASTE                    = 0xFFCF;
+    /** @since 1.2 */
+    public static final int VK_UNDO                     = 0xFFCB;
+    /** @since 1.2 */
+    public static final int VK_AGAIN                    = 0xFFC9;
+    /** @since 1.2 */
+    public static final int VK_FIND                     = 0xFFD0;
+    /** @since 1.2 */
+    public static final int VK_PROPS                    = 0xFFCA;
+    /** @since 1.2 */
+    public static final int VK_STOP                     = 0xFFC8;
+
+    /**
+     * Constant for the Compose function key.
+     * @since 1.2
+     */
+    public static final int VK_COMPOSE                  = 0xFF20;
+
+    /**
+     * Constant for the AltGraph function key.
+     * @since 1.2
+     */
+    public static final int VK_ALT_GRAPH                = 0xFF7E;
+
+    /**
+     * Constant for the Begin key.
+     * @since 1.5
+     */
+    public static final int VK_BEGIN                    = 0xFF58;
+
+    /**
+     * This value is used to indicate that the keyCode is unknown.
+     * KEY_TYPED events do not have a keyCode value; this value
+     * is used instead.
+     */
+    public static final int VK_UNDEFINED      = 0x0;
+
+    /**
+     * KEY_PRESSED and KEY_RELEASED events which do not map to a
+     * valid Unicode character use this for the keyChar value.
+     */
+    public static final char CHAR_UNDEFINED   = 0xFFFF;
+
+    /**
+     * A constant indicating that the keyLocation is indeterminate
+     * or not relevant.
+     * <code>KEY_TYPED</code> events do not have a keyLocation; this value
+     * is used instead.
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_UNKNOWN  = 0;
+
+    /**
+     * A constant indicating that the key pressed or released
+     * is not distinguished as the left or right version of a key,
+     * and did not originate on the numeric keypad (or did not
+     * originate with a virtual key corresponding to the numeric
+     * keypad).
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_STANDARD = 1;
+
+    /**
+     * A constant indicating that the key pressed or released is in
+     * the left key location (there is more than one possible location
+     * for this key).  Example: the left shift key.
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_LEFT     = 2;
+
+    /**
+     * A constant indicating that the key pressed or released is in
+     * the right key location (there is more than one possible location
+     * for this key).  Example: the right shift key.
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_RIGHT    = 3;
+
+    /**
+     * A constant indicating that the key event originated on the
+     * numeric keypad or with a virtual key corresponding to the
+     * numeric keypad.
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_NUMPAD   = 4;
+
+    /**
+     * Returns a String describing the keyCode, such as "HOME", "F1" or "A".
+     * These strings can be localized by changing the awt.properties file.
+     *
+     * @return a string containing a text description for a physical key,
+     *         identified by its keyCode
+     */
+    public static String getKeyText(int keyCode) {
+        if (keyCode >= VK_0 && keyCode <= VK_9 ||
+            keyCode >= VK_A && keyCode <= VK_Z) {
+            return String.valueOf((char)keyCode);
+        }
+
+        switch(keyCode) {
+          case VK_ENTER: return getToolkitProperty("AWT.enter", "Enter");
+          case VK_BACK_SPACE: return getToolkitProperty("AWT.backSpace", "Backspace");
+          case VK_TAB: return getToolkitProperty("AWT.tab", "Tab");
+          case VK_CANCEL: return getToolkitProperty("AWT.cancel", "Cancel");
+          case VK_CLEAR: return getToolkitProperty("AWT.clear", "Clear");
+          case VK_COMPOSE: return getToolkitProperty("AWT.compose", "Compose");
+          case VK_PAUSE: return getToolkitProperty("AWT.pause", "Pause");
+          case VK_CAPS_LOCK: return getToolkitProperty("AWT.capsLock", "Caps Lock");
+          case VK_ESCAPE: return getToolkitProperty("AWT.escape", "Escape");
+          case VK_SPACE: return getToolkitProperty("AWT.space", "Space");
+          case VK_PAGE_UP: return getToolkitProperty("AWT.pgup", "Page Up");
+          case VK_PAGE_DOWN: return getToolkitProperty("AWT.pgdn", "Page Down");
+          case VK_END: return getToolkitProperty("AWT.end", "End");
+          case VK_HOME: return getToolkitProperty("AWT.home", "Home");
+          case VK_LEFT: return getToolkitProperty("AWT.left", "Left");
+          case VK_UP: return getToolkitProperty("AWT.up", "Up");
+          case VK_RIGHT: return getToolkitProperty("AWT.right", "Right");
+          case VK_DOWN: return getToolkitProperty("AWT.down", "Down");
+          case VK_BEGIN: return getToolkitProperty("AWT.begin", "Begin");
+
+          // modifiers
+          case VK_SHIFT: return getToolkitProperty("AWT.shift", "Shift");
+          case VK_CONTROL: return getToolkitProperty("AWT.control", "Control");
+          case VK_ALT: return getToolkitProperty("AWT.alt", "Alt");
+          case VK_META: return getToolkitProperty("AWT.meta", "Meta");
+          case VK_ALT_GRAPH: return getToolkitProperty("AWT.altGraph", "Alt Graph");
+
+          // punctuation
+          case VK_COMMA: return getToolkitProperty("AWT.comma", "Comma");
+          case VK_PERIOD: return getToolkitProperty("AWT.period", "Period");
+          case VK_SLASH: return getToolkitProperty("AWT.slash", "Slash");
+          case VK_SEMICOLON: return getToolkitProperty("AWT.semicolon", "Semicolon");
+          case VK_EQUALS: return getToolkitProperty("AWT.equals", "Equals");
+          case VK_OPEN_BRACKET: return getToolkitProperty("AWT.openBracket", "Open Bracket");
+          case VK_BACK_SLASH: return getToolkitProperty("AWT.backSlash", "Back Slash");
+          case VK_CLOSE_BRACKET: return getToolkitProperty("AWT.closeBracket", "Close Bracket");
+
+          // numpad numeric keys handled below
+          case VK_MULTIPLY: return getToolkitProperty("AWT.multiply", "NumPad *");
+          case VK_ADD: return getToolkitProperty("AWT.add", "NumPad +");
+          case VK_SEPARATOR: return getToolkitProperty("AWT.separator", "NumPad ,");
+          case VK_SUBTRACT: return getToolkitProperty("AWT.subtract", "NumPad -");
+          case VK_DECIMAL: return getToolkitProperty("AWT.decimal", "NumPad .");
+          case VK_DIVIDE: return getToolkitProperty("AWT.divide", "NumPad /");
+          case VK_DELETE: return getToolkitProperty("AWT.delete", "Delete");
+          case VK_NUM_LOCK: return getToolkitProperty("AWT.numLock", "Num Lock");
+          case VK_SCROLL_LOCK: return getToolkitProperty("AWT.scrollLock", "Scroll Lock");
+
+          case VK_WINDOWS: return getToolkitProperty("AWT.windows", "Windows");
+          case VK_CONTEXT_MENU: return getToolkitProperty("AWT.context", "Context Menu");
+
+          case VK_F1: return getToolkitProperty("AWT.f1", "F1");
+          case VK_F2: return getToolkitProperty("AWT.f2", "F2");
+          case VK_F3: return getToolkitProperty("AWT.f3", "F3");
+          case VK_F4: return getToolkitProperty("AWT.f4", "F4");
+          case VK_F5: return getToolkitProperty("AWT.f5", "F5");
+          case VK_F6: return getToolkitProperty("AWT.f6", "F6");
+          case VK_F7: return getToolkitProperty("AWT.f7", "F7");
+          case VK_F8: return getToolkitProperty("AWT.f8", "F8");
+          case VK_F9: return getToolkitProperty("AWT.f9", "F9");
+          case VK_F10: return getToolkitProperty("AWT.f10", "F10");
+          case VK_F11: return getToolkitProperty("AWT.f11", "F11");
+          case VK_F12: return getToolkitProperty("AWT.f12", "F12");
+          case VK_F13: return getToolkitProperty("AWT.f13", "F13");
+          case VK_F14: return getToolkitProperty("AWT.f14", "F14");
+          case VK_F15: return getToolkitProperty("AWT.f15", "F15");
+          case VK_F16: return getToolkitProperty("AWT.f16", "F16");
+          case VK_F17: return getToolkitProperty("AWT.f17", "F17");
+          case VK_F18: return getToolkitProperty("AWT.f18", "F18");
+          case VK_F19: return getToolkitProperty("AWT.f19", "F19");
+          case VK_F20: return getToolkitProperty("AWT.f20", "F20");
+          case VK_F21: return getToolkitProperty("AWT.f21", "F21");
+          case VK_F22: return getToolkitProperty("AWT.f22", "F22");
+          case VK_F23: return getToolkitProperty("AWT.f23", "F23");
+          case VK_F24: return getToolkitProperty("AWT.f24", "F24");
+
+          case VK_PRINTSCREEN: return getToolkitProperty("AWT.printScreen", "Print Screen");
+          case VK_INSERT: return getToolkitProperty("AWT.insert", "Insert");
+          case VK_HELP: return getToolkitProperty("AWT.help", "Help");
+          case VK_BACK_QUOTE: return getToolkitProperty("AWT.backQuote", "Back Quote");
+          case VK_QUOTE: return getToolkitProperty("AWT.quote", "Quote");
+
+          case VK_KP_UP: return getToolkitProperty("AWT.up", "Up");
+          case VK_KP_DOWN: return getToolkitProperty("AWT.down", "Down");
+          case VK_KP_LEFT: return getToolkitProperty("AWT.left", "Left");
+          case VK_KP_RIGHT: return getToolkitProperty("AWT.right", "Right");
+
+          case VK_DEAD_GRAVE: return getToolkitProperty("AWT.deadGrave", "Dead Grave");
+          case VK_DEAD_ACUTE: return getToolkitProperty("AWT.deadAcute", "Dead Acute");
+          case VK_DEAD_CIRCUMFLEX: return getToolkitProperty("AWT.deadCircumflex", "Dead Circumflex");
+          case VK_DEAD_TILDE: return getToolkitProperty("AWT.deadTilde", "Dead Tilde");
+          case VK_DEAD_MACRON: return getToolkitProperty("AWT.deadMacron", "Dead Macron");
+          case VK_DEAD_BREVE: return getToolkitProperty("AWT.deadBreve", "Dead Breve");
+          case VK_DEAD_ABOVEDOT: return getToolkitProperty("AWT.deadAboveDot", "Dead Above Dot");
+          case VK_DEAD_DIAERESIS: return getToolkitProperty("AWT.deadDiaeresis", "Dead Diaeresis");
+          case VK_DEAD_ABOVERING: return getToolkitProperty("AWT.deadAboveRing", "Dead Above Ring");
+          case VK_DEAD_DOUBLEACUTE: return getToolkitProperty("AWT.deadDoubleAcute", "Dead Double Acute");
+          case VK_DEAD_CARON: return getToolkitProperty("AWT.deadCaron", "Dead Caron");
+          case VK_DEAD_CEDILLA: return getToolkitProperty("AWT.deadCedilla", "Dead Cedilla");
+          case VK_DEAD_OGONEK: return getToolkitProperty("AWT.deadOgonek", "Dead Ogonek");
+          case VK_DEAD_IOTA: return getToolkitProperty("AWT.deadIota", "Dead Iota");
+          case VK_DEAD_VOICED_SOUND: return getToolkitProperty("AWT.deadVoicedSound", "Dead Voiced Sound");
+          case VK_DEAD_SEMIVOICED_SOUND: return getToolkitProperty("AWT.deadSemivoicedSound", "Dead Semivoiced Sound");
+
+          case VK_AMPERSAND: return getToolkitProperty("AWT.ampersand", "Ampersand");
+          case VK_ASTERISK: return getToolkitProperty("AWT.asterisk", "Asterisk");
+          case VK_QUOTEDBL: return getToolkitProperty("AWT.quoteDbl", "Double Quote");
+          case VK_LESS: return getToolkitProperty("AWT.Less", "Less");
+          case VK_GREATER: return getToolkitProperty("AWT.greater", "Greater");
+          case VK_BRACELEFT: return getToolkitProperty("AWT.braceLeft", "Left Brace");
+          case VK_BRACERIGHT: return getToolkitProperty("AWT.braceRight", "Right Brace");
+          case VK_AT: return getToolkitProperty("AWT.at", "At");
+          case VK_COLON: return getToolkitProperty("AWT.colon", "Colon");
+          case VK_CIRCUMFLEX: return getToolkitProperty("AWT.circumflex", "Circumflex");
+          case VK_DOLLAR: return getToolkitProperty("AWT.dollar", "Dollar");
+          case VK_EURO_SIGN: return getToolkitProperty("AWT.euro", "Euro");
+          case VK_EXCLAMATION_MARK: return getToolkitProperty("AWT.exclamationMark", "Exclamation Mark");
+          case VK_INVERTED_EXCLAMATION_MARK: return getToolkitProperty("AWT.invertedExclamationMark", "Inverted Exclamation Mark");
+          case VK_LEFT_PARENTHESIS: return getToolkitProperty("AWT.leftParenthesis", "Left Parenthesis");
+          case VK_NUMBER_SIGN: return getToolkitProperty("AWT.numberSign", "Number Sign");
+          case VK_MINUS: return getToolkitProperty("AWT.minus", "Minus");
+          case VK_PLUS: return getToolkitProperty("AWT.plus", "Plus");
+          case VK_RIGHT_PARENTHESIS: return getToolkitProperty("AWT.rightParenthesis", "Right Parenthesis");
+          case VK_UNDERSCORE: return getToolkitProperty("AWT.underscore", "Underscore");
+
+          case VK_FINAL: return getToolkitProperty("AWT.final", "Final");
+          case VK_CONVERT: return getToolkitProperty("AWT.convert", "Convert");
+          case VK_NONCONVERT: return getToolkitProperty("AWT.noconvert", "No Convert");
+          case VK_ACCEPT: return getToolkitProperty("AWT.accept", "Accept");
+          case VK_MODECHANGE: return getToolkitProperty("AWT.modechange", "Mode Change");
+          case VK_KANA: return getToolkitProperty("AWT.kana", "Kana");
+          case VK_KANJI: return getToolkitProperty("AWT.kanji", "Kanji");
+          case VK_ALPHANUMERIC: return getToolkitProperty("AWT.alphanumeric", "Alphanumeric");
+          case VK_KATAKANA: return getToolkitProperty("AWT.katakana", "Katakana");
+          case VK_HIRAGANA: return getToolkitProperty("AWT.hiragana", "Hiragana");
+          case VK_FULL_WIDTH: return getToolkitProperty("AWT.fullWidth", "Full-Width");
+          case VK_HALF_WIDTH: return getToolkitProperty("AWT.halfWidth", "Half-Width");
+          case VK_ROMAN_CHARACTERS: return getToolkitProperty("AWT.romanCharacters", "Roman Characters");
+          case VK_ALL_CANDIDATES: return getToolkitProperty("AWT.allCandidates", "All Candidates");
+          case VK_PREVIOUS_CANDIDATE: return getToolkitProperty("AWT.previousCandidate", "Previous Candidate");
+          case VK_CODE_INPUT: return getToolkitProperty("AWT.codeInput", "Code Input");
+          case VK_JAPANESE_KATAKANA: return getToolkitProperty("AWT.japaneseKatakana", "Japanese Katakana");
+          case VK_JAPANESE_HIRAGANA: return getToolkitProperty("AWT.japaneseHiragana", "Japanese Hiragana");
+          case VK_JAPANESE_ROMAN: return getToolkitProperty("AWT.japaneseRoman", "Japanese Roman");
+          case VK_KANA_LOCK: return getToolkitProperty("AWT.kanaLock", "Kana Lock");
+          case VK_INPUT_METHOD_ON_OFF: return getToolkitProperty("AWT.inputMethodOnOff", "Input Method On/Off");
+
+          case VK_AGAIN: return getToolkitProperty("AWT.again", "Again");
+          case VK_UNDO: return getToolkitProperty("AWT.undo", "Undo");
+          case VK_COPY: return getToolkitProperty("AWT.copy", "Copy");
+          case VK_PASTE: return getToolkitProperty("AWT.paste", "Paste");
+          case VK_CUT: return getToolkitProperty("AWT.cut", "Cut");
+          case VK_FIND: return getToolkitProperty("AWT.find", "Find");
+          case VK_PROPS: return getToolkitProperty("AWT.props", "Props");
+          case VK_STOP: return getToolkitProperty("AWT.stop", "Stop");
+        }
+
+        if (keyCode >= VK_NUMPAD0 && keyCode <= VK_NUMPAD9) {
+            String numpad = getToolkitProperty("AWT.numpad", "NumPad");
+            char c = (char)(keyCode - VK_NUMPAD0 + '0');
+            return numpad + "-" + c;
+        }
+
+        if ((keyCode & 0x01000000) != 0) {
+            return String.valueOf((char)(keyCode ^ 0x01000000 ));
+        }
+        String unknown = getToolkitProperty("AWT.unknown", "Unknown");
+        return unknown + " keyCode: 0x" + Integer.toString(keyCode, 16);
+    }
+
+    /**
+     * The AltGraph key modifier constant.
+     */
+    public static final int ALT_GRAPH_MASK = 1 << 5;
+
+    /**
+     * The Mouse Button1 modifier constant.
+     * It is recommended that BUTTON1_DOWN_MASK be used instead.
+     */
+    public static final int BUTTON1_MASK = 1 << 4;
+
+    /**
+     * This flag indicates that the Shift key was down when the event
+     * occurred.
+     */
+    public static final int SHIFT_MASK          = 1 << 0;
+
+    /**
+     * This flag indicates that the Control key was down when the event
+     * occurred.
+     */
+    public static final int CTRL_MASK           = 1 << 1;
+
+    /**
+     * This flag indicates that the Meta key was down when the event
+     * occurred. For mouse events, this flag indicates that the right
+     * button was pressed or released.
+     */
+    public static final int META_MASK           = 1 << 2;
+
+    /**
+     * This flag indicates that the Alt key was down when
+     * the event occurred. For mouse events, this flag indicates that the
+     * middle mouse button was pressed or released.
+     */
+    public static final int ALT_MASK            = 1 << 3;
+
+    /**
+     * Returns a <code>String</code> describing the modifier key(s),
+     * such as "Shift", or "Ctrl+Shift".  These strings can be
+     * localized by changing the <code>awt.properties</code> file.
+     * <p>
+     * Note that <code>InputEvent.ALT_MASK</code> and
+     * <code>InputEvent.BUTTON2_MASK</code> have the same value,
+     * so the string "Alt" is returned for both modifiers.  Likewise,
+     * <code>InputEvent.META_MASK</code> and
+     * <code>InputEvent.BUTTON3_MASK</code> have the same value,
+     * so the string "Meta" is returned for both modifiers.
+     *
+     * @return string a text description of the combination of modifier
+     *                keys that were held down during the event
+     * @see InputEvent#getModifiersExText(int)
+     */
+    public static String getKeyModifiersText(int modifiers) {
+        StringBuffer buf = new StringBuffer();
+        if ((modifiers & META_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.meta", "Meta"));
+            buf.append("+");
+        }
+        if ((modifiers & CTRL_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.control", "Ctrl"));
+            buf.append("+");
+        }
+        if ((modifiers & ALT_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.alt", "Alt"));
+            buf.append("+");
+        }
+        if ((modifiers & SHIFT_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.shift", "Shift"));
+            buf.append("+");
+        }
+        if ((modifiers & ALT_GRAPH_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.altGraph", "Alt Graph"));
+            buf.append("+");
+        }
+        if ((modifiers & BUTTON1_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.button1", "Button1"));
+            buf.append("+");
+        }
+        if (buf.length() > 0) {
+            buf.setLength(buf.length()-1); // remove trailing '+'
+        }
+        return buf.toString();
+    }
+
+
+	public static String getToolkitProperty(String name, String defValue)
+	{
+		return defValue;
+	}
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/builtinsage/MouseEvent.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/builtinsage/MouseEvent.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/builtinsage/MouseEvent.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/builtinsage/MouseEvent.java	2010-05-15 14:00:05.000000000 -0400
@@ -0,0 +1,1436 @@
+/*
+ * Copyright 1996-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.event;
+
+import java.awt.Point;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+
+/**
+ * An event which indicates that a mouse action occurred in a component.
+ * A mouse action is considered to occur in a particular component if and only
+ * if the mouse cursor is over the unobscured part of the component's bounds
+ * when the action happens.
+ * For lightweight components, such as Swing's components, mouse events
+ * are only dispatched to the component if the mouse event type has been
+ * enabled on the component. A mouse event type is enabled by adding the
+ * appropriate mouse-based {@code EventListener} to the component
+ * ({@link MouseListener} or {@link MouseMotionListener}), or by invoking
+ * {@link Component#enableEvents(long)} with the appropriate mask parameter
+ * ({@code AWTEvent.MOUSE_EVENT_MASK} or {@code AWTEvent.MOUSE_MOTION_EVENT_MASK}).
+ * If the mouse event type has not been enabled on the component, the
+ * corresponding mouse events are dispatched to the first ancestor that
+ * has enabled the mouse event type.
+ *<p>
+ * For example, if a {@code MouseListener} has been added to a component, or
+ * {@code enableEvents(AWTEvent.MOUSE_EVENT_MASK)} has been invoked, then all
+ * the events defined by {@code MouseListener} are dispatched to the component.
+ * On the other hand, if a {@code MouseMotionListener} has not been added and
+ * {@code enableEvents} has not been invoked with
+ * {@code AWTEvent.MOUSE_MOTION_EVENT_MASK}, then mouse motion events are not
+ * dispatched to the component. Instead the mouse motion events are
+ * dispatched to the first ancestors that has enabled mouse motion
+ * events.
+ * <P>
+ * This low-level event is generated by a component object for:
+ * <ul>
+ * <li>Mouse Events
+ *     <ul>
+ *     <li>a mouse button is pressed
+ *     <li>a mouse button is released
+ *     <li>a mouse button is clicked (pressed and released)
+ *     <li>the mouse cursor enters the unobscured part of component's geometry
+ *     <li>the mouse cursor exits the unobscured part of component's geometry
+ *     </ul>
+ * <li> Mouse Motion Events
+ *     <ul>
+ *     <li>the mouse is moved
+ *     <li>the mouse is dragged
+ *     </ul>
+ * </ul>
+ * <P>
+ * A <code>MouseEvent</code> object is passed to every
+ * <code>MouseListener</code>
+ * or <code>MouseAdapter</code> object which is registered to receive
+ * the "interesting" mouse events using the component's
+ * <code>addMouseListener</code> method.
+ * (<code>MouseAdapter</code> objects implement the
+ * <code>MouseListener</code> interface.) Each such listener object
+ * gets a <code>MouseEvent</code> containing the mouse event.
+ * <P>
+ * A <code>MouseEvent</code> object is also passed to every
+ * <code>MouseMotionListener</code> or
+ * <code>MouseMotionAdapter</code> object which is registered to receive
+ * mouse motion events using the component's
+ * <code>addMouseMotionListener</code>
+ * method. (<code>MouseMotionAdapter</code> objects implement the
+ * <code>MouseMotionListener</code> interface.) Each such listener object
+ * gets a <code>MouseEvent</code> containing the mouse motion event.
+ * <P>
+ * When a mouse button is clicked, events are generated and sent to the
+ * registered <code>MouseListener</code>s.
+ * The state of modal keys can be retrieved using {@link InputEvent#getModifiers}
+ * and {@link InputEvent#getModifiersEx}.
+ * The button mask returned by {@link InputEvent#getModifiers} reflects
+ * only the button that changed state, not the current state of all buttons.
+ * (Note: Due to overlap in the values of ALT_MASK/BUTTON2_MASK and
+ * META_MASK/BUTTON3_MASK, this is not always true for mouse events involving
+ * modifier keys).
+ * To get the state of all buttons and modifier keys, use
+ * {@link InputEvent#getModifiersEx}.
+ * The button which has changed state is returned by {@link MouseEvent#getButton}
+ * <P>
+ * For example, if the first mouse button is pressed, events are sent in the
+ * following order:
+ * <PRE>
+ *    <b   >id           </b   >   <b   >modifiers   </b   > <b   >button </b   >
+ *    <code>MOUSE_PRESSED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>
+ *    <code>MOUSE_RELEASED</code>: <code>BUTTON1_MASK</code> <code>BUTTON1</code>
+ *    <code>MOUSE_CLICKED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>
+ * </PRE>
+ * When multiple mouse buttons are pressed, each press, release, and click
+ * results in a separate event.
+ * <P>
+ * For example, if the user presses <b>button 1</b> followed by
+ * <b>button 2</b>, and then releases them in the same order,
+ * the following sequence of events is generated:
+ * <PRE>
+ *    <b   >id           </b   >   <b   >modifiers   </b   > <b   >button </b   >
+ *    <code>MOUSE_PRESSED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>
+ *    <code>MOUSE_PRESSED</code>:  <code>BUTTON2_MASK</code> <code>BUTTON2</code>
+ *    <code>MOUSE_RELEASED</code>: <code>BUTTON1_MASK</code> <code>BUTTON1</code>
+ *    <code>MOUSE_CLICKED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>
+ *    <code>MOUSE_RELEASED</code>: <code>BUTTON2_MASK</code> <code>BUTTON2</code>
+ *    <code>MOUSE_CLICKED</code>:  <code>BUTTON2_MASK</code> <code>BUTTON2</code>
+ * </PRE>
+ * If <b>button 2</b> is released first, the
+ * <code>MOUSE_RELEASED</code>/<code>MOUSE_CLICKED</code> pair
+ * for <code>BUTTON2_MASK</code> arrives first,
+ * followed by the pair for <code>BUTTON1_MASK</code>.
+ * <p>
+ * Some extra mouse buttons are added to extend the standard set of buttons
+ * represented by the following constants:{@code BUTTON1}, {@code BUTTON2}, and {@code BUTTON3}.
+ * Extra buttons have no assigned {@code BUTTONx}
+ * constants as well as their button masks have no assigned {@code BUTTONx_DOWN_MASK}
+ * constants. Nevertheless, ordinal numbers starting from 4 may be
+ * used as button numbers (button ids). Values obtained by the
+ * {@link InputEvent#getMaskForButton(int) getMaskForButton(button)} method may be used
+ * as button masks.
+ * <p>
+ * <code>MOUSE_DRAGGED</code> events are delivered to the <code>Component</code>
+ * in which the mouse button was pressed until the mouse button is released
+ * (regardless of whether the mouse position is within the bounds of the
+ * <code>Component</code>).  Due to platform-dependent Drag&Drop implementations,
+ * <code>MOUSE_DRAGGED</code> events may not be delivered during a native
+ * Drag&Drop operation.
+ *
+ * In a multi-screen environment mouse drag events are delivered to the
+ * <code>Component</code> even if the mouse position is outside the bounds of the
+ * <code>GraphicsConfiguration</code> associated with that
+ * <code>Component</code>. However, the reported position for mouse drag events
+ * in this case may differ from the actual mouse position:
+ * <ul>
+ * <li>In a multi-screen environment without a virtual device:
+ * <br>
+ * The reported coordinates for mouse drag events are clipped to fit within the
+ * bounds of the <code>GraphicsConfiguration</code> associated with
+ * the <code>Component</code>.
+ * <li>In a multi-screen environment with a virtual device:
+ * <br>
+ * The reported coordinates for mouse drag events are clipped to fit within the
+ * bounds of the virtual device associated with the <code>Component</code>.
+ * </ul>
+ * <p>
+ * An unspecified behavior will be caused if the {@code id} parameter
+ * of any particular {@code MouseEvent} instance is not
+ * in the range from {@code MOUSE_FIRST} to {@code MOUSE_LAST}-1
+ * ({@code MOUSE_WHEEL} is not acceptable).
+ *
+ * @author Carl Quinn
+ *
+ * @see MouseAdapter
+ * @see MouseListener
+ * @see MouseMotionAdapter
+ * @see MouseMotionListener
+ * @see MouseWheelListener
+ * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/mouselistener.html">Tutorial: Writing a Mouse Listener</a>
+ * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/mousemotionlistener.html">Tutorial: Writing a Mouse Motion Listener</a>
+ *
+ * @since 1.1
+ */
+public class MouseEvent extends java.util.EventObject {
+
+    /**
+     * The first number in the range of ids used for mouse events.
+     */
+    public static final int MOUSE_FIRST         = 500;
+
+    /**
+     * The last number in the range of ids used for mouse events.
+     */
+    public static final int MOUSE_LAST          = 507;
+
+    /**
+     * The "mouse clicked" event. This <code>MouseEvent</code>
+     * occurs when a mouse button is pressed and released.
+     */
+    public static final int MOUSE_CLICKED = MOUSE_FIRST;
+
+    /**
+     * The "mouse pressed" event. This <code>MouseEvent</code>
+     * occurs when a mouse button is pushed down.
+     */
+    public static final int MOUSE_PRESSED = 1 + MOUSE_FIRST; //Event.MOUSE_DOWN
+
+    /**
+     * The "mouse released" event. This <code>MouseEvent</code>
+     * occurs when a mouse button is let up.
+     */
+    public static final int MOUSE_RELEASED = 2 + MOUSE_FIRST; //Event.MOUSE_UP
+
+    /**
+     * The "mouse moved" event. This <code>MouseEvent</code>
+     * occurs when the mouse position changes.
+     */
+    public static final int MOUSE_MOVED = 3 + MOUSE_FIRST; //Event.MOUSE_MOVE
+
+    /**
+     * The "mouse entered" event. This <code>MouseEvent</code>
+     * occurs when the mouse cursor enters the unobscured part of component's
+     * geometry.
+     */
+    public static final int MOUSE_ENTERED = 4 + MOUSE_FIRST; //Event.MOUSE_ENTER
+
+    /**
+     * The "mouse exited" event. This <code>MouseEvent</code>
+     * occurs when the mouse cursor exits the unobscured part of component's
+     * geometry.
+     */
+    public static final int MOUSE_EXITED = 5 + MOUSE_FIRST; //Event.MOUSE_EXIT
+
+    /**
+     * The "mouse dragged" event. This <code>MouseEvent</code>
+     * occurs when the mouse position changes while a mouse button is pressed.
+     */
+    public static final int MOUSE_DRAGGED = 6 + MOUSE_FIRST; //Event.MOUSE_DRAG
+
+    /**
+     * The "mouse wheel" event.  This is the only <code>MouseWheelEvent</code>.
+     * It occurs when a mouse equipped with a wheel has its wheel rotated.
+     * @since 1.4
+     */
+    public static final int MOUSE_WHEEL = 7 + MOUSE_FIRST;
+
+    /**
+     * Indicates no mouse buttons; used by {@link #getButton}.
+     * @since 1.4
+     */
+    public static final int NOBUTTON = 0;
+
+    /**
+     * Indicates mouse button #1; used by {@link #getButton}.
+     * @since 1.4
+     */
+    public static final int BUTTON1 = 1;
+
+    /**
+     * Indicates mouse button #2; used by {@link #getButton}.
+     * @since 1.4
+     */
+    public static final int BUTTON2 = 2;
+
+    /**
+     * Indicates mouse button #3; used by {@link #getButton}.
+     * @since 1.4
+     */
+    public static final int BUTTON3 = 3;
+
+    /**
+     * This flag indicates that the Shift key was down when the event
+     * occurred.
+     */
+    public static final int SHIFT_MASK          = 1 << 0;
+
+    /**
+     * This flag indicates that the Control key was down when the event
+     * occurred.
+     */
+    public static final int CTRL_MASK           = 1 << 1;
+
+    /**
+     * This flag indicates that the Meta key was down when the event
+     * occurred. For mouse events, this flag indicates that the right
+     * button was pressed or released.
+     */
+    public static final int META_MASK           = 1 << 2;
+
+    /**
+     * This flag indicates that the Alt key was down when
+     * the event occurred. For mouse events, this flag indicates that the
+     * middle mouse button was pressed or released.
+     */
+    public static final int ALT_MASK            = 1 << 3;
+
+    /**
+     * The AltGraph key modifier constant.
+     */
+    public static final int ALT_GRAPH_MASK = 1 << 5;
+
+    /**
+     * The Mouse Button1 modifier constant.
+     * It is recommended that BUTTON1_DOWN_MASK be used instead.
+     */
+    public static final int BUTTON1_MASK = 1 << 4;
+
+    /**
+     * The Mouse Button2 modifier constant.
+     * It is recommended that BUTTON2_DOWN_MASK be used instead.
+     * Note that BUTTON2_MASK has the same value as ALT_MASK.
+     */
+    public static final int BUTTON2_MASK = ALT_MASK;
+
+    /**
+     * The Mouse Button3 modifier constant.
+     * It is recommended that BUTTON3_DOWN_MASK be used instead.
+     * Note that BUTTON3_MASK has the same value as META_MASK.
+     */
+    public static final int BUTTON3_MASK = META_MASK;
+
+    /**
+     * The Shift key extended modifier constant.
+     * @since 1.4
+     */
+    public static final int SHIFT_DOWN_MASK = 1 << 6;
+
+    /**
+     * The Control key extended modifier constant.
+     * @since 1.4
+     */
+    public static final int CTRL_DOWN_MASK = 1 << 7;
+
+    /**
+     * The Meta key extended modifier constant.
+     * @since 1.4
+     */
+    public static final int META_DOWN_MASK = 1 << 8;
+
+    /**
+     * The Alt key extended modifier constant.
+     * @since 1.4
+     */
+    public static final int ALT_DOWN_MASK = 1 << 9;
+
+    /**
+     * The Mouse Button1 extended modifier constant.
+     * @since 1.4
+     */
+    public static final int BUTTON1_DOWN_MASK = 1 << 10;
+
+    /**
+     * The Mouse Button2 extended modifier constant.
+     * @since 1.4
+     */
+    public static final int BUTTON2_DOWN_MASK = 1 << 11;
+
+    /**
+     * The Mouse Button3 extended modifier constant.
+     * @since 1.4
+     */
+    public static final int BUTTON3_DOWN_MASK = 1 << 12;
+
+    /**
+     * The AltGraph key extended modifier constant.
+     * @since 1.4
+     */
+    public static final int ALT_GRAPH_DOWN_MASK = 1 << 13;
+
+    // the constant below MUST be updated if any extra modifier
+    // bits are to be added!
+    // in fact, it is undesirable to add modifier bits
+    // to the same field as this may break applications
+    // see bug# 5066958
+    static final int FIRST_HIGH_BIT = 1 << 31;
+
+    static final int JDK_1_3_MODIFIERS = SHIFT_DOWN_MASK - 1;
+    static final int HIGH_MODIFIERS = ~( FIRST_HIGH_BIT - 1 );
+
+    /**
+     * An array of extended modifiers for additional buttons.
+     * @see getButtonDownMasks
+     * There are twenty buttons fit into 4byte space.
+     * one more bit is reserved for FIRST_HIGH_BIT.
+     * @since 7.0
+     */
+    private static final int [] BUTTON_DOWN_MASK = new int [] { BUTTON1_DOWN_MASK,
+                                                               BUTTON2_DOWN_MASK,
+                                                               BUTTON3_DOWN_MASK,
+                                                               1<<14, //4th phisical button (this is not a wheel!)
+                                                               1<<15, //(this is not a wheel!)
+                                                               1<<16,
+                                                               1<<17,
+                                                               1<<18,
+                                                               1<<19,
+                                                               1<<20,
+                                                               1<<21,
+                                                               1<<22,
+                                                               1<<23,
+                                                               1<<24,
+                                                               1<<25,
+                                                               1<<26,
+                                                               1<<27,
+                                                               1<<28,
+                                                               1<<29,
+                                                               1<<30};
+
+    /**
+     * The mouse event's x coordinate.
+     * The x value is relative to the component that fired the event.
+     *
+     * @serial
+     * @see #getX()
+     */
+    int x;
+
+    /**
+     * The mouse event's y coordinate.
+     * The y value is relative to the component that fired the event.
+     *
+     * @serial
+     * @see #getY()
+     */
+    int y;
+
+    /**
+     * The mouse event's x absolute coordinate.
+     * In a virtual device multi-screen environment in which the
+     * desktop area could span multiple physical screen devices,
+     * this coordinate is relative to the virtual coordinate system.
+     * Otherwise, this coordinate is relative to the coordinate system
+     * associated with the Component's GraphicsConfiguration.
+     *
+     * @serial
+   */
+    private int xAbs;
+
+    /**
+     * The mouse event's y absolute coordinate.
+     * In a virtual device multi-screen environment in which the
+     * desktop area could span multiple physical screen devices,
+     * this coordinate is relative to the virtual coordinate system.
+     * Otherwise, this coordinate is relative to the coordinate system
+     * associated with the Component's GraphicsConfiguration.
+     *
+     * @serial
+     */
+    private int yAbs;
+
+    /**
+     * Indicates the number of quick consecutive clicks of
+     * a mouse button.
+     * clickCount will be valid for only three mouse events :<BR>
+     * <code>MOUSE_CLICKED</code>,
+     * <code>MOUSE_PRESSED</code> and
+     * <code>MOUSE_RELEASED</code>.
+     * For the above, the <code>clickCount</code> will be at least 1.
+     * For all other events the count will be 0.
+     *
+     * @serial
+     * @see #getClickCount().
+     */
+    int clickCount;
+
+    /**
+     * Indicates which, if any, of the mouse buttons has changed state.
+     *
+     * The valid values are ranged from 0 to the value returned by the
+     * {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()} method.
+     * This range already includes constants {@code NOBUTTON}, {@code BUTTON1},
+     * {@code BUTTON2}, and {@code BUTTON3}
+     * if these buttons are present. So it is allowed to use these constants too.
+     * For example, for a mouse with two buttons this field may contain the following values:
+     * <ul>
+     * <li> 0 ({@code NOBUTTON})
+     * <li> 1 ({@code BUTTON1})
+     * <li> 2 ({@code BUTTON2})
+     * </ul>
+     * If a mouse has 5 buttons, this field may contain the following values:
+     * <ul>
+     * <li> 0 ({@code NOBUTTON})
+     * <li> 1 ({@code BUTTON1})
+     * <li> 2 ({@code BUTTON2})
+     * <li> 3 ({@code BUTTON3})
+     * <li> 4
+     * <li> 5
+     * </ul>
+     * If support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled()} disabled by Java
+     * then the field may not contain the value larger than {@code BUTTON3}.
+     * @serial
+     * @see #getButton()
+     * @see java.awt.Toolkit#areExtraMouseButtonsEnabled()
+     */
+    int button;
+
+    /**
+     * A property used to indicate whether a Popup Menu
+     * should appear  with a certain gestures.
+     * If <code>popupTrigger</code> = <code>false</code>,
+     * no popup menu should appear.  If it is <code>true</code>
+     * then a popup menu should appear.
+     *
+     * @serial
+     * @see java.awt.PopupMenu
+     * @see #isPopupTrigger()
+     */
+    boolean popupTrigger = false;
+
+    /**
+     * The input event's Time stamp in UTC format.  The time stamp
+     * indicates when the input event was created.
+     *
+     * @serial
+     * @see #getWhen()
+     */
+    long when;
+
+    /**
+     * The state of the modifier mask at the time the input
+     * event was fired.
+     *
+     * @serial
+     * @see #getModifiers()
+     * @see #getModifiersEx()
+     * @see java.awt.event.KeyEvent
+     * @see java.awt.event.MouseEvent
+     */
+    int modifiers;
+
+    /**
+     * The event's id.
+     * @serial
+     * @see #getID()
+     * @see #AWTEvent
+     */
+    protected int id;
+
+    /**
+     * Controls whether or not the event is sent back down to the peer once the
+     * source has processed it - false means it's sent to the peer; true means
+     * it's not. Semantic events always have a 'true' value since they were
+     * generated by the peer in response to a low-level event.
+     * @serial
+     * @see #consume
+     * @see #isConsumed
+     */
+    protected boolean consumed = false;
+
+    /*
+     * JDK 1.1 serialVersionUID
+     */
+    private static final long serialVersionUID = -991214153494842848L;
+
+    /**
+     * A number of buttons available on the mouse at the {@code Toolkit} machinery startup.
+     */
+    private static int cachedNumberOfButtons;
+
+    /**
+     * Returns the absolute x, y position of the event.
+     * In a virtual device multi-screen environment in which the
+     * desktop area could span multiple physical screen devices,
+     * these coordinates are relative to the virtual coordinate system.
+     * Otherwise, these coordinates are relative to the coordinate system
+     * associated with the Component's GraphicsConfiguration.
+     *
+     * @return a <code>Point</code> object containing the absolute  x
+     *  and y coordinates.
+     *
+     * @see java.awt.GraphicsConfiguration
+     * @since 1.6
+     */
+    public Point getLocationOnScreen(){
+      return new Point(xAbs, yAbs);
+    }
+
+    /**
+     * Returns the event type.
+     */
+    public int getID() {
+        return id;
+    }
+
+    /**
+     * Consumes this event so that it will not be processed
+     * in the default manner by the source which originated it.
+     */
+    public void consume() {
+        consumed = true;
+    }
+
+    /**
+     * Returns whether or not this event has been consumed.
+     * @see #consume
+     */
+    public boolean isConsumed() {
+        return consumed;
+    }
+
+    /**
+     * Returns the absolute horizontal x position of the event.
+     * In a virtual device multi-screen environment in which the
+     * desktop area could span multiple physical screen devices,
+     * this coordinate is relative to the virtual coordinate system.
+     * Otherwise, this coordinate is relative to the coordinate system
+     * associated with the Component's GraphicsConfiguration.
+     *
+     * @return x  an integer indicating absolute horizontal position.
+     *
+     * @see java.awt.GraphicsConfiguration
+     * @since 1.6
+     */
+    public int getXOnScreen() {
+        return xAbs;
+    }
+
+    /**
+     * Returns the difference in milliseconds between the timestamp of when this event occurred and
+     * midnight, January 1, 1970 UTC.
+     */
+    public long getWhen() {
+        return when;
+    }
+
+    /**
+     * Returns the modifier mask for this event.
+     */
+    public int getModifiers() {
+        return modifiers & (JDK_1_3_MODIFIERS | HIGH_MODIFIERS);
+    }
+
+    /**
+     * Returns the absolute vertical y position of the event.
+     * In a virtual device multi-screen environment in which the
+     * desktop area could span multiple physical screen devices,
+     * this coordinate is relative to the virtual coordinate system.
+     * Otherwise, this coordinate is relative to the coordinate system
+     * associated with the Component's GraphicsConfiguration.
+     *
+     * @return y  an integer indicating absolute vertical position.
+     *
+     * @see java.awt.GraphicsConfiguration
+     * @since 1.6
+     */
+    public int getYOnScreen() {
+        return yAbs;
+    }
+
+    /**
+     * Constructs a <code>MouseEvent</code> object with the
+     * specified source component,
+     * type, time, modifiers, coordinates, click count, popupTrigger flag,
+     * and button number.
+     * <p>
+     * Creating an invalid event (such
+     * as by using more than one of the old _MASKs, or modifier/button
+     * values which don't match) results in unspecified behavior.
+     * An invocation of the form
+     * <tt>MouseEvent(source, id, when, modifiers, x, y, clickCount, popupTrigger, button)</tt>
+     * behaves in exactly the same way as the invocation
+     * <tt> {@link #MouseEvent(Component, int, long, int, int, int,
+     * int, int, int, boolean, int) MouseEvent}(source, id, when, modifiers,
+     * x, y, xAbs, yAbs, clickCount, popupTrigger, button)</tt>
+     * where xAbs and yAbs defines as source's location on screen plus
+     * relative coordinates x and y.
+     * xAbs and yAbs are set to zero if the source is not showing.
+     * This method throws an
+     * <code>IllegalArgumentException</code> if <code>source</code>
+     * is <code>null</code>.
+     *
+     * @param source       The <code>Component</code> that originated the event
+     * @param id              An integer indicating the type of event.
+     *                     For information on allowable values, see
+     *                     the class description for {@link MouseEvent}
+     * @param when         A long integer that gives the time the event occurred.
+     *                     Passing negative or zero value
+     *                     is not recommended
+     * @param modifiers    The modifier keys down during event (e.g. shift, ctrl,
+     *                     alt, meta)
+     *                     Passing negative parameter
+     *                     is not recommended.
+     *                     Zero value means that no modifiers were passed.
+     *                     Use either an extended _DOWN_MASK or old _MASK modifiers,
+     *                     however do not mix models in the one event.
+     *                     The extended modifiers are preferred for using
+     * @param x            The horizontal x coordinate for the mouse location.
+     *                       It is allowed to pass negative values
+     * @param y            The vertical y coordinate for the mouse location.
+     *                       It is allowed to pass negative values
+     * @param clickCount   The number of mouse clicks associated with event.
+     *                       Passing negative value
+     *                       is not recommended
+     * @param popupTrigger A boolean that equals {@code true} if this event
+     *                     is a trigger for a popup menu
+     * @param button       An integer that indicates, which of the mouse buttons has
+     *                     changed its state.
+     * The following rules are applied to this parameter:
+     * <ul>
+     * <li>If support for the extended mouse buttons is
+     * {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java
+     * then it is allowed to create {@code MouseEvent} objects only with the standard buttons:
+     * {@code NOBUTTON}, {@code BUTTON1}, {@code BUTTON2}, and
+     * {@code BUTTON3}.
+     * <li> If support for the extended mouse buttons is
+     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java
+     * then it is allowed to create {@code MouseEvent} objects with
+     * the standard buttons.
+     * In case the support for extended mouse buttons is
+     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java, then
+     * in addition to the standard buttons, {@code MouseEvent} objects can be created
+     * using buttons from the range starting from 4 to
+     * {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}
+     * if the mouse has more than three buttons.
+     * </ul>
+     * @throws IllegalArgumentException if {@code button} is less then zero
+     * @throws IllegalArgumentException if <code>source</code> is null
+     * @throws IllegalArgumentException if {@code button} is greater then BUTTON3 and the support for extended mouse buttons is
+     *                                  {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java
+     * @throws IllegalArgumentException if {@code button} is greater then the
+     *                                  {@link java.awt.MouseInfo#getNumberOfButtons() current number of buttons} and the support
+     *                                  for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled}
+     *                                  by Java
+     * @throws IllegalArgumentException if an invalid <code>button</code>
+     *            value is passed in
+     * @throws IllegalArgumentException if <code>source</code> is null
+     * @see #getSource()
+     * @see #getID()
+     * @see #getWhen()
+     * @see #getModifiers()
+     * @see #getX()
+     * @see #getY()
+     * @see #getClickCount()
+     * @see #isPopupTrigger()
+     * @see #getButton()
+     * @since 1.4
+     */
+    public MouseEvent(Object source, int id, long when, int modifiers,
+                      int x, int y, int clickCount, boolean popupTrigger,
+                      int button)
+    {
+        this(source, id, when, modifiers, x, y, 0, 0, clickCount, popupTrigger, button);
+    }
+
+    /**
+     * Constructs a <code>MouseEvent</code> object with the
+     * specified source component,
+     * type, modifiers, coordinates, click count, and popupTrigger flag.
+     * An invocation of the form
+     * <tt>MouseEvent(source, id, when, modifiers, x, y, clickCount, popupTrigger)</tt>
+     * behaves in exactly the same way as the invocation
+     * <tt> {@link #MouseEvent(Component, int, long, int, int, int,
+     * int, int, int, boolean, int) MouseEvent}(source, id, when, modifiers,
+     * x, y, xAbs, yAbs, clickCount, popupTrigger, MouseEvent.NOBUTTON)</tt>
+     * where xAbs and yAbs defines as source's location on screen plus
+     * relative coordinates x and y.
+     * xAbs and yAbs are set to zero if the source is not showing.
+     * This method throws an <code>IllegalArgumentException</code>
+     * if <code>source</code> is <code>null</code>.
+     *
+     * @param source       The <code>Component</code> that originated the event
+     * @param id              An integer indicating the type of event.
+     *                     For information on allowable values, see
+     *                     the class description for {@link MouseEvent}
+     * @param when         A long integer that gives the time the event occurred.
+     *                     Passing negative or zero value
+     *                     is not recommended
+     * @param modifiers    The modifier keys down during event (e.g. shift, ctrl,
+     *                     alt, meta)
+     *                     Passing negative parameter
+     *                     is not recommended.
+     *                     Zero value means that no modifiers were passed.
+     *                     Use either an extended _DOWN_MASK or old _MASK modifiers,
+     *                     however do not mix models in the one event.
+     *                     The extended modifiers are preferred for using
+     * @param x            The horizontal x coordinate for the mouse location.
+     *                       It is allowed to pass negative values
+     * @param y            The vertical y coordinate for the mouse location.
+     *                       It is allowed to pass negative values
+     * @param clickCount   The number of mouse clicks associated with event.
+     *                       Passing negative value
+     *                       is not recommended
+     * @param popupTrigger A boolean that equals {@code true} if this event
+     *                     is a trigger for a popup menu
+     * @throws IllegalArgumentException if <code>source</code> is null
+     * @see #getSource()
+     * @see #getID()
+     * @see #getWhen()
+     * @see #getModifiers()
+     * @see #getX()
+     * @see #getY()
+     * @see #getClickCount()
+     * @see #isPopupTrigger()
+     */
+     public MouseEvent(Object source, int id, long when, int modifiers,
+                      int x, int y, int clickCount, boolean popupTrigger) {
+        this(source, id, when, modifiers, x, y, clickCount, popupTrigger, NOBUTTON);
+     }
+
+
+    /* if the button is an extra button and it is released or clicked then in Xsystem its state
+       is not modified. Exclude this button number from ExtModifiers mask.*/
+    transient private boolean shouldExcludeButtonFromExtModifiers = false;
+
+    /**
+     * Constructs a <code>MouseEvent</code> object with the
+     * specified source component,
+     * type, time, modifiers, coordinates, absolute coordinates, click count, popupTrigger flag,
+     * and button number.
+     * <p>
+     * Creating an invalid event (such
+     * as by using more than one of the old _MASKs, or modifier/button
+     * values which don't match) results in unspecified behavior.
+     * Even if inconsistent values for relative and absolute coordinates are
+     * passed to the constructor, the mouse event instance is still
+     * created and no exception is thrown.
+     * This method throws an
+     * <code>IllegalArgumentException</code> if <code>source</code>
+     * is <code>null</code>.
+     *
+     * @param source       The <code>Component</code> that originated the event
+     * @param id              An integer indicating the type of event.
+     *                     For information on allowable values, see
+     *                     the class description for {@link MouseEvent}
+     * @param when         A long integer that gives the time the event occurred.
+     *                     Passing negative or zero value
+     *                     is not recommended
+     * @param modifiers    The modifier keys down during event (e.g. shift, ctrl,
+     *                     alt, meta)
+     *                     Passing negative parameter
+     *                     is not recommended.
+     *                     Zero value means that no modifiers were passed.
+     *                     Use either an extended _DOWN_MASK or old _MASK modifiers,
+     *                     however do not mix models in the one event.
+     *                     The extended modifiers are preferred for using
+     * @param x            The horizontal x coordinate for the mouse location.
+     *                       It is allowed to pass negative values
+     * @param y            The vertical y coordinate for the mouse location.
+     *                       It is allowed to pass negative values
+     * @param xAbs           The absolute horizontal x coordinate for the mouse location
+     *                       It is allowed to pass negative values
+     * @param yAbs           The absolute vertical y coordinate for the mouse location
+     *                       It is allowed to pass negative values
+     * @param clickCount   The number of mouse clicks associated with event.
+     *                       Passing negative value
+     *                       is not recommended
+     * @param popupTrigger A boolean that equals {@code true} if this event
+     *                     is a trigger for a popup menu
+     * @param button       An integer that indicates, which of the mouse buttons has
+     *                     changed its state.
+     * The following rules are applied to this parameter:
+     * <ul>
+     * <li>If support for the extended mouse buttons is
+     * {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java
+     * then it is allowed to create {@code MouseEvent} objects only with the standard buttons:
+     * {@code NOBUTTON}, {@code BUTTON1}, {@code BUTTON2}, and
+     * {@code BUTTON3}.
+     * <li> If support for the extended mouse buttons is
+     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java
+     * then it is allowed to create {@code MouseEvent} objects with
+     * the standard buttons.
+     * In case the support for extended mouse buttons is
+     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java, then
+     * in addition to the standard buttons, {@code MouseEvent} objects can be created
+     * using buttons from the range starting from 4 to
+     * {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}
+     * if the mouse has more than three buttons.
+     * </ul>
+     * @throws IllegalArgumentException if {@code button} is less then zero
+     * @throws IllegalArgumentException if <code>source</code> is null
+     * @throws IllegalArgumentException if {@code button} is greater then BUTTON3 and the support for extended mouse buttons is
+     *                                  {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java
+     * @throws IllegalArgumentException if {@code button} is greater then the
+     *                                  {@link java.awt.MouseInfo#getNumberOfButtons() current number of buttons} and the support
+     *                                  for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled}
+     *                                  by Java
+     * @throws IllegalArgumentException if an invalid <code>button</code>
+     *            value is passed in
+     * @throws IllegalArgumentException if <code>source</code> is null
+     * @see #getSource()
+     * @see #getID()
+     * @see #getWhen()
+     * @see #getModifiers()
+     * @see #getX()
+     * @see #getY()
+     * @see #getXOnScreen()
+     * @see #getYOnScreen()
+     * @see #getClickCount()
+     * @see #isPopupTrigger()
+     * @see #getButton()
+     * @see #button
+     * @see Toolkit#areExtraMouseButtonsEnabled()
+     * @see java.awt.MouseInfo#getNumberOfButtons()
+     * @see InputEvent#getMaskForButton(int)
+     * @since 1.6
+     */
+    public MouseEvent(Object source, int id, long when, int modifiers,
+                      int x, int y, int xAbs, int yAbs,
+                      int clickCount, boolean popupTrigger, int button)
+    {
+        super(source);
+		this.id = id;
+		this.when = when;
+		this.modifiers = modifiers;
+        this.x = x;
+        this.y = y;
+        this.xAbs = xAbs;
+        this.yAbs = yAbs;
+        this.clickCount = clickCount;
+        this.popupTrigger = popupTrigger;
+        if (button < NOBUTTON){
+            throw new IllegalArgumentException("Invalid button value :" + button);
+        }
+        this.button = button;
+
+        if ((getModifiers() != 0) && (getModifiersEx() == 0)) {
+            setNewModifiers();
+        } else if ((getModifiers() == 0) &&
+                   (getModifiersEx() != 0 || button != NOBUTTON) &&
+                   (button <= BUTTON3))
+        {
+            setOldModifiers();
+        }
+    }
+
+    public int getModifiersEx() {
+        int tmpModifiers = modifiers;
+//        if (shouldExcludeButtonFromExtModifiers) {
+  //          tmpModifiers &= ~(InputEvent.getMaskForButton(getButton()));
+    //    }
+        return tmpModifiers & ~JDK_1_3_MODIFIERS;
+    }
+
+    /**
+     * Returns the horizontal x position of the event relative to the
+     * source component.
+     *
+     * @return x  an integer indicating horizontal position relative to
+     *            the component
+     */
+    public int getX() {
+        return x;
+    }
+
+    /**
+     * Returns the vertical y position of the event relative to the
+     * source component.
+     *
+     * @return y  an integer indicating vertical position relative to
+     *            the component
+     */
+    public int getY() {
+        return y;
+    }
+
+    /**
+     * Returns the x,y position of the event relative to the source component.
+     *
+     * @return a <code>Point</code> object containing the x and y coordinates
+     *         relative to the source component
+     *
+     */
+    public Point getPoint() {
+        int x;
+        int y;
+        synchronized (this) {
+            x = this.x;
+            y = this.y;
+        }
+        return new Point(x, y);
+    }
+
+    /**
+     * Translates the event's coordinates to a new position
+     * by adding specified <code>x</code> (horizontal) and <code>y</code>
+     * (vertical) offsets.
+     *
+     * @param x the horizontal x value to add to the current x
+     *          coordinate position
+     * @param y the vertical y value to add to the current y
+                coordinate position
+     */
+    public synchronized void translatePoint(int x, int y) {
+        this.x += x;
+        this.y += y;
+    }
+
+    /**
+     * Returns the number of mouse clicks associated with this event.
+     *
+     * @return integer value for the number of clicks
+     */
+    public int getClickCount() {
+        return clickCount;
+    }
+
+    /**
+     * Returns which, if any, of the mouse buttons has changed state.
+     * The returned value is ranged
+     * from 0 to the {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}
+     * value.
+     * The returned value includes at least the following constants:
+     * <ul>
+     * <li> {@code NOBUTTON}
+     * <li> {@code BUTTON1}
+     * <li> {@code BUTTON2}
+     * <li> {@code BUTTON3}
+     * </ul>
+     * It is allowed to use those constants to compare with the returned button number in the application.
+     * For example,
+     * <pre>
+     * if (anEvent.getButton() == MouseEvent.BUTTON1) {
+     * </pre>
+     * In particular, for a mouse with one, two, or three buttons this method may return the following values:
+     * <ul>
+     * <li> 0 ({@code NOBUTTON})
+     * <li> 1 ({@code BUTTON1})
+     * <li> 2 ({@code BUTTON2})
+     * <li> 3 ({@code BUTTON3})
+     * </ul>
+     * Button numbers greater then {@code BUTTON3} have no constant identifier. So if a mouse with five buttons is
+     * installed, this method may return the following values:
+     * <ul>
+     * <li> 0 ({@code NOBUTTON})
+     * <li> 1 ({@code BUTTON1})
+     * <li> 2 ({@code BUTTON2})
+     * <li> 3 ({@code BUTTON3})
+     * <li> 4
+     * <li> 5
+     * </ul>
+     * <p>
+     * Note: If support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java
+     * then the AWT event subsystem does not produce mouse events for the extended mouse
+     * buttons. So it is not expected that this method returns anything except {@code NOBUTTON}, {@code BUTTON1},
+     * {@code BUTTON2}, {@code BUTTON3}.
+     *
+     * @return one of the values from 0 to {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}
+     *         if support for the extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java.
+     *         That range includes {@code NOBUTTON}, {@code BUTTON1}, {@code BUTTON2}, {@code BUTTON3};
+     *         <br>
+     *         {@code NOBUTTON}, {@code BUTTON1}, {@code BUTTON2} or {@code BUTTON3}
+     *         if support for the extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java
+     * @since 1.4
+     * @see Toolkit#areExtraMouseButtonsEnabled()
+     * @see java.awt.MouseInfo#getNumberOfButtons()
+     * @see #MouseEvent(Component, int, long, int, int, int, int, int, int, boolean, int)
+     * @see InputEvent#getMaskForButton(int)
+     */
+    public int getButton() {
+        return button;
+    }
+
+    /**
+     * Returns whether or not this mouse event is the popup menu
+     * trigger event for the platform.
+     * <p><b>Note</b>: Popup menus are triggered differently
+     * on different systems. Therefore, <code>isPopupTrigger</code>
+     * should be checked in both <code>mousePressed</code>
+     * and <code>mouseReleased</code>
+     * for proper cross-platform functionality.
+     *
+     * @return boolean, true if this event is the popup menu trigger
+     *         for this platform
+     */
+    public boolean isPopupTrigger() {
+        return popupTrigger;
+    }
+
+    /**
+     * Returns a <code>String</code> instance describing the modifier keys and
+     * mouse buttons that were down during the event, such as "Shift",
+     * or "Ctrl+Shift". These strings can be localized by changing
+     * the <code>awt.properties</code> file.
+     * <p>
+     * Note that the <code>InputEvent.ALT_MASK</code> and
+     * <code>InputEvent.BUTTON2_MASK</code> have equal values,
+     * so the "Alt" string is returned for both modifiers.  Likewise,
+     * the <code>InputEvent.META_MASK</code> and
+     * <code>InputEvent.BUTTON3_MASK</code> have equal values,
+     * so the "Meta" string is returned for both modifiers.
+     * <p>
+     * Note that passing negative parameter is incorrect,
+     * and will cause the returning an unspecified string.
+     * Zero parameter means that no modifiers were passed and will
+     * cause the returning an empty string.
+     * <p>
+     * @param modifiers A modifier mask describing the modifier keys and
+     *                  mouse buttons that were down during the event
+     * @return string   string text description of the combination of modifier
+     *                  keys and mouse buttons that were down during the event
+     * @see InputEvent#getModifiersExText(int)
+     * @since 1.4
+     */
+    public static String getMouseModifiersText(int modifiers) {
+        StringBuffer buf = new StringBuffer();
+        if ((modifiers & ALT_MASK) != 0) {
+            buf.append("Alt");
+            buf.append("+");
+        }
+        if ((modifiers & META_MASK) != 0) {
+            buf.append("Meta");
+            buf.append("+");
+        }
+        if ((modifiers & CTRL_MASK) != 0) {
+            buf.append("Ctrl");
+            buf.append("+");
+        }
+        if ((modifiers & SHIFT_MASK) != 0) {
+            buf.append("Shift");
+            buf.append("+");
+        }
+        if ((modifiers & ALT_GRAPH_MASK) != 0) {
+            buf.append("Alt Graph");
+            buf.append("+");
+        }
+        if ((modifiers & BUTTON1_MASK) != 0) {
+            buf.append("Button1");
+            buf.append("+");
+        }
+        if ((modifiers & BUTTON2_MASK) != 0) {
+            buf.append("Button2");
+            buf.append("+");
+        }
+        if ((modifiers & BUTTON3_MASK) != 0) {
+            buf.append("Button3");
+            buf.append("+");
+        }
+
+        int mask;
+
+        // TODO: add a toolkit field that holds a number of button on the mouse.
+        // As the method getMouseModifiersText() is static and obtain
+        // an integer as a parameter then we may not restrict this with the number
+        // of buttons installed on the mouse.
+        // It's a temporary solution. We need to somehow hold the number of buttons somewhere else.
+        for (int i = 1; i <= cachedNumberOfButtons; i++){
+            mask = getMaskForButton(i);
+            if ((modifiers & mask) != 0 &&
+                buf.indexOf("Button"+i) == -1) //1,2,3 buttons may already be there; so don't duplicate it.
+            {
+                buf.append("Button"+i);
+                buf.append("+");
+            }
+        }
+
+        if (buf.length() > 0) {
+            buf.setLength(buf.length()-1); // remove trailing '+'
+        }
+        return buf.toString();
+    }
+
+    /**
+     * A method to obtain a mask for any existing mouse button.
+     * The returned mask may be used for different purposes. Following are some of them:
+     * <ul>
+     * <li> {@link java.awt.Robot#mousePress(int) mousePress(buttons)} and
+     *      {@link java.awt.Robot#mouseRelease(int) mouseRelease(buttons)}
+     * <li> as a {@code modifiers} parameter when creating a new {@link MouseEvent} instance
+     * <li> to check {@link MouseEvent#getModifiersEx() modifiersEx} of existing {@code MouseEvent}
+     * </ul>
+     * @param button is a number to represent a button starting from 1.
+     * For example,
+     * <pre>
+     * int button = InputEvent.getMaskForButton(1);
+     * </pre>
+     * will have the same meaning as
+     * <pre>
+     * int button = InputEvent.getMaskForButton(MouseEvent.BUTTON1);
+     * </pre>
+     * because {@link MouseEvent#BUTTON1 MouseEvent.BUTTON1} equals to 1.
+     * If a mouse has three enabled buttons(see {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()})
+     * then the values from the left column passed into the method will return
+     * corresponding values from the right column:
+     * <PRE>
+     *    <b>button </b>   <b>returned mask</b>
+     *    {@link MouseEvent#BUTTON1 BUTTON1}  {@link MouseEvent#BUTTON1_DOWN_MASK BUTTON1_DOWN_MASK}
+     *    {@link MouseEvent#BUTTON2 BUTTON2}  {@link MouseEvent#BUTTON2_DOWN_MASK BUTTON2_DOWN_MASK}
+     *    {@link MouseEvent#BUTTON3 BUTTON3}  {@link MouseEvent#BUTTON3_DOWN_MASK BUTTON3_DOWN_MASK}
+     * </PRE>
+     * If a mouse has more than three enabled buttons then more values
+     * are admissible (4, 5, etc.). There is no assigned constants for these extended buttons.
+     * The button masks for the extra buttons returned by this method have no assigned names like the
+     * first three button masks.
+     * <p>
+     * This method has the following implementation restriction.
+     * It returns masks for a limited number of buttons only. The maximum number is
+     * implementation dependent and may vary.
+     * This limit is defined by the relevant number
+     * of buttons that may hypothetically exist on the mouse but it is greater than the
+     * {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}.
+     * <p>
+     * @throws IllegalArgumentException if {@code button} is less than zero or greater than the number
+     *         of button masks reserved for buttons
+     * @since 7.0
+     * @see java.awt.MouseInfo#getNumberOfButtons()
+     * @see Toolkit#areExtraMouseButtonsEnabled()
+     * @see MouseEvent#getModifiers()
+     * @see MouseEvent#getModifiersEx()
+     */
+    public static int getMaskForButton(int button) {
+        if (button <= 0 || button > BUTTON_DOWN_MASK.length) {
+            throw new IllegalArgumentException("button doesn\'t exist " + button);
+        }
+        return BUTTON_DOWN_MASK[button - 1];
+    }
+    /**
+     * Returns a parameter string identifying this event.
+     * This method is useful for event-logging and for debugging.
+     *
+     * @return a string identifying the event and its attributes
+     */
+    public String paramString() {
+        StringBuffer str = new StringBuffer(80);
+
+        switch(id) {
+          case MOUSE_PRESSED:
+              str.append("MOUSE_PRESSED");
+              break;
+          case MOUSE_RELEASED:
+              str.append("MOUSE_RELEASED");
+              break;
+          case MOUSE_CLICKED:
+              str.append("MOUSE_CLICKED");
+              break;
+          case MOUSE_ENTERED:
+              str.append("MOUSE_ENTERED");
+              break;
+          case MOUSE_EXITED:
+              str.append("MOUSE_EXITED");
+              break;
+          case MOUSE_MOVED:
+              str.append("MOUSE_MOVED");
+              break;
+          case MOUSE_DRAGGED:
+              str.append("MOUSE_DRAGGED");
+              break;
+          case MOUSE_WHEEL:
+              str.append("MOUSE_WHEEL");
+              break;
+           default:
+              str.append("unknown type");
+        }
+
+        // (x,y) coordinates
+        str.append(",(").append(x).append(",").append(y).append(")");
+        str.append(",absolute(").append(xAbs).append(",").append(yAbs).append(")");
+
+        if (id != MOUSE_DRAGGED && id != MOUSE_MOVED){
+            str.append(",button=").append(getButton());
+        }
+
+        if (getModifiers() != 0) {
+            str.append(",modifiers=").append(getMouseModifiersText(modifiers));
+        }
+
+        if (getModifiersEx() != 0) {
+            //Using plain "modifiers" here does show an excluded extended buttons in the string event representation.
+            //getModifiersEx() solves the problem.
+            str.append(",extModifiers=").append(getModifiersExText(getModifiersEx()));
+        }
+
+        str.append(",clickCount=").append(clickCount);
+
+        return str.toString();
+    }
+
+    /**
+     * Returns a String describing the extended modifier keys and
+     * mouse buttons, such as "Shift", "Button1", or "Ctrl+Shift".
+     * These strings can be localized by changing the
+     * <code>awt.properties</code> file.
+     * <p>
+     * Note that passing negative parameter is incorrect,
+     * and will cause the returning an unspecified string.
+     * Zero parameter means that no modifiers were passed and will
+     * cause the returning an empty string.
+     *
+     * @param modifiers a modifier mask describing the extended
+     *                modifier keys and mouse buttons for the event
+     * @return a text description of the combination of extended
+     *         modifier keys and mouse buttons that were held down
+     *         during the event.
+     * @since 1.4
+     */
+    public static String getModifiersExText(int modifiers) {
+        StringBuffer buf = new StringBuffer();
+        if ((modifiers & META_DOWN_MASK) != 0) {
+            buf.append("Meta");
+            buf.append("+");
+        }
+        if ((modifiers & CTRL_DOWN_MASK) != 0) {
+            buf.append("Ctrl");
+            buf.append("+");
+        }
+        if ((modifiers & ALT_DOWN_MASK) != 0) {
+            buf.append("Alt");
+            buf.append("+");
+        }
+        if ((modifiers & SHIFT_DOWN_MASK) != 0) {
+            buf.append("Shift");
+            buf.append("+");
+        }
+        if ((modifiers & ALT_GRAPH_DOWN_MASK) != 0) {
+            buf.append("Alt Graph");
+            buf.append("+");
+        }
+
+        int buttonNumber = 1;
+        for (int mask = 0; mask < BUTTON_DOWN_MASK.length; mask++){
+            if ((modifiers & mask) != 0) {
+                buf.append("Button"+buttonNumber);
+                buf.append("+");
+            }
+            buttonNumber++;
+        }
+        if (buf.length() > 0) {
+            buf.setLength(buf.length()-1); // remove trailing '+'
+        }
+        return buf.toString();
+    }    /**
+     * Sets new modifiers by the old ones.
+     * Also sets button.
+     */
+    private void setNewModifiers() {
+        if ((modifiers & BUTTON1_MASK) != 0) {
+            modifiers |= BUTTON1_DOWN_MASK;
+        }
+        if ((modifiers & BUTTON2_MASK) != 0) {
+            modifiers |= BUTTON2_DOWN_MASK;
+        }
+        if ((modifiers & BUTTON3_MASK) != 0) {
+            modifiers |= BUTTON3_DOWN_MASK;
+        }
+        if (id == MOUSE_PRESSED
+            || id == MOUSE_RELEASED
+            || id == MOUSE_CLICKED)
+        {
+            if ((modifiers & BUTTON1_MASK) != 0) {
+                button = BUTTON1;
+                modifiers &= ~BUTTON2_MASK & ~BUTTON3_MASK;
+                if (id != MOUSE_PRESSED) {
+                    modifiers &= ~BUTTON1_DOWN_MASK;
+                }
+            } else if ((modifiers & BUTTON2_MASK) != 0) {
+                button = BUTTON2;
+                modifiers &= ~BUTTON1_MASK & ~BUTTON3_MASK;
+                if (id != MOUSE_PRESSED) {
+                    modifiers &= ~BUTTON2_DOWN_MASK;
+                }
+            } else if ((modifiers & BUTTON3_MASK) != 0) {
+                button = BUTTON3;
+                modifiers &= ~BUTTON1_MASK & ~BUTTON2_MASK;
+                if (id != MOUSE_PRESSED) {
+                    modifiers &= ~BUTTON3_DOWN_MASK;
+                }
+            }
+        }
+        if ((modifiers & ALT_MASK) != 0) {
+            modifiers |= ALT_DOWN_MASK;
+        }
+        if ((modifiers & META_MASK) != 0) {
+            modifiers |= META_DOWN_MASK;
+        }
+        if ((modifiers & SHIFT_MASK) != 0) {
+            modifiers |= SHIFT_DOWN_MASK;
+        }
+        if ((modifiers & CTRL_MASK) != 0) {
+            modifiers |= CTRL_DOWN_MASK;
+        }
+        if ((modifiers & ALT_GRAPH_MASK) != 0) {
+            modifiers |= ALT_GRAPH_DOWN_MASK;
+        }
+    }
+
+    /**
+     * Sets old modifiers by the new ones.
+     */
+    private void setOldModifiers() {
+        if (id == MOUSE_PRESSED
+            || id == MOUSE_RELEASED
+            || id == MOUSE_CLICKED)
+        {
+            switch(button) {
+            case BUTTON1:
+                modifiers |= BUTTON1_MASK;
+                break;
+            case BUTTON2:
+                modifiers |= BUTTON2_MASK;
+                break;
+            case BUTTON3:
+                modifiers |= BUTTON3_MASK;
+                break;
+            }
+        } else {
+            if ((modifiers & BUTTON1_DOWN_MASK) != 0) {
+                modifiers |= BUTTON1_MASK;
+            }
+            if ((modifiers & BUTTON2_DOWN_MASK) != 0) {
+                modifiers |= BUTTON2_MASK;
+            }
+            if ((modifiers & BUTTON3_DOWN_MASK) != 0) {
+                modifiers |= BUTTON3_MASK;
+            }
+        }
+        if ((modifiers & ALT_DOWN_MASK) != 0) {
+            modifiers |= ALT_MASK;
+        }
+        if ((modifiers & META_DOWN_MASK) != 0) {
+            modifiers |= META_MASK;
+        }
+        if ((modifiers & SHIFT_DOWN_MASK) != 0) {
+            modifiers |= SHIFT_MASK;
+        }
+        if ((modifiers & CTRL_DOWN_MASK) != 0) {
+            modifiers |= CTRL_MASK;
+        }
+        if ((modifiers & ALT_GRAPH_DOWN_MASK) != 0) {
+            modifiers |= ALT_GRAPH_MASK;
+        }
+    }
+
+    /**
+     * Sets new modifiers by the old ones.
+     * @serial
+     */
+    private void readObject(ObjectInputStream s)
+      throws IOException, ClassNotFoundException {
+        s.defaultReadObject();
+        if (getModifiers() != 0 && getModifiersEx() == 0) {
+            setNewModifiers();
+        }
+    }
+
+    public void setSource(Object newSource) {
+		source = newSource;
+	}
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/builtinsage/MouseListener.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/builtinsage/MouseListener.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/builtinsage/MouseListener.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/builtinsage/MouseListener.java	2010-05-15 14:00:05.000000000 -0400
@@ -0,0 +1,84 @@
+/*
+ * Copyright 1996-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.event;
+
+import java.util.EventListener;
+
+/**
+ * The listener interface for receiving "interesting" mouse events
+ * (press, release, click, enter, and exit) on a component.
+ * (To track mouse moves and mouse drags, use the
+ * <code>MouseMotionListener</code>.)
+ * <P>
+ * The class that is interested in processing a mouse event
+ * either implements this interface (and all the methods it
+ * contains) or extends the abstract <code>MouseAdapter</code> class
+ * (overriding only the methods of interest).
+ * <P>
+ * The listener object created from that class is then registered with a
+ * component using the component's <code>addMouseListener</code>
+ * method. A mouse event is generated when the mouse is pressed, released
+ * clicked (pressed and released). A mouse event is also generated when
+ * the mouse cursor enters or leaves a component. When a mouse event
+ * occurs, the relevant method in the listener object is invoked, and
+ * the <code>MouseEvent</code> is passed to it.
+ *
+ * @author Carl Quinn
+ *
+ * @see MouseAdapter
+ * @see MouseEvent
+ * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/mouselistener.html">Tutorial: Writing a Mouse Listener</a>
+ *
+ * @since 1.1
+ */
+public interface MouseListener extends EventListener {
+
+    /**
+     * Invoked when the mouse button has been clicked (pressed
+     * and released) on a component.
+     */
+    public void mouseClicked(MouseEvent e);
+
+    /**
+     * Invoked when a mouse button has been pressed on a component.
+     */
+    public void mousePressed(MouseEvent e);
+
+    /**
+     * Invoked when a mouse button has been released on a component.
+     */
+    public void mouseReleased(MouseEvent e);
+
+    /**
+     * Invoked when the mouse enters a component.
+     */
+    public void mouseEntered(MouseEvent e);
+
+    /**
+     * Invoked when the mouse exits a component.
+     */
+    public void mouseExited(MouseEvent e);
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/builtinsage/MouseMotionListener.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/builtinsage/MouseMotionListener.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/builtinsage/MouseMotionListener.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/builtinsage/MouseMotionListener.java	2010-05-15 14:00:05.000000000 -0400
@@ -0,0 +1,75 @@
+/*
+ * Copyright 1996-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.event;
+
+import java.util.EventListener;
+
+/**
+ * The listener interface for receiving mouse motion events on a component.
+ * (For clicks and other mouse events, use the <code>MouseListener</code>.)
+ * <P>
+ * The class that is interested in processing a mouse motion event
+ * either implements this interface (and all the methods it
+ * contains) or extends the abstract <code>MouseMotionAdapter</code> class
+ * (overriding only the methods of interest).
+ * <P>
+ * The listener object created from that class is then registered with a
+ * component using the component's <code>addMouseMotionListener</code>
+ * method. A mouse motion event is generated when the mouse is moved
+ * or dragged. (Many such events will be generated). When a mouse motion event
+ * occurs, the relevant method in the listener object is invoked, and
+ * the <code>MouseEvent</code> is passed to it.
+ *
+ * @author Amy Fowler
+ *
+ * @see MouseMotionAdapter
+ * @see MouseEvent
+ * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/mousemotionlistener.html">Tutorial: Writing a Mouse Motion Listener</a>
+ *
+ * @since 1.1
+ */
+public interface MouseMotionListener extends EventListener {
+
+    /**
+     * Invoked when a mouse button is pressed on a component and then
+     * dragged.  <code>MOUSE_DRAGGED</code> events will continue to be
+     * delivered to the component where the drag originated until the
+     * mouse button is released (regardless of whether the mouse position
+     * is within the bounds of the component).
+     * <p>
+     * Due to platform-dependent Drag&Drop implementations,
+     * <code>MOUSE_DRAGGED</code> events may not be delivered during a native
+     * Drag&Drop operation.
+     */
+    public void mouseDragged(MouseEvent e);
+
+    /**
+     * Invoked when the mouse cursor has been moved onto a component
+     * but no buttons have been pushed.
+     */
+    public void mouseMoved(MouseEvent e);
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/builtinsage/Point.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/builtinsage/Point.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/builtinsage/Point.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/builtinsage/Point.java	2010-05-15 14:00:05.000000000 -0400
@@ -0,0 +1,216 @@
+/*
+ * @(#)Point.java	1.23 06/10/10
+ *
+ * Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 only, as published by the Free Software Foundation. 
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License version 2 for more details (a copy is
+ * included at /legal/license.txt). 
+ * 
+ * You should have received a copy of the GNU General Public License
+ * version 2 along with this work; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA 
+ * 
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+ * Clara, CA 95054 or visit www.sun.com if you need additional
+ * information or have any questions. 
+ *
+ */
+package java.awt;
+
+/**
+ * The <code>Point</code> class represents a location in a
+ * two-dimensional (<i>x</i>,&nbsp;<i>y</i>) coordinate space.
+ *
+ * @version 	1.18, 08/19/02
+ * @author 	Sami Shaio
+ * @since       JDK1.0
+ */
+public class Point implements java.io.Serializable, Cloneable {
+    /**
+     * The <i>x</i> coordinate. 
+     * @since   JDK1.0
+     */
+    public int x;
+    /**
+     * The <i>y</i> coordinate. 
+     * @since   JDK1.0
+     */
+    public int y;
+    /*
+     * JDK 1.1 serialVersionUID 
+     */
+    private static final long serialVersionUID = -5276940640259749850L;
+    /**
+     * Constructs and initializes a point at the origin 
+     * (0,&nbsp;0) of the coordinate space. 
+     * @param       x   the <i>x</i> coordinate.
+     * @param       y   the <i>y</i> coordinate.
+     * @since       JDK1.1
+     */
+    public Point() {
+        this(0, 0);
+    }
+
+    /**
+     * Constructs and initializes a point with the same location as
+     * the specified <code>Point</code> object.
+     * @param       p a point.
+     * @since       JDK1.1
+     */
+    public Point(Point p) {
+        this(p.x, p.y);
+    }
+
+    /**
+     * Constructs and initializes a point at the specified 
+     * (<i>x</i>,&nbsp;<i>y</i>) location in the coordinate space. 
+     * @param       x   the <i>x</i> coordinate.
+     * @param       y   the <i>y</i> coordinate.
+     * @since       JDK1.0
+     */
+    public Point(int x, int y) {
+        this.x = x;
+        this.y = y;
+    }
+
+    /**
+     * Returns the location of this point.
+     * This method is included for completeness, to parallel the
+     * <code>getLocation</code> method of <code>Component</code>.
+     * @return      a copy of this point, at the same location.
+     * @see         sage.awt.Component#getLocation
+     * @see         sage.awt.Point#setLocation(sage.awt.Point)
+     * @see         sage.awt.Point#setLocation(int, int)
+     * @since       JDK1.1
+     */
+    public Point getLocation() {
+        return new Point(x, y);
+    }	
+
+    /**
+     * Sets the location of the point to the specificed location.
+     * This method is included for completeness, to parallel the
+     * <code>setLocation</code> method of <code>Component</code>.
+     * @param       p  a point, the new location for this point.
+     * @see         sage.awt.Component#setLocation(sage.awt.Point)
+     * @see         sage.awt.Point#getLocation
+     * @since       JDK1.1
+     */
+    public void setLocation(Point p) {
+        setLocation(p.x, p.y);
+    }	
+
+    /**
+     * Changes the point to have the specificed location.
+     * <p>
+     * This method is included for completeness, to parallel the
+     * <code>setLocation</code> method of <code>Component</code>.
+     * Its behavior is identical with <code>move(int,&nbsp;int)</code>.
+     * @param       x  the <i>x</i> coordinate of the new location.
+     * @param       y  the <i>y</i> coordinate of the new location.
+     * @see         sage.awt.Component#setLocation(int, int)
+     * @see         sage.awt.Point#getLocation
+     * @see         sage.awt.Point#move(int, int)
+     * @since       JDK1.1
+     */
+    public void setLocation(int x, int y) {
+        move(x, y);
+    }	
+
+    /**
+     * Moves this point to the specificed location in the 
+     * (<i>x</i>,&nbsp;<i>y</i>) coordinate plane. This method
+     * is identical with <code>setLocation(int,&nbsp;int)</code>.
+     * @param       x  the <i>x</i> coordinate of the new location.
+     * @param       y  the <i>y</i> coordinate of the new location.
+     * @see         sage.awt.Component#setLocation(int, int)
+     * @since       JDK1.0
+     */
+    public void move(int x, int y) {
+        this.x = x;
+        this.y = y;
+    }	
+
+    /**
+     * Translates this point, at location (<i>x</i>,&nbsp;<i>y</i>), 
+     * by <code>dx</code> along the <i>x</i> axis and <code>dy</code> 
+     * along the <i>y</i> axis so that it now represents the point 
+     * (<code>x</code>&nbsp;<code>+</code>&nbsp;<code>dx</code>, 
+     * <code>y</code>&nbsp;<code>+</code>&nbsp;<code>dy</code>). 
+     * @param       dx   the distance to move this point 
+     *                            along the <i>x</i> axis.
+     * @param       dy    the distance to move this point 
+     *                            along the <i>y</i> axis.
+     * @since       JDK1.0
+     */
+    public void translate(int x, int y) {
+        this.x += x;
+        this.y += y;
+    }	
+
+    /**
+     * Returns the hashcode for this point.
+     * @return      a hash code for this point.
+     * @since       JDK1.0
+     */
+    public int hashCode() {
+        return x ^ (y * 31);
+    }
+
+    /**
+     * Determines whether two points are equal. Two instances of
+     * <code>Point</code> are equal if the values of their 
+     * <code>x</code> and <code>y</code> member fields, representing
+     * their position in the coordinate space, are the same.
+     * @param      obj   an object to be compared with this point.
+     * @return     <code>true</code> if the object to be compared is
+     *                     an instance of <code>Point</code> and has
+     *                     the same values; <code>false</code> otherwise.
+     * @since      JDK1.0
+     */
+    public boolean equals(Object obj) {
+        if (obj instanceof Point) {
+            Point pt = (Point) obj;
+            return (x == pt.x) && (y == pt.y);
+        }
+        return false;
+    }
+
+    /**
+     * Returns a representation of this point and its location
+     * in the (<i>x</i>,&nbsp;<i>y</i>) coordinate space as a string.
+     * @return    a string representation of this point, 
+     *                 including the values of its member fields.
+     * @since     JDK1.0
+     */
+    public String toString() {
+        return getClass().getName() + "[x=" + x + ",y=" + y + "]";
+    }
+
+    /**
+     * Creates a new object of the same class and with the
+     * same contents as this object.
+     * @return     a clone of this instance.
+     * @exception  OutOfMemoryError            if there is not enough memory.
+     * @see        java.lang.Cloneable
+     * @since      1.2
+     */
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch (CloneNotSupportedException e) {
+            // this shouldn't happen, since we are Cloneable
+            throw new InternalError();
+        }
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/.EXCLUDE phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/.EXCLUDE
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/.EXCLUDE	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/.EXCLUDE	2009-07-07 19:08:58.000000000 -0400
@@ -0,0 +1,154 @@
+java/io/CharConversionException.class
+java/io/File.class
+java/io/FilterInputStream.class
+java/io/IOException.class
+java/io/InputStream.class
+java/io/InvalidClassException.class
+java/io/ObjectStreamException.class
+java/io/Serializable.class
+java/lang/AbstractMethodError.class
+java/lang/ArithmeticException.class
+java/lang/ArrayIndexOutOfBoundsException.class
+java/lang/ArrayStoreException.class
+java/lang/AssertionStatusDirectives.class
+java/lang/AssertionStatusDirectives.class
+java/lang/Boolean.class
+java/lang/Boolean.class
+java/lang/Byte.class
+java/lang/Byte.class
+java/lang/CharSequence.class
+java/lang/Character.class
+java/lang/Character.class
+java/lang/Class$LoadingList.class
+java/lang/Class.class
+java/lang/Class.class
+java/lang/ClassCastException.class
+java/lang/ClassCircularityError.class
+java/lang/ClassFormatError.class
+java/lang/ClassLoader$NativeLibrary.class
+java/lang/ClassLoader.class
+java/lang/ClassLoader.class
+java/lang/ClassNotFoundException.class
+java/lang/CloneNotSupportedException.class
+java/lang/Cloneable.class
+java/lang/Comparable.class
+java/lang/Double.class
+java/lang/Double.class
+java/lang/Error.class
+java/lang/Exception.class
+java/lang/Float.class
+java/lang/Float.class
+java/lang/IllegalAccessError.class
+java/lang/IllegalAccessException.class
+java/lang/IllegalArgumentException.class
+java/lang/IllegalMonitorStateException.class
+java/lang/IllegalStateException.class
+java/lang/IncompatibleClassChangeError.class
+java/lang/IndexOutOfBoundsException.class
+java/lang/InstantiationError.class
+java/lang/InstantiationException.class
+java/lang/Integer.class
+java/lang/Integer.class
+java/lang/InternalError.class
+java/lang/InterruptedException.class
+java/lang/LinkageError.class
+java/lang/Long.class
+java/lang/Long.class
+java/lang/NegativeArraySizeException.class
+java/lang/NoClassDefFoundError.class
+java/lang/NoSuchFieldError.class
+java/lang/NoSuchFieldException.class
+java/lang/NoSuchMethodError.class
+java/lang/NoSuchMethodException.class
+java/lang/NullPointerException.class
+java/lang/Number.class
+java/lang/Object.class
+java/lang/OutOfMemoryError.class
+java/lang/Runnable.class
+java/lang/RuntimeException.class
+java/lang/Short.class
+java/lang/Short.class
+java/lang/Shutdown.class
+java/lang/StackOverflowError.class
+java/lang/StackTraceElement.class
+java/lang/StackTraceElement.class
+java/lang/String.class
+java/lang/String.class
+java/lang/StringBuffer.class
+java/lang/StringIndexOutOfBoundsException.class
+java/lang/System.class
+java/lang/Thread.class
+java/lang/Thread.class
+java/lang/ThreadGroup.class
+java/lang/ThreadLocal.class
+java/lang/Throwable.class
+java/lang/Throwable.class
+java/lang/UnsatisfiedLinkError.class
+java/lang/UnsupportedClassVersionError.class
+java/lang/UnsupportedOperationException.class
+java/lang/VerifyError.class
+java/lang/VirtualMachineError.class
+java/lang/ref/FinalReference.class
+java/lang/ref/Finalizer.class
+java/lang/ref/PhantomReference.class
+java/lang/ref/Reference.class
+java/lang/ref/Reference.class
+java/lang/ref/SoftReference.class
+java/lang/ref/WeakReference.class
+java/lang/reflect/AccessibleObject.class
+java/lang/reflect/AccessibleObject.class
+java/lang/reflect/Constructor$AccessException.class
+java/lang/reflect/Constructor$ArgumentException.class
+java/lang/reflect/Constructor.class
+java/lang/reflect/Constructor.class
+java/lang/reflect/Field.class
+java/lang/reflect/Field.class
+java/lang/reflect/Member.class
+java/lang/reflect/Method$AccessException.class
+java/lang/reflect/Method$ArgumentException.class
+java/lang/reflect/Method.class
+java/lang/reflect/Method.class
+java/net/ContentHandler.class
+java/net/FileNameMap.class
+java/net/URLClassLoader.class
+java/net/URLClassLoader.class
+java/net/URLConnection.class
+java/net/URLStreamHandlerFactory.class
+java/security/AccessController.class
+java/security/CodeSource.class
+java/security/PermissionCollection.class
+java/security/PrivilegedAction.class
+java/security/PrivilegedActionException.class
+java/security/PrivilegedExceptionAction.class
+java/security/SecureClassLoader.class
+java/util/AbstractCollection.class
+java/util/AbstractList.class
+java/util/Collection.class
+java/util/Comparator.class
+java/util/Dictionary.class
+java/util/Enumeration.class
+java/util/Hashtable.class
+java/util/List.class
+java/util/Map.class
+java/util/Random.class
+java/util/RandomAccess.class
+java/util/Vector$1.class
+java/util/Vector.class
+java/util/jar/JarEntry.class
+java/util/jar/JarFile.class
+java/util/zip/InflaterInputStream.class
+java/util/zip/ZipConstants.class
+java/util/zip/ZipEntry.class
+java/util/zip/ZipFile.class
+sun/io/ByteToCharConverter.class
+sun/io/CharToByteConverter.class
+sun/io/CharToByteISO8859_1.class
+sun/io/ConversionBufferFullException.class
+sun/io/MalformedInputException.class
+sun/io/Markable.class
+sun/io/UnknownCharacterException.class
+sun/misc/CVM.class
+sun/misc/Launcher$AppClassLoader.class
+sun/misc/Launcher$ClassContainer.class
+sun/misc/Launcher.class
+sun/misc/ThreadRegistry.class
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/GNUmakefile phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/GNUmakefile
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigma/GNUmakefile	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigma/GNUmakefile	2010-05-15 14:01:07.000000000 -0400
@@ -0,0 +1,64 @@
+#
+# Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
+# 
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License version
+# 2 only, as published by the Free Software Foundation. 
+# 
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License version 2 for more details (a copy is
+# included at /legal/license.txt). 
+# 
+# You should have received a copy of the GNU General Public License
+# version 2 along with this work; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+# 02110-1301 USA 
+# 
+# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+# Clara, CA 95054 or visit www.sun.com if you need additional
+# information or have any questions. 
+#
+# @(#)GNUmakefile	1.6 06/10/10
+#
+
+#
+# GNUmakefile for linux-arm-strongarm target using GCC 3.x and VFP
+#
+
+#
+# platform specific architecture flags
+#
+# NOTE: -msoft-float is enabled in linux-arm/defs.mk automatically if
+# CVM_FORCE_HARD_FLOAT is not true, which is the default.
+#
+ASM_ARCH_FLAGS		= -msoft-float -mips32r2
+CC_ARCH_FLAGS		= -msoft-float -mips32r2
+CC_ARCH_FLAGS_FDLIB	=
+CC_ARCH_FLAGS_LOOP 	=
+LINK_ARCH_FLAGS		=  
+LINK_ARCH_LIBS		= -lm
+
+# assume the JIT is enabled for this device unless told otherwise
+CVM_JIT ?= true
+#CVM_JIT_PROFILE ?= true
+#CVM_TRACE_JIT ?= true
+#CVM_DEBUG ?= true
+
+CVM_JCC_INPUT +=  builtinsage/KeyEvent.class builtinsage/MouseEvent.class builtinsage/MouseListener.class builtinsage/MouseMotionListener.class builtinsage/Point.class
+
+#CVM_SRCDIRS += builtinsage
+#CVM_BUILDDIRS += builtinsage
+#CLASSLIB_CLASSES = java.awt.event.KeyEvent
+
+CCFLAGS_SPEED_OPTIONS ?= -Os
+CCFLAGS_SPACE_OPTIONS ?= -Os
+
+USE_VERBOSE_MAKE = true
+
+# Only enable USE_GCC2 if GCC 3.x or later is *not* being used
+# USE_GCC2 ?= false
+
+include ../share/top.mk
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/buildscript.sh phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/buildscript.sh
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/buildscript.sh	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/buildscript.sh	2009-12-30 21:30:34.000000000 -0500
@@ -0,0 +1,3 @@
+make J2ME_CLASSLIB=foundation CVM_PRELOAD_LIB=true CVM_TARGET_TOOLS_PREFIX=mips-linux-gnu- CVM_COMPILER_INCOMPATIBLE=false CVM_DEBUG_DUMPSTACK=true 
+#USE_JSR_172=true USE_JUMP=false 
+# CVM_JVMTI=true
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/builtinclass.zip.b64 phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/builtinclass.zip.b64
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/builtinclass.zip.b64	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/builtinclass.zip.b64	2011-06-14 16:14:39.000000000 -0400
@@ -0,0 +1,856 @@
+UEsDBBQAAAAIADyhtTzDM0K3wAAAAAYBAAAbABwAamF2YS9hd3QvVHJhbnNwYXJl
+bmN5LmNsYXNzVVQJAAPTIPdL8yL3S3V4CwABBOgDAAAE6AMAAFWPSw6CQBBEqwVB
+8cvChTfQjXgFNJoY/wLuRzIhGjIaGDVezYUH8FDGGVe46HRepbq7+v15vgAM4dpo
+2WgTrPXG30YTAs0IjfFZ5JIJuWfplRvKSQR7NAuXfjDXWCLUwp2/ChbReLIKtWQQ
+WgmXYcZEfmEZF/GDYPT6ap0TnK9ZzKfHlBPcomNwYjdG6Ojmsbv0/sfbPz1lIvHW
+hxOPpaXyoaSvoavKVFTWcWAptgtcUVwtsAMyVWbU9S9o/LTmF1BLAwQUAAAACAA8
+obU8le8+25oBAADiAgAAFAAcAGphdmEvYXd0L1BhbmVsLmNsYXNzVVQJAAPTIPdL
+8yL3S3V4CwABBOgDAAAE6AMAAG2RXUvjQBSG32mTpo3ph19VV7t+a8yF9d7FC10W
+C7IKimsvUzu0IzUFm/r1m7xQsAgK/oD9Ucu+E8MuxA7M8545eeecyczvP6/vALbg
+2sjhaw5ZzGssaCxqLFlYtpHBioVVC2sC4pazxnknYN6oZtgWyLSlarVDBt9UoMId
+gbS7cSpg7HWbUqB4oAL5s3/ZkFcnfqPDTK4nw91uP2j2BCy3xhHZWzI8i/bWPhZ1
+Oin7cfUs418fHS2Gx+qepcruxsGFf+1X/Zuw+l1dyqCnusG2gH3c7V+dyx9KN7SP
+/EB2NrXRQRElBzZGHDgaeY0CRgTGPhfS7nWBwr8vUSGBUpTo+EGreti4kOc8nunq
+38Aiby3HSzU42QR6OLHmYy1EakHos5CjXFWogmp6LxBPDHgeMhMl0+Q4JmLrDlIw
+qWVvdoCUNzdA2qsMYHiTxgDm/73lyGWRWegHLpKTbC3I8qe2z0g9JNrmyamh1nTS
+WiSnh1rNpHWUnBlqNZLWcfILZmOry0vV2dIbMnVt19VfYD0mdunSc9QUKn8BUEsD
+BBQAAAAIAEGhtTyBZ7ieAQMAAFAFAAAfABwAamF2YS9hd3QvY29sb3IvQ29sb3JT
+cGFjZS5jbGFzc1VUCQAD2iD3S/Mi90t1eAsAAQToAwAABOgDAAB9VFtPE0EYPdPb
+tkuhWBCBAgKKtgWpWrkoeIHKZaEBsUBSeSBLWZrF7W6zuxU1Pvpb5EEfvAGJJPpi
+YuIv8c13H4zfbLlIqW6y55s5c+a7zDe7339/+gzgKtIiGpEMoAE3OAxwGBQwJMKL
+pIBhP26KEHBLwIiAURE1SPpxm9s7HO76cY/bMREiF40LSAm4z1BvKaYqa8uKaamG
+viQRxWYYalOGbtmybi/LWknx/lpY/Dm/8vIrg8d+VlRII5FGLxVSRqFo6IpuWwwB
+6+HUuFWUc7QeSW/KT+SEvGUncoZmmIkUxwxfHGHwL2YfTKyS2k21eRmEVGbVKk/d
+Pxh8o6qu2ncYvFFJii1T0JSxTk5DaVVX5kqFNcVclNc0Ymryii05ifKgHVEp9t+4
+Asnn5AJJzx5JNVnPJzK2qep5UtRzxcmy3NGYVN666JQeUK2DdJ21RwxixiiZOWVS
+5SmFjiP28wBBXMREEBG0BdHOoQPnGdoq0iRvx/sYuo9TkzRNycvamJkvFSihiac5
+pWhTqxgalvTHurGldzouOp2T59EmqYzK0hiaKqnx0saGYjI0L+k6ncn6gZvcYenR
+IKYwzYHKZ7EgZjDL0PLP8z0RdX5tU8nZDI0OpRqJjHPN1OflvtG5LfMmnG4B531y
+sajo6wx91QSnqHIh1LxItaYerfpt4/AsGqNVmu/pok+qEZQWfGhGE87RuJkuqAst
+9FIDnXG7Y0XeRrIt6KT5oa6L5t1/zS+QJw91pIeYS8QkieNXPhTfA4tHduCKt+3A
+/Y4ohsuEYZIDA4SDCGAIdRgmG0XswEGetrvIDrW+Bn/izk76aMg2vIfnG2r34c3u
+wfcBHpqntzkhZMP+PQS+9L49CtRB/wpgkuqdRiskynGWwqTRi3kKv0CqOI3LQYcp
+HR60cx9idh815D4Yrt1FXWQXoXA9DXZxZg/hY+8+nhRWCPtw5cBLO1nOeuMf4X5T
+Ic0R9leVuiqlJmGCfohlaQ9lxtnaOFX7CoJnG55T3l8QXnMacv0PUEsDBBQAAAAI
+AEGhtTz8dB3otAAAAOsAAAAiABwAamF2YS9hd3QvY29sb3IvUkdCQ29sb3JTcGFj
+ZS5jbGFzc1VUCQAD2iD3S/Mi90t1eAsAAQToAwAABOgDAAA79W/XPgYGBgMGPi4G
+ZgYudgZudgYeRgY2m8y8zBI7RgZmDc0wRgYW5/yUVEYGfp/MvFS/0tyk1KKQxKQc
+oAhXcH5pUXKqWyaIw++cn5NfFFyQmJyql5VYlsjDwMLAy8ggA2LrJ5aX6CeD5PWD
+3J0QChkZJNGkkeVYNTw9NcMYFBiYgI4DAUYgZGFgBZJsQJ4yUJQRSLNrcbBtZ2Dc
+CFbADiS5gBoYGJqAipqBIhxANhMDJwBQSwMEFAAAAAgAPKG1PCS36CxCBQAAvwkA
+AB0AHABqYXZhL2F3dC9BbHBoYUNvbXBvc2l0ZS5jbGFzc1VUCQAD0yD3S/Mi90t1
+eAsAAQToAwAABOgDAAB9VOtvU2UY/5339N6zrWxQWMulbEO6DRggIGzjUroNKmXF
+rcwN0HHWnbUd3TmlPR2IMcQQY4waY8w0YuIlMTExSCZKIJp4+WKMn/gj/CP8ZHye
+t4etLEiT5/c8v+c8t/fS969/f/oFwF68HkAYlwKI4BUvXvVhOgAVl33Q/eSfYcgx
+zDIYDHMMeYYCQ5FhnuEKQ4lhgcFksLh62YurrCsBVGGzVfNiUYE7mR5OjClQUgqa
+kpZZtXXTntBLNUOl0RQF6vhYkk1B5tB4lk2/Ah95pzMTw2PMVeL0aYW7FHj4e2qU
+mZsYf60zjwKvzD0vS3mJytQ69TmVE9nMOeYBp/JjHqQhJjOyicazlwy9oqA9Pa8v
+6n36NbsvUSoX9KS1ULaqRdsY4PErOZ68anPjSi6zaFS4Z9WuW27ypUzS5GHt4Zia
+zTNTSM3JSthWuZ5Vt9RJi3J9Z1Oj02Pn08NsJiYdM2Bctyu6HIS2dUSBq1IrGVRw
+sGgW7WPE46nuCVJJa5bcLemiaYzWFmaMSlaf4UB3PDXCAcG8QSPxgeTIu5mynrHO
+LZz0jO8+KubMpMa7aSovOcbkYMTp8D2zRqW4KBs9u1BBrxbqo3uMqzW9VFWwIV5P
+KOlmvi8zM2/k7IHuCxQ7mCs5i6YmtKTAuFWr5IyRIvdte7L2Hi6h4RTOMEwp6Fit
+mSqVjLxeSlTytQXDtIev54yyXbTovDbpXCS2yDc2ZtXsmDUXq1CKwUWuKQjXzCum
+dc2M5R73ifFxaBjBZg1DGNZwEIc0vMBwmOEIQz/DAMMgw1GGYwzHGU4wJBjSOKtg
+4//sFn8e9eK6htdwg+c5rSC0dqPW7N64XSma+QHerJZV70jJ0imyeY511kqZ9smi
+XeWrNNKdwj76N0foL7EZ7YgS0m3gPyy2Et/WwGPEtzfwDuKdDbyL+I4G/hzxnQ08
+Try7gfcQ723gu4jvbuB7iPc18L3E9zXw/cSfb+AHiNNhkN3O5yH1YUcfcXS/owcc
+Pejoo44+5ujjjj7h6ITUEZx8Yn8iSD7RH3wjwD+6HvzekJeOjSJSxDrpVRb8aPVE
+tQdQvucHEi/yM8VuYcAj5mTCGSfBpAR+q/p7HkB0BT/+DP4ubelzNP0MdarV9QDu
+X6Our+CPhrSvHaeHnT3R+9Sk6z58qz064KMeBbhEESExj4goYYdYQJ+wcECUcURc
+hZ/vo9P7D+qskL4R+VYuyJKV6N0kOU6SJDlDkiEZJ3mZ5CLJNMkpkhxJnuTKPfiX
+7yFAEiTRSJpImklaSEIk60haSdpI1i+vLmNl9n400+xv4IS4iSHxJk6LW0iLt3BO
+vI2seAeT4l1cEu/jsvgAs+JDFMRHKIkllMUnck2jzpoOwiUPYEOntnQbvshDbKB2
+4alIJx3H8kq7Zt508R0dx10ExTJ5MzjnlNhCmrfB3fMjfHdXUjzsFH8SvoSxp4R6
+76wJfUQ4vrLZu2ksORiHRr+kw/sGwSi3eIiNy2tS/5apWSd1j5Ma5uhOWpbM5Tqd
+T8n9h/D8yoRxyuQJQ/VOm0LbCpx4ec2wKkdN0AnXs6Ypi29lb+/vCN+GW73T+xvC
+ZzlzF8kX7OGCRHxLnzJzrRaU11Btg1ddD7+6Ec1qO9rVCKLqFuxUt6Jb3U4Rk5hy
+mj2SrYD3+Jzoxrf/AD+bbmkG2Az5pR1k2yNNjU2vNJvY9EmzWQbXI1qkXQ8JSbse
+s07aAWm3Sjso7TZpa9Jev/qn2s9/BxGkW9KKsIigQ2zHbhHHYdGHpDiEjDiKi2II
+eZFGVWRxU1yizAvytbj4H1BLAwQUAAAACACLq547b6tZde0cAABJPAAAHQAcAGph
+dmEvYXd0L2V2ZW50L0tleUV2ZW50LmNsYXNzVVQJAANGDDxL8yL3S3V4CwABBOgD
+AAAE6AMAAG2bB3gUVdfHZ+bM7p6EAGECimCJHaQHELC9bjabZCHJLtmEYoMl2SQL
+m92QbChW7NixvApWsGJHXwvqp2LHjr0r9q6xd/nOOXdmc0EfH/Z/fufeuXPm3Dow
+PvX3vQ8YhjHW9heaI6xnC8x9rOcKreetTWi9gNaLhcQvofUyWq+g9Spar6H1Olpv
+oPUmWm+h9TZa76D1LlrvobUZrffR+gCtD9H6CK2P0foErU/R+gytz9H6Aq0v0foK
+ra/R+gatb9HqQes7tL5H6we0fkTrJ7R+RusXtH5F6ze0fkfrD7T+ROsvtP5GawuC
+gWAiWAiAYCP4EPwIAQREKEAoROiDUITQF6EfQn+EYoQBCA5CCcJAhEEI2yFsjzAY
+YQeEIQhDEXZE2AlhZ4RdEEoRdkXYDWF3hD0Q9kTYC2FvhGEIwxH2QRiBMBJhFMJo
+hDEIYxHGIZQhjEeYgDARYV+ESQiTEaYg7IewP8IBCAciHITwH4SDEYII5QghhAqE
+MEIlQhVCNUIEYSrCNIQahFqEOoQoQgxhOkI9QhyhAaERYQbCTIRZCLMRDkE4FOEw
+hMMRjkCYgzAXIYEwD6EJoRkhidCC0IrQhpBCmI+wACGN0I6QQcgidCAsROhE6ELI
+IXQjLEJYjLAEYSnCkQhHIRyNcAzCsQjHISxDOB7hBIQTEU5COBnhFIRTEZYjnIZw
+OsIZCGcinIVwNsI5CCsQzkU4D+F8hAsQ/otwIcJFCCsRViFcjHAJwqUIlyFcjnAF
+wmqENQhXIlyFcDXCNQjXIlyHsBbheoQbEG5EuAnhZoRbEG5FWIdwG8LtCP9DuAPh
+ToS7EO5GWI9wD8K9CPch/B/C/QgPIDyIsAHhIYSHER5BeBThMYTHEZ5A2IjwJMJT
+CE8jPIPwLMJzCM8jbEJ4AeFFhJcQXkZ4BeFVhNcQXkd4A+FNhLcQ3kZ4B+FdhPcQ
+NiO8j/ABwocIHyF8HIBPCs0drGfpBz5F+Iz1c/75AkyacQhfInyF8HUhfAPfIvQg
+fIfwPcIPXOdH/vkpAD8H4BfT6JvqinVmlywNNuVSi5KmYR5iGgXTwrPnVEbq4w3E
+EaoTyma6colMbkYi3Z0EwzBXmAZypZpgvIH5PPeihtmxcIVp9GE7Vh+Ox8MVXHyu
+aRSxqz5cEw7GuQbOmDYnXNcQrqdio5BuQVweDE2bE48FQ2F2omn4ydkQLGcqoBsQ
+hYJ1oXANO0C1EaIGpY0ixfHqSCVHZBSbRiGXR+sa6qNyxQDVYLBGyh1VPxZsjMvt
+SihEuUEsPqcmGprGvoHqpuE4eaXSUPcmXoyl6iaxYFV4TmOMPbuqZsRTEZ1Zx77d
+1I3DdZwLY3fTCBBVR2uliT0U1oRV2Huaho9QNbaXul19pKpaCvdWdb12h7kpiNbW
+BplHKq6N1DXGmUep8GPh+khUbj3aDZ96rZp5jGnYxGPZHqvscWyPU3YZ22XKHs/2
+eGVPYHuCsieyPVHZ+7K9r7InsT1J2ZPZnqzsKWxPUUmKh2sjoWhNVB5mfzfX0xuD
+NRL9geoCebKgsmUklCs7xHZI2fJwFcqWpIaVXcl2pbKr2K5Stjx8tbIjbEeUPZXt
+qcqWATBN2TJ8apRdy3atsiXwOmVH2Y4qWzovpuzpbE9XtgzUemXLM8aVLZ3boOxG
+thuVPYPtGcqeyfZMZc9ie5ayZ7M9W9mHsE3ztz/HEwvXzSmvpykVluYP1eeYNwAO
+M41imUTReFivfLga13WNtbFghQyPubpHBklC98hQmad7ZMA06R4ZNs26RwZPUvfI
+EGrRPTKQWnWPDKc23SODKkXLDvdPY01DJFYjaZnvzvgKGSALvFEXC9YH3ZUnvZUv
+Wq/aiDeWN1AyJBXt6kYV4VCkNigDIaNGakVkRqRCRlvWddDi1iCO41QzFFx+KaEF
+sx+3HKLFqCbvPVfN9kpJaIcLksuFLkgaO12QDHa5IMnLuSB563ZBUrbIBcnWYhck
+UUtUVirHSccu9UhiONIjCeIojziKHsMjDqPH9Ijj6LE84kB6wCOOpMf2iEPp8XnE
+sfT4XSrjWHoCHnEsPegRx9JT4JHEUuiRxNJHJTdWH6lroAyHwzIxL1bdEqmLh+ul
+Ky9xV95wjUzQSxXWhhtkjblMmyDTG6OqJzeoFTPP7yqeFnNX6M1qdBB7i/L7eY+3
+pH+gRgN58gv5h+peFeFgxZyq+uAMaXuZ5gyGGtUNjzcNx3OGIvWhxtrKmrDM/xO0
+6g2RGjUUT1SZEGdtkAabxHSSVrW8Pqxud7Ka++p25dEZ4YqoxHaKaQzw/BWRYJh2
+8YgsVqdqBXIBpVtW1eWmUZK/ItpYTluyF/5p2p1DQTec09UKpZzhikhNjXTAGVrs
+0apoXVimyJlqhoo3ElVddZZpDPR8M6IRamNOPNqottezTWOwV8YbzLbl56j2grW0
+LcaDyneh6iE6y9AzxeW2FymXdHxFucz7ld5OHZd0rFIdXVUf9haT1appXkfDXuev
+cUcV+/Ldf6WajkEGy/B2cbURWqa6YqvOtix3iaHFQ447Fqh7hRvro3PikSq50lb9
+EJ4VqgnWBhsi0ToaA/X8OBbNuh1lLlCv0QP9ax2/upwjp/NLPZ3Oqt2utwKqa2hB
+Kw/X5++HKiGxGjluWAWqV+Qpt23APeFRH1DWQ9F6HhxWH5XBmZE6mjxSrUiNDD60
+hWc10NSs4+3Q6qtSVBmpUyvw4PzZboY7tXdU7ddF6zTnTippwVAoHBPHzqpWbZRW
+8+pgXZUM0V3UU0wL1snYGuTO8GDdVDka7KBCCtbE6IrGWupEOXn0uJM62BD0rvxO
+uaoj9cEq1/W9umFlI635MyMVDbLp/qCc1cGayl7njyr59dHaYN0cCo63H0oVF/2k
+5l2Q2qDjb0WkgsYbF9DZ3Bgky154RiTaGO8t5UJvGNGzUrfHGuWYbqkumhqMBevC
+tOVr4ZuwTZn2HKatQsiXSZhc4FPDkNvwNjWTxtF2Mtbopry6VkdpPtfNiVbyccx0
+1/iQBLTlBZX8UDTGG/aWZ71DeVweYsvzqpiGDR+vtjytiimsCN99y5OqmMYFT+Mt
+m9yr66Mxzs+Wp1RxvCHKa/WWjd6oqY1F5cy/pdRdC2oaeBWOcUdsOVY1Uh6uUveY
+perwyKX7yOsMp74f91Gvl/qCh8WWLZREeS+KhtTkaqybVkc7A/XUVu54A/VVsF5a
+o54asFWht3ZQbzlbFcjUooGylVMdgbg+9VK//LPQtI7T8bWovLGhIVo3zsVCeT9y
+oSDUUF/j2bwNujZyI8r0H5DKpHIHmQYMG84H0VC2mc5r/WtSmWRdd/u8ZGdDYl6a
+T3Ctydy05NKG5BI6kQwaFhleMz+xKDEmnci0jonnOlOZVjrfl6hKtdnmVEsq2dml
+ajvkbchm0wtSOXoR7Uh25uhIMnnYPxv4p+df71IYz3Z3NiUrUxxXX7pfeFEykxvN
+NYush61HisyR5qgA/FoEv8Hv9ODBmQ2jqUKSD1lh1iLrSYuGTl8umJdoWhDvSDRR
+UwXlZHcpO8BluQQdeKGBfwuZmxKZpiQdKP0h15Cmm9LJBDcdUtpHfNn2jmwXtxPy
+LKnbkehm2xdTWqRa7eiqyTYt4O4is1TZcsNkFxVSPX/YNaQRN0SfGzZKw63ddLoM
+xBKtydLGjryzmY+y4qzILs64j5XM0Bkdwvwr1dqy7dSMXS0innSyhfrNrhHxs4db
+t7hhiaAz1drGB9N6pXJNs9zAVveRWvOSrSmyfeVKVextKW7TF1fqJiuT68ymJVme
+xf5EmmpAMO3doT2Zo1cSu1akyK1R1ZnoaOPG07nSvK16oD3BvaJU0klDL5Wlp/bH
+XEOFlE50tXFISmVUdCXbU03ZdJbDjvfaqlMWdifSXdwprtGfvTSuM+WdNICSFG5R
+lKg0j70DTd2ikAdaqQvFagzRGOmtH2LsvV6etb07nUt1pGnqIE3MWKK5dB8vT83N
+vc4R+SfoSHQmctnO3qKRbktd3fNy1HSut2SU2xPNyaZUeyLdWzDafebm1KIUrwue
+f4znT6aTOR6gFa4hzWS629Ug5urueO4nd26i3k0rR5+4gFss1y1OZWgUUUYDMz0r
+P0BkJSkKKau0NpnpdkdmyzgamZXjPCpjKvNoPNN4jyYwTfBoItNEj/Zl2tejSUyT
+PJrMNNmjKUxT3Ny3jBtLY7SSf10eJzwuz2XCZXkeLzw+zxOEJ+R5ovDEPO8rvG+e
+JwlPyvNk4cl5niKcj69M4ivLx1cm8ZXl4yuT+Mry8ZVJfGX5+MokPv6VYd5Ba3CO
+ei6ZpOlQFGMq9VBGRCrTRQs85SriGmqJSaY7eIkRyU+H6d1ZHjNqOrggU3Khsn2u
+r68aaolmmuD8N5iFFWSXupAvDDZ15/KFLjheYSjV2dTd3pJO0rtxf6mhe/JtNKTS
+zfk2XOjnFdYmaMTSc/aRUo/y15Z3JnuDc6E4H9y87KJkRZby0U/Fx1wqjgFenYpU
+ItmZ7Ep1eZU0x4CtGqqnjdB7DtWS8pTkm8p2067tJmGAakxcXmLyUYcS8hQqahf6
+5wuTzal0mldbVexhPiXR1mwmucBLiUdFXnEky0t1gRQqOx/hjGyqKdlMOzlvQypC
+5Sp1fdt7NXn9XaTXHiS1e93eFfJMiXZa5bsSGVnde221XXTR5p/q4oUpmDeL8gOu
+Yh7/ZZGbJ3foyeitSXZ1yXbY5a1IrZ3JhBwoAlWepUY1ratJtW0Wssga7o0hKXS3
+zD6iXrEsLAlyW8Fcfv+SHYf2L1FpoEkbsoX6+FVrMa2mfADxV7iGxJ7s7sxS7GER
+yX5ySVM60Z7IpbKZ2kQnZaA43OspVa6haiovohmcbA5ve8EOEbek9J9Xlnjnh1ii
+kw5dbWr4FksytnL1c3cKOmLGU608rdR5s1SRJKE9lenmvw2rVaoONWk27ZjIwPxp
+ZKu2B6js/vN+NE5oRDRlO3miNmogt2tJZXjz81Uq9faeRbKO8eFEWdLTmWy+pLAu
+W5ovlK5INDUlO+To5Bpy83Y6Wje10VGW90k6IydLQy7Jgy1IZPh4M02kwPXMT1E8
+05QWqyNPB13U3U6jt4kH7zYoV+USqi2cljelpC3VmWhVJdV5U56mpTudnplqzvHh
+pJLsUS5IYVsi3eIVVpPtFUpXd2bbExl6Dj5QUDYpynr2lOquASrwNB2bm1PNNF2k
+O2jv1x2D1PaSXJTKdnflC2gJj7m+Us3ZV3VNczKS6ejmrPNrS6kLMijmJzoSmWRX
+sjcFA6a6rtJe31ZVe3PSW1Xz6VXlGekh8vVcR5HXke6BnjvTPeEMVFOKIqQDbFu2
+OZqJtrRQEiXoUuUrjWbGiFe6n24s5+egUnQHME/nRhFUWehYKu9tLO5LRldOvWSI
+yj7exImBULe3IdNQp1XRrkxlvGNwB72a8VyLKZVaXbksb9txkUJ3wnYk+AitDoKm
+sd22L2jl3S0t9IoFf8Cf9M48io2/iuBv2OJOqO7Mgox6F2n0rKLSBcml3IP7lY5d
+ErANqm7TO7M5gp8r1+lNxXnduVw2wyeXcmUV2ZYNRbZt+2i7kDgSi3Njkvw2OMZ7
+LaQB2RthdN78ZNPWLhU0tbmI/+Uz2sIvt6F/fe30Jzo65NVp5L+8uv7zCpUHum7o
+v7WXL8Vc1gth4LB/ve+AXl+ETr+tvNlsNyzy72/g/nQy08qTk17nI9SzXclcjeux
+6aV9hrGruY85wjCM5w2LX5Pl779Gm2MM0xwrfyExjrhM4/HEE7Ypn6jxvsSTtqk/
+WeMpxPtpvD/xARofSHyQxv8hPljjIHG5xiHiCo3DxJUaVxFXaxwhnqrxNOIajWuJ
+6zSOEsc0nk5cr3GcuEHjRuIZGs8knqXxbOJDND6U+DCNDyc+QuM5xHM1ThDP07iJ
+uFnjJHGLxq3EbRqniOdrvIA4rXE7cUbjLHGHxguJOzXuIs5p3E28SOPFxEs0Xkp8
+pMZHER+t8THEx2p8HPEyjY8nPkHjE4lP0vhk4lM0PpV4ucanEZ+u8RnEZ2p8FvHZ
+Gp9DvELjc4nP0/h84gs0/i/xhRpfRLxS41XEF2t8CfGlGl9GfLnGVxCv1ngN8ZUa
+X0V8tcbXEF+r8XXEazW+nvgGjW8kvknjm4lv0fhW4nUa30Z8u8b/I75D4zuJ79L4
+buL1Gt9DfK/G9xH/n8b3Ez+g8YPEGzR+iPhhjR8hflTjx4gf1/gJ4o0aP0n8lMZP
+Ez+j8bPEz2n8PPEmjV8gflHjl4hf3oZf0fhV4tc0fp34DY3fJH5L47eJ39H4XeL3
+NN5M/L7GHxB/qPFHxB9r/Anxpxp/Rvy5xl8Qf6nxV8Rfa/wN8bca9xB/p/H3xD9o
+/CPxTxr/TPyLxr8S/6bx78R/aPwn8V8a/028pZct2p8sU2OLGDS2iX0a+4kDGiNx
+gcaFxH00LiLuq3E/4v4aFxMP0NghLtF4IPEgjbcj3l7jwcQ7aDyEeKjGOxLvpPHO
+xLtoXEq8q8a7Ee+u8R7Ee2q8F/HeGg8jHq7xPsQjNB5JPErj0cRjNB5LPE7jMuLx
+Gk8g1s4DFp0HLO08YE0mnqLxfsT7a3wA8YEaH0T8H40PJg5qXE4c0riCOKxxJXGV
+xtXEEY2nEk/TuIa4VuM64qjGMeLpGtcTxzVuIG7UeAbxTI1nEc/W+BDiQzU+jPhw
+jY8gnqPxXOKExvOImzRuJk5q3ELcqnEbcUrj+cQLNE4Tt2ucIc5q3EG8UONO4i6N
+c8TdGi8iXqzxEuKlGh9JfJTGRxMfo/GxxMdpvIz4eI1PID5R45OIT9b4FOJTNV5O
+fJrGpxOfofGZxGdpfDbxORqvID5X4/OIz9f4AuL/anwh8UUaryRepfHFxJdofCnx
+ZRpfTnyFxquJ12h8JfFVGl9NfI3G1xJfp/Fa4us1voH4Ro1vIr5Z41uIb9V4HfFt
+1u15pv3fumOb8js1vov4bo3XE9+jre90vre084BF5wFLPw/Q+du6X2M671sPbNP+
+g9u0v2Gb9h7Srt/fsA2T/1WQfh8lz17yPYZhFO5zt2HuA3ca1m0G/7v5Y+yjMsO4
+gK643CiwHreeUNf0+ckA+s8oOH5I8dg1RsGQ4ilXG/2HFAfX8O8hV5HnvPUGrBty
+o2FgD7VwFv2h+vZppEi6lLSA9Hi5h2EvJC0iPZe02DB8VGYMIKU/hkO6A2kJla8h
+HUh6Pekgaor9gw0j8B0p2bgr6VAq5yfYkfy/ke4k39Uaxs6k3O4upNxuKdW7h5Su
+sR8i3Y30SdLdSV8g3YP0DdI9Sd+XPBn256R7k/L9hpFy+yMpvnGk9OYY4OtGE08h
+HUMaJN2fNEJ6IOl00kNJZ5MeRpogPZw0RTqflPOwgJTzkybl/LSTct4ypJyfLOkq
+0g5Sjpeu8fF9O0k53i5SjjdHyvF2k3K8i0g53sWG4ed8LCHlfNC9/JyPI0k5n0eR
+ch6Po/qc72XE3D7F4uf2TyDl9k8k5fZPIuX2Tybl9k+hPHD7p5Jy+8tJuX16hgC3
+fzopt38G6XDSM0nHqTES4LydTcp5O4eU87aC4uD+pmf3cb9eSH7O40WknMeVpJxH
+ykmA83gxxcH5uoSU83UpKefrMrqe77ua6nGe6dkCnOcrSTnPG6geP++7pHy/zaR8
+P3pWP4+TD0h5nHxIynmncY0cPz07cvzfk3L8P5By/D+Scvw/kU43ZIrhbPn0wcAE
+TzDSFH+EQrqQPzghXcrfl5CewN+UkJ7JX4+Q0jPzRAycxhOY9Fx1EAzQc1l0fYDi
+pnOfEaC4Lbo+QHHTuc8IUNwWXR+guOncZwQobov6JED9SOc+I0DPZvUhpX6kc5/h
+4/p9SR+SxzP8w+WrH8M/jr93JJ3CXzqSBvkbR9IIf91IOp2/aySdzV80kib4W0bS
+FH/FSLqQv18kXcpfLpIez1+i0PxZxV+b0P1M/gqFdDh/s0LP+wl/6UK6mj9pIX2b
+v4QhvYE/mCG9gz+UIX2AP4EhfZG/qyHd6NiOb73hX+cEHBQtcApF+zhFon2dfqL9
+nWLRAY4jWuIMFB3kbCe6vTNYdAdniOhQZ0fRnZydRXdxSkV3dXYT3d3ZQ3RPZy/R
+vZ1hosOdfURHOCNFRzmjRcc4Y0XHOWWi450JohOdfUUnOZNFpzj7ie7vHCB6oHOQ
+6H+cg0WDTrloyKkQDTuVolVOtWjEmSo6zakRrXXqRKNOTHS6Uy8adxpEG50ZojOd
+WaKznUNED3UOEz3cOUJ0jjNXNOHME21ymkWTTotoq9MmmnLmiy5w0qLtTkY063SI
+LnQ6RbucnGi3s0h0sbNEdKlzpOhRztGixzjHih7nLBM93jlB9ETnJNGTnVNET3WW
+i57mnC56hnOm6FnO2aLnOCtEz3XOEz3fuWCrfvT6z+tfr1//61woepGzUnSVc7Ho
+Jc6lopc5l4te4awWXeNcKXqVc7XoNc61otc5a0Wvd24QvdG5SfRm5xbRW511orc5
+t4v+z7lD9E7nLtG7nfWi9zj3it7n/J/o/c4Dog86G0Qfch4WfcR5VPQx53HRJ5yN
+ok86T4k+7Twj+qzznOjzzibRF5wXRV9yXhZ9xXlV9DXnddE3nDdF33LeFn3HeVf0
+PWez6PvOB6IfOh+Jfux8Ivqp85no584Xol86X4l+7Xwj+q3TI/qd873oD86Poj85
+P4v+4vwq+pvzu+gfzp+ifzl/i24pMQ02SkyzxLSUBSWmrSxfielXVqDERGUVlJiF
+yupTYhYpq2+J2U9Z/UvMYmUNKDEdZZWUmAOVNajElGVjSPHcNcbEIcWpq4wxJeb2
+JSYvIjXkbS4eO/e8A+8zd5h9tzlkxF3m0BJzR/qlPzvdZe68bkiJucuxq4y+rCfI
+0anELC0xd+Wrt7poN/odUly83tydDL7SO6rRaxBthDDXGAzzjJ0haa+AFnsltNqr
+oc1eCyl7Hcy318MCewOk7Y3Qbm+CjP06ZO3N0GF/BgvtHui0f4UunwE5H0K3rxgW
++QbDYl8pLPENg6N8Y+Fo32Q4xncwHOurhuN8MTjBNwtO9M2Fk3xtcLKvA07xLYFT
+fctguW85nOZbAWf6VsJZvtVwtm8tnONbByt86+Fc3wY4z7cRzvdtggt8r8OFvs1w
+ke8zWOXrgYt9v8IlfgMu9SNc5i+Gy/2D4Qp/Kaz2D4M1/rFwpX8yXOU/GK72V8M1
+/hhc658F1/nnwlp/G1zv74Ab/EvgRv8yuMm/HG72r4Bb/CvhVv9qWOdfC7f718H/
+/OvhDv8GuNO/Ee7yb4L1/tfhHv9muNf/Gdzn74H7/b/CAwEDHgwgbAgUw0OBwfBw
+oBQeCQyDRwNj4bHAZHg8cDA8EaiGjYEYPBmYBU8F5sLTgTZ4JtABzwWWwPOBZbAp
+sBxeCKyAFwMr4aXAang5sBZeCayDVwPr4bXABng9sBHeCGyCNwOvw1uBzfB24DN4
+J9AD7wZ+hffQgM3I/+tbMXyIg+EjLIWPcRh8gmPhU5wMn+HB8DlWwxcYgy9xFnyF
+c+FrbINvsAO+xSXQg8vgO1wO3+MK+AFXwo+4Bn7CG+FnvBN+wQfhN3wSfseX4A98
+B/7ET+Ev/A7+xj9gS4HPNgr621Aw1LYL9rR9BaNtf0GVXVAQtQsLZttFBU12X3oF
+2Oi9Apgj6UDPZ5IN7visGRKgEbz9CHdHo+E5c0SJuQfrEB+VDB7hjCox99y2qBjV
+VWo/3KrIViVq59z6olJVpDbNrYuKqWgHwr1KzL23KaQpNOxyo+8IVrv5LnP4CH0G
+GYcY29GRpNJAu8roZ1cbQ+yIsZs9zRhm1xgT7VrjQDtqVNgxI2ZPN2bZceMIu8GY
+bzcanfZMY6k9yzjZnm2cZR9qXGAfZlxpH27cYM8xbrPnGvfZ8yhzT1pPuS9cQ+gs
+yJmzRvTe28/nQ7uN6Gl5aXvm/wFQSwMEFAAAAAgAlJWkPLQHkmCcDgAAZxwAAB8A
+HABqYXZhL2F3dC9ldmVudC9Nb3VzZUV2ZW50LmNsYXNzVVQJAANYo+BL8yL3S3V4
+CwABBOgDAAAE6AMAAIVYC3xU1Zn/n7nnZG4mk2RywwQICQyPapgJIFBtKwEJYUIG
+kkxMwiNoGybJTRgYZtJ5QGgVU1EUte1atRUf4Ktl28W10CZhlaL1Wa3aWtfWrn1u
+a+2227VbH7S4q/3OvZM7N8O4m99vvnP+3+s8vu8759w89/7DpwFcwBY68dNibMa/
+SfKaCww/k72fS/ILSX4pya+UUeASF/V+Lcm/u7AFv5GC30ryuiS/k+QNSX7vxH84
+8QcXKvFHFf8p2z9J8l+SvOmChj9Ltf+Wnv4iyVuSvC3JOyreVXFGxV9V/E3FWRXv
+qfgfFf+r4n1p8wEpMaiMkSvmkESRhJOMCZUVSeBUsU1Fn4peFYMqtqsYULFDRUxl
+qsqKVeZSWYnK3Corld7KVFYuW4/KKmSrqazSxaYxr/RZpQCjUGhXiDgk4ZKokngk
+8UmyWhLaIIXUoDgk4ZKokngk8UlCanCy6U42g6GkLbyxK9jbHOrs6mZgIYbSpkQ8
+lY7E05sisYxO47K3GVymWmtjV7fkvEdqJqepNdS0IbjWwh2dwa6u4Fqp9A5Dmcns
+DLYGG7Pcd60x28KbTNYZyzrY3h3sNJl/ZXBnmVtC3Sbvb5bi2s7GdetM5lnL4eaW
+YLCVotIeXrOxuzvcTlKSw2mipRIyCy6T0GHB5RLSvrm6WkLN3b1tjV0bGIqbujtb
+J/ttwe5Goy81OQ3T2NptYZXWKvG6zsaOFovrozVkB7d4Hou3LOs5C5dnYbk5g7Xh
+ze2W0Wpyb8xlCndUbrCclZ1LQUSpnIqd6SBmxeRM7AKeEyybIlBzguVTBB4SVOaW
+ahf5SFRmZFJvS2hdS++aULcsV+lp/doNvUt7aYnhtaHmULCzS87/ElI3FC0ug8cc
+M+eXwXEZZSUbod9eBj7S2JeiZq/RuPpj0f6dTYlMPM1Q1JdJpxNx2tDhxHBmuDsZ
+HRrSk2S2lfT3bNdJwtZTIHclBqKDUT1J9o7oAAWynxI+s0unrielJ6OR2CYSRhPx
+jaG14i+rrjr7wKETFElvf6R/uz7QntnVpyfDg2uMwcjH/NT2RCY2EBzpj2UGdJPd
+nEzsCo6k23IjVQ7p6dZEfyRNfsPxrv6kLuej1S1s3RHZHVkS2ZNe0pGIxtMraK5N
+iQGd8qA1GtfN0bojfTHiCPIRolJT6hbSjjiz0zbwJtqLaKrJWgixaNVuMtiSG81J
+cLOxDyReb4ptU5SwJ6dd1BCNR9OrGGrrzDnGIvGhJeG+HXp/ekVofYj+tobkwDUf
+LpfiOR8qnnRQZp9HkALN5bzNpofiQ42xN6SZTkbiqVgkrWcZoi5kuCglnSZbLhQT
+XpNNh7JoqmNKQniN8TIp3Rq0Wx8hI29daKFtrl3pZDQ+RAHxSP1IamdzIjnpk5Mq
+xaBkOJKM7DIVGabVFTTXpi7PHKs8pafb9T227ZeccGzAxnEl9ciAuWMMs7PbGE1k
+NzEUH86kaRA9smuFEX/KQH1Y5lfKyWY6WTXtArnsSmSS/bpc3LlhkGZqA9WQGWiX
+qdsclclWbuxQcLceTy+WhrSPUzPVjTuw1Y07JfkXPO7G/bL3AI64cQ/udeM+U3BK
+koclecWNw1L6dUlul9JDktwFytR5ubmFYjF9KBJrTA5RKsfT1qoYqvI3d01mcFBP
+St/HSRqK747EogM+8xjw7ZbXl+9iN5vFaiSpdbPZ+D4pszlu3C1HnsBDbnxHkhdw
+3I0XpRelMUabzQIU4jY9HZHVmE7GKNG6tkcHZWKR3LcuGRneLq8OY6SlVm+Z1Vvu
+xj/KIb6HZ6mSTJ6b+dhcN5tHA7L5bIEbX8ZXKC7Z6Q4k9FT8/LRPH4mm0j45zQVU
+kpn4znhiT9yX3jtMMXHU19Hc6um3kKJVH+lLJWKZtE5Mtd50s9KNJ/EQJWa9dcoR
+62k8Q+Gr120nEnGfl1x3fe4IXelkH3Gz82gv2PmMnM60Aq7LNFiSywiatiHLpKOx
+JQZnMk0rJ5M0FLZFzpeLXFMskkq1J9LNNOKATaUoMjysx+noqq87t4jOrSsz9FRd
+swoVrSVV04nJ6vQW8ksF4IzGB/SR8OCHaFCVF8X0+FB6u1lPrdm+PAE2Te5RoaKk
+W29AH4xkYulOWxkXpbL1qJ1bjphLL8st8jWMmejBVro4L5OPFFxO+JM2/CnCvXny
+bTYcIdxnw/2EB2xYJzxow0OEt9twlPAOG95JOJY3/i4bjhNO2PAw4U/bcJJwyobT
+hDN5+rvz9PfY8AjhvTb8GcKfteErCF9pw/sIX5WnP5rn73M2fDXh/TZ8DeFrbfgA
+4ets+HrCB234BsI32vBNhD9vw18g/EUb/gfMwM02/CXCt9jwrYRvmyKvloeFfM7K
+g9NoDxmtQx7CRntnln9Xtr0729KRa7R0JhvtfQafy9PaaB8w5NX4Ksknx/saXPL4
+ov7V8rSmtoZk38A/ET1GqM54N9Jb8BGwHv+34aCfMgH+TeOx9yDRIil3rCL6z3go
+a1VrvE0BQdriWJ5qkOg3cTyrOs94sZLMz8dQdNzSdclvH0cbhKOdOCfwrQKui/Jd
+byT67YKzcOSrDhIdw7il6rBUnQ/mqcaJTlhefVlVlVRVrXhfvuMM0ZMF56Dkqx4g
+SjdmVnUZSlFCbZU/UDPXK7xFXqeieFVvsdc1AVf+zrwOr+N3hv0jWfslZO2itjJn
+L60pWiV5xkoNNKXWMD5lGtPHLafhKWf8gQm4/coYSiUpkqTMXzNGC5g7BqffK8Zo
+5d6iMZT7vc4xePxedYyywls8BsXvdY2hwu8tIWuv+y7MeQRazyOo7JnANM07jiqv
+exzTxzFjAjMf9XvdY6j2j2PWIbIZR80dcPknUHsUPsm8AzNNpup1H5Luiu6n4Scw
+O7eWTfDSWq6BYO/B5ZiPcmUepinXYqZyALOV67BAuR5+5SAuUG7ARcqNaFBuwhrl
+82hRvoA25YuIKjcjodyCK5VbcY1yG+5WDuFe5U7y/h0rfufRfsmva5eMdsMsz2O2
+eJt7eRhCuY84pwvGvDwv5sqDRB8tqOrJVz1J9DGrEi+nCAlqF/h72h+XnhukzcpF
+TxyF62K+6ImZ/FFZo7NqjOp0kLYHlTIdMN1oTc9V0ofyFLjyNIqVZ1CmfA/VyrN0
+H30Xj2dHuhAK5Eeb199Dw8zaJmNNPU8N9Ty57S+TSspP4FJepW3/KXGfKLiuivx1
+/ZrokwVVq/NU+UyiTxWs/dJ81YUolq+fbD6fMP9vwqqy6dda7VH3UaIFtDmUh5sD
+mk821U6TN9fOEyZvnp3HTd58O8/jM5kLpjA9JvMjU5jZoc8rMPT5Nh5fVXsCdfej
+vfYkFq6sriGNlYHJ+qFqqKo1y2ccAcc9mFdYZHm7RmFHPzgeGEf9YZQGZMsHxrGI
+OjNyp/cNdACDN0Pl61DOW1DFQ6jlGzCft8LP27CUh/Ex3oFV/FIEeRc28G508o3o
+4ZuxjW/BEO9BnF+GDL8cV/BPYj/vxQ18G27mEdzO+3GYD+CrXMcxnsAYH8bD/NN4
+jafxFs/gLE/Iz3vm5J9hFfwKih+9obOhDmfvnSXVh1FSfQKLTz+A2fbjZAktsTp3
+mpBGNR9YfGxqdlIhuPlxnM9lBj2H72eT47T5nzV2kXTm6ZjABa3yovqGvDT3yf+C
+yf97UX8N/RbT7+P020a/VuPQAT2YgHRAWyp3+Sg6Atoys9cc0JabvYaA9lGztyyg
+XWj26gLaRWZvdkD7mNmbFtA+bvZcAe0TZvAupkbWNy1OW2H2PbLfYIpXmiyHTaxY
+YrmMCnb2CGaZvTNHZI6tkmrjuITUNpsHLo272rRVT6LRsKTD1uCvMZVrTqLJHHCt
+qVghracmz26qSPBTcPHTaOCPoYl/F838CbTxJ9HBn8Zm/gy28mcR4c9hgD+PnfwF
+SpYfULL8ECP8R7iKv4yr+Ss4yH+Mm/iruIX/DCf4z/ES/yVe57+iJPkNJclvWQl/
+g2n8D2w+/xNbyt+kRHneKvRGs9DxlFXoFQwFqroCowXqusKBAqeCZ3WBcq/w4dx6
+5ysVWbOLT9+HpdW1JJ9alDXnFqWDGXX5wv9TlzvonQYhoIoieIQT04WK2cKF80QJ
+Fgk3PirK0CDK0SQ8WC80XCoqsUVMQ6+owpCYjriYgYyYhT2iBp8TtbhOzMYRMQdf
+E3PxdeI9JOZjXCzAY0LecC9MPsfYGfM/z6xXpoZxmBlnv1rBMTpmvnmM0yzLVS2u
+M8f0TDIpAd85gulm790j9KQwem/fg9st9/Xy3VdtGHre2me3S5ve3vtAco9Ct8au
+9wvL5I9TTBpNkzNZk2WTE1voL7Is3phikZ3ymx/sK7A6R6HVMYspL4Uy0+nqSZ7I
+KWLU2jFfjuszzHO36AG6eiHq4RKLUCWWwCcuQL1YhgvFcjSKCymgn0BUXEwBXYG9
+ogH7xUp8SVyCu8Rq3CsacUysoUA24SkRxIuiGS+LdfiFaMHvRQhviza8L9qZS3Sw
+SnEpmyO6WJ3oZsvFJtYgNrMW0cM6xVb2KXE5JcGLVhIczCZBxf8Zw/XywjbOzNXG
+amA8GqqNjwbgInNjPKNGJGaZSDVRqYGcJljrN9Mrt5meyX2j9MpxVYvrkVybD78Z
+q0KqrICqUd0mj1uKxulgMoXF9Nl8+qaGbZC+8yD6qCYHqQ63Y52IUh3uxEYRozqM
+o08koIskhkUKnxUZHBC7cbMYobDtpRq8AsfFlTglrsIzYhQviavxmtiP18W1+LM4
+gLPieibEQeYRN1JYfoAfEpUX2woaW75Fp9NRETTP8TLzjSwfxrW5yWnyRBS3gItb
+oYnbKK++gpeMh5IDP8LLpPWveMX2/eUwvr8CY2jO+1AQd9AZdCdU/Nj6XvuycdrS
+PemZdsrVo1Dgwj2cAhXuERSYcE9RxWqiTm1duEfVWsI9niItRNSprSeqahuIFmut
+RF1aG9ESrZ2oWwsTLdU6iJZplxIt1zqJerQuohVaN1FN20i0UtsU/hYW5+ZpPP7Y
+fqI/MT5oX/07UEsDBBQAAAAIAJqVpDxLHAMqxwAAAC0BAAAiABwAamF2YS9hd3Qv
+ZXZlbnQvTW91c2VMaXN0ZW5lci5jbGFzc1VUCQADY6PgS/Mi90t1eAsAAQToAwAA
+BOgDAABtj7GOwjAQRGchkIMAh2iuOVEfDaanRFCBOIFEb8LqZM4EKXGAb6PgA/go
+hG2SjsI7Hs/Trvf+uN4AjPAZohWiHaJDaB2OecYTreJ/3hH6P/O9PEkhz0bwiRMj
+Fi6fuut4sCn535SzzPFtb1esWXr/iqeJ4dTZ6GUvyjjXXB/zNOaZ0kzo+cZzlRlO
+OB26qYTvd8NLhtD1sZbJn1hu9xwbwpd/yo3Swn+yhOsEQsWeql25FhAC1ACr9ULD
+Qj8KbTi1fNPWCqInUEsDBBQAAAAIAJiVpDydcPOGrAAAAPIAAAAoABwAamF2YS9h
+d3QvZXZlbnQvTW91c2VNb3Rpb25MaXN0ZW5lci5jbGFzc1VUCQADYKPgS/Mi90t1
+eAsAAQToAwAABOgDAABtj7EOgkAQRGcRQZHCTisLK208e1u1gliY2J+4IUcQEjjw
+3yz8AD/KeIexMLHYzGbmZbL7fN0fANYIfQx9BD5GhPBaNjVvK5mmfCHMFlEmWynk
+TQtuudAitvnOrpvliRB0fFy2lg6OZVMlvFc5E6bxJ9GqLCJVay64Wtkywvxf5y9J
+GHdQLotUHM4ZJ5ow6axGq1x0F3xhj0BwzPTMP45LcNEHjHpWje9bH4M3UEsDBBQA
+AAAIAGKhtTyw9eeN3wQAAIUJAAAlABwAamF2YS9hd3QvZ2VvbS9SZWN0YW5nbGUy
+RCRGbG9hdC5jbGFzc1VUCQADFyH3S1Ek90t1eAsAAQToAwAABOgDAACdVWtvFGUU
+fl52Z2cv04stLb1IBdrKdru0pWBFbgpdCq0UhEK5ibptp+3gdrfZnRXQxKDf/GBS
+v6AkQuInYmIiJnarVI0m3sIXL/wF7/EaP5oYn/POQqW3RDeZ55w573Oe951zzsze
++Pv6BwA6MBlGAxJhRLAnROgR2CuwT6BXVvsEHhbYL9Bv4oDwDwkkTBwOo1QUGnBE
+4KiJwTAqJHIMx8M4gZNyeyqIR8WeDuKxIB4P4okgkhIYMjFsYkRBnePVw+u8gnHW
+GXHHFQLjtjM27iqU5+ysk0wN2tmck0kf7U2Q16dQ0p1J59xk2h1MpvK2sXnmw5vb
+4oZi4nYn7bg7FXzRlkEFf3dmxFYo2++k7QP5iSE7eyQ5lGLEjPbwpyljtntc8xPe
+zQmFIM0x7yQhuvuKhzGd3J6JSfe8Zp/kfc52D9vDshJN8CdyDdH9Z5JPJduTZ932
+MTsz0S6EZHosZXcmtgnBzOTdYX0qg0ktvQoRbrE7k0+P5Dp5hNXRlmUUFCqGs3bS
+tXvTLmvCFZZFYcuyuy6rF/H0jqa1UNDNDLhZJz2msPLWQVIkt3tR8sMDmXx22O5x
+pIzl/9JqE7KFGFotdKHNwhqstbBOoFGgSaAdHRY2CnQKbEKHwj1LHq+pJ5VJsrxG
+0Vq96bSd7U4lczk7J1u1KaxZOjuRyetmBzzHgo1RC2MYVaie/2S786OjdtbEuAUH
+Z0w8aSGFXRYmwKr4Tp3bIW6Gbvz8DsGzGseJ6rSFh7BLoXbJk7CYes3JtA/oeXae
+9sYw5Nxqo8KR5Xr4/5Zk3oy819nyuSc+OHRG7yhjroupUHlHs3WQvS6bF+L0MuVA
+ckKKmpyctNN8f+PRhWOycHK8+lKzPtqz5CrW8tPSAI4EDCIHiN8qJTOkbWPRNmlb
+h2bcy7v19FcgijL6HD5inJG1tIrWiM1AvaXTNhDDpAIZ+DGp6W1Fehs3NGhLhR5r
+bGpe5S9gxVxeKXzEC8x7DiV4nlFOcjG3gZqyVSD2Nnwvvnk7J6CjLxA3Lsr1L+C+
+ROxclGss4F4iblqUG1jAfY24GfcVuR1Fbo3oRi5egSVJkYuXYfqvwu97Y17268Su
+25XayWypVHWscRq+WNM0/LHmadZ5lX8agbmKVWvWu8TrrPos2/MeqvC+1rq/qNXN
+qoZo62Prp0SsZUrUaowp0asxpxYR/JiH+gQWPkUlPuMMfK4FtxQF+ykoDW6OtRZg
+ak06QS1LJ6SF6YQXk/6CZ/mS/0xfoR5fc8hucvUBbC1K3+DGAdpnfV2GV7jLsKqM
+4IUu4yri63XvX3lVQn4dqvVCunfDL19BqMowL+hUXeqSKqM8rIkbWvQseLmGDtV5
+Id1LyQ2TLBtVGXO92cqZBL7hA3/LcnzH2n7P1+YHvgg/shw/sU8/Yy9+wSH8ilP4
+DSP4HS7+wDP4kwrbsP32NHhdrplF5IQcWbaWU8vuM7CuzZuGv4g7qO5l93F/eTPW
+tX6EyCWUisgMSvqvIjKLUrpl/bHW+Dsoj1+7s9rKD1MZqFAm6lQIa1SYqw/+Z927
+FuhWUncldaupW0PdWq7y81zUHSrOft8sKqhSGStgZQFVBVRXrCLI8xdQU1Hr+X7x
+6zzfEL/e8wPi302/gNXz6qOauMNu/UnqxiO0FfTko3aQ01VKO4DQP1BLAwQUAAAA
+CABiobU8e/AgiWwDAACQBgAAKgAcAGphdmEvYXd0L2dlb20vUm91bmRSZWN0YW5n
+bGUyRCRGbG9hdC5jbGFzc1VUCQADFyH3S1Ek90t1eAsAAQToAwAABOgDAAB9VEtv
+E1cU/gZ7PLE9IRAedtKSAnGIPWnjkBYoj/KKcQlNuwglEHZDMjiDnDHyTHgt+tgg
+NkheoW5addWyQIJKGBCV+gNY0ZbHlkfbXd+rdoH6netJqGKDpfnOufd+53xn7jnj
+O89ufwdgCO8n0IlNCSzH5jhhi8DbAlsFtglsF9ghvHcEdgrsEtgtsEdgr4FCAh14
+18B+A6MGDmjQzvAp8jmrQT/tTgczGmIzjluaCTS02dWpcC9Od357me9UXbs84VR9
+t+IdGi0wnKnaRyqeH9heMGGX5xz97kfnv9r4z8UJ5tvhem6wU0Mkm+MyOlKZdjR0
+jLme88Hc7DGn+qF9rMydeLaofopUcoIjKqLQWEyyHJrDYTl094flJOnvqU6FJ2Zj
+NX9ouP6+2ZPBWZXqKI99JxivzHnT485UIJIF9RPJ3uzYCfuUnbdPB/mSU5nNL/Bs
+r1R2hgvbhSVqe+XAH2Zla7K5xUH/42tIHKzMVaecoivvt2pxwkEJNbEW60wMImNi
+JVaZWC2QEkgLdAl0C/Rhg4l+gaxATsASGMAGA+9peO2FpWSK5YrN99VDa456nlMd
+Kdu+7/hSwZiGzMvffj5Fz8tpGlYqglvJH1Rj4p5rdLfrhcWxS9lG37GOQ9wJDStg
+EHkdHH9NbkTZVGjToe0Kbbey3XgFr3K1hv4S9KCdPq+WuJ47YjVa3boJ7RsV1ktM
+kAocRxQlRc+E9GEWYNB2Ct3qzfSloik9FbuBJc9jlyJC/Jixn7DsT7nLDoXxPcwr
+cjHrOiIXry7ExNTuBWJ/S260iVsjZlty9SbuZ8RcS26sifsl0WrJNZq4l4kDLblt
+TdxrxNfxRsgdCrlpqTd56QuYUkzy0ucwol8jGrmyKPoWcXChC+OMli6st3rriFiZ
+OqJWX509TEXrlE/pdRhWKlZH2/Ou9KiI76HjB3b3R/7f3eN43OdwPOAQPFT582H+
+SXawnTZn9ddEIFcThbReE420URORdLwmKulkrYXMI5b9GCaecGKfcgJ/osTPbNcv
+SmYolClRRsZsizVwA3GlRCehxOgklRwdUwnSaVeSdJa2Ev0VcfzGz+R3vtMfvKs/
+edt/YTP+JmsjJ3f+5hs3mv4WHZMyhTJd0gVpwE0su7bo5v9liW+qT+ctFGXy6XVg
+BPsQVx8l7X9QSwMEFAAAAAgAYqG1PPYVKSTwBAAATQoAACQAHABqYXZhL2F3dC9n
+ZW9tL1JlY3Rhbmd1bGFyU2hhcGUuY2xhc3NVVAkAAxch90vzIvdLdXgLAAEE6AMA
+AAToAwAAjVVJcxNXEP6eLXnQaDEYA2MIxgaDLRtvJCwCwmbZsR1jATZGJutYHsSA
+NCMkOSGHHJNKLr5RRVVySVWOqYJcbCpUJff8geQHJD8hS2X/ejQSRhaEUb3unn79
+dffr7qf5/p9vvgUwgrKOA5jWsR+vC5kRclHIbMs5VB4Nl3RswZyOeTGaF6OrYnQV
+s2K5oCMlGynZSMlGqrJxTUcaiyJdF/KGkDeFvKXhbR0dEjeNd4S8K6+m5LKkIaNh
+WUcXpjVYGm5oyGq4qdBy2nbs8hmF5r74gkJgzF22FFpnbMeaXckvWcV5cylHTSBr
+ldOeVbLysqiwheyavVymmxDFScvO3iwraJQv2k66Ji36knk3XZOo0ymNWU7ZKqY3
+vviOJ4pmnnH39sVnbpnvmcPm++XhrOXmh69YmbLpZHPWkeQpurNL4/lC+QMvteuE
+lmpQrS/JR051tK/OxyXXdsrE16mTdt5ySrbrcEtwnfW4jbHFoL0abaLo5pO2mXUd
+M6cw+oLxqmpx1bbRVaUSPE3Gdcqm7ZQUdj/Lp5xat8W+xOxK/5f19UqzLrgrzjKN
+d26sb82QhQ1mcq7DKrZXDXLcGU4t3aINt/U5d6WYsSZsGY4dPnAlZxbnbpoFa0gQ
+ERxCbwT9GIjgsJBBIUMY0GArdD0zx56ku+LNXEtViEw5jlUcy5mlklUStyc13NJw
+O4IETkbwqrznIsjDieCsaM7BjeACCiIVWNvNJ4zgjlgXhRwCnU7gNYWeJycdk+PP
+uuW5lULBLZat5fG7GatQ5nAo7HpiNiWFZ9PHi0WXDetseKpaXRS21tdSIVbD+Dbb
+67Ko3MCOZxaMDWg4GpswG+a7GtaLctGUO9xsLnEgAn1JueJBXh6ZFf8SUQreyLly
+xEDGsnOyMcUnvhDo5n/PATShBwf5v9aBgLQdCn186yZX5MH+daivKSjESXWaA8dp
+eiKgZEAA8sM+H/T5kHAihskr7vYSV3G3hqYHNXctntIiHWlo2lxveod0tGa6n3mI
+VhevXIFMvf2HpEca2jdzBTfZf0r6cs3+kK+NVf23o8XdhLlH+kpDjBejIeYL0qM4
+5mNGWFfRGo+xZdGPJdiA4NcReliHfsAaH8cJr9a8R95uAqd8b6MIoZl8R//AGnSu
+8OE1RLiia4jVt/IHtONHD356A7ypCm/l2sq1jautAfwnwn+mhhfZh+cR5o9ujGDv
+/c8R7U2EjOCkEUoEDS0uijgV2jQVWn9vnEZZ6rNPue6nc+AXfml/pfQbovgd2/AH
+DPyJPfgLnfibrfwXIwpe6DPPO7jOFV7D9rrMVRTtKkbN2VrmKeYdJR+QpB6hXfKM
+e0K4v9cIZeNGOGuE2M7bRljoUzm3cbSgOhFS+9CmutCvuj3nL5LbjvrcBpnbMDXn
+cN6HH0TQq3e0Bl/Dzq+eHgsl43QBYz5k8Dl93FUPPeNFexGoUQ+dIE1i3Id+Seg2
+8mUZ30mZ3+ne2P3PEIrH2PzwY3QsrmP3QxnyhHfDE5oRfIQ9UmxhYRY/8wgvJaIs
+vie0CsYIrRrhVSPKNqwarWzE6jr2PrkWQzJyahZBlYKuLmGnuoxONYceNc9OXMWo
+WsAJdQ3nVRrTapEofjT8jI/xqE3ehV1H58OZx+hiht3feRctwLLv82PEpH/qI8b4
+GC3qE2ImqW3CFK54jeM3nyN0GaH/AFBLAwQUAAAACABhobU88Nd2PlMCAADzAwAA
+IQAcAGphdmEvYXd0L2dlb20vUG9pbnQyRCRGbG9hdC5jbGFzc1VUCQADFiH3S1Ek
+90t1eAsAAQToAwAABOgDAAB1Ul1PE0EUPdPtd7e0VvCDKoIU2ZZCEfx40BhDyyaY
+xhgLjUR9WOjQrNnukt2tCr76atI/YtRESoKJP8BfYHz1fxjvTBeNFB/23jt3z5m5
+58x8+3X0FcAibieRxkwCKq6JMBuDlkQYM3EURS6JMBdHOY55US7EUIlhKYZlBvaa
+Pp2+PYasx13TsJrc9UzH3lirUfsBQ7rq2J5v2H7TsLo88r34vvfj6OcKQ/SuaZv+
+PQZFKzYZwlWnxRkyddPmD7udLe6uG1sWdSKarktAm/tPJLo2WGwypDzu151tw6cT
+BbJWE8i47zR817TbDKNasf7CeGlULMNuVwbdOwzJhtN1t7luigPUR45p+0u1BQFU
+cR4XVGSQVXEGWYZzJ+kr3Z0d7jKMHNN0yzH8pypu4KYItxhC5UkS/1zFFK4y5OUO
+xiu/0uZOpxLQCpJGQwdZXbNt7lYtw/O4xzB2KokEyb7pVBrSbXN/YFLU2N3ldouh
+rA3rHbZgoIGMyGv6f//S9Cq9DFIKhSJZQs+FCVcojyOHs7QapTqEMcSoJucoXqTO
+FGVGOVI6BPskaeMUkwQFVukR6RKeD+DL1FcoZwS8NH2AUKlwAOUvMUcU4DHFBhJY
+p4k26M8lXA42mKANxHnR0meE3n34w4vK7jOKE6dilSFsi+IVTAbYeRorQjldmu2J
+qYq9f8YakVNbRO2QVbakHmuaCzSlTtMzIO7R3vtkyhvq0ksJiPeD+bQvCG8eIpKL
+9hETuvqI5xKDWhF1kuo+Uh9PKHhL/Gl5KwVcl6YzeY+LSPwGUEsDBBQAAAAIAGGh
+tTyW7WLgMwIAALEDAAAiABwAamF2YS9hd3QvZ2VvbS9Qb2ludDJEJERvdWJsZS5j
+bGFzc1VUCQADFiH3S1Ek90t1eAsAAQToAwAABOgDAAB1U11rE0EUPZOvzcfGxNj6
+0TaaaLSbNHa1VV8UEbMILUGE2GApItt2GlbS2bK78evvCPqoYpOCom++FNRXf4pP
+4p3ZtEIaH/beO3fPmTn37Oz+n09fAVzBjTSyqKSg46IMlzTMphFDJQlD5qoMtSTm
+kqjL8rKGeQ1XNSwwsBf0WPS8ZMj73HPsbpt7vuOKlSXZXmbINlzhB7YI2na3x+Mr
+a7/3U6+LTxgStxzhBLcZoka1zRBruJucIdd0BL/f217n3kN7vUuduGFZCtDhwSOF
+tsLFKkPG50HT3bADOpEhGbitwHNEh2HCqDaf2s9ss2uLjhl2bzKkW27P2+D3HLmx
+/sB1RLBgzUugjlM4rSOHvI7jyDOcHKXf7W1tcY8UHtAst0cC13Qs4poM1xki9RJN
+/VhHCWWGGbWF/TwwO9zdNoe8SsgjAw4KfUkI7jW6tu9zn2FyLI1mUn3HNVvKaOdV
+6E/C3tnhYpOhbhwd+agL4RjkxbRh/fctynQRsmA4hihFcoVuCpPGUJ5CASdoNUF1
+BJNIUE3mUTxDnTJlRjle2wP7oGhTFNMEBd7Q/Xmr4NND+CIdEKeck/DabB+RWrWP
+6D9igSjAR4q7SKFPigb0ZgbF4QZF2jg8bxeRd4e0hGp+oXh2LDQ6Cv1G8dyhrLmh
+rMw4SdIU4DsBftBcP6lbUmNL4h1lGGB8Rmx1D/FCYgBNShsgWUiFdVTWaaoHyLwf
+kfGLNJ5Xxl6gX1P6xtSnMJH6C1BLAwQUAAAACABiobU8uKPQ210FAABeCQAAJAAc
+AGphdmEvYXd0L2dlb20vUm91bmRSZWN0YW5nbGUyRC5jbGFzc1VUCQADFyH3S/Mi
+90t1eAsAAQToAwAABOgDAACFVNtzE1UY/+3Jbra5NGla0i72BrQ0lxaq1QKhgIVe
+aEsBhdICMo7bNKaBJsEm1WF88gq86CPlIjCg8mB98EFAnXH0QZ3x1fHPcHxyfEN/
+32bTMgi4M+c7v+98l/Pdzv764NvvATyLU360YKcfzRgQskvIbiF7hLwoZFDIXiH7
+/BjCsJAR7yAqn5yPCtnvxxjGDfd4cxV0V0FvFfRXwYCJCRMHTExq8A4Xl2YXMhqC
+44VCZnFowS6VMiUTBzUYowtFu0yVXblCrrxHgyeemNagDxXnqB+ezBUyh5bys5nF
+KdvxEMhmynsX0zO5ufK8ozxMr5WzsUwuO09XwVKmfKS4VJg7kkmT9cWHnU/cdsQn
+T9tv2r32W+XebKaY713VswvZhUzf8IBo1dDB6KKd53VmvGpaky4WynauUGLMPEyc
+lCNJJPf6uVW9cQ3+XKGcWSzRZWn1WHTn7dJ8JSkGTT1v5o0le4E6UTemBYbQe3j2
+NC0HxMJ/tLi0mM6M5iTt6KOBbhWbIDahI4hDiAVxWMhLQl4W0iUkLiSBZBBHcNTE
+VBDHMB3EDI4HOR3PBbEVvSZOBHESr2hoe3pp/qtQkS0t2ItH5+2zjHLz0z10Vseg
+83/03JnQ2dfjle0EK8jNbbuPsNptM1cayZ8tn3PqyrKF1op50HZmxJ5llfX4sIyK
+J58ruA0kV7emWw2tbs4BU8XJYiG7L1d2TSf0jXwFLc5kB6FL3cE8yG3krnE3kveg
+fUXAMjgvRxH+BF37WdekGyCUhjg7e+JoJtDtukmhVizQmuy+C8Xl4dK5DC4vl3kX
+NY+6/wst2t886cEW100v3fi4NyRjCcuwzCSNk483foB67R+ecAYqxlo7vIhQ/gst
+fJdheFYIVMog9aRMS3Y9nfI5Xo10KhCzjOWrsBKWyS0Ss3yXrsGfsAKXrrq2ulx/
+H/77CKxDsJiqFUMJ56GzML1YtelTKYNm9XRi1WbJLF+Doa/QtRWmzBQZPVthysyK
+jHZZq7Y4Rp2sFS5OxGJnEokz6fDyJzD1O9A9K6sJj0paygtTmfApH8LKj6gKoE0F
+EVMhDKkwRlQEJ1Q98iqK86oRF5WF22o9PlPN+FK14GvVyrLx1biVnmWxpNIstMTj
+WWHBzfRqaAxKsCFYgHfFXIunSyxVB7yqEzVqMyKqCw0qhlYVR7tKoEslEVc91O7D
+825zvqHNeu7j0pwriFhGaPk6/JYZYsLVVvmcVgUsX6VVtVag0iopctry0aA5ZtWy
+TeskWCsgHhJW+IkNizymYRwtaZIVuYfQtmiy4rnKNyadLlkNwjQlK7dUeSsaNW4g
+Gm0kDUebSH1Ry7gpFaPkFrlG47YjuYUAJZ86kkb9psyFc0sknT01dgfBmNyXJR6L
+WiJ272mgeILihNxI8cREzIrIhDQ8dTxeRRPb0c+R2IYmtYNtSKFD7USPGkC/2o0Z
+tYejMcjR2It31D58pIZwXQ3jCzWC79R+/KbG8Ls6gD/UJP5UU1pIHdO2qGmtT81o
+29Vx5425bUQepjM2B5/UxljiLsKXsdUpbAVvSjqz5eDGynmVfTSVEDxM5TWmYjOV
+NE9fQL979XlOLKWYkVG5j7rBdpkWgnWI5GyH0x2uweUMh4u6nNfhmlzOdLj1wl1o
+r9vw9oV314JoY45Q73G030ej+gCd6kP0qfMYVBdwSF2k1jZsd4P6mD9TCSrdnfxc
+2t39I5ovY7r7BzRLiVQP16UrGJJQiT3E2yVQYp24W8IkNoidIIm9xA0SIrFJ7Nbo
+oSo9w0pAcejVNf4TriOkbvD93YSt7vCN76CG4g+5nXs9USv//G1s2gbuG+H7F1BL
+AwQUAAAACABhobU8VCT22I4BAABnAgAAHwAcAGphdmEvYXd0L2dlb20vRGltZW5z
+aW9uMkQuY2xhc3NVVAkAAxYh90vzIvdLdXgLAAEE6AMAAAToAwAAdVFNT8JAEH0L
+LdVa8AO/P1CUA2gixqgXjReq0YToAaPxpAU2sKZ0SV3U+Kv0AokmevdHGWeRBEPi
+Yd903r55Mzv9+n77ALCFjA0b8zaGsaBhUcOS5lIWli2s2LAwbyFtYdXCGkPsQARC
+HTJEs7lLBqMgq5xhtCgCftZqlHl44ZV9YoZqXF2Jqqp3lS7DMBEnXNTqisG656ok
+nklmZl1X+6SyxTvvwct7jypf47KRd0WDB/dCBtvuvhaYFV8GVDCZzf0qfS+o5c/L
+d7yi9hnskmyFFX4sdO+xP8WbWuzAQdzBGMYdTGhIYtLBNGYYMn2zgu5wJlWp1WzK
+UPHq0VOFNxXZMMz0ZaeB4mHg+UdhKEOGuX/npkEGJ2VIDvTT2zLStHQbDCP0S2Iw
+9LSUJShLU2QUzfUO2Ct90K4JbUQId0i6azD9LoDiRC/S67rKJKZ6NjmY3Yr4+kYb
+ETrRNoxBuxvqe0sM7aVXtke8vklQd/Ol+A7ruoOhz+5EBlnGevUJRAl9YhrESWJn
+KY9g7gdQSwMEFAAAAAgAYqG1PJ0ckq1zBAAAsAgAACYAHABqYXZhL2F3dC9nZW9t
+L1JlY3RhbmdsZTJEJERvdWJsZS5jbGFzc1VUCQADFyH3S1Ek90t1eAsAAQToAwAA
+BOgDAACdVNtTG2UU/50mm03CEiJtIG1thVolCUhobbH2XkhrQUprubdWu8AWlsuG
+STZCO+NMx0cffbGjhTdFZ5yxaglYvLw444wv6mP13b/CcTzn2xQ0XJwxmfzO2fP9
+zmXPOfl++uvRdwBaMBnG0zgXRgXaQgztAhmB8wIX5PQVgYsCHQKdOl4VfrfAObFc
+Frii47UwomK5ip4wetEnj/1BDIgcDGIoiGtBXA/idTHc0PGGjjcJNMe/DP9uE7RZ
+e9QdJwTGLXts3CVE81bONqf6rVzezjp9HcLrJFS2Z528azpuvzlVsLTJx2dX4n9e
+eZsdT9qO7Z4m+BLJfoK/PTtqEaq6bMfqLkwPW7lec3iKLXoiwx9FGbPcQcXPeA9D
+hCCLAa+SEKsXS8Xodv789Ix7W7Gv8XPecq9aI3yyP9E1Yb5lps1ZNz1mZafTYjad
+sSnrcOaEZNGzBXdE1aJx5mQHoYIDt2ULzmj+MCfel0huE4FQPZKzTNfqcFzuBJ9w
+MwjHts26bbwKL16fowIF3WyPm7OdMcKuJ4VMMTntWZkf7skWciPWBVuaF/1HrGYh
+G0ggaeAImgzsxzMG6gTqBQ4IvIBmA2mBFoFDaCbUbVnewUy2oIYUeKIYHY5j5dqn
+zHzeyksyznMTnHYYJqGmvN62wq1bVk7HiIFRWDpuGRjDaQPjsHl01+dOiTrBatPt
+U4KzCscZ6YaBU+D12b1lddwidWZn0z1qN+073kqF7CfDIfRuN5n/dyRbpBW8eUXX
+3/jy8ITKKCurGkTY+a8RKiNPsKrMxDvJLt3mtDTanJmxnFFCU2Lj8Dfug9dfjrk3
+kdnylMdfwdcCrzY0Rl4Lvm9INkPJ+pI8oOQePIuD/PQc6zvwPCKs80oxpthSz5JY
+aqll0BfKrZExzFTQIPw0pOhNJXoaIf4CVUJPNSTjWlwvYse6YwQ+Vm12nECEJtnK
+C1py3sdBvVwP4ft8zSUgRsoxpjel+supdxhbNqVq5dR3GA9tSg2UU99lPIwXS9QW
++BU1LlEj9xZgiE/k3jx0/yL8vs/KvN9jPLLWpjPcBWlTbaphCb5Ucgn+VFxb4sRx
+fQmB9XbV8ABBH0CjDxGm+4jSPGpoQQU7WgrWwcF2yKhSjUXoEo9lUEKyDElQluFN
+wn6EIH3MIRcRp09QR5/yaSteKoX9gSsPsJzztWreS87DiGnBu63aIpINMqN798Xi
+V5ZaZRHiyPsLCMU0/a7yUz2pjGnRsKKlkjIxz1FTlriyCFMcw8yUFDFtvYPHeWtA
+D+DjBTToS8ToK+ynh2igJRylIk7QCjL0NbrpEQZoFTfpGzj0LQr0PUc4hpfXZhb2
+ZraKiqFStZJYlbkM40HZzH5kPI4Ta94+2V1ExXsZlZdSjU0riDSte3m7/TN39Rfe
+7V/ZevI/vKs2eD9m79/Y+3e28m1Y8h7mM6m8cxVR9n4qVUR1ETuL2FUdY5B3KaKm
+utbT/aLHPV0TfbenB0Tfw3oRe8vf9Q9eoTPqBjiLS+oPTuoO6ULob1BLAwQUAAAA
+CABiobU8Vzwd+hgDAAAWBgAAKwAcAGphdmEvYXd0L2dlb20vUm91bmRSZWN0YW5n
+bGUyRCREb3VibGUuY2xhc3NVVAkAAxch90tRJPdLdXgLAAEE6AMAAAToAwAAfZPb
+TxNREMa/Qy9Ly1KQ64JAuNMuSrl4B1GgICjxgZti4sMCG1hTtqa7FTHx0Ud9MhEv
++KSixkRJLCSa+OSTf5RxZrsUsym06W9mz/nmzOzM6Z+/P34B6MV0GBU4E8YJnA0R
+zjHOMy4wLjIuMQZZN8S4zBhmXGFcZYxIGAujDBMSrkmYlDAlIB7SL0G/TYHAhrFi
+rwkE13Rjdc0WKNbSy+5aiNyD5XJLTxtackFPW0bKnJ/i8OsCpWMp07I1017Qkhk9
+EHn2/Hf3TL1O5w0ZpmEPC/iisQUB/1hqhVbLpg1Tv5lZX9LTc9pSklZC0YTzcUSr
+un3biUjkHhapHDK33HLInXTLKSF/JL3s7si5p4NNybDG1+/bm85Rd2jb0u2ZVMZc
+mdGXabstOn1Pe6DFtQ07vqqn1uP5Pc1cTer9iUEuhjOM8obVT9U0RmPeoP/0AuHZ
+VCa9rE8Y/E7V3gN7OFRGM1pk9KBdRhWqZdQwahkKo45Rz+hAp4wuRpQRY6iMbnRK
+oK43H1lKeyKVcfoaPHDkKdPU02NJzbJ0i2u4IdBx/PvnD2k6XidQ5QiMVHzWuR3G
+o9xQ646sj4YTzY0bLXR3KyBQCYlIHaFbL7gpjq11reLaOtfWO7YeJ9FAT43kF6EJ
+MvnUXWIrrbAVZAPqPsSuE9ZGDJMUYhB+MeTI2135AErpC1SyXO2KKQFFUkJKyR6K
+DoMj8JE7R8HzqBALtEpTcg9opINz+b7D9zUfEuRFcZfYVVDq90p1YrSgNOCVrhNj
+BaVBrzRDVAtKJa/0MbG7oLTYK31CPIXTrrQXfkeqcK2RrbeQuZLI1jYk/w78vi+e
+6KfEnvwAZqm3PIA2tSsLnxrLwq8qgSwlVqQsgqoSykJSlZIsig8H0kTXBuIFAmIL
+YfES5eIVasRrNIg3aBXbToK4m0CjBDR79KndewhxDrJhTkO2hBORlTkV2VJORjZS
+IN07FIv3lOoDFLGDZvERUfEJveIzqXrRl+9GONeNnyhb5DvBw+bOcFP2Uf7N041d
+Kq7fuckDGCdbQV4ZRpFAyPmPkP0HUEsDBBQAAAAIAGGhtTwL7ITwXAMAAB0GAAAb
+ABwAamF2YS9hd3QvZ2VvbS9Qb2ludDJELmNsYXNzVVQJAAMWIfdL8yL3S3V4CwAB
+BOgDAAAE6AMAAH2T3U8TWRjGn9NOO1CHgnxZFRdELNNWLbKKIq4i1I+S+pFAjHg3
+lEkZqDMwM12NeuXeuJu9dc3uH7BuNibqjRhN/Lj1f9E/wfic6QBaGpv0nDPnPO/v
+POc97/n45fVbACMoJNCOwwm04Yhs8rIZSeAoRuXCzyqOqTieQIvUjOFEDPVfv4qT
+UjCu4pSKCRWnBeIFp7ZQNQW0om2b7nTV8DzTU/GLQOxC1TF8Sk5btuWfEYjqmesC
+yrSzSH17ybLNK7VbC6Y7ZwQEpWL6NwJVof4xL7DDM/2SUzZ8y7FJ1AsFidijl5aN
+X428cdvPV0znVv6aY9n+aGFCLiYWLc837LI5uyagMoIxBLZsTIeYwo8wXIyVq45N
+cbeeqauqhl3JX11YNsv+BHFLhrdUPwkNF3lKc61mVD2BHn27PnOTvmadmls2L1hB
+tsKtjkiphl7s0rAHezX0yWYfflJxRsNZTGo4iLTA0BZyWvq64viztdVVx/XNxfN3
+yuZqPUG7tmRF2zdd26ied13HVXFOwxSm6a7piTVkkBXoaDQu0NWwcf2q+ppShjZq
+YW/z5bAeklvIy4a/xLv21lzOK3pwK9+Y2OB1LAaDOafk2JUpy/fq4hllPwu3HRSw
+OpNQZB75leLXfvaCfSy7DvGCA4HdbBOIsP1E6WdFyIwD7PvCnnkPlPvQH2IyiAUR
+bdncS0T4j76E0oATndBEF1oxEOwqw0YR5+sBOtMppXJRT8UrxXR6RddXys82Y5OI
+cngAMTGEhDjI+MHN+ONhfM+2+FeINSLGiDhBxEnODuBAiBgjQj7c3uEsnVcuZdhF
+KzPDwyuZzHYbl6CKIpJiJmAMhYyzZMTlw5eHDzBFmYKANK7QTkpJKdthN2hmHj3i
+JmcHNw2Nh4Z2NzXU5FzL9LRCT9UAs+FpKvQ0+GNPTXh3aesebd3nLB/VZp4iwQ0n
+WSjx56U3aJlfR+u7oHgUGla/Y/zOXP+BuPiTs8PQv8lTVOZJ+nmFxKQcRDnoxg7r
+t8n+h/0dA/cePnjaYOgRWsRf6BWPOcv3F8LmuK2EjeQ+oO1vpHPv0XZZgg/x//gf
+dEk2x1GOVeUJlOjTbG4dyS16JwkQ/zJ9T1iZ//Fl/88j5rgSwSF0BYoIdvLtdLLq
+utn3oPUrUEsDBBQAAAAIAGKhtTxDxhZqdgYAAGAMAAAfABwAamF2YS9hd3QvZ2Vv
+bS9SZWN0YW5nbGUyRC5jbGFzc1VUCQADFyH3S/Mi90t1eAsAAQToAwAABOgDAACd
+VV1zE9cZfnZXq9VqZWGDBeu0YAi2JdmAwSQEY+IQWxjb2JiCzFc/kkXeygJ5F/QR
+SNNkprSZMu1F72pMSqYXbUhmuEhnWkJ60Wlv+yf6edUfUfq8q5WsuNgX0Yze877n
+vOc8z3k/zv71v3/8E4DD+CCO3TgXh4UFEedFfEvEBREXReTjWJTVxcbqJQOXZbwi
+4moc1/Bt0b4j4rtifk+0t0S8LcIRcT2OApZ0NH79TWWoqQwbcA18X0E059evl10F
+iRnPcyuTZadadasGigr0qbLv1BTEFhbzb82dnsorUGYUdEz6XrXmeLVLTrnuajxM
+UWCIT37hvJiqAlPMCzNnpvMyEVEQl4mJhXx+YV5mYgQ+WfJKtXEFWiZ7SUFk0l8i
+i21zJc89V1+57lbyTsDLqLq1C26BPIxMjj9x3pOZu+G84ww7d2rDRddfGRYHxyuW
+3ZHcmDgkS17NrVQ5W5UDW3uvUfPrtUKApXMuywu9tPG08z63y0lcjBF+quKs0N8q
+urUJv+4tVUdyCnZnsluQ4MaC79WcklcNgQgdX2elYHuh4jo1d6Y5VfI9Bce3vNiW
+eGbrcAX5rY75eksSVatBedELuOr1xqg5S0vhHS9tFUwuxpad6nIj0cw6oxt1b9ed
+MqORCreViTe8cP0GkceCkF3065WCO1WSUuhsI3RI3BM4iEMJLKOUwA0RN0WURRzB
+SALH8JqBlQQ8+Ap6Nr1cArdwO4EKSgaqCdRQT+AdOeSOiLtivivaqJz5AxGnMWXg
+vQR+iPdZjS88uF52KheXnVvkvXdT5L5m9/Vu7hJ2YYTVdyWIW65hXGU8OVwuLdWW
+mX6q026puEzX1AszwBwVyr40Q3ezdNujzc4oVU+v3Kq9G4BIp/DI+ZJH0OS697wj
+aNqKczfMea7leDXUnLvCc6XktWyudDf7aKrir+RKTtH3nDJTun5yMxSdS4GS9+d8
+rzhRkl6JZHLZ2cg+vmu75TlBD/ajDwr65bXBAO10m52hnW2zB2kPtdkH0M0zWDmc
+GebMPo4KR33wCyi/k/eM7zQQpyuU54io8oCxnoKVIzgabjsCUzyQGhx6CpV/jf8I
+//pTRDcco+5Ct2pz5hW8Gm7/D2Lo4PizQVu3jacwrh6LP4QeeTKYzgaWuQY/Zabi
+H6xB156kzBiVw4OEGrVSpkEjYVs0I4VRK2tb6aJtZIs3bT1d9AuztjX9+PmXXNXE
+uTPW8tbpnbatbFEcb8oWvzBtW7OPn/888qTF+Rx2kPNBJNVD6FQP45vqEfSpIxhQ
+X8FB9VUcVY/hhPoaJtVR5NUTuKyO4Zp6Em+rr2NZHcdt9RTuqW/iQ3UC99Ucw8dO
+DE4/huPh/fuhB+HrkPDF+Dd563UKUUmJeoeSXRduSTPiJkeLIWoE7f/i/FPE1fuc
+OYGxcNPeMLsx3j7+Z1ifb4D4BeVJvB56X+GsQBwPAq0HETTStr76EQaytsGhl1YQ
+9ge/wg5OBUGlbkQeI6KtXyAJfujUVUTVB0ioa5wdb+X+faJI7he5OfEQXbaefPAx
+4raRfPBIkh2Am430Ea5gm6sfI0uwgm1RIwWzjYK1GYWdDDHU3yCl/ha71MfYrX6K
+/epnwYW/HhWTAThARA79DWINHo+ws8GuQeXRJlR+Typ/IJUvSOUZqXzJyngDp7hu
+4k1MhJRusc8tjjke1sHC6HiG5Cz1bdS3UQ/S0kmj8xm6RiUB22lsF8M8EBQGy9u0
+9eJT7Fivj5d4Uah/Yy7+jh71H6zlf7KO/8Ua/jdZTIYsci0WN2kJizfWWXS1sehq
+Z5FsZ5FssrBZ0d0bCGhRJDQDPVoMA5qJo1oc45pFD35RQuAiYSUjYwKcbiGlmzDb
+ssFNBTArc5Y8ICbh9KJt2WbxK13RAN2HuPYyurX92KP1IaP144Q2EICeCUGzL+jG
+1Ibm0sbI/WSw7WhbquJfTVXXTHtcIu0Ri7YHKTaYsaN2JFO0Y3b0RaTPEG2akZph
+pGYZqbOY1OboMY2ZEL1APy2MFOtp56leqVMq3dhVcgIrElg9oaUH1jfEut/bufe9
++/c2VKj2I8S0e9ip/Rh92k8won3I1VmcDQHv8LshgGeHBj+Rp3roL7DWMD7EZ2Ve
+OBzgf/UhhoQGdY16QIJ6hPoOoUBdpx42SFuLNG79SzbdKgxtDUmNO7SPMKP9mtGf
+Cz5d83zOgO3U9jDyvSxR+Si+DPN/UEsDBBQAAAAIAJaVpDxKIiZnkQMAAHYGAAAU
+ABwAamF2YS9hd3QvUG9pbnQuY2xhc3NVVAkAA1yj4EvzIvdLdXgLAAEE6AMAAATo
+AwAAfVRdb9tkFH7eOolT101L1m6wFKaxriROWWBfMNYOWNaOlCzrllGpIKS6qdd6
+cu1gO6PjYkhc8vEDkADtCm52MSSaCirxIe0CcQfi9yCe1/HazitcvOc9Oec8z/l6
+nT/++elnAC/hhoY0zvZTvCLFqxoO4pyK16T5vBRTKqY1ZHFOei5oeB1vyJ9vZnFR
+3tUsLmUxI9VZGXFZxVsqahpGJM2cirdV1AXEBk+N547AcGD5tuksWH5ge+47tUs0
+zwkMVj03CE03XDCdjpXuPvzUP3339wmBzJTt2uEFAaVYWhBIVb0VS2CobrtWo7O+
+bPk3zGWHlgPF+i3ztlkxPwwr857thudleLpYq8l7YNUK617LDJlTIF8sJYMZEuwN
+Sa17t8naH/qmGzhmSD27ZgZrvfSshe1krA86phMIjMa5HdNdrVxdvmW1mP1dIkKv
+Gfq2uyow8ihlFNOzMmm65XiulXTHFAJa0+v4LWvWlh1qUaUnZJiOo5jQ8QwO6yhI
+cRTPC+Qe70lHSQYZ4BQPJnNf7Ny8afk6rqCh4qqOebys4xqus7f3Nqal2qQ6eWea
+63lf51Oh+yROCYzvMlVl7Q0vbHbabc8PrZWZjZbV7s3v0G5YzQ0t3zWdGd/3fD6A
+ZJ/sPjLZXqUZvQ37o3iliVQ9a5arrDpmEMid751aZOTQhhImAZWQhrlOcMZsty13
+RWCy+OQ6ntxQb0rkLBRr/+nl8NN8+304hKehQMi18OsScjO8D2MMz/LXc9T7cAQ6
+da6L8hgtxyIEoBqKsgXxfQQcp9QYDEwhg+kIcDwGlAiQnkGj/AP6ePaDzTLL5Qg2
+EcNO0a7wHjK2kDIKm+gzxjah7ALzSFHOU15DP64jhyY9L6AYExTpkYUObyO9aDC1
+0Uv9YIchE/mXKEv/U20XmWS166zWjWATe6aiRFMpjHWhJgF3metjWowdQDlub2C/
+1nKR6zNu6XMSfEFreQd4Js40aiyywMKSRFNTxpb2ofiK8K/53/YNrZN4MaY4Hq9w
+8NFUho+sfXI/MZZvKU+gEkMacblG+Tekv8R4+Vekr0j4JM895CULVeUe1NR3SCn3
+lV2+3qI2oaLLuW1xMT/Sww805p4jt8x4chvZxS30G11oXQwwOD9IIbN0kcsP9XRF
+6sPUu3gqucqHlPzmY96z5JXDz/EF5R/UtzFC9tFfosgUZ3vgsVH9Sctf5Pmb1tPR
+yz/zL1BLAwQUAAAACAA8obU8NZzAVdUAAABfAQAAFAAcAGphdmEvYXd0L1NoYXBl
+LmNsYXNzVVQJAAPTIPdLFiH3S3V4CwABBOgDAAAE6AMAAF2NvY7CMBCEZ/lLIPw2
+FEhQh4YgWrpTdNVJoLuOzgQrBAUbgbl7Nwoe4B4KsTERRLjw7I7nG//fLlcAU/Qc
+dBx0CfVYmg99VpsToe+Pv3biVwTizwTfMjJCxamcE7xnaBYShsVYLPX+lZ2FnHYj
+rYxIFDdW/TAcrwgD/41Y6kQZTmePDR7l8cQdTDhMPJjRO1P8xXI/+nyM5GeSymzZ
+ioOcZASh/QStS+haI2U6WKx33FMjEErIjlshlFEBWKuoWXXg5lq32oCXazP3vVx5
+56YW3yW071BLAwQUAAAACAA8obU8vj5zLJgBAADkAgAAFQAcAGphdmEvYXd0L0Nh
+bnZhcy5jbGFzc1VUCQAD0yD3S/Mi90t1eAsAAQToAwAABOgDAABtkVtL60AUhde0
+SdNLauutXuv1HE/Mg/Vd8UFFLIg+KF4eUzu0I5qCTfXob/JBwSIo+AP8UeKaNCjE
+Dsy39uys2Xtm8vH5+g5gFU4WGcxkkMasxpzGvMaChcUsUvhj4a+FJQHxn7PKeSdg
+3qp60BRINaVqNAMG68pXwYZA0lk+FjC2WnUpUNhTvtzvXNXk9ZFXu2Qm05bBZqvj
+19sCllPlCO0NGZyGe6u9xRmdlN2oeprxSa+jxfBQ3bNUyVneu/BuvIp3G1S21ZX0
+26rlrwlkD1ud63O5o3TD3Jbn33jtFe20UUDRRhY5G7ZGXmMAOYGh35W0+x/v8P2l
+V0mgGGYuPb9ROahdyHMe0HT0RTDPd8vwWQ1OdoEedqT5SAdCtSD0YchBrspUQTXd
+F4gnBjwQmQqTSXIYI5F1AwmY1JI71UXCne4i6Za7MNxRowvzZ28pdFlkGvoXF8hR
+thZk6VfbZyQeYm3z5FhfazJuLZDjfa1m3DpITvS1GnHrMDmJqcjq8FF1tviG1Jm2
+6+ovsB5ju3TpaWoC5S9QSwMEFAAAAAgAPKG1PMQirlvzDgAASRwAABQAHABqYXZh
+L2F3dC9Db2xvci5jbGFzc1VUCQAD0yD3S/Mi90t1eAsAAQToAwAABOgDAACdWAt8
+lNWV/9/vfvPIZJJMhgwTMhmIeUgyBKFUswFCIIQkBEIw4aERRSbJZBKYzMTJRAJV
+Gl9o14K1VgVUihSNIFVMIIliKT6xbrWtbdfa7rbdbrttd91HW9tqfdBzvu+byYPB
+9reTmf+5j3PPOffcc8+9N69/8twZAPOFx4pTFozYoGCUYcyKZ5k+Z8VpK5634hsW
+nLHimzbYcNaGPLzA8KINGzCaQqWXGF5meIXhVYZz8jzJZr7X1OrPA+alP4f24aZv
+MbzO8E8M32Z4g+FNC77D9Ls2fA9vMXyftfzAhh/in614m636kRXvWPFjK35iw7/g
+Xxl+ymN+xqWf85h/My/L1pWZl0V0teqyAYazuv5fMPw7wy8ZfmXDf+DXbPVvGH7L
+8J8M/8XwLsN/M/wPw/8y/B/D7xh+z/AHhvcY/sjwJ4Y/M7zP8AHDXxg+ZPiI4WOG
+TxjOEwgwCItQLEJahCpg2t7ZFQsIOBq2+m/0z/Nvj82rjoQi0cXUddXK+vU1NCTU
+FeyM1UX9OwRsDfV1K9dfX9dc1SKgBrU2Va9Z2/3RbTpXyoqq5tUGk6k15G/bRnR5
+Q1X1agEZDbQTNtesoJE9XWHqUq+sb6QecyTqDwfJFvPa5qrGOtJs3hEIhSLbqdBS
+09Cw9iqSEowGAmGidc01NY0Clm5/MBCO+am0pqqupnF9FYlr2+EnFrW6pYo41NZQ
+H8lUlzdsIImmnhV+5hb1VL7Rr3WldESDrUZZ2VRL2jqMmrnDH+rpZHZqVdp6BTzj
+bmpjN+nOWtfjbwuQxxy9gWiXP7QxEO3tioQ31NMUxSqBtOpIuDfmD8c2sliTeMx9
+m+Oez/aR/Nqq6vVrmyXFDSmYFgv0xjR5Gl+z7gxLcT19SjbyhCLt1JDR0BUONPZ1
+twai6/2tIY2llj7MYq7oCnfFKqlQHB9UrBFTcf01GkNxnDMYiDVrK1FcQr6wUrVO
+d62Fisu16XNjle4Ajb1uObW1RjkaAlEBZ3HJhUFj5ijgXmunv7dTt9gcuKHPHyLv
+uYr1ASGa2ry1rVsDbbHFJdcQbyyyLhbtCgcFsuJCNR69VRMbaNNkFRZf2J3EDFtN
+f1ugJ0ar0GsRJn0qWp/A5UkkTBWQRGJRkmH1SfisK9ctj0U0X+nOZu9SNRahDgo2
+XphNtSUcZ6lkFDUadrk07gsFOnTXV0e6eyJhivVeFmxIcMX7iHUiQ5o23fG6Mz79
+iY0Z1Lietlxvjz8aCLftiA+LB7SAd+IKJ4l3a0VbyAg4CiOKKtu6SF+0LVDbxWFp
+03gvYwECEJg+1X/L+zo6AlE7voAhuzBTVoI5T4s3Ow7gIYrdPC1CzXlGZJry9LjM
+HxdUHwoFgv5QVTTY102zSqy6gE/Tnkdz83cHKF7zIn2x3q72QF6kIy/Q30OhF2jP
+0xLOIrJAWNmMu+24HXfYcSO229HPsAM77fgcbrKjDzFmuYvhDuaj0n24x469DF9i
+uBf3CKRPXkBm/0eLSLELm0i1CztDmki3iAy7cPAk5aboEp59JhVLg0sYWwnFdRbh
+tONhMc0uslj4ITxqFy6uThduO76GI3Z8mTuO4pgdT+KYRWTbxQyRY8fVaLHjGoZN
+DNcyXMewmeF6hi0MfoZWhjaGdoYAQwdDkKGToYthK8M2hhBDN0OYIcLQw3ADQxSU
+9B1TtzltbK2pKzJvnZYju3bqucuVcNfkUJw1LkHPdbWRaLd/4gKb/T09gTDFR+nF
+U8IFwbZ4ShKKs2+ML5zWusYf66SF6O4Ka5mznvew7Pb3G3kk5O+l7TNtUqbSGkl6
+xpQmPZ82UgzS4VFc/yl2ZU6I6nAsEOQkOvtvTM1g5K3YZRwvtO9IYUKCqSMU4eyi
+Fq8ooeNoxkW3s56O6rWDimszi+s/bfPjErpSbKBb0kZchXzM4KCjY2wGx51GNxn0
+WoNeZ9DNBr3eoFsM6jdoq0HbDNpu0IBBOwwaNGinQbsMutWg2wwaMmi3QcMGjRi0
+x6A3GDSq0VvRi5h2oevTqMI5QaP9BqXMoFFKDkRzcDN2UY77vNY2QPVbaVy8fhv5
+ysaphVp2Uyp0QoWZep6TZapTLDJ5H4LNm4nzR5CrlqmnobSMQs4wjUB1MozAvMiU
+Qzw5yXkscR4P8XiS81jjPLnEk5ucJyXO41LVQ5h1GrYWo9+ZSl0zDFtGYf/mM+CM
+fidfXJBJ+DtI/B4W/AFOvAcX/og5+DPK8D4W4gOsxYcUFx9RDHxMfj2PXXQe3CIE
+HhQSjwgVzwqL5p+7DP94Df+8YvinKPUBsrpoT8aDBz/FQ/l70vcRW35ytoSTCnS2
+guRsCT8V6myFydn+/64SmZAUABYxDVmU2d3ChbnCjcUiG5ViBtYLD1pFLgLkhM+J
+WXQy5eGL4hIcFgV4QhTiZTGbpNGZorsKdeQqlehsHy/8LoejP1ej1v4Bjqhdsn9g
+FGmeXK6MIX3cmHRaMYhF8IrFuFRUaEKN+KSIVmEiutI3igyfOAUHQ6Yv9RScXJrm
+c6maluz+uNaBC9SeQhapdamTtObDSsXVJP8cPUXeIit+gmn4JbJFA5aKK1EnmjRL
+7jYsaSIrFaKXXNQSp8vDqsZVzKQwhGhPoiJAb58OTfwXDfEBEs+377kXE5+7H6k+
+D8kfJHqBqktJAUR/ElU7kCt2olDchFKxS1O5x1BZRJ7lBUvxFRQW2UcxfVwcPzoh
+7oNVfEUbYmwH7COn8XJs8RU43Vv3ZCG7bW9holSUKLnVRHEUOSTeTc73+MzPm3li
+J+GQBU1M1EKNmIqafG6VZ8o1mvbUiT1OkTmIK8QTqBBHUS2OYZV4Ek3iOK4SX8f1
+4iniptuPYWUhWU/7GnbfCHIdjp0cBscTEs3cJ8YIv3SREdakI14ivDcxosAYkcoj
+ZNIBbxJ++SIqspOOeJvwvsQIL1EeYSKnZE1l/TXhV3C/wXqGWnldbiXh3gqCmUsI
+ZlWay1TPAczIPQCX9wAyTyOvxaXy3yguOeE5CLvHpR6G2aVW5FIl16gs8VLFa1Qq
+eZDH0d7pqA1pOzc/d2LFO7HCUhN2+iiKIN6HSXwAm/gLMiiknAod54qCUkXFQsWE
+WsWMdYqFRjyQmMsqfYZYwIp5Po7aTkd7SI6hgCc2qTZrvDZJtyZBySF88O9yp1JE
+uA/7DdbP0lrxXvfMeQF5++GacxZ5NIgHHoJFHYQqpwq4nJCeCoaAjcZiVxqpmEwt
+HEER5+tLCXhWI5jtLNbLM7lcopdncdmn5+yp81lKe+FhPEKy9Xxr1jLGbN8Y5jTM
+GUHpEvZYPODjYaxlw0nO0fKtciVMShNsSjMO8j+LqO+rJP4QidenMNOYgtlHe2Xu
+VFM6NN5HDd4N1KpqyWsMl60pPQfTnBOlZJAWO17DIK9hkPcCg6Zz7Co3kUE3I0XZ
+hVRlAA7lFk3F4UT61VV8RlfxKmysgFbCk1yJviWTzPtBUrOPAnE/iaeni3HOv07B
+6iC6QFbSSS/LTAWp9x+Ak3Pb3S1lppYytXJQ0Lmev2cM84JZmL9toTmb/ri20EpH
+c8Ge4LaFNq2Qbd1GZbtWzsi2BrmWnm3ee4xseBn6x6TlX2AZ/TbR70b63Uu/45rG
+yuz0LCzYtrdMzbbpBdMg7sy2a+VKjWVSV8goJ7rSE11N8S5jdJmq81BXmcFWGZc0
+3uUxzIh3xAebnC4vH7Eulc9Xl4kO1/GNsJtu4lCehlU5gXTlGXiVYcxRTuIK5RQq
+lRGsUkZxtTKGAeU57FZO4x7leexTvoGHlLP4mvICjikvYlh5CSPKqzijnMMrymt4
+U/kWvqd8G+8ob+AXypv4rfIdvKu8hfeU7+Nj5QdCVX4oLMqPRJryjpiu/FjMUn5K
+6/oYHjfWtYXW3E62vTP3HCx0/DTmeI7AksNxU2bJdVmOwJxbZsnxHI43WnNd1sPc
+aHVZdjvd4XKzy7IfTpfFZW3fTU3hcnKPObXc5DZxhKSkllM66HZZcriXecLlKS6L
+Z7xmc1lyx2upOS7LIaS5U922Dh45y8P1jDR3Sqs7VWtJc17utrW6U6hCp+gVYSap
+DzyMFLdqby1X50q32jRXdZua5prc5qYJGzMMD7n/fajKB7QEHyJL+YiW4GOUKJ9g
+gXIeiyj6l0qBRinRJFVcLU3YLC0ISSt2yhTcJW3YK1OxT9pxUKbhmMzASenAaZmJ
+F6UTr8ksvCFdeEtOx9vSTW4exBPG7ryUAppzUTrvxfyCwjGU0V1vStKQPsKjOGaM
+eZr2M48JzjkHm+V585pBShtr+AJwDgtKOWV6eQGaSrUUqRdNnCH1opmK/6AVB1FE
+7HypmM/MfK2Yz6x8sZjPjCfhbCodN6YMaWTMYkriFUiVlUiTy5AlqzBLLodPVuMK
+uQLVshYNsg4b5EpyUj0CcjWNfjJh/P2G8RvYePNk42f/TeMHMfPTLB439TKkkqmb
+yNRrydTNZOoWMtVPpraSqW0olwFUyQ6skkGsk1006njCxDuMq3MNic2kW6GPjojy
+E1w5U0lW273qlrjdlPJcqvcwskpdbE2mi8y5XRWD598t9U71nm7SzbDIXWTOAKbJ
+W+CWtyJP3o58uRtz5J0oI1ohv0Be5MfB1xMm9RsmVUwwaeG4STbv32HQlAuGfIQs
+OUiWHCJLHiVLDmOmPELWPI4SOYjLiS6SR2nEU4mLwHLjdJ/OEVTBz4ZDMKnH6aJk
+Mh03j+ezHH75yVMwyRHY5SjS6ZrhlM/SApwmjqdxwpBXZpyU08nSaeeQ5suUvxnD
+In4SUMOU80e+TPa+gkx5jq7Sz2DIyFOPaX6BKOENRBbpXzq+hrF4CIuHUaF3nNW/
+WseSISwZRqXeMaB/tY6lQ1g6jGXc4VjGf1pr1RCqhrGcW6WUWlP1EKqHscLQaTTW
+DKFmGLUJQ56mr9ZRN4S6YaxMdLym89cPoX4Yq8YN15tXD2H1MBo0dYnGNUNYM4zG
+uML4FNcOYe0wrozzxpubhtA0jGbd4njjuiGsG8b68RfCVloooJyeOxWYQQdqKWqw
+gG6RNfTYX4312r9//NhM+bENMXTiNnTTiyZKN6ntdLu4CcO4Bc/SIrxOT73v0pvg
+Z7S5f0V3uT/RhegjHBFpOEov5KdEPnEK+vG/UU7+FVBLAwQUAAAACAA8obU8kUh3
+xv8CAADXBAAAFQAcAGphdmEvYXd0L0luc2V0cy5jbGFzc1VUCQAD0yD3S/Mi90t1
+eAsAAQToAwAABOgDAAB1U1tPE0EU/qa77ZayXCw35aYY1FIqRVFUbiIFtAgFRUnU
+eNmWAZcsu3U7RdRf4huJD77wgIktiSReXv0VJv4P45ndCgqxSc/55syZ78z5zuz3
+X58+A+jHQgQt6K9CCBekuSjNgDSXNFzWMBiBhn6ZcyWCq7gml0NhDEs/EsZoGGNh
+XA9jXAZuyLwJDSkNkxE0oV/DlIZpDTcZFOHkGViaQbX4imAIZR0hnHWGoGuuPqdA
+fYG7pmEtcbdgOvb99CSlzzDUpBy7IAxbLBlWkQd/bAwMKT/fKUQwYtqmGGPQYmn6
+9SwRdcpZ5gx1s6bNM8X1LHfvGVmLIiH+omhYBYam2OyasWEkLcNeTc5n13hODPc8
+ZAgLZ1G4pr3K0Bjr+SvHjw7TNXOWY/PD2xUKhsiiU3RzfNqU5arTdoGLQp/M09GN
+Wzpa0aajXZoOaTrRRvf0eIyXIunnMzQfLjxRXFnhro40ZjTc1jGLXh1zyNB9HpGi
+o3IxT/0lpKij1EfCl5WglvCEJcQe64jLgwmcZ+g+qJGSLWUcsVjM5x1X8OWpzRzP
+C5KfoeUgLW0L7tqGNeW6jkuDOtw+Q8MhTl/1Ri9qOslFb7Lmaz+sxOSswqtcpCyj
+QF03/COpFxz+o85BiDqiIxljXc7TyOe5vcyQiB2d1dHx+SoSZ1ss/d9ddNGrb0EA
+x3ECQTA5MvpEmJya5zsqvtPzrTiJU7TqIhzAaaiEu3GG7FmKTFMsKLPiu2DxthIC
+8fYSlHhHCWq8SS0h+MHjOucxhcjOEUMGVZhHLRbQgDt0i7uUEUNPhXOZOBXy473f
+EHqLod6vCM3FPyKQoP8WYgQVgsoWOgiqBNUtRAkGCQa3oKnvoSrbyvZ+5SjVBJ7Q
+p/sUOp5hDDnaoadSqZilioz8zB60B7sIx8uoKiNSRnVUJyNrl1ETrfWxInGdj1WJ
+630clPgY4TKiO/u1Qx6zTZZeZaXeINULkK8l1Rp2ZvfQRFWbv3iZKunZWDlb6+mw
+SZFXxPOGon3eFJK/AVBLAwQUAAAACAA8obU8pomItW0DAABCBgAAGAAcAGphdmEv
+YXd0L0RpbWVuc2lvbi5jbGFzc1VUCQAD0yD3SxYh90t1eAsAAQToAwAABOgDAAB1
+U0tvE1cU/iZjexwzcVKTRyGBEh7NeBxiGh59JKGEuDRO86BKCQKEyCS52APjMdjj
+IiGxZlOyR2LBriqKVCqB0xKpIq26YdEuEZv+lKrfnZkk4ISFzz33nPud853veF79
+9+J3AMfwbQIxfNJMMyjN8QRSOJHASZzS8KnMfabh8wTiMvgFhhIYxoi8no7jS3me
+iWM0jrPSHdOQ0/CVgugde8krKlDyCmJFYReKnoK2qqjYljMnKlW77F7I55ifUNAy
+VnarnuV6c5ZTE9HR5TevV67l2gkctl3bO61ANdJzCiJj5SWhoHXSdsV0rbQgKt9Z
+Cw4jXcbkDet7K2vd8bI5uyRcWX5IQqJGPi/PeEF4FwNGrMW+zQyMh7S0qvBm7btC
+Ps/l5HOtsBHpNNI71SY3cbtmOVUFHWFzx3IL2ZmFG2LRG0pfZsuiVS0GjNmSMsS9
+8qxXsd2CgvaNqj4oiLJmYrZcqyyKc7YcKrnZbUA+1dGDXh3t6NDRKU0P9mk4p+Nr
+jCtIbeeo4wh6OUBjn7O169dFRUNexwS+0TCpYwoDOqYxw8Gv+HsbkdfzpNwfrG6E
+i7qq4ygGFOzZbFUQ5dJWv0Gq2u7n7HJ21l+0fTfYT3KLw5QldxBZFLbDw8jJXbQ1
+6hfsa8yxqtR39zta+UFK1doQCnY2bZXYLmbduiXcJQX9xnaVtwsfCMKa3Ub+vVn0
+8jtIgXSg0nIN/HQUuQmee9GFD3nbQ7+JN50+10O7n5FDPgLQTFVdhfKLD/yINsHH
+wAUWnvMBB0JAmgCZaTEzz9DE304wi10WfFhvCDvOuMqz1VxFxOx+jiaz5znULWAK
+EdqbtA6aUUISLjMHSTAosJ8FJNGYybb3f97Exfxojfbwjm/VbW/v0R7Bx5vEVER5
+7jb7fkV0WRJLB85b5JI+9x9I7AGJLjPaByMsYJCyLNu2htglSc4MNHna0PaR3/b9
+MtahNcr4E2V84sM2ZMyEMu7aScKA5W8c5wULrDGahhkCp0OgmVlH7CEOZ14iNiXZ
+9vP3GClJmq76GFrkR0TUFXWlYTXr0PAHCf3Jif9iJoP+tySUdLs2pp8f7u6OzBej
+jgzMrzRM9TfPfxjhBxsWmAj3NbiG+KVVNJt1JOrYVYeeaqGRVepIploDX5V+G/06
+PmgU+V/arP9HP/Y/UEsDBBQAAAAIADyhtTwnmXuQuw4AAAcdAAAYABwAamF2YS9h
+d3QvUmVjdGFuZ2xlLmNsYXNzVVQJAAPTIPdLFiH3S3V4CwABBOgDAAAE6AMAAM1Y
+a3Rc1XX+7j3nzp3HlS3LuoOsmbGlYCxpJD+BETGWwJLsWsYvbDCWwY1G0lgeIc3I
+evgFFPEQVoBAQhyw8QPbCAzBBJPYMuCEQMGBeLX90+dqf0CAJqUhSZuktE2buHuf
+ezUajWQnK7+qteY8995n729/53F14XdvvAlgAc77EcBDPir2cjHExZe5eNiPGjzi
+wwyemMETEZ6I4GETj7LSV7h4zLP0FxcvXnwLEPdSzUOPe97+EOpPDFDhWfqBI+DH
+V/E1Lp4w8XU/mdzH0t/g4kkTT/nJtBrZz8UBLp7m4iAXhwyycZHNce+wwdZH1zvC
+xTMmjvpRiUfY62d5ZJhbz3HxvIkTfizkuRfwoh/fxEvcPenFy1x/y4tXvDjlxate
+fJsHvmPitIkzJkY0aLvo10i/3RqMncm2vm0aPNsSyfZtfRryexM9yXjnxkRPbzKd
+urWxgeRWasirT6d6++Kpvo3xzv6E8c6pDqP4QgfJe5YkU8m+Wg2ivGKjBlmfbkto
+mLoqmUqs6e9qSfTcEm/ppJEryld1xHfE58d39s1fn2glU+2dietZxSxvpD9uGeVO
+XZYluy6dTPVdP9ZvSHYlUuya0p0+QZJHs9caLy/bE32blK8NTqdJg5eq2xwUfNRc
+4QLB7bp0f6qtV0OwvGIy7zUEMkKLyGAkW6w9ke4ak13UQNK+3jGTJrV5luNvoD/l
+XWtnspthaNhcQfkxexK92+LdBJ6/IdHdk2iN9yXanDVXpalDQWkoyF7TgYBEerNF
+ZFd6Bxnx9fXEU72dZIRMk40NyT2JnNDGwHIcdEQ85IdqeFvTqb54MtU7KfCb3QRu
+vmSyN2eSTS0P2UkyV/ykTWwjMbJrZTrK9ejkhiZPhtGfUkoi3tbG2e1J76QFk73L
+urr7dqukswPp/r5WxVGCuYFhLmjtSRAojeMWvq78Mpm8fJYDjr1bHWc8ie398U6K
+zHYtdpLk/LUtHaSjEPH2pTf09SRT7RoKR3OhZJxRMujfkO7vaU0sT/I+mpJZbB6L
+WliJtRZuxFILdVzUc9HAxUrcRMFNRMrCFlZp4aIZcRNnLbyG1y28gdfJ/vi0spl1
+FrZy0Y512QYzZLFwJ093ctGFtIUeLrqwnZXXWNjJE33o11BySdxmN6T71TnhGW1Y
+jalUoqe+M97bm+i1cA7ftbAD/VxQawD3EXdzwarr37o10WPiexbexPdNvGXhbTxg
+4c/xDuX/9l013HyXmlW7a4gKVerwo5a3yjn+qKltsXA/HtAw45K+ZoO0wdmghWog
+mZ6/QZ2eyT3OoTdlzMHVcT5gZGsi2UlVeQMfQMbWznS6h3ZmhvQabrkc8f64KT5a
+8nO555x7Cl7ezdnEU4PEu6k5Q86xsSbexWmKd3cnUrTNqsonUnYii53EkM1QeeMl
+Z1FKV1wNdNTiBhjQmNV0J2pMbFXXu3WDqouxDMup9yfU1rECc6lNnKdyFY1cpSwA
+vqigv7PQXlWqq9V1q1N5EnRXKpU1rspCUuEZO1p5Gjr9BP0k/YxJ1M+ikHYNq691
+1ZfTOF/ixdGz8ERDZ6BHw2cgopEzkFFbnoExZqMYHirPQ+IH8OE9TMH7mI4f0gPi
+grK5LisK4UYRCk/ixt9QFH+rVG7OikKMRmHSz1t1Gj76+SdR/4ii+Fipr3fVK10Q
+pmbUJ0XvM3L5Z0pxwwRFwbj5Kidf8XNS/E8auQW3uoozaZwz5YkS6ntfych71OhF
+KjdOKityZTUvlbdNKisnyE6jctOkssYE2WIqm7DZlV3gelZ0DoEm9pl94TWiDlNO
+5WhXUnk77vgjta+mcssfQNERWDlQa3Uo1OqV+ihF55A6U9QfDYUjthxBXq7OJvi0
+Jhr5U3zJ1flrciSP6r1lhZjy1BHkFeTHfHoscALzysRrmBbzFRlTnjqIvCKjzPbt
+bW/9olFkOEOmPAGpZAIVY8p+PWaRcoWa8BeZjrJZYftZ2SwynaExZStq+2y/HbCt
+cQ4vJiZB64JX64el7UCBtgsztN2IantQo92DZdq9aNQGsFa7Hxu1B9CuPYg92l48
+pA1RsHTzuQGupV3IG6ZsTiEK9h+Gp6DwJDVt8sFTkH8yfAD+Oa/hihMwqSp67GTG
+gSBjqT1KDnwFAe1xTNe+iqD2BM3S3UposvFa91AI/p4DwbH1HAztefi1E5iqvQBb
+exGt6qNDQxsSrrvl5C4TKP8cZmQIdBbFucThw2lrZltXUIhMnLzMth5BKDf57xGO
+7yu10fPnSlJjbEwizAjCuQp/B4/29zRCLwM33kqqWSEwFu+Y0hSe0j6iID+mID/J
+BLdtdD1tGQXHcJ3nwGojoeaYDB3CVbaMDOMm3iUHMS3aRLUtCwrbmgnIgsIYEWU+
+SRxHhSMxc1QiX0nw4CE6QQvyWTw/5mCvYKuNhGmFcPYKhruCMbqCkbuC4a5gjK5g
+8ODoCkZmhazAUwhR85cU+K8o8F9jivY57c3/RkjXUKGbWKAHENPzUKPn4yZ9Ojbp
+Nu7Qi9CiF6NdD6FTD6Nbn4kdegnu0UvxiD4bT+jl2K9H8YxeiZf1Kryhz8Ob+kK8
+qy+iVZPomMiXSNPYQTMzhy96HZV3Zk7zcXxRZ/kIZuWkX78Zlr5eqU3Ol5JchTg8
+eguNdE7OF8l8MXL4oqdg6Gn49e4MX7oI0NH7cSKtS0/mRHa3Ukm7KrPGufiFXOFH
+lXC3Kzz3MuftlbmqTyvV7a7qf5Gij+r9jHlMcSTmsQ3bMxAZsOXAIRjiJLM8ZjIT
+Y96QbR6DL2x7j/MMCZrNMYN2AO2CZ1HA/ePwRWxjGIXO9DEEVJelPba3maxLpjOV
+z2I6Dx2H35a2Zxi2I3IMltMnFTnm/Rp6ekB/mXLzLUroK5ihv0rMPI1S/QzK9BFc
+rZ/FtfrrWKK/gRv1c1imv4Vb9PNo1d9Dh/4+MfOHxMwLeEj/Czyp/xVZpQ8AN7/7
+qTap3sQo1CoQZGRc+IYK3xOyDRW+R4VPgTXXsq/NLE4z3kiIAucRkqIIh937YSyK
+efR4hP4BkeVDBPQfoUD/GIX6j1Gs/wQl+r+gSv8U8/SfUjSfYbH+8wyZejPJ/oR8
+9VO9j32tYV9rOdsxle8YbfcjyLeNIwiEj8CMHM5EoB4jMWafHvMyR2LkISdEUpp8
+lEWKqrkmQgnlkCgLblbm8jT3KJnDmBVWsREBhjE9osgQsX0T46zFVIrztxTn72hT
+XEQ+kTkoNJQLHVEhsUAYiAkPlggTdcKLRuHDOuHHrSKAzSKPrNCnmHvcWpQbukRx
+muOoUSeiikKqKIzwYLUnqJ5Pg/FqT2Sw2hv0MizU89pysNof9Fc6kxTDYLUVtCqd
+WStsy+MgPlLUBjeM2qAn6N9HuAX9ZNMbtFTbIoue8GCChyJUUa8Qs/cdgpcqHszq
+efnBFI4EPUNB79C4h9JyTANEKeXjC/CLKwmR2YTIVZgt5mCRKMNSUU4IVKBJRNEi
+KpESVdgj5uI+MQ9DYhGeFFdjWFxD1nZkkNngIvNPKvqlKupqWRKU9/nIIYt9qTyL
+OadU/NUeFTe7H/SOCURZQDHErxgSKLH9g/GlQWkHCCOpkLYU0nlBj20xxkGvnafQ
+9dsWpd62YvzuyeNmHukHPWSbUkI2gl5qmkEvOUVWE47VBPUKUcbYUkVjTofwK6uW
+7BI/o0qGgnI8gFvpuwNiLTxiHfLEzQTeJswSmzFH3I654g5Uiy24UXwJy0UzVok4
+1osWolIrmkUbtooEAboVO0Q7AboNj4okAdqB4+JOvCA6cUp047tiOy6IHlptZ+am
+L6BDk4/Hb45eSXQkFGU9kqJiM90FdCe8qp4CCkB1lQ9WG042zKARIayMoGkzBU0+
+IYxQrTocPOGYDBqhQcYoNMgyYdUOu2oJVy3B3SyQaDSrZ0bpqAoaQ0FzaNzLcyNs
+wutrsMQTmCa+TnjtQ4n4BkrFU4TZflSJA7haPI3F4iCR7xBtwcNEwCNEwGeQEEex
+XRzDLnEcA+JZPCaGcUg8hxfF8wqfyz3YKnLuU/EuuXBeqbkfCNptBOuleXvFJNdY
+3iUo7AD//4O60Qxvx+Whg76jIT4g3n5IvP0R5eEjOgI/wULxz7hO/JiOv5+gXnxK
++P8r1oqf0hH4GbaIn6FV/BxJ8QvKw79ht/h3PCh+icfFr3BA/BrPif/AS+JzfEf8
+Bt8X/4O/FP+LfxS/pRV3Zbj7MYFMl422lhEarGOEHFYSjqYDuS9olhIng76gEa/2
+lYYGE3VBI+zwLjSoZsJUsRiBcS1VTEUz67wzS52On6q6E1hf6gCykirq1o+fnVo6
+hl3deGMBZewEpo2nNntGs4u5TpAfvqylfbwnMrrGCTSNbpJ1apOcwIpciWk522i8
+VSXlYylflpQvWjrk7K6gb3xi70cJIK+ARxYhT85AoSxGSIZQKsMolzMxV87CNbIE
+18tS1Mkr0SjLsVZWYIuMolNW4i45Hw/LBXhSLsQhGcPLshrn5GK8I5fggqzBP8ha
+fCpvwG/kUi0g67QZsl4rkQ3aQrlMu0Gu0NbIRvJkN/a4m7GKan5DF3KOj4D3hHF4
+ws2sXoGSSXIX7nY1f0Cj/K+ePUI9dORheoIZ3oEYQVZVpv7hsf8QD0k1NMMZUv+w
+aKXPZZ9tmAPO2/Ew8mwj36/E5laof384moYaKnaG1L8vWJMu5HxexjbG/FMfzDIO
+IVvgl62YLtsQkQnMkVsRk+1YIpOolx1YLe/EbbITzZIewjKFnZJfSPfgz9yYVrgv
+6JLKtxE4ACta+RYCI4ieOofKprOoWh2trHoNc6vGLhj1dSt3EWK7kS/vQpG8GzPl
+PTR77++zOm+81fkTrA6S1YfI6hBZ/TJZfZhmB3Cfa3Wb+33R4FhdzEZXM8hV9DuK
+ckaNmnQoRxh1asqjKGAYqWkcHc1xlC77BWNIFtA3FeTTNHsQFn1c1spjNHM/HnBX
+bXH/nbTyHBaS74ui9IgewTUjuLYgRgWvP4LqguuctuD2F5225PZip21w+3pqj2BJ
+zteafIlWeBD8j89BHFf3gUbfUjWgV+P/AVBLAQIeAxQAAAAIADyhtTzDM0K3wAAA
+AAYBAAAbABgAAAAAAAAAAACkgQAAAABqYXZhL2F3dC9UcmFuc3BhcmVuY3kuY2xh
+c3NVVAUAA9Mg90t1eAsAAQToAwAABOgDAABQSwECHgMUAAAACAA8obU8le8+25oB
+AADiAgAAFAAYAAAAAAAAAAAApIEVAQAAamF2YS9hd3QvUGFuZWwuY2xhc3NVVAUA
+A9Mg90t1eAsAAQToAwAABOgDAABQSwECHgMUAAAACABBobU8gWe4ngEDAABQBQAA
+HwAYAAAAAAAAAAAApIH9AgAAamF2YS9hd3QvY29sb3IvQ29sb3JTcGFjZS5jbGFz
+c1VUBQAD2iD3S3V4CwABBOgDAAAE6AMAAFBLAQIeAxQAAAAIAEGhtTz8dB3otAAA
+AOsAAAAiABgAAAAAAAAAAACkgVcGAABqYXZhL2F3dC9jb2xvci9SR0JDb2xvclNw
+YWNlLmNsYXNzVVQFAAPaIPdLdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgAPKG1
+PCS36CxCBQAAvwkAAB0AGAAAAAAAAAAAAKSBZwcAAGphdmEvYXd0L0FscGhhQ29t
+cG9zaXRlLmNsYXNzVVQFAAPTIPdLdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgA
+i6ueO2+rWXXtHAAASTwAAB0AGAAAAAAAAAAAAKSBAA0AAGphdmEvYXd0L2V2ZW50
+L0tleUV2ZW50LmNsYXNzVVQFAANGDDxLdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAA
+AAgAlJWkPLQHkmCcDgAAZxwAAB8AGAAAAAAAAAAAAKSBRCoAAGphdmEvYXd0L2V2
+ZW50L01vdXNlRXZlbnQuY2xhc3NVVAUAA1ij4Et1eAsAAQToAwAABOgDAABQSwEC
+HgMUAAAACACalaQ8SxwDKscAAAAtAQAAIgAYAAAAAAAAAAAApIE5OQAAamF2YS9h
+d3QvZXZlbnQvTW91c2VMaXN0ZW5lci5jbGFzc1VUBQADY6PgS3V4CwABBOgDAAAE
+6AMAAFBLAQIeAxQAAAAIAJiVpDydcPOGrAAAAPIAAAAoABgAAAAAAAAAAACkgVw6
+AABqYXZhL2F3dC9ldmVudC9Nb3VzZU1vdGlvbkxpc3RlbmVyLmNsYXNzVVQFAANg
+o+BLdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgAYqG1PLD1543fBAAAhQkAACUA
+GAAAAAAAAAAAAKSBajsAAGphdmEvYXd0L2dlb20vUmVjdGFuZ2xlMkQkRmxvYXQu
+Y2xhc3NVVAUAAxch90t1eAsAAQToAwAABOgDAABQSwECHgMUAAAACABiobU8e/Ag
+iWwDAACQBgAAKgAYAAAAAAAAAAAApIGoQAAAamF2YS9hd3QvZ2VvbS9Sb3VuZFJl
+Y3RhbmdsZTJEJEZsb2F0LmNsYXNzVVQFAAMXIfdLdXgLAAEE6AMAAAToAwAAUEsB
+Ah4DFAAAAAgAYqG1PPYVKSTwBAAATQoAACQAGAAAAAAAAAAAAKSBeEQAAGphdmEv
+YXd0L2dlb20vUmVjdGFuZ3VsYXJTaGFwZS5jbGFzc1VUBQADFyH3S3V4CwABBOgD
+AAAE6AMAAFBLAQIeAxQAAAAIAGGhtTzw13Y+UwIAAPMDAAAhABgAAAAAAAAAAACk
+gcZJAABqYXZhL2F3dC9nZW9tL1BvaW50MkQkRmxvYXQuY2xhc3NVVAUAAxYh90t1
+eAsAAQToAwAABOgDAABQSwECHgMUAAAACABhobU8lu1i4DMCAACxAwAAIgAYAAAA
+AAAAAAAApIF0TAAAamF2YS9hd3QvZ2VvbS9Qb2ludDJEJERvdWJsZS5jbGFzc1VU
+BQADFiH3S3V4CwABBOgDAAAE6AMAAFBLAQIeAxQAAAAIAGKhtTy4o9DbXQUAAF4J
+AAAkABgAAAAAAAAAAACkgQNPAABqYXZhL2F3dC9nZW9tL1JvdW5kUmVjdGFuZ2xl
+MkQuY2xhc3NVVAUAAxch90t1eAsAAQToAwAABOgDAABQSwECHgMUAAAACABhobU8
+VCT22I4BAABnAgAAHwAYAAAAAAAAAAAApIG+VAAAamF2YS9hd3QvZ2VvbS9EaW1l
+bnNpb24yRC5jbGFzc1VUBQADFiH3S3V4CwABBOgDAAAE6AMAAFBLAQIeAxQAAAAI
+AGKhtTydHJKtcwQAALAIAAAmABgAAAAAAAAAAACkgaVWAABqYXZhL2F3dC9nZW9t
+L1JlY3RhbmdsZTJEJERvdWJsZS5jbGFzc1VUBQADFyH3S3V4CwABBOgDAAAE6AMA
+AFBLAQIeAxQAAAAIAGKhtTxXPB36GAMAABYGAAArABgAAAAAAAAAAACkgXhbAABq
+YXZhL2F3dC9nZW9tL1JvdW5kUmVjdGFuZ2xlMkQkRG91YmxlLmNsYXNzVVQFAAMX
+IfdLdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgAYaG1PAvshPBcAwAAHQYAABsA
+GAAAAAAAAAAAAKSB9V4AAGphdmEvYXd0L2dlb20vUG9pbnQyRC5jbGFzc1VUBQAD
+FiH3S3V4CwABBOgDAAAE6AMAAFBLAQIeAxQAAAAIAGKhtTxDxhZqdgYAAGAMAAAf
+ABgAAAAAAAAAAACkgaZiAABqYXZhL2F3dC9nZW9tL1JlY3RhbmdsZTJELmNsYXNz
+VVQFAAMXIfdLdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgAlpWkPEoiJmeRAwAA
+dgYAABQAGAAAAAAAAAAAAKSBdWkAAGphdmEvYXd0L1BvaW50LmNsYXNzVVQFAANc
+o+BLdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgAPKG1PDWcwFXVAAAAXwEAABQA
+GAAAAAAAAAAAAKSBVG0AAGphdmEvYXd0L1NoYXBlLmNsYXNzVVQFAAPTIPdLdXgL
+AAEE6AMAAAToAwAAUEsBAh4DFAAAAAgAPKG1PL4+cyyYAQAA5AIAABUAGAAAAAAA
+AAAAAKSBd24AAGphdmEvYXd0L0NhbnZhcy5jbGFzc1VUBQAD0yD3S3V4CwABBOgD
+AAAE6AMAAFBLAQIeAxQAAAAIADyhtTzEIq5b8w4AAEkcAAAUABgAAAAAAAAAAACk
+gV5wAABqYXZhL2F3dC9Db2xvci5jbGFzc1VUBQAD0yD3S3V4CwABBOgDAAAE6AMA
+AFBLAQIeAxQAAAAIADyhtTyRSHfG/wIAANcEAAAVABgAAAAAAAAAAACkgZ9/AABq
+YXZhL2F3dC9JbnNldHMuY2xhc3NVVAUAA9Mg90t1eAsAAQToAwAABOgDAABQSwEC
+HgMUAAAACAA8obU8pomItW0DAABCBgAAGAAYAAAAAAAAAAAApIHtggAAamF2YS9h
+d3QvRGltZW5zaW9uLmNsYXNzVVQFAAPTIPdLdXgLAAEE6AMAAAToAwAAUEsBAh4D
+FAAAAAgAPKG1PCeZe5C7DgAABx0AABgAGAAAAAAAAAAAAKSBrIYAAGphdmEvYXd0
+L1JlY3RhbmdsZS5jbGFzc1VUBQAD0yD3S3V4CwABBOgDAAAE6AMAAFBLBQYAAAAA
+GwAbAI8KAAC5lQAAAAA=
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/AlphaComposite.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/AlphaComposite.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/AlphaComposite.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/AlphaComposite.java	2010-05-19 14:43:52.000000000 -0400
@@ -0,0 +1,804 @@
+/*
+ * Copyright 1997-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt;
+
+//import java.awt.image.ColorModel;
+//import sun.java2d.SunCompositeContext;
+
+/**
+ * The <code>AlphaComposite</code> class implements basic alpha
+ * compositing rules for combining source and destination colors
+ * to achieve blending and transparency effects with graphics and
+ * images.
+ * The specific rules implemented by this class are the basic set
+ * of 12 rules described in
+ * T. Porter and T. Duff, "Compositing Digital Images", SIGGRAPH 84,
+ * 253-259.
+ * The rest of this documentation assumes some familiarity with the
+ * definitions and concepts outlined in that paper.
+ *
+ * <p>
+ * This class extends the standard equations defined by Porter and
+ * Duff to include one additional factor.
+ * An instance of the <code>AlphaComposite</code> class can contain
+ * an alpha value that is used to modify the opacity or coverage of
+ * every source pixel before it is used in the blending equations.
+ *
+ * <p>
+ * It is important to note that the equations defined by the Porter
+ * and Duff paper are all defined to operate on color components
+ * that are premultiplied by their corresponding alpha components.
+ * Since the <code>ColorModel</code> and <code>Raster</code> classes
+ * allow the storage of pixel data in either premultiplied or
+ * non-premultiplied form, all input data must be normalized into
+ * premultiplied form before applying the equations and all results
+ * might need to be adjusted back to the form required by the destination
+ * before the pixel values are stored.
+ *
+ * <p>
+ * Also note that this class defines only the equations
+ * for combining color and alpha values in a purely mathematical
+ * sense. The accurate application of its equations depends
+ * on the way the data is retrieved from its sources and stored
+ * in its destinations.
+ * See <a href="#caveats">Implementation Caveats</a>
+ * for further information.
+ *
+ * <p>
+ * The following factors are used in the description of the blending
+ * equation in the Porter and Duff paper:
+ *
+ * <blockquote>
+ * <table summary="layout">
+ * <tr><th align=left>Factor&nbsp;&nbsp;<th align=left>Definition
+ * <tr><td><em>A<sub>s</sub></em><td>the alpha component of the source pixel
+ * <tr><td><em>C<sub>s</sub></em><td>a color component of the source pixel in premultiplied form
+ * <tr><td><em>A<sub>d</sub></em><td>the alpha component of the destination pixel
+ * <tr><td><em>C<sub>d</sub></em><td>a color component of the destination pixel in premultiplied form
+ * <tr><td><em>F<sub>s</sub></em><td>the fraction of the source pixel that contributes to the output
+ * <tr><td><em>F<sub>d</sub></em><td>the fraction of the destination pixel that contributes
+ * to the output
+ * <tr><td><em>A<sub>r</sub></em><td>the alpha component of the result
+ * <tr><td><em>C<sub>r</sub></em><td>a color component of the result in premultiplied form
+ * </table>
+ * </blockquote>
+ *
+ * <p>
+ * Using these factors, Porter and Duff define 12 ways of choosing
+ * the blending factors <em>F<sub>s</sub></em> and <em>F<sub>d</sub></em> to
+ * produce each of 12 desirable visual effects.
+ * The equations for determining <em>F<sub>s</sub></em> and <em>F<sub>d</sub></em>
+ * are given in the descriptions of the 12 static fields
+ * that specify visual effects.
+ * For example,
+ * the description for
+ * <a href="#SRC_OVER"><code>SRC_OVER</code></a>
+ * specifies that <em>F<sub>s</sub></em> = 1 and <em>F<sub>d</sub></em> = (1-<em>A<sub>s</sub></em>).
+ * Once a set of equations for determining the blending factors is
+ * known they can then be applied to each pixel to produce a result
+ * using the following set of equations:
+ *
+ * <pre>
+ *      <em>F<sub>s</sub></em> = <em>f</em>(<em>A<sub>d</sub></em>)
+ *      <em>F<sub>d</sub></em> = <em>f</em>(<em>A<sub>s</sub></em>)
+ *      <em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*<em>F<sub>s</sub></em> + <em>A<sub>d</sub></em>*<em>F<sub>d</sub></em>
+ *      <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*<em>F<sub>s</sub></em> + <em>C<sub>d</sub></em>*<em>F<sub>d</sub></em></pre>
+ *
+ * <p>
+ * The following factors will be used to discuss our extensions to
+ * the blending equation in the Porter and Duff paper:
+ *
+ * <blockquote>
+ * <table summary="layout">
+ * <tr><th align=left>Factor&nbsp;&nbsp;<th align=left>Definition
+ * <tr><td><em>C<sub>sr</sub></em> <td>one of the raw color components of the source pixel
+ * <tr><td><em>C<sub>dr</sub></em> <td>one of the raw color components of the destination pixel
+ * <tr><td><em>A<sub>ac</sub></em>  <td>the "extra" alpha component from the AlphaComposite instance
+ * <tr><td><em>A<sub>sr</sub></em> <td>the raw alpha component of the source pixel
+ * <tr><td><em>A<sub>dr</sub></em><td>the raw alpha component of the destination pixel
+ * <tr><td><em>A<sub>df</sub></em> <td>the final alpha component stored in the destination
+ * <tr><td><em>C<sub>df</sub></em> <td>the final raw color component stored in the destination
+ * </table>
+ *</blockquote>
+ *
+ * <h3>Preparing Inputs</h3>
+ *
+ * <p>
+ * The <code>AlphaComposite</code> class defines an additional alpha
+ * value that is applied to the source alpha.
+ * This value is applied as if an implicit SRC_IN rule were first
+ * applied to the source pixel against a pixel with the indicated
+ * alpha by multiplying both the raw source alpha and the raw
+ * source colors by the alpha in the <code>AlphaComposite</code>.
+ * This leads to the following equation for producing the alpha
+ * used in the Porter and Duff blending equation:
+ *
+ * <pre>
+ *      <em>A<sub>s</sub></em> = <em>A<sub>sr</sub></em> * <em>A<sub>ac</sub></em> </pre>
+ *
+ * All of the raw source color components need to be multiplied
+ * by the alpha in the <code>AlphaComposite</code> instance.
+ * Additionally, if the source was not in premultiplied form
+ * then the color components also need to be multiplied by the
+ * source alpha.
+ * Thus, the equation for producing the source color components
+ * for the Porter and Duff equation depends on whether the source
+ * pixels are premultiplied or not:
+ *
+ * <pre>
+ *      <em>C<sub>s</sub></em> = <em>C<sub>sr</sub></em> * <em>A<sub>sr</sub></em> * <em>A<sub>ac</sub></em>     (if source is not premultiplied)
+ *      <em>C<sub>s</sub></em> = <em>C<sub>sr</sub></em> * <em>A<sub>ac</sub></em>           (if source is premultiplied) </pre>
+ *
+ * No adjustment needs to be made to the destination alpha:
+ *
+ * <pre>
+ *      <em>A<sub>d</sub></em> = <em>A<sub>dr</sub></em> </pre>
+ *
+ * <p>
+ * The destination color components need to be adjusted only if
+ * they are not in premultiplied form:
+ *
+ * <pre>
+ *      <em>C<sub>d</sub></em> = <em>C<sub>dr</sub></em> * <em>A<sub>d</sub></em>    (if destination is not premultiplied)
+ *      <em>C<sub>d</sub></em> = <em>C<sub>dr</sub></em>         (if destination is premultiplied) </pre>
+ *
+ * <h3>Applying the Blending Equation</h3>
+ *
+ * <p>
+ * The adjusted <em>A<sub>s</sub></em>, <em>A<sub>d</sub></em>,
+ * <em>C<sub>s</sub></em>, and <em>C<sub>d</sub></em> are used in the standard
+ * Porter and Duff equations to calculate the blending factors
+ * <em>F<sub>s</sub></em> and <em>F<sub>d</sub></em> and then the resulting
+ * premultiplied components <em>A<sub>r</sub></em> and <em>C<sub>r</sub></em>.
+ *
+ * <p>
+ * <h3>Preparing Results</h3>
+ *
+ * <p>
+ * The results only need to be adjusted if they are to be stored
+ * back into a destination buffer that holds data that is not
+ * premultiplied, using the following equations:
+ *
+ * <pre>
+ *      <em>A<sub>df</sub></em> = <em>A<sub>r</sub></em>
+ *      <em>C<sub>df</sub></em> = <em>C<sub>r</sub></em>                 (if dest is premultiplied)
+ *      <em>C<sub>df</sub></em> = <em>C<sub>r</sub></em> / <em>A<sub>r</sub></em>            (if dest is not premultiplied) </pre>
+ *
+ * Note that since the division is undefined if the resulting alpha
+ * is zero, the division in that case is omitted to avoid the "divide
+ * by zero" and the color components are left as
+ * all zeros.
+ *
+ * <p>
+ * <h3>Performance Considerations</h3>
+ *
+ * <p>
+ * For performance reasons, it is preferrable that
+ * <code>Raster</code> objects passed to the <code>compose</code>
+ * method of a {@link CompositeContext} object created by the
+ * <code>AlphaComposite</code> class have premultiplied data.
+ * If either the source <code>Raster</code>
+ * or the destination <code>Raster</code>
+ * is not premultiplied, however,
+ * appropriate conversions are performed before and after the compositing
+ * operation.
+ *
+ * <h3><a name="caveats">Implementation Caveats</a></h3>
+ *
+ * <ul>
+ * <li>
+ * Many sources, such as some of the opaque image types listed
+ * in the <code>BufferedImage</code> class, do not store alpha values
+ * for their pixels.  Such sources supply an alpha of 1.0 for
+ * all of their pixels.
+ *
+ * <p>
+ * <li>
+ * Many destinations also have no place to store the alpha values
+ * that result from the blending calculations performed by this class.
+ * Such destinations thus implicitly discard the resulting
+ * alpha values that this class produces.
+ * It is recommended that such destinations should treat their stored
+ * color values as non-premultiplied and divide the resulting color
+ * values by the resulting alpha value before storing the color
+ * values and discarding the alpha value.
+ *
+ * <p>
+ * <li>
+ * The accuracy of the results depends on the manner in which pixels
+ * are stored in the destination.
+ * An image format that provides at least 8 bits of storage per color
+ * and alpha component is at least adequate for use as a destination
+ * for a sequence of a few to a dozen compositing operations.
+ * An image format with fewer than 8 bits of storage per component
+ * is of limited use for just one or two compositing operations
+ * before the rounding errors dominate the results.
+ * An image format
+ * that does not separately store
+ * color components is not a
+ * good candidate for any type of translucent blending.
+ * For example, <code>BufferedImage.TYPE_BYTE_INDEXED</code>
+ * should not be used as a destination for a blending operation
+ * because every operation
+ * can introduce large errors, due to
+ * the need to choose a pixel from a limited palette to match the
+ * results of the blending equations.
+ *
+ * <p>
+ * <li>
+ * Nearly all formats store pixels as discrete integers rather than
+ * the floating point values used in the reference equations above.
+ * The implementation can either scale the integer pixel
+ * values into floating point values in the range 0.0 to 1.0 or
+ * use slightly modified versions of the equations
+ * that operate entirely in the integer domain and yet produce
+ * analogous results to the reference equations.
+ *
+ * <p>
+ * Typically the integer values are related to the floating point
+ * values in such a way that the integer 0 is equated
+ * to the floating point value 0.0 and the integer
+ * 2^<em>n</em>-1 (where <em>n</em> is the number of bits
+ * in the representation) is equated to 1.0.
+ * For 8-bit representations, this means that 0x00
+ * represents 0.0 and 0xff represents
+ * 1.0.
+ *
+ * <p>
+ * <li>
+ * The internal implementation can approximate some of the equations
+ * and it can also eliminate some steps to avoid unnecessary operations.
+ * For example, consider a discrete integer image with non-premultiplied
+ * alpha values that uses 8 bits per component for storage.
+ * The stored values for a
+ * nearly transparent darkened red might be:
+ *
+ * <pre>
+ *    (A, R, G, B) = (0x01, 0xb0, 0x00, 0x00)</pre>
+ *
+ * <p>
+ * If integer math were being used and this value were being
+ * composited in
+ * <a href="#SRC"><code>SRC</code></a>
+ * mode with no extra alpha, then the math would
+ * indicate that the results were (in integer format):
+ *
+ * <pre>
+ *    (A, R, G, B) = (0x01, 0x01, 0x00, 0x00)</pre>
+ *
+ * <p>
+ * Note that the intermediate values, which are always in premultiplied
+ * form, would only allow the integer red component to be either 0x00
+ * or 0x01.  When we try to store this result back into a destination
+ * that is not premultiplied, dividing out the alpha will give us
+ * very few choices for the non-premultiplied red value.
+ * In this case an implementation that performs the math in integer
+ * space without shortcuts is likely to end up with the final pixel
+ * values of:
+ *
+ * <pre>
+ *    (A, R, G, B) = (0x01, 0xff, 0x00, 0x00)</pre>
+ *
+ * <p>
+ * (Note that 0x01 divided by 0x01 gives you 1.0, which is equivalent
+ * to the value 0xff in an 8-bit storage format.)
+ *
+ * <p>
+ * Alternately, an implementation that uses floating point math
+ * might produce more accurate results and end up returning to the
+ * original pixel value with little, if any, roundoff error.
+ * Or, an implementation using integer math might decide that since
+ * the equations boil down to a virtual NOP on the color values
+ * if performed in a floating point space, it can transfer the
+ * pixel untouched to the destination and avoid all the math entirely.
+ *
+ * <p>
+ * These implementations all attempt to honor the
+ * same equations, but use different tradeoffs of integer and
+ * floating point math and reduced or full equations.
+ * To account for such differences, it is probably best to
+ * expect only that the premultiplied form of the results to
+ * match between implementations and image formats.  In this
+ * case both answers, expressed in premultiplied form would
+ * equate to:
+ *
+ * <pre>
+ *    (A, R, G, B) = (0x01, 0x01, 0x00, 0x00)</pre>
+ *
+ * <p>
+ * and thus they would all match.
+ *
+ * <p>
+ * <li>
+ * Because of the technique of simplifying the equations for
+ * calculation efficiency, some implementations might perform
+ * differently when encountering result alpha values of 0.0
+ * on a non-premultiplied destination.
+ * Note that the simplification of removing the divide by alpha
+ * in the case of the SRC rule is technically not valid if the
+ * denominator (alpha) is 0.
+ * But, since the results should only be expected to be accurate
+ * when viewed in premultiplied form, a resulting alpha of 0
+ * essentially renders the resulting color components irrelevant
+ * and so exact behavior in this case should not be expected.
+ * </ul>
+ * @see Composite
+ * @see CompositeContext
+ */
+
+public final class AlphaComposite /*implements Composite*/ {
+    /**
+     * Both the color and the alpha of the destination are cleared
+     * (Porter-Duff Clear rule).
+     * Neither the source nor the destination is used as input.
+     *<p>
+     * <em>F<sub>s</sub></em> = 0 and <em>F<sub>d</sub></em> = 0, thus:
+     *<pre>
+     *  <em>A<sub>r</sub></em> = 0
+     *  <em>C<sub>r</sub></em> = 0
+     *</pre>
+     */
+    public static final int     CLEAR           = 1;
+
+    /**
+     * The source is copied to the destination
+     * (Porter-Duff Source rule).
+     * The destination is not used as input.
+     *<p>
+     * <em>F<sub>s</sub></em> = 1 and <em>F<sub>d</sub></em> = 0, thus:
+     *<pre>
+     *  <em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>
+     *  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>
+     *</pre>
+     */
+    public static final int     SRC             = 2;
+
+    /**
+     * The destination is left untouched
+     * (Porter-Duff Destination rule).
+     *<p>
+     * <em>F<sub>s</sub></em> = 0 and <em>F<sub>d</sub></em> = 1, thus:
+     *<pre>
+     *  <em>A<sub>r</sub></em> = <em>A<sub>d</sub></em>
+     *  <em>C<sub>r</sub></em> = <em>C<sub>d</sub></em>
+     *</pre>
+     * @since 1.4
+     */
+    public static final int     DST             = 9;
+    // Note that DST was added in 1.4 so it is numbered out of order...
+
+    /**
+     * The source is composited over the destination
+     * (Porter-Duff Source Over Destination rule).
+     *<p>
+     * <em>F<sub>s</sub></em> = 1 and <em>F<sub>d</sub></em> = (1-<em>A<sub>s</sub></em>), thus:
+     *<pre>
+     *  <em>A<sub>r</sub></em> = <em>A<sub>s</sub></em> + <em>A<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)
+     *  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em> + <em>C<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)
+     *</pre>
+     */
+    public static final int     SRC_OVER        = 3;
+
+    /**
+     * The destination is composited over the source and
+     * the result replaces the destination
+     * (Porter-Duff Destination Over Source rule).
+     *<p>
+     * <em>F<sub>s</sub></em> = (1-<em>A<sub>d</sub></em>) and <em>F<sub>d</sub></em> = 1, thus:
+     *<pre>
+     *  <em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>) + <em>A<sub>d</sub></em>
+     *  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>) + <em>C<sub>d</sub></em>
+     *</pre>
+     */
+    public static final int     DST_OVER        = 4;
+
+    /**
+     * The part of the source lying inside of the destination replaces
+     * the destination
+     * (Porter-Duff Source In Destination rule).
+     *<p>
+     * <em>F<sub>s</sub></em> = <em>A<sub>d</sub></em> and <em>F<sub>d</sub></em> = 0, thus:
+     *<pre>
+     *  <em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*<em>A<sub>d</sub></em>
+     *  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*<em>A<sub>d</sub></em>
+     *</pre>
+     */
+    public static final int     SRC_IN          = 5;
+
+    /**
+     * The part of the destination lying inside of the source
+     * replaces the destination
+     * (Porter-Duff Destination In Source rule).
+     *<p>
+     * <em>F<sub>s</sub></em> = 0 and <em>F<sub>d</sub></em> = <em>A<sub>s</sub></em>, thus:
+     *<pre>
+     *  <em>A<sub>r</sub></em> = <em>A<sub>d</sub></em>*<em>A<sub>s</sub></em>
+     *  <em>C<sub>r</sub></em> = <em>C<sub>d</sub></em>*<em>A<sub>s</sub></em>
+     *</pre>
+     */
+    public static final int     DST_IN          = 6;
+
+    /**
+     * The part of the source lying outside of the destination
+     * replaces the destination
+     * (Porter-Duff Source Held Out By Destination rule).
+     *<p>
+     * <em>F<sub>s</sub></em> = (1-<em>A<sub>d</sub></em>) and <em>F<sub>d</sub></em> = 0, thus:
+     *<pre>
+     *  <em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>)
+     *  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>)
+     *</pre>
+     */
+    public static final int     SRC_OUT         = 7;
+
+    /**
+     * The part of the destination lying outside of the source
+     * replaces the destination
+     * (Porter-Duff Destination Held Out By Source rule).
+     *<p>
+     * <em>F<sub>s</sub></em> = 0 and <em>F<sub>d</sub></em> = (1-<em>A<sub>s</sub></em>), thus:
+     *<pre>
+     *  <em>A<sub>r</sub></em> = <em>A<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)
+     *  <em>C<sub>r</sub></em> = <em>C<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)
+     *</pre>
+     */
+    public static final int     DST_OUT         = 8;
+
+    // Rule 9 is DST which is defined above where it fits into the
+    // list logically, rather than numerically
+    //
+    // public static final int  DST             = 9;
+
+    /**
+     * The part of the source lying inside of the destination
+     * is composited onto the destination
+     * (Porter-Duff Source Atop Destination rule).
+     *<p>
+     * <em>F<sub>s</sub></em> = <em>A<sub>d</sub></em> and <em>F<sub>d</sub></em> = (1-<em>A<sub>s</sub></em>), thus:
+     *<pre>
+     *  <em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*<em>A<sub>d</sub></em> + <em>A<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>) = <em>A<sub>d</sub></em>
+     *  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*<em>A<sub>d</sub></em> + <em>C<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)
+     *</pre>
+     * @since 1.4
+     */
+    public static final int     SRC_ATOP        = 10;
+
+    /**
+     * The part of the destination lying inside of the source
+     * is composited over the source and replaces the destination
+     * (Porter-Duff Destination Atop Source rule).
+     *<p>
+     * <em>F<sub>s</sub></em> = (1-<em>A<sub>d</sub></em>) and <em>F<sub>d</sub></em> = <em>A<sub>s</sub></em>, thus:
+     *<pre>
+     *  <em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>) + <em>A<sub>d</sub></em>*<em>A<sub>s</sub></em> = <em>A<sub>s</sub></em>
+     *  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>) + <em>C<sub>d</sub></em>*<em>A<sub>s</sub></em>
+     *</pre>
+     * @since 1.4
+     */
+    public static final int     DST_ATOP        = 11;
+
+    /**
+     * The part of the source that lies outside of the destination
+     * is combined with the part of the destination that lies outside
+     * of the source
+     * (Porter-Duff Source Xor Destination rule).
+     *<p>
+     * <em>F<sub>s</sub></em> = (1-<em>A<sub>d</sub></em>) and <em>F<sub>d</sub></em> = (1-<em>A<sub>s</sub></em>), thus:
+     *<pre>
+     *  <em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>) + <em>A<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)
+     *  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>) + <em>C<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)
+     *</pre>
+     * @since 1.4
+     */
+    public static final int     XOR             = 12;
+
+    /**
+     * <code>AlphaComposite</code> object that implements the opaque CLEAR rule
+     * with an alpha of 1.0f.
+     * @see #CLEAR
+     */
+    public static final AlphaComposite Clear    = new AlphaComposite(CLEAR);
+
+    /**
+     * <code>AlphaComposite</code> object that implements the opaque SRC rule
+     * with an alpha of 1.0f.
+     * @see #SRC
+     */
+    public static final AlphaComposite Src      = new AlphaComposite(SRC);
+
+    /**
+     * <code>AlphaComposite</code> object that implements the opaque DST rule
+     * with an alpha of 1.0f.
+     * @see #DST
+     * @since 1.4
+     */
+    public static final AlphaComposite Dst      = new AlphaComposite(DST);
+
+    /**
+     * <code>AlphaComposite</code> object that implements the opaque SRC_OVER rule
+     * with an alpha of 1.0f.
+     * @see #SRC_OVER
+     */
+    public static final AlphaComposite SrcOver  = new AlphaComposite(SRC_OVER);
+
+    /**
+     * <code>AlphaComposite</code> object that implements the opaque DST_OVER rule
+     * with an alpha of 1.0f.
+     * @see #DST_OVER
+     */
+    public static final AlphaComposite DstOver  = new AlphaComposite(DST_OVER);
+
+    /**
+     * <code>AlphaComposite</code> object that implements the opaque SRC_IN rule
+     * with an alpha of 1.0f.
+     * @see #SRC_IN
+     */
+    public static final AlphaComposite SrcIn    = new AlphaComposite(SRC_IN);
+
+    /**
+     * <code>AlphaComposite</code> object that implements the opaque DST_IN rule
+     * with an alpha of 1.0f.
+     * @see #DST_IN
+     */
+    public static final AlphaComposite DstIn    = new AlphaComposite(DST_IN);
+
+    /**
+     * <code>AlphaComposite</code> object that implements the opaque SRC_OUT rule
+     * with an alpha of 1.0f.
+     * @see #SRC_OUT
+     */
+    public static final AlphaComposite SrcOut   = new AlphaComposite(SRC_OUT);
+
+    /**
+     * <code>AlphaComposite</code> object that implements the opaque DST_OUT rule
+     * with an alpha of 1.0f.
+     * @see #DST_OUT
+     */
+    public static final AlphaComposite DstOut   = new AlphaComposite(DST_OUT);
+
+    /**
+     * <code>AlphaComposite</code> object that implements the opaque SRC_ATOP rule
+     * with an alpha of 1.0f.
+     * @see #SRC_ATOP
+     * @since 1.4
+     */
+    public static final AlphaComposite SrcAtop  = new AlphaComposite(SRC_ATOP);
+
+    /**
+     * <code>AlphaComposite</code> object that implements the opaque DST_ATOP rule
+     * with an alpha of 1.0f.
+     * @see #DST_ATOP
+     * @since 1.4
+     */
+    public static final AlphaComposite DstAtop  = new AlphaComposite(DST_ATOP);
+
+    /**
+     * <code>AlphaComposite</code> object that implements the opaque XOR rule
+     * with an alpha of 1.0f.
+     * @see #XOR
+     * @since 1.4
+     */
+    public static final AlphaComposite Xor      = new AlphaComposite(XOR);
+
+    private static final int MIN_RULE = CLEAR;
+    private static final int MAX_RULE = XOR;
+
+    float extraAlpha;
+    int rule;
+
+    private AlphaComposite(int rule) {
+        this(rule, 1.0f);
+    }
+
+    private AlphaComposite(int rule, float alpha) {
+        if (alpha < 0.0f || alpha > 1.0f) {
+            throw new IllegalArgumentException("alpha value out of range");
+        }
+        if (rule < MIN_RULE || rule > MAX_RULE) {
+            throw new IllegalArgumentException("unknown composite rule");
+        }
+        this.rule = rule;
+        this.extraAlpha = alpha;
+    }
+
+    /**
+     * Creates an <code>AlphaComposite</code> object with the specified rule.
+     * @param rule the compositing rule
+     * @throws IllegalArgumentException if <code>rule</code> is not one of
+     *         the following:  {@link #CLEAR}, {@link #SRC}, {@link #DST},
+     *         {@link #SRC_OVER}, {@link #DST_OVER}, {@link #SRC_IN},
+     *         {@link #DST_IN}, {@link #SRC_OUT}, {@link #DST_OUT},
+     *         {@link #SRC_ATOP}, {@link #DST_ATOP}, or {@link #XOR}
+     */
+    public static AlphaComposite getInstance(int rule) {
+        switch (rule) {
+        case CLEAR:
+            return Clear;
+        case SRC:
+            return Src;
+        case DST:
+            return Dst;
+        case SRC_OVER:
+            return SrcOver;
+        case DST_OVER:
+            return DstOver;
+        case SRC_IN:
+            return SrcIn;
+        case DST_IN:
+            return DstIn;
+        case SRC_OUT:
+            return SrcOut;
+        case DST_OUT:
+            return DstOut;
+        case SRC_ATOP:
+            return SrcAtop;
+        case DST_ATOP:
+            return DstAtop;
+        case XOR:
+            return Xor;
+        default:
+            throw new IllegalArgumentException("unknown composite rule");
+        }
+    }
+
+    /**
+     * Creates an <code>AlphaComposite</code> object with the specified rule and
+     * the constant alpha to multiply with the alpha of the source.
+     * The source is multiplied with the specified alpha before being composited
+     * with the destination.
+     * @param rule the compositing rule
+     * @param alpha the constant alpha to be multiplied with the alpha of
+     * the source. <code>alpha</code> must be a floating point number in the
+     * inclusive range [0.0,&nbsp;1.0].
+     * @throws IllegalArgumentException if
+     *         <code>alpha</code> is less than 0.0 or greater than 1.0, or if
+     *         <code>rule</code> is not one of
+     *         the following:  {@link #CLEAR}, {@link #SRC}, {@link #DST},
+     *         {@link #SRC_OVER}, {@link #DST_OVER}, {@link #SRC_IN},
+     *         {@link #DST_IN}, {@link #SRC_OUT}, {@link #DST_OUT},
+     *         {@link #SRC_ATOP}, {@link #DST_ATOP}, or {@link #XOR}
+     */
+    public static AlphaComposite getInstance(int rule, float alpha) {
+        if (alpha == 1.0f) {
+            return getInstance(rule);
+        }
+        return new AlphaComposite(rule, alpha);
+    }
+
+    /**
+     * Creates a context for the compositing operation.
+     * The context contains state that is used in performing
+     * the compositing operation.
+     * @param srcColorModel  the {@link ColorModel} of the source
+     * @param dstColorModel  the <code>ColorModel</code> of the destination
+     * @return the <code>CompositeContext</code> object to be used to perform
+     * compositing operations.
+     */
+/*    public CompositeContext createContext(ColorModel srcColorModel,
+                                          ColorModel dstColorModel,
+                                          RenderingHints hints) {
+        return new SunCompositeContext(this, srcColorModel, dstColorModel);
+    }
+*/
+    /**
+     * Returns the alpha value of this <code>AlphaComposite</code>.  If this
+     * <code>AlphaComposite</code> does not have an alpha value, 1.0 is returned.
+     * @return the alpha value of this <code>AlphaComposite</code>.
+     */
+    public float getAlpha() {
+        return extraAlpha;
+    }
+
+    /**
+     * Returns the compositing rule of this <code>AlphaComposite</code>.
+     * @return the compositing rule of this <code>AlphaComposite</code>.
+     */
+    public int getRule() {
+        return rule;
+    }
+
+    /**
+     * Returns a similar <code>AlphaComposite</code> object that uses
+     * the specified compositing rule.
+     * If this object already uses the specified compositing rule,
+     * this object is returned.
+     * @return an <code>AlphaComposite</code> object derived from
+     * this object that uses the specified compositing rule.
+     * @param rule the compositing rule
+     * @throws IllegalArgumentException if
+     *         <code>rule</code> is not one of
+     *         the following:  {@link #CLEAR}, {@link #SRC}, {@link #DST},
+     *         {@link #SRC_OVER}, {@link #DST_OVER}, {@link #SRC_IN},
+     *         {@link #DST_IN}, {@link #SRC_OUT}, {@link #DST_OUT},
+     *         {@link #SRC_ATOP}, {@link #DST_ATOP}, or {@link #XOR}
+     * @since 1.6
+     */
+    public AlphaComposite derive(int rule) {
+        return (this.rule == rule)
+            ? this
+            : getInstance(rule, this.extraAlpha);
+    }
+
+    /**
+     * Returns a similar <code>AlphaComposite</code> object that uses
+     * the specified alpha value.
+     * If this object already has the specified alpha value,
+     * this object is returned.
+     * @return an <code>AlphaComposite</code> object derived from
+     * this object that uses the specified alpha value.
+     * @param alpha the constant alpha to be multiplied with the alpha of
+     * the source. <code>alpha</code> must be a floating point number in the
+     * inclusive range [0.0,&nbsp;1.0].
+     * @throws IllegalArgumentException if
+     *         <code>alpha</code> is less than 0.0 or greater than 1.0
+     * @since 1.6
+     */
+    public AlphaComposite derive(float alpha) {
+        return (this.extraAlpha == alpha)
+            ? this
+            : getInstance(this.rule, alpha);
+    }
+
+    /**
+     * Returns the hashcode for this composite.
+     * @return      a hash code for this composite.
+     */
+    public int hashCode() {
+        return (Float.floatToIntBits(extraAlpha) * 31 + rule);
+    }
+
+    /**
+     * Determines whether the specified object is equal to this
+     * <code>AlphaComposite</code>.
+     * <p>
+     * The result is <code>true</code> if and only if
+     * the argument is not <code>null</code> and is an
+     * <code>AlphaComposite</code> object that has the same
+     * compositing rule and alpha value as this object.
+     *
+     * @param obj the <code>Object</code> to test for equality
+     * @return <code>true</code> if <code>obj</code> equals this
+     * <code>AlphaComposite</code>; <code>false</code> otherwise.
+     */
+    public boolean equals(Object obj) {
+        if (!(obj instanceof AlphaComposite)) {
+            return false;
+        }
+
+        AlphaComposite ac = (AlphaComposite) obj;
+
+        if (rule != ac.rule) {
+            return false;
+        }
+
+        if (extraAlpha != ac.extraAlpha) {
+            return false;
+        }
+
+        return true;
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Canvas.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Canvas.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Canvas.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Canvas.java	2010-05-18 17:13:40.000000000 -0400
@@ -0,0 +1,23 @@
+package java.awt;
+
+public class Canvas
+{
+public void setBounds(int x, int y, int width, int height)
+{
+this.x = x;
+this.y = y;
+this.width = width;
+this.height = height;
+}
+public int getX()
+{ return x; }
+public int getY()
+{ return y; }
+public int getHeight()
+{ return height; }
+public int getWidth()
+{ return width; }
+int x; int y; int width; int height;
+
+public java.awt.Dimension getSize() { return new java.awt.Dimension(width, height); }
+}
\ No newline at end of file
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/color/ColorSpace.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/color/ColorSpace.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/color/ColorSpace.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/color/ColorSpace.java	2010-05-18 17:15:36.000000000 -0400
@@ -0,0 +1,132 @@
+/*
+ * @(#)ColorSpace.java	1.8 06/10/10
+ *
+ * Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 only, as published by the Free Software Foundation. 
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License version 2 for more details (a copy is
+ * included at /legal/license.txt). 
+ * 
+ * You should have received a copy of the GNU General Public License
+ * version 2 along with this work; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA 
+ * 
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+ * Clara, CA 95054 or visit www.sun.com if you need additional
+ * information or have any questions. 
+ *
+ */
+
+package java.awt.color;
+
+public abstract class ColorSpace implements java.io.Serializable {
+    static final long serialVersionUID = -409452704308689724L;
+    private int type;
+    private int numComponents;
+    // Cache of singletons for the predefined color spaces.
+    private static ColorSpace sRGBspace;
+    /**
+     * Any of the family of RGB color spaces.
+     */
+    public static final int TYPE_RGB = 5;
+    /**
+     * The sRGB color space defined at
+     * <A href="http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html">
+     * http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html
+     * </A>.
+     */
+    public static final int CS_sRGB = 1000;
+    /**
+     * Constructs a ColorSpace object given a color space type
+     * and the number of components.
+     * @param type One of the <CODE>ColorSpace</CODE> type constants.
+     * @param numcomponents The number of components in the color space.
+     */
+    protected ColorSpace (int type, int numcomponents) {
+        this.type = type;
+        this.numComponents = numcomponents;
+    }
+
+    /**
+     * Returns a ColorSpace representing one of the specific
+     * predefined color spaces.
+     * @param colorspace a specific color space identified by one of
+     *        the predefined class constants (e.g. CS_sRGB, CS_LINEAR_RGB,
+     *        CS_CIEXYZ, CS_GRAY, or CS_PYCC)
+     * @return The requested <CODE>ColorSpace</CODE> object.
+     */
+    // NOTE: This method may be called by privileged threads.
+    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
+    public static ColorSpace getInstance(int colorspace) {
+        ColorSpace    theColorSpace;
+        switch (colorspace) {
+        case CS_sRGB:
+            if (sRGBspace == null) {
+                sRGBspace = new RGBColorSpace();
+            }
+            theColorSpace = sRGBspace;
+            break;
+
+        default:
+            throw new IllegalArgumentException ("Unknown color space");
+        }
+        return theColorSpace;
+    }
+
+    /**
+     * Returns the name of the component given the component index.
+     * @param idx The component index.
+     * @return The name of the component at the specified index.
+     */
+    public String getName(int idx) {
+        /* TODO - handle common cases here */
+        return new String("Unnamed color component(" + idx + ")");
+    }
+
+    /**
+     * Returns the number of components of this ColorSpace.
+     * @return The number of components in this <CODE>ColorSpace</CODE>.
+     */
+    public int getNumComponents() {
+        return numComponents;
+    }
+
+    /**
+     * Returns the color space type of this ColorSpace (for example
+     * TYPE_RGB, TYPE_XYZ, ...).  The type defines the
+     * number of components of the color space and the interpretation,
+     * e.g. TYPE_RGB identifies a color space with three components - red,
+     * green, and blue.  It does not define the particular color
+     * characteristics of the space, e.g. the chromaticities of the
+     * primaries.
+     * @return The type constant that represents the type of this
+     *         <CODE>ColorSpace</CODE>.
+     */
+    public int getType() {
+        return type;
+    }
+
+    /**
+     * Returns true if the ColorSpace is CS_sRGB.
+     * @return <CODE>true</CODE> if this is a <CODE>CS_sRGB</CODE> color
+     * space, <code>false</code> if it is not.
+     */
+    public boolean isCS_sRGB() {
+        /* NOTE - make sure we know sRGBspace exists already */
+        return (this == sRGBspace);
+    }
+}
+
+class RGBColorSpace extends ColorSpace {
+    public RGBColorSpace() {
+        super(TYPE_RGB, 3);
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Color.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Color.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Color.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Color.java	2010-05-18 17:14:06.000000000 -0400
@@ -0,0 +1,969 @@
+/*
+ * @(#)Color.java	1.51 06/10/10
+ *
+ * Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 only, as published by the Free Software Foundation. 
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License version 2 for more details (a copy is
+ * included at /legal/license.txt). 
+ * 
+ * You should have received a copy of the GNU General Public License
+ * version 2 along with this work; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA 
+ * 
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+ * Clara, CA 95054 or visit www.sun.com if you need additional
+ * information or have any questions. 
+ *
+ */
+package java.awt;
+
+import java.io.*;
+import java.lang.*;
+import java.awt.color.ColorSpace;
+
+/**
+ * This class encapsulates colors using the RGB format. In RGB
+ * format, the red, blue, and green components of a color are each
+ * represented by an integer in the range 0-255. The value 0
+ * indicates no contribution from this primary color. The value 255
+ * indicates the maximum intensity of this color component.
+ * <p>
+ * Although the <code>Color</code> class is based on the
+ * three-component RGB model, the class provides a set of convenience
+ * methods for converting between RGB and HSB colors. For a
+ * definition of the RGB and HSB color models, see Foley, van&nbsp;Dam,
+ * Feiner, and Hughes, <cite>Computer Graphics: Principles
+ * and Practice</cite>.
+ *
+ * @version 	1.46, 08/19/02
+ * @author 	Sami Shaio
+ * @author 	Arthur van Hoff
+ * @since       JDK1.0
+ */
+public class Color implements java.io.Serializable, Transparency {
+    /**
+     * The color white.
+     */
+    public final static Color white = new Color(255, 255, 255);
+    /**
+     * The color white.  In the default sRGB space.
+     */
+    public final static Color WHITE = white;
+    /**
+     * The color light gray.
+     */
+    public final static Color lightGray = new Color(192, 192, 192);
+
+    /**
+     * The color light gray.  In the default sRGB space.
+     */
+    public final static Color LIGHT_GRAY = lightGray;
+
+    /**
+     * The color gray.
+     */
+    public final static Color gray = new Color(128, 128, 128);
+
+    /**
+     * The color gray.  In the default sRGB space.
+     */
+    public final static Color GRAY = gray;
+
+    /**
+     * The color dark gray.
+     */
+    public final static Color darkGray = new Color(64, 64, 64);
+
+    /**
+     * The color dark gray.  In the default sRGB space.
+     */
+    public final static Color DARK_GRAY = darkGray;
+
+    /**
+     * The color black.
+     */
+    public final static Color black = new Color(0, 0, 0);
+
+    /**
+     * The color black.  In the default sRGB space.
+     */
+    public final static Color BLACK = black;
+
+    /**
+     * The color red.
+     */
+    public final static Color red = new Color(255, 0, 0);
+
+    /**
+     * The color red.  In the default sRGB space.
+     */
+    public final static Color RED = red;
+
+    /**
+     * The color pink.
+     */
+    public final static Color pink = new Color(255, 175, 175);
+
+    /**
+     * The color pink.  In the default sRGB space.
+     */
+    public final static Color PINK = pink;
+
+    /**
+     * The color orange.
+     */
+    public final static Color orange = new Color(255, 200, 0);
+
+    /**
+     * The color orange.  In the default sRGB space.
+     */
+    public final static Color ORANGE = orange;
+
+    /**
+     * The color yellow.
+     */
+    public final static Color yellow = new Color(255, 255, 0);
+
+    /**
+     * The color yellow.  In the default sRGB space.
+     */
+    public final static Color YELLOW = yellow;
+
+    /**
+     * The color green.
+     */
+    public final static Color green = new Color(0, 255, 0);
+
+    /**
+     * The color green.  In the default sRGB space.
+     */
+    public final static Color GREEN = green;
+
+    /**
+     * The color magenta.
+     */
+    public final static Color magenta = new Color(255, 0, 255);
+
+    /**
+     * The color magenta.  In the default sRGB space.
+     */
+    public final static Color MAGENTA = magenta;
+
+    /**
+     * The color cyan.
+     */
+    public final static Color cyan = new Color(0, 255, 255);
+
+    /**
+     * The color cyan.  In the default sRGB space.
+     */
+    public final static Color CYAN = cyan;
+
+    /**
+     * The color blue.
+     */
+    public final static Color blue = new Color(0, 0, 255);
+
+    /**
+     * The color blue.  In the default sRGB space.
+     */
+    public final static Color BLUE = blue;
+
+    /**
+     * Private data.
+     */
+    transient private int pData;
+    /**
+     * The color value.
+     */
+    int value;
+    /**
+     * The color value in the default sRGB <code>ColorSpace</code> as
+     * <code>float</code> components (no alpha).
+     * If <code>null</code> after object construction, this must be an
+     * sRGB color constructed with 8-bit precision, so compute from the
+     * <code>int</code> color value.
+     * @serial
+     * @see #getRGBColorComponents
+     * @see #getRGBComponents
+     */
+    private float frgbvalue[] = null;
+    /**
+     * The color value in the native <code>ColorSpace</code> as
+     * <code>float</code> components (no alpha).
+     * If <code>null</code> after object construction, this must be an
+     * sRGB color constructed with 8-bit precision, so compute from the
+     * <code>int</code> color value.
+     * @serial
+     * @see #getRGBColorComponents
+     * @see #getRGBComponents
+     */
+    private float fvalue[] = null;
+    /**
+     * The alpha value as a <code>float</code> component.
+     * If <code>frgbvalue</code> is <code>null</code>, this is not valid
+     * data, so compute from the <code>int</code> color value.
+     * @serial
+     * @see #getRGBComponents
+     * @see #getComponents
+     */
+    private float falpha = 0.0f;
+    /**
+     * The <code>ColorSpace</code>.  If <code>null</code>, then it's
+     * default is sRGB.
+     * @serial
+     * @see #getColor
+     * @see #getColorSpace
+     * @see #getColorComponents
+     */
+    private ColorSpace cs = null;
+    /*
+     * JDK 1.1 serialVersionUID
+     */
+    private static final long serialVersionUID = 118526816881161077L;
+    /**
+     * Checks the color integer components supplied for validity.
+     * Throws an IllegalArgumentException if the value is out of range.
+     * @param r the Red component
+     * @param g the Green component
+     * @param b the Blue component
+     **/
+    private static void testColorValueRange(int r, int g, int b, int a) {
+        boolean rangeError = false;
+        String badComponentString = "";
+        if (a < 0 || a > 255) {
+            rangeError = true;
+            badComponentString = badComponentString + " Alpha";
+        }
+        if (r < 0 || r > 255) {
+            rangeError = true;
+            badComponentString = badComponentString + " Red";
+        }
+        if (g < 0 || g > 255) {
+            rangeError = true;
+            badComponentString = badComponentString + " Green";
+        }
+        if (b < 0 || b > 255) {
+            rangeError = true;
+            badComponentString = badComponentString + " Blue";
+        }
+        if (rangeError == true) {
+            throw new IllegalArgumentException("Color parameter outside of expected range:"
+                    + badComponentString);
+        }
+    }
+
+    /**
+     * Checks the color float components supplied for validity.
+     * Throws an IllegalArgumentException if the value is out of range.
+     * @param r the Red component
+     * @param g the Green component
+     * @param b the Blue component
+     **/
+    private static void testColorValueRange(float r, float g, float b, float a) {
+        boolean rangeError = false;
+        String badComponentString = "";
+        if (a < 0 || a > 1.0) {
+            rangeError = true;
+            badComponentString = badComponentString + " Alpha";
+        }
+        if (r < 0.0 || r > 1.0) {
+            rangeError = true;
+            badComponentString = badComponentString + " Red";
+        }
+        if (g < 0.0 || g > 1.0) {
+            rangeError = true;
+            badComponentString = badComponentString + " Green";
+        }
+        if (b < 0.0 || b > 1.0) {
+            rangeError = true;
+            badComponentString = badComponentString + " Blue";
+        }
+        if (rangeError == true) {
+            throw new IllegalArgumentException("Color parameter outside of expected range:"
+                    + badComponentString);
+        }
+    }
+
+    /**
+     * Creates a color with the specified red, green, and blue
+     * components. The three arguments must each be in the range
+     * 0-255.
+     * <p>
+     * The actual color used in rendering depends on finding the best
+     * match given the color space available for a given output device.
+     * @param       r the red component.
+     * @param       g the green component.
+     * @param       b the blue component.
+     * @see         sage.awt.Color#getRed
+     * @see         sage.awt.Color#getGreen
+     * @see         sage.awt.Color#getBlue
+     * @see         sage.awt.Color#getRGB
+     * @since       JDK1.0
+     */
+    public Color(int r, int g, int b) {
+        this(((r & 0xFF) << 16) | ((g & 0xFF) << 8) | ((b & 0xFF) << 0));
+        testColorValueRange(r, g, b, 255);
+    }
+
+    /**
+     * Creates an sRGB color with the specified red, green, blue, and alpha
+     * values in the range (0 - 255).
+     * @param r the red component
+     * @param g the green component
+     * @param b the blue component
+     * @param a the alpha component
+     * @see #getRed
+     * @see #getGreen
+     * @see #getBlue
+     * @see #getAlpha
+     * @see #getRGB
+     */
+    public Color(int r, int g, int b, int a) {
+        value = ((a & 0xFF) << 24) |
+                ((r & 0xFF) << 16) |
+                ((g & 0xFF) << 8) |
+                ((b & 0xFF) << 0);
+        testColorValueRange(r, g, b, a);
+    }
+
+    /**
+     * Creates a color with the specified RGB value, where the red
+     * component is in bits 16-23 of the argument, the green
+     * component is in bits 8-15 of the argument, and the blue
+     * component is in bits 0-7. The value zero indicates no
+     * contribution from the primary color component.
+     * <p>
+     * The actual color used in rendering depends on finding the best
+     * match given the color space available for a given output device.
+     * @param       rgb   an integer giving the red, green, and blue components.
+     * @see         sage.awt.image.ColorModel#getRGBdefault
+     * @see         sage.awt.Color#getRed
+     * @see         sage.awt.Color#getGreen
+     * @see         sage.awt.Color#getBlue
+     * @see         sage.awt.Color#getRGB
+     * @since       JDK1.0
+     */
+    public Color(int rgb) {
+        value = 0xff000000 | rgb;
+    }
+
+    /**
+     * Creates an sRGB color with the specified combined RGBA value consisting
+     * of the alpha component in bits 24-31, the red component in bits 16-23,
+     * the green component in bits 8-15, and the blue component in bits 0-7.
+     * If the <code>hasalpha</code> argument is <code>false</code>, alpha
+     * is defaulted to 255.
+     * @param rgba the combined RGBA components
+     * @param hasalpha <code>true</code> if the alpha bits are valid;
+     * <code>false</code> otherwise
+     * @see sage.awt.image.ColorModel#getRGBdefault
+     * @see #getRed
+     * @see #getGreen
+     * @see #getBlue
+     * @see #getAlpha
+     * @see #getRGB
+     */
+    public Color(int rgba, boolean hasalpha) {
+        if (hasalpha) {
+            value = rgba;
+        } else {
+            value = 0xff000000 | rgba;
+        }
+    }
+
+    /**
+     * Creates a color with the specified red, green, and blue values,
+     * where each of the values is in the range 0.0-1.0. The value
+     * 0.0 indicates no contribution from the primary color component.
+     * The value 1.0 indicates the maximum intensity of the primary color
+     * component.
+     * <p>
+     * The actual color used in rendering depends on finding the best
+     * match given the color space available for a given output device.
+     * @param       r the red component
+     * @param       g the red component
+     * @param       b the red component
+     * @see         sage.awt.Color#getRed
+     * @see         sage.awt.Color#getGreen
+     * @see         sage.awt.Color#getBlue
+     * @see         sage.awt.Color#getRGB
+     * @since       JDK1.0
+     */
+    public Color(float r, float g, float b) {
+        this(r, g, b, 1.0f);
+    }
+
+    /**
+     * Creates an sRGB color with the specified red, green, blue, and
+     * alpha values in the range (0.0 - 1.0).  The actual color
+     * used in rendering depends on finding the best match given the
+     * color space available for a particular output device.
+     * @param r the red component
+     * @param g the green component
+     * @param b the blue component
+     * @param a the alpha component
+     * @see #getRed
+     * @see #getGreen
+     * @see #getBlue
+     * @see #getAlpha
+     * @see #getRGB
+     */
+    public Color(float r, float g, float b, float a) {
+        this((int) (r * 255 + 0.5), (int) (g * 255 + 0.5), (int) (b * 255 + 0.5), (int) (a * 255 + 0.5));
+        testColorValueRange(r, g, b, a);
+        frgbvalue = new float[3];
+        frgbvalue[0] = r;
+        frgbvalue[1] = g;
+        frgbvalue[2] = b;
+        falpha = a;
+        fvalue = frgbvalue;
+    }
+
+    /**
+     * Gets the red component of this color. The result is
+     * an integer in the range 0 to 255.
+     * @return        the red component of this color.
+     * @see           sage.awt.Color#getRGB
+     * @since         JDK1.0
+     */
+    public int getRed() {
+        return (getRGB() >> 16) & 0xFF;
+    }
+
+    /**
+     * Gets the green component of this color. The result is
+     * an integer in the range 0 to 255.
+     * @return        the green component of this color.
+     * @see           sage.awt.Color#getRGB
+     * @since         JDK1.0
+     */
+    public int getGreen() {
+        return (getRGB() >> 8) & 0xFF;
+    }
+
+    /**
+     * Gets the blue component of this color. The result is
+     * an integer in the range 0 to 255.
+     * @return        the blue component of this color.
+     * @see           sage.awt.Color#getRGB
+     * @since         JDK1.0
+     */
+    public int getBlue() {
+        return (getRGB() >> 0) & 0xFF;
+    }
+
+    /**
+     * Returns the alpha component in the range 0-255.
+     * @return the alpha component.
+     * @see #getRGB
+     */
+    public int getAlpha() {
+        return (getRGB() >> 24) & 0xff;
+    }
+
+    /**
+     * Gets the RGB value representing the color in the default RGB ColorModel.
+     * The red, green, and blue components of the color are each scaled to be
+     * a value between 0 (abscence of the color) and 255 (complete saturation).
+     * Bits 24-31 of the returned integer are 0xff, bits 16-23 are the red
+     * value, bit 8-15 are the green value, and bits 0-7 are the blue value.
+     * @see sage.awt.image.ColorModel#getRGBdefault
+     * @see #getRed
+     * @see #getGreen
+     * @see #getBlue
+     * @since JDK1.0
+     */
+    public int getRGB() {
+        return value;
+    }
+    private static final int FACTOR = 70;
+    /**
+     * Creates a brighter version of this color.
+     * <p>
+     * This method applies an arbitrary scale factor to each of the three RGB
+     * components of the color to create a brighter version of the same
+     * color. Although <code>brighter</code> and <code>darker</code> are
+     * inverse operations, the results of a series of invocations of
+     * these two methods may be inconsistent because of rounding errors.
+     * @return     a new <code>Color</code> object,
+     *                            a brighter version of this color.
+     * @see        sage.awt.Color#darker
+     * @since      JDK1.0
+     */
+    public Color brighter() {
+        int r = getRed();
+        int g = getGreen();
+        int b = getBlue();
+        /* From 2D group:
+         * 1. black.brighter() should return grey
+         * 2. applying brighter to blue will always return blue, brighter
+         * 3. non pure color (non zero rgb) will eventually return white
+         */
+        int i = (int) (100 / (100 - FACTOR));
+        if (r == 0 && g == 0 && b == 0) {
+            return new Color(i, i, i);
+        }
+        if (r > 0 && r < i) r = i;
+        if (g > 0 && g < i) g = i;
+        if (b > 0 && b < i) b = i;
+        return new Color(Math.min((r * 100) / FACTOR, 255),
+                Math.min((g * 100) / FACTOR, 255),
+                Math.min((b * 100) / FACTOR, 255));
+    }
+
+    /**
+     * Creates a darker version of this color.
+     * <p>
+     * This method applies an arbitrary scale factor to each of the three RGB
+     * components of the color to create a darker version of the same
+     * color. Although <code>brighter</code> and <code>darker</code> are
+     * inverse operations, the results of a series of invocations of
+     * these two methods may be inconsistent because of rounding errors.
+     * @return  a new <code>Color</code> object,
+     *                              a darker version of this color.
+     * @see        sage.awt.Color#brighter
+     * @since      JDK1.0
+     */
+    public Color darker() {
+        return new Color(Math.max((getRed() * FACTOR) / 100, 0),
+                Math.max((getGreen() * FACTOR) / 100, 0),
+                Math.max((getBlue() * FACTOR) / 100, 0));
+    }
+
+    /**
+     * Computes the hash code for this color.
+     * @return     a hash code value for this object.
+     * @since      JDK1.0
+     */
+    public int hashCode() {
+        return value;
+    }
+
+    /**
+     * Determines whether another object is equal to this color.
+     * <p>
+     * The result is <code>true</code> if and only if the argument is not
+     * <code>null</code> and is a <code>Color</code> object that has the same
+     * red, green, and blue values as this object.
+     * @param       obj   the object to compare with.
+     * @return      <code>true</code> if the objects are the same;
+     *                             <code>false</code> otherwise.
+     * @since   JDK1.0
+     */
+    public boolean equals(Object obj) {
+        return obj instanceof Color && ((Color) obj).value == this.value;
+    }
+
+    /**
+     * Creates a string that represents this color and indicates the
+     * values of its RGB components.
+     * @return     a representation of this color as a
+     *                           <code>String</code> object.
+     * @since      JDK1.0
+     */
+    public String toString() {
+        return getClass().getName() + "[r=" + getRed() + ",g=" + getGreen() + ",b=" + getBlue() + "]";
+    }
+
+    /**
+     * Converts a string to an integer and returns the
+     * specified color. This method handles string formats that
+     * are used to represent octal and hexidecimal numbers.
+     * @param      nm a string that represents
+     *                            a color as a 24-bit integer.
+     * @return     the new color
+     * @see        java.lang.Integer#decode
+     * @exception  NumberFormatException  if the specified string cannot
+     *                      be interpreted as a decimal,
+     *                      octal, or hexidecimal integer.
+     * @since      JDK1.1
+     */
+    public static Color decode(String nm) throws NumberFormatException {
+        Integer intval = Integer.decode(nm);
+        int i = intval.intValue();
+        return new Color((i >> 16) & 0xFF, (i >> 8) & 0xFF, i & 0xFF);
+    }
+
+    /**
+     * Finds a color in the system properties.
+     * <p>
+     * The argument is treated as the name of a system property to
+     * be obtained. The string value of this property is then interpreted
+     * as an integer which is then converted to a color.
+     * <p>
+     * If the specified property is not found, or could not be parsed as
+     * an integer, then <code>null</code> is returned.
+     * @param    nm the name of the color property
+     * @return   the color value of the property.
+     * @see      java.lang.System#getProperty(java.lang.String)
+     * @see      java.lang.Integer#getInteger(java.lang.String)
+     * @see      sage.awt.Color#Color(int)
+     * @since    JDK1.0
+     */
+    public static Color getColor(String nm) {
+        return getColor(nm, null);
+    }
+
+    /**
+     * Finds a color in the system properties.
+     * <p>
+     * The first argument is treated as the name of a system property to
+     * be obtained. The string value of this property is then interpreted
+     * as an integer which is then converted to a color.
+     * <p>
+     * If the specified property is not found, or cannot be parsed as
+     * an integer, then the color specified by the second argument is
+     * returned instead.
+     * @param    nm the name of the color property
+     * @param    v    the default color value.
+     * @return   the color value of the property.
+     * @see      java.lang.System#getProperty(java.lang.String)
+     * @see      java.lang.Integer#getInteger(java.lang.String)
+     * @see      sage.awt.Color#Color(int)
+     * @since    JDK1.0
+     */
+    public static Color getColor(String nm, Color v) {
+        Integer intval = Integer.getInteger(nm);
+        if (intval == null) {
+            return v;
+        }
+        int i = intval.intValue();
+        return new Color((i >> 16) & 0xFF, (i >> 8) & 0xFF, i & 0xFF);
+    }
+
+    /**
+     * Finds a color in the system properties.
+     * <p>
+     * The first argument is treated as the name of a system property to
+     * be obtained. The string value of this property is then interpreted
+     * as an integer which is then converted to a color.
+     * <p>
+     * If the specified property is not found, or could not be parsed as
+     * an integer, then the integer value <code>v</code> is used instead,
+     * and is converted to a color.
+     * @param    nm  the name of the color property.
+     * @param    v   the default color value, as an integer.
+     * @return   the color value of the property.
+     * @see      java.lang.System#getProperty(java.lang.String)
+     * @see      java.lang.Integer#getInteger(java.lang.String)
+     * @see      sage.awt.Color#Color(int)
+     * @since    JDK1.0
+     */
+    public static Color getColor(String nm, int v) {
+        Integer intval = Integer.getInteger(nm);
+        int i = (intval != null) ? intval.intValue() : v;
+        return new Color((i >> 16) & 0xFF, (i >> 8) & 0xFF, (i >> 0) & 0xFF);
+    }
+
+    /**
+     * Converts the components of a color, as specified by the HSB
+     * model, to an equivalent set of values for the RGB model.
+     * <p>
+     * The integer that is returned by <code>HSBtoRGB</code> encodes the
+     * value of a color in bits 0&endash;23 of an integer value, the same
+     * format used by the method <code>getRGB</code>. This integer can be
+     * supplied as an argument to the <code>Color</code> constructor that
+     * takes a single integer argument.
+     * @param     hue   the hue component of the color.
+     * @param     saturation   the saturation of the color.
+     * @param     brightness   the brightness of the color.
+     * @return    the RGB value of the color with the indicated hue,
+     *                            saturation, and brightness.
+     * @see       sage.awt.Color#getRGB()
+     * @see       sage.awt.Color#Color(int)
+     * @since     JDK1.0
+     */
+    public static int HSBtoRGB(float hue, float saturation, float brightness) {
+        int r = 0, g = 0, b = 0;
+        if (saturation == 0) {
+            r = g = b = (int) (brightness * 255);
+        } else {
+            double h = (hue - Math.floor(hue)) * 6.0;
+            double f = h - java.lang.Math.floor(h);
+            double p = brightness * (1.0 - saturation);
+            double q = brightness * (1.0 - saturation * f);
+            double t = brightness * (1.0 - (saturation * (1.0 - f)));
+            switch ((int) h) {
+            case 0:
+                r = (int) (brightness * 255);
+                g = (int) (t * 255);
+                b = (int) (p * 255);
+                break;
+
+            case 1:
+                r = (int) (q * 255);
+                g = (int) (brightness * 255);
+                b = (int) (p * 255);
+                break;
+
+            case 2:
+                r = (int) (p * 255);
+                g = (int) (brightness * 255);
+                b = (int) (t * 255);
+                break;
+
+            case 3:
+                r = (int) (p * 255);
+                g = (int) (q * 255);
+                b = (int) (brightness * 255);
+                break;
+
+            case 4:
+                r = (int) (t * 255);
+                g = (int) (p * 255);
+                b = (int) (brightness * 255);
+                break;
+
+            case 5:
+                r = (int) (brightness * 255);
+                g = (int) (p * 255);
+                b = (int) (q * 255);
+                break;
+            }
+        }
+        return 0xff000000 | (r << 16) | (g << 8) | (b << 0);
+    }
+
+    /**
+     * Converts the components of a color, as specified by the RGB
+     * model, to an equivalent set of values for hue, saturation, and
+     * brightness, the three components of the HSB model.
+     * <p>
+     * If the <code>hsbvals</code> argument is <code>null</code>, then a
+     * new array is allocated to return the result. Otherwise, the method
+     * returns the array <code>hsbvals</code>, with the values put into
+     * that array.
+     * @param     r   the red component of the color.
+     * @param     g   the green component of the color.
+     * @param     b   the blue component of the color.
+     * @param     hsbvals  the array to be used to return the
+     *                     three HSB values, or <code>null</code>.
+     * @return    an array of three elements containing the hue, saturation,
+     *                     and brightness (in that order), of the color with
+     *                     the indicated red, green, and blue components.
+     * @see       sage.awt.Color#getRGB()
+     * @see       sage.awt.Color#Color(int)
+     * @since     JDK1.0
+     */
+    public static float[] RGBtoHSB(int r, int g, int b, float[] hsbvals) {
+        float hue, saturation, brightness;
+        if (hsbvals == null) {
+            hsbvals = new float[3];
+        }
+        int cmax = (r > g) ? r : g;
+        if (b > cmax) cmax = b;
+        int cmin = (r < g) ? r : g;
+        if (b < cmin) cmin = b;
+        brightness = ((float) cmax) / 255.0f;
+        if (cmax != 0)
+            saturation = ((float) (cmax - cmin)) / ((float) cmax);
+        else
+            saturation = 0;
+        if (saturation == 0)
+            hue = 0;
+        else {
+            float redc = ((float) (cmax - r)) / ((float) (cmax - cmin));
+            float greenc = ((float) (cmax - g)) / ((float) (cmax - cmin));
+            float bluec = ((float) (cmax - b)) / ((float) (cmax - cmin));
+            if (r == cmax)
+                hue = bluec - greenc;
+            else if (g == cmax)
+                hue = 2.0f + redc - bluec;
+            else
+                hue = 4.0f + greenc - redc;
+            hue = hue / 6.0f;
+            if (hue < 0)
+                hue = hue + 1.0f;
+        }
+        hsbvals[0] = hue;
+        hsbvals[1] = saturation;
+        hsbvals[2] = brightness;
+        return hsbvals;
+    }
+
+    /**
+     * Creates a <code>Color</code> object based on values supplied
+     * for the HSB color model.
+     * <p>
+     * Each of the three components should be a floating-point
+     * value between zero and one (a number in the range
+     * <code>0.0</code>&nbsp;&le;&nbsp;<code>h</code>, <code>s</code>,
+     * <code>b</code>&nbsp;&le;&nbsp;<code>1.0). </code>
+     * @param  h   the hue component.
+     * @param  s   the saturation of the color.
+     * @param  b   the brightness of the color.
+     * @return  a <code>Color</code> object with the specified hue,
+     *                                 saturation, and brightness.
+     * @since   JDK1.0
+     */
+    public static Color getHSBColor(float h, float s, float b) {
+        return new Color(HSBtoRGB(h, s, b));
+    }
+
+    /**
+     * Returns a <code>float</code> array containing the color and alpha
+     * components of the <code>Color</code>, as represented in the default
+     * sRGB color space.
+     * If <code>compArray</code> is <code>null</code>, an array of length
+     * 4 is created for the return value.  Otherwise,
+     * <code>compArray</code> must have length 4 or greater,
+     * and it is filled in with the components and returned.
+     * @param compArray an array that this method fills with
+     *			color and alpha components and returns
+     * @return the RGBA components in a <code>float</code> array.
+     */
+    public float[] getRGBComponents(float[] compArray) {
+        float[] f;
+        if (compArray == null) {
+            f = new float[4];
+        } else {
+            f = compArray;
+        }
+        if (frgbvalue == null) {
+            f[0] = ((float) getRed()) / 255f;
+            f[1] = ((float) getGreen()) / 255f;
+            f[2] = ((float) getBlue()) / 255f;
+            f[3] = ((float) getAlpha()) / 255f;
+        } else {
+            f[0] = frgbvalue[0];
+            f[1] = frgbvalue[1];
+            f[2] = frgbvalue[2];
+            f[3] = falpha;
+        }
+        return f;
+    }
+
+    /**
+     * Returns a <code>float</code> array containing only the color
+     * components of the <code>Color</code>, in the default sRGB color
+     * space.  If <code>compArray</code> is <code>null</code>, an array of
+     * length 3 is created for the return value.  Otherwise,
+     * <code>compArray</code> must have length 3 or greater, and it is
+     * filled in with the components and returned.
+     * @param compArray an array that this method fills with color
+     *		components and returns
+     * @return the RGB components in a <code>float</code> array.
+     */
+    public float[] getRGBColorComponents(float[] compArray) {
+        float[] f;
+        if (compArray == null) {
+            f = new float[3];
+        } else {
+            f = compArray;
+        }
+        if (frgbvalue == null) {
+            f[0] = ((float) getRed()) / 255f;
+            f[1] = ((float) getGreen()) / 255f;
+            f[2] = ((float) getBlue()) / 255f;
+        } else {
+            f[0] = frgbvalue[0];
+            f[1] = frgbvalue[1];
+            f[2] = frgbvalue[2];
+        }
+        return f;
+    }
+
+    /**
+     * Returns a <code>float</code> array containing the color and alpha
+     * components of the <code>Color</code>, in the
+     * <code>ColorSpace</code> of the <code>Color</code>.
+     * If <code>compArray</code> is <code>null</code>, an array with
+     * length equal to the number of components in the associated
+     * <code>ColorSpace</code> plus one is created for
+     * the return value.  Otherwise, <code>compArray</code> must have at
+     * least this length and it is filled in with the components and
+     * returned.
+     * @param compArray an array that this method fills with the color and
+     *		alpha components of this <code>Color</code> in its
+     *		<code>ColorSpace</code> and returns
+     * @return the color and alpha components in a <code>float</code>
+     * 		array.
+     */
+    public float[] getComponents(float[] compArray) {
+        if (fvalue == null)
+            return getRGBComponents(compArray);
+        float[] f;
+        int n = fvalue.length;
+        if (compArray == null) {
+            f = new float[n + 1];
+        } else {
+            f = compArray;
+        }
+        for (int i = 0; i < n; i++) {
+            f[i] = fvalue[i];
+        }
+        f[n] = falpha;
+        return f;
+    }
+
+    /**
+     * Returns a <code>float</code> array containing only the color
+     * components of the <code>Color</code>, in the
+     * <code>ColorSpace</code> of the <code>Color</code>.
+     * If <code>compArray</code> is <code>null</code>, an array with
+     * length equal to the number of components in the associated
+     * <code>ColorSpace</code> is created for
+     * the return value.  Otherwise, <code>compArray</code> must have at
+     * least this length and it is filled in with the components and
+     * returned.
+     * @param compArray an array that this method fills with the color
+     *		components of this <code>Color</code> in its
+     *		<code>ColorSpace</code> and returns
+     * @return the color components in a <code>float</code> array.
+     */
+    public float[] getColorComponents(float[] compArray) {
+        if (fvalue == null)
+            return getRGBColorComponents(compArray);
+        float[] f;
+        int n = fvalue.length;
+        if (compArray == null) {
+            f = new float[n];
+        } else {
+            f = compArray;
+        }
+        for (int i = 0; i < n; i++) {
+            f[i] = fvalue[i];
+        }
+        return f;
+    }
+
+    /**
+     * Returns the transparency mode for this <code>Color</code>.  This is
+     * required to implement the <code>Paint</code> interface.
+     * @return this <code>Color</code> object's transparency mode.
+     * @see Paint
+     * @see Transparency
+     * @see #createContext
+     */
+    public int getTransparency() {
+        int alpha = getAlpha();
+        if (alpha == 0xff) {
+            return Transparency.OPAQUE;
+        } else if (alpha == 0) {
+            return Transparency.BITMASK;
+        } else {
+            return Transparency.TRANSLUCENT;
+        }
+    }
+
+    /**
+     * Returns the <code>ColorSpace</code> of this <code>Color</code>.
+     * @return this <code>Color</code> object's <code>ColorSpace</code>.
+     */
+    public ColorSpace getColorSpace() {
+        if (cs == null) {
+            cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);
+        }
+        return cs;
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Dimension.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Dimension.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Dimension.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Dimension.java	2010-05-18 16:50:12.000000000 -0400
@@ -0,0 +1,224 @@
+/*
+ * Copyright 1995-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt;
+
+import java.awt.geom.Dimension2D;
+
+/**
+ * The <code>Dimension</code> class encapsulates the width and
+ * height of a component (in integer precision) in a single object.
+ * The class is
+ * associated with certain properties of components. Several methods
+ * defined by the <code>Component</code> class and the
+ * <code>LayoutManager</code> interface return a
+ * <code>Dimension</code> object.
+ * <p>
+ * Normally the values of <code>width</code>
+ * and <code>height</code> are non-negative integers.
+ * The constructors that allow you to create a dimension do
+ * not prevent you from setting a negative value for these properties.
+ * If the value of <code>width</code> or <code>height</code> is
+ * negative, the behavior of some methods defined by other objects is
+ * undefined.
+ *
+ * @author      Sami Shaio
+ * @author      Arthur van Hoff
+ * @see         java.awt.Component
+ * @see         java.awt.LayoutManager
+ * @since       1.0
+ */
+public class Dimension extends Dimension2D implements java.io.Serializable {
+
+    /**
+     * The width dimension; negative values can be used.
+     *
+     * @serial
+     * @see #getSize
+     * @see #setSize
+     * @since 1.0
+     */
+    public int width;
+
+    /**
+     * The height dimension; negative values can be used.
+     *
+     * @serial
+     * @see #getSize
+     * @see #setSize
+     * @since 1.0
+     */
+    public int height;
+
+    /*
+     * JDK 1.1 serialVersionUID
+     */
+     private static final long serialVersionUID = 4723952579491349524L;
+
+    /**
+     * Creates an instance of <code>Dimension</code> with a width
+     * of zero and a height of zero.
+     */
+    public Dimension() {
+        this(0, 0);
+    }
+
+    /**
+     * Creates an instance of <code>Dimension</code> whose width
+     * and height are the same as for the specified dimension.
+     *
+     * @param    d   the specified dimension for the
+     *               <code>width</code> and
+     *               <code>height</code> values
+     */
+    public Dimension(Dimension d) {
+        this(d.width, d.height);
+    }
+
+    /**
+     * Constructs a <code>Dimension</code> and initializes
+     * it to the specified width and specified height.
+     *
+     * @param width the specified width
+     * @param height the specified height
+     */
+    public Dimension(int width, int height) {
+        this.width = width;
+        this.height = height;
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public double getWidth() {
+        return width;
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public double getHeight() {
+        return height;
+    }
+
+    /**
+     * Sets the size of this <code>Dimension</code> object to
+     * the specified width and height in double precision.
+     * Note that if <code>width</code> or <code>height</code>
+     * are larger than <code>Integer.MAX_VALUE</code>, they will
+     * be reset to <code>Integer.MAX_VALUE</code>.
+     *
+     * @param width  the new width for the <code>Dimension</code> object
+     * @param height the new height for the <code>Dimension</code> object
+     * @since 1.2
+     */
+    public void setSize(double width, double height) {
+        this.width = (int) Math.ceil(width);
+        this.height = (int) Math.ceil(height);
+    }
+
+    /**
+     * Gets the size of this <code>Dimension</code> object.
+     * This method is included for completeness, to parallel the
+     * <code>getSize</code> method defined by <code>Component</code>.
+     *
+     * @return   the size of this dimension, a new instance of
+     *           <code>Dimension</code> with the same width and height
+     * @see      java.awt.Dimension#setSize
+     * @see      java.awt.Component#getSize
+     * @since    1.1
+     */
+    public Dimension getSize() {
+        return new Dimension(width, height);
+    }
+
+    /**
+     * Sets the size of this <code>Dimension</code> object to the specified size.
+     * This method is included for completeness, to parallel the
+     * <code>setSize</code> method defined by <code>Component</code>.
+     * @param    d  the new size for this <code>Dimension</code> object
+     * @see      java.awt.Dimension#getSize
+     * @see      java.awt.Component#setSize
+     * @since    1.1
+     */
+    public void setSize(Dimension d) {
+        setSize(d.width, d.height);
+    }
+
+    /**
+     * Sets the size of this <code>Dimension</code> object
+     * to the specified width and height.
+     * This method is included for completeness, to parallel the
+     * <code>setSize</code> method defined by <code>Component</code>.
+     *
+     * @param    width   the new width for this <code>Dimension</code> object
+     * @param    height  the new height for this <code>Dimension</code> object
+     * @see      java.awt.Dimension#getSize
+     * @see      java.awt.Component#setSize
+     * @since    1.1
+     */
+    public void setSize(int width, int height) {
+        this.width = width;
+        this.height = height;
+    }
+
+    /**
+     * Checks whether two dimension objects have equal values.
+     */
+    public boolean equals(Object obj) {
+        if (obj instanceof Dimension) {
+            Dimension d = (Dimension)obj;
+            return (width == d.width) && (height == d.height);
+        }
+        return false;
+    }
+
+    /**
+     * Returns the hash code for this <code>Dimension</code>.
+     *
+     * @return    a hash code for this <code>Dimension</code>
+     */
+    public int hashCode() {
+        int sum = width + height;
+        return sum * (sum + 1)/2 + width;
+    }
+
+    /**
+     * Returns a string representation of the values of this
+     * <code>Dimension</code> object's <code>height</code> and
+     * <code>width</code> fields. This method is intended to be used only
+     * for debugging purposes, and the content and format of the returned
+     * string may vary between implementations. The returned string may be
+     * empty but may not be <code>null</code>.
+     *
+     * @return  a string representation of this <code>Dimension</code>
+     *          object
+     */
+    public String toString() {
+        return getClass().getName() + "[width=" + width + ",height=" + height + "]";
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/KeyEvent.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/KeyEvent.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/KeyEvent.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/KeyEvent.java	2009-12-30 21:28:22.000000000 -0500
@@ -0,0 +1,1130 @@
+/*
+ * Copyright 1996-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.event;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+
+/**
+ * An event which indicates that a keystroke occurred in a component.
+ * <p>
+ * This low-level event is generated by a component object (such as a text
+ * field) when a key is pressed, released, or typed.
+ * The event is passed to every <code>KeyListener</code>
+ * or <code>KeyAdapter</code> object which registered to receive such
+ * events using the component's <code>addKeyListener</code> method.
+ * (<code>KeyAdapter</code> objects implement the
+ * <code>KeyListener</code> interface.)  Each such listener object
+ * gets this <code>KeyEvent</code> when the event occurs.
+ * <p>
+ * <em>"Key typed" events</em> are higher-level and generally do not depend on
+ * the platform or keyboard layout.  They are generated when a Unicode character
+ * is entered, and are the preferred way to find out about character input.
+ * In the simplest case, a key typed event is produced by a single key press
+ * (e.g., 'a').  Often, however, characters are produced by series of key
+ * presses (e.g., 'shift' + 'a'), and the mapping from key pressed events to
+ * key typed events may be many-to-one or many-to-many.  Key releases are not
+ * usually necessary to generate a key typed event, but there are some cases
+ * where the key typed event is not generated until a key is released (e.g.,
+ * entering ASCII sequences via the Alt-Numpad method in Windows).
+ * No key typed events are generated for keys that don't generate Unicode
+ * characters (e.g., action keys, modifier keys, etc.).
+ * <p>
+ * The getKeyChar method always returns a valid Unicode character or
+ * CHAR_UNDEFINED.  Character input is reported by KEY_TYPED events:
+ * KEY_PRESSED and KEY_RELEASED events are not necessarily associated
+ * with character input.  Therefore, the result of the getKeyChar method
+ * is guaranteed to be meaningful only for KEY_TYPED events.
+ * <p>
+ * For key pressed and key released events, the getKeyCode method returns
+ * the event's keyCode.  For key typed events, the getKeyCode method
+ * always returns {@code VK_UNDEFINED}. The {@code getExtendedKeyCode} method
+ * may also be used with many international keyboard layouts.
+ *
+ * <p>
+ * <em>"Key pressed" and "key released" events</em> are lower-level and depend
+ * on the platform and keyboard layout. They are generated whenever a key is
+ * pressed or released, and are the only way to find out about keys that don't
+ * generate character input (e.g., action keys, modifier keys, etc.). The key
+ * being pressed or released is indicated by the {@code getKeyCode} and {@code getExtendedKeyCode}
+ * methods, which return a virtual key code.
+ *
+ * <p>
+ * <em>Virtual key codes</em> are used to report which keyboard key has
+ * been pressed, rather than a character generated by the combination
+ * of one or more keystrokes (such as "A", which comes from shift and "a").
+ *
+ * <p>
+ * For example, pressing the Shift key will cause a KEY_PRESSED event
+ * with a VK_SHIFT keyCode, while pressing the 'a' key will result in
+ * a VK_A keyCode.  After the 'a' key is released, a KEY_RELEASED event
+ * will be fired with VK_A. Separately, a KEY_TYPED event with a keyChar
+ * value of 'A' is generated.
+ *
+ * <p>
+ * Pressing and releasing a key on the keyboard results in the generating
+ * the following key events (in order):
+ * <PRE>
+ *    {@code KEY_PRESSED}
+ *    {@code KEY_TYPED} (is only generated if a valid Unicode character could be generated.)
+ *    {@code KEY_RELEASED}
+ * </PRE>
+ *
+ * But in some cases (e.g. auto-repeat or input method is activated) the order
+ * could be different (and platform dependent).
+ *
+ * <p>
+ * Notes:
+ * <ul>
+ * <li>Key combinations which do not result in Unicode characters, such as action
+ * keys like F1 and the HELP key, do not generate KEY_TYPED events.
+ * <li>Not all keyboards or systems are capable of generating all
+ * virtual key codes.  No attempt is made in Java to generate these keys
+ * artificially.
+ * <li>Virtual key codes do not identify a physical key: they depend on the
+ * platform and keyboard layout. For example, the key that generates VK_Q
+ * when using a U.S. keyboard layout will generate VK_A when using a French
+ * keyboard layout.
+ * <li>The key that generates {@code VK_Q} when using a U.S. keyboard layout also
+ * generates a unique code for Russian or Hebrew layout. There is no a
+ * {@code VK_} constant for these and many other codes in various layouts. These codes
+ * may be obtained by using {@code getExtendedKeyCode} and are used whenever
+ * a {@code VK_} constant is used.
+ * <li>Not all characters have a keycode associated with them.  For example,
+ * there is no keycode for the question mark because there is no keyboard
+ * for which it appears on the primary layer.
+ * <li>In order to support the platform-independent handling of action keys,
+ * the Java platform uses a few additional virtual key constants for functions
+ * that would otherwise have to be recognized by interpreting virtual key codes
+ * and modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES
+ * is returned instead of VK_CONVERT with the ALT modifier.
+ * <li>As specified in <a href="../doc-files/FocusSpec.html">Focus Specification</a>
+ * key events are dispatched to the focus owner by default.
+ * </ul>
+ *
+ * <p>
+ * WARNING: Aside from those keys that are defined by the Java language
+ * (VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_
+ * constants.  Sun reserves the right to change these values as needed
+ * to accomodate a wider range of keyboards in the future.
+ * <p>
+ * An unspecified behavior will be caused if the {@code id} parameter
+ * of any particular {@code KeyEvent} instance is not
+ * in the range from {@code KEY_FIRST} to {@code KEY_LAST}.
+ *
+ * @author Carl Quinn
+ * @author Amy Fowler
+ * @author Norbert Lindenberg
+ *
+ * @see KeyAdapter
+ * @see KeyListener
+ * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/keylistener.html">Tutorial: Writing a Key Listener</a>
+ *
+ * @since 1.1
+ */
+public class KeyEvent{
+
+    /**
+     * Stores the state of native event dispatching system
+     * - true, if when the event was created event proxying
+     *         mechanism was active
+     * - false, if it was inactive
+     * Used in Component.dispatchEventImpl to correctly dispatch
+     * events when proxy is active
+     */
+    private boolean isProxyActive = false;
+
+    /**
+     * The first number in the range of ids used for key events.
+     */
+    public static final int KEY_FIRST = 400;
+
+    /**
+     * The last number in the range of ids used for key events.
+     */
+    public static final int KEY_LAST  = 402;
+
+    /**
+     * The "key typed" event.  This event is generated when a character is
+     * entered.  In the simplest case, it is produced by a single key press.
+     * Often, however, characters are produced by series of key presses, and
+     * the mapping from key pressed events to key typed events may be
+     * many-to-one or many-to-many.
+     */
+    public static final int KEY_TYPED = KEY_FIRST;
+
+    /**
+     * The "key pressed" event. This event is generated when a key
+     * is pushed down.
+     */
+    public static final int KEY_PRESSED = 1 + KEY_FIRST; //Event.KEY_PRESS
+
+    /**
+     * The "key released" event. This event is generated when a key
+     * is let up.
+     */
+    public static final int KEY_RELEASED = 2 + KEY_FIRST; //Event.KEY_RELEASE
+
+    /* Virtual key codes. */
+
+    public static final int VK_ENTER          = '\n';
+    public static final int VK_BACK_SPACE     = '\b';
+    public static final int VK_TAB            = '\t';
+    public static final int VK_CANCEL         = 0x03;
+    public static final int VK_CLEAR          = 0x0C;
+    public static final int VK_SHIFT          = 0x10;
+    public static final int VK_CONTROL        = 0x11;
+    public static final int VK_ALT            = 0x12;
+    public static final int VK_PAUSE          = 0x13;
+    public static final int VK_CAPS_LOCK      = 0x14;
+    public static final int VK_ESCAPE         = 0x1B;
+    public static final int VK_SPACE          = 0x20;
+    public static final int VK_PAGE_UP        = 0x21;
+    public static final int VK_PAGE_DOWN      = 0x22;
+    public static final int VK_END            = 0x23;
+    public static final int VK_HOME           = 0x24;
+
+    /**
+     * Constant for the non-numpad <b>left</b> arrow key.
+     * @see #VK_KP_LEFT
+     */
+    public static final int VK_LEFT           = 0x25;
+
+    /**
+     * Constant for the non-numpad <b>up</b> arrow key.
+     * @see #VK_KP_UP
+     */
+    public static final int VK_UP             = 0x26;
+
+    /**
+     * Constant for the non-numpad <b>right</b> arrow key.
+     * @see #VK_KP_RIGHT
+     */
+    public static final int VK_RIGHT          = 0x27;
+
+    /**
+     * Constant for the non-numpad <b>down</b> arrow key.
+     * @see #VK_KP_DOWN
+     */
+    public static final int VK_DOWN           = 0x28;
+
+    /**
+     * Constant for the comma key, ","
+     */
+    public static final int VK_COMMA          = 0x2C;
+
+    /**
+     * Constant for the minus key, "-"
+     * @since 1.2
+     */
+    public static final int VK_MINUS          = 0x2D;
+
+    /**
+     * Constant for the period key, "."
+     */
+    public static final int VK_PERIOD         = 0x2E;
+
+    /**
+     * Constant for the forward slash key, "/"
+     */
+    public static final int VK_SLASH          = 0x2F;
+
+    /** VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
+    public static final int VK_0              = 0x30;
+    public static final int VK_1              = 0x31;
+    public static final int VK_2              = 0x32;
+    public static final int VK_3              = 0x33;
+    public static final int VK_4              = 0x34;
+    public static final int VK_5              = 0x35;
+    public static final int VK_6              = 0x36;
+    public static final int VK_7              = 0x37;
+    public static final int VK_8              = 0x38;
+    public static final int VK_9              = 0x39;
+
+    /**
+     * Constant for the semicolon key, ";"
+     */
+    public static final int VK_SEMICOLON      = 0x3B;
+
+    /**
+     * Constant for the equals key, "="
+     */
+    public static final int VK_EQUALS         = 0x3D;
+
+    /** VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */
+    public static final int VK_A              = 0x41;
+    public static final int VK_B              = 0x42;
+    public static final int VK_C              = 0x43;
+    public static final int VK_D              = 0x44;
+    public static final int VK_E              = 0x45;
+    public static final int VK_F              = 0x46;
+    public static final int VK_G              = 0x47;
+    public static final int VK_H              = 0x48;
+    public static final int VK_I              = 0x49;
+    public static final int VK_J              = 0x4A;
+    public static final int VK_K              = 0x4B;
+    public static final int VK_L              = 0x4C;
+    public static final int VK_M              = 0x4D;
+    public static final int VK_N              = 0x4E;
+    public static final int VK_O              = 0x4F;
+    public static final int VK_P              = 0x50;
+    public static final int VK_Q              = 0x51;
+    public static final int VK_R              = 0x52;
+    public static final int VK_S              = 0x53;
+    public static final int VK_T              = 0x54;
+    public static final int VK_U              = 0x55;
+    public static final int VK_V              = 0x56;
+    public static final int VK_W              = 0x57;
+    public static final int VK_X              = 0x58;
+    public static final int VK_Y              = 0x59;
+    public static final int VK_Z              = 0x5A;
+
+    /**
+     * Constant for the open bracket key, "["
+     */
+    public static final int VK_OPEN_BRACKET   = 0x5B;
+
+    /**
+     * Constant for the back slash key, "\"
+     */
+    public static final int VK_BACK_SLASH     = 0x5C;
+
+    /**
+     * Constant for the close bracket key, "]"
+     */
+    public static final int VK_CLOSE_BRACKET  = 0x5D;
+
+    public static final int VK_NUMPAD0        = 0x60;
+    public static final int VK_NUMPAD1        = 0x61;
+    public static final int VK_NUMPAD2        = 0x62;
+    public static final int VK_NUMPAD3        = 0x63;
+    public static final int VK_NUMPAD4        = 0x64;
+    public static final int VK_NUMPAD5        = 0x65;
+    public static final int VK_NUMPAD6        = 0x66;
+    public static final int VK_NUMPAD7        = 0x67;
+    public static final int VK_NUMPAD8        = 0x68;
+    public static final int VK_NUMPAD9        = 0x69;
+    public static final int VK_MULTIPLY       = 0x6A;
+    public static final int VK_ADD            = 0x6B;
+
+    /**
+     * This constant is obsolete, and is included only for backwards
+     * compatibility.
+     * @see #VK_SEPARATOR
+     */
+    public static final int VK_SEPARATER      = 0x6C;
+
+    /**
+     * Constant for the Numpad Separator key.
+     * @since 1.4
+     */
+    public static final int VK_SEPARATOR      = VK_SEPARATER;
+
+    public static final int VK_SUBTRACT       = 0x6D;
+    public static final int VK_DECIMAL        = 0x6E;
+    public static final int VK_DIVIDE         = 0x6F;
+    public static final int VK_DELETE         = 0x7F; /* ASCII DEL */
+    public static final int VK_NUM_LOCK       = 0x90;
+    public static final int VK_SCROLL_LOCK    = 0x91;
+
+    /** Constant for the F1 function key. */
+    public static final int VK_F1             = 0x70;
+
+    /** Constant for the F2 function key. */
+    public static final int VK_F2             = 0x71;
+
+    /** Constant for the F3 function key. */
+    public static final int VK_F3             = 0x72;
+
+    /** Constant for the F4 function key. */
+    public static final int VK_F4             = 0x73;
+
+    /** Constant for the F5 function key. */
+    public static final int VK_F5             = 0x74;
+
+    /** Constant for the F6 function key. */
+    public static final int VK_F6             = 0x75;
+
+    /** Constant for the F7 function key. */
+    public static final int VK_F7             = 0x76;
+
+    /** Constant for the F8 function key. */
+    public static final int VK_F8             = 0x77;
+
+    /** Constant for the F9 function key. */
+    public static final int VK_F9             = 0x78;
+
+    /** Constant for the F10 function key. */
+    public static final int VK_F10            = 0x79;
+
+    /** Constant for the F11 function key. */
+    public static final int VK_F11            = 0x7A;
+
+    /** Constant for the F12 function key. */
+    public static final int VK_F12            = 0x7B;
+
+    /**
+     * Constant for the F13 function key.
+     * @since 1.2
+     */
+    /* F13 - F24 are used on IBM 3270 keyboard; use random range for constants. */
+    public static final int VK_F13            = 0xF000;
+
+    /**
+     * Constant for the F14 function key.
+     * @since 1.2
+     */
+    public static final int VK_F14            = 0xF001;
+
+    /**
+     * Constant for the F15 function key.
+     * @since 1.2
+     */
+    public static final int VK_F15            = 0xF002;
+
+    /**
+     * Constant for the F16 function key.
+     * @since 1.2
+     */
+    public static final int VK_F16            = 0xF003;
+
+    /**
+     * Constant for the F17 function key.
+     * @since 1.2
+     */
+    public static final int VK_F17            = 0xF004;
+
+    /**
+     * Constant for the F18 function key.
+     * @since 1.2
+     */
+    public static final int VK_F18            = 0xF005;
+
+    /**
+     * Constant for the F19 function key.
+     * @since 1.2
+     */
+    public static final int VK_F19            = 0xF006;
+
+    /**
+     * Constant for the F20 function key.
+     * @since 1.2
+     */
+    public static final int VK_F20            = 0xF007;
+
+    /**
+     * Constant for the F21 function key.
+     * @since 1.2
+     */
+    public static final int VK_F21            = 0xF008;
+
+    /**
+     * Constant for the F22 function key.
+     * @since 1.2
+     */
+    public static final int VK_F22            = 0xF009;
+
+    /**
+     * Constant for the F23 function key.
+     * @since 1.2
+     */
+    public static final int VK_F23            = 0xF00A;
+
+    /**
+     * Constant for the F24 function key.
+     * @since 1.2
+     */
+    public static final int VK_F24            = 0xF00B;
+
+    public static final int VK_PRINTSCREEN    = 0x9A;
+    public static final int VK_INSERT         = 0x9B;
+    public static final int VK_HELP           = 0x9C;
+    public static final int VK_META           = 0x9D;
+
+    public static final int VK_BACK_QUOTE     = 0xC0;
+    public static final int VK_QUOTE          = 0xDE;
+
+    /**
+     * Constant for the numeric keypad <b>up</b> arrow key.
+     * @see #VK_UP
+     * @since 1.2
+     */
+    public static final int VK_KP_UP          = 0xE0;
+
+    /**
+     * Constant for the numeric keypad <b>down</b> arrow key.
+     * @see #VK_DOWN
+     * @since 1.2
+     */
+    public static final int VK_KP_DOWN        = 0xE1;
+
+    /**
+     * Constant for the numeric keypad <b>left</b> arrow key.
+     * @see #VK_LEFT
+     * @since 1.2
+     */
+    public static final int VK_KP_LEFT        = 0xE2;
+
+    /**
+     * Constant for the numeric keypad <b>right</b> arrow key.
+     * @see #VK_RIGHT
+     * @since 1.2
+     */
+    public static final int VK_KP_RIGHT       = 0xE3;
+
+    /* For European keyboards */
+    /** @since 1.2 */
+    public static final int VK_DEAD_GRAVE               = 0x80;
+    /** @since 1.2 */
+    public static final int VK_DEAD_ACUTE               = 0x81;
+    /** @since 1.2 */
+    public static final int VK_DEAD_CIRCUMFLEX          = 0x82;
+    /** @since 1.2 */
+    public static final int VK_DEAD_TILDE               = 0x83;
+    /** @since 1.2 */
+    public static final int VK_DEAD_MACRON              = 0x84;
+    /** @since 1.2 */
+    public static final int VK_DEAD_BREVE               = 0x85;
+    /** @since 1.2 */
+    public static final int VK_DEAD_ABOVEDOT            = 0x86;
+    /** @since 1.2 */
+    public static final int VK_DEAD_DIAERESIS           = 0x87;
+    /** @since 1.2 */
+    public static final int VK_DEAD_ABOVERING           = 0x88;
+    /** @since 1.2 */
+    public static final int VK_DEAD_DOUBLEACUTE         = 0x89;
+    /** @since 1.2 */
+    public static final int VK_DEAD_CARON               = 0x8a;
+    /** @since 1.2 */
+    public static final int VK_DEAD_CEDILLA             = 0x8b;
+    /** @since 1.2 */
+    public static final int VK_DEAD_OGONEK              = 0x8c;
+    /** @since 1.2 */
+    public static final int VK_DEAD_IOTA                = 0x8d;
+    /** @since 1.2 */
+    public static final int VK_DEAD_VOICED_SOUND        = 0x8e;
+    /** @since 1.2 */
+    public static final int VK_DEAD_SEMIVOICED_SOUND    = 0x8f;
+
+    /** @since 1.2 */
+    public static final int VK_AMPERSAND                = 0x96;
+    /** @since 1.2 */
+    public static final int VK_ASTERISK                 = 0x97;
+    /** @since 1.2 */
+    public static final int VK_QUOTEDBL                 = 0x98;
+    /** @since 1.2 */
+    public static final int VK_LESS                     = 0x99;
+
+    /** @since 1.2 */
+    public static final int VK_GREATER                  = 0xa0;
+    /** @since 1.2 */
+    public static final int VK_BRACELEFT                = 0xa1;
+    /** @since 1.2 */
+    public static final int VK_BRACERIGHT               = 0xa2;
+
+    /**
+     * Constant for the "@" key.
+     * @since 1.2
+     */
+    public static final int VK_AT                       = 0x0200;
+
+    /**
+     * Constant for the ":" key.
+     * @since 1.2
+     */
+    public static final int VK_COLON                    = 0x0201;
+
+    /**
+     * Constant for the "^" key.
+     * @since 1.2
+     */
+    public static final int VK_CIRCUMFLEX               = 0x0202;
+
+    /**
+     * Constant for the "$" key.
+     * @since 1.2
+     */
+    public static final int VK_DOLLAR                   = 0x0203;
+
+    /**
+     * Constant for the Euro currency sign key.
+     * @since 1.2
+     */
+    public static final int VK_EURO_SIGN                = 0x0204;
+
+    /**
+     * Constant for the "!" key.
+     * @since 1.2
+     */
+    public static final int VK_EXCLAMATION_MARK         = 0x0205;
+
+    /**
+     * Constant for the inverted exclamation mark key.
+     * @since 1.2
+     */
+    public static final int VK_INVERTED_EXCLAMATION_MARK = 0x0206;
+
+    /**
+     * Constant for the "(" key.
+     * @since 1.2
+     */
+    public static final int VK_LEFT_PARENTHESIS         = 0x0207;
+
+    /**
+     * Constant for the "#" key.
+     * @since 1.2
+     */
+    public static final int VK_NUMBER_SIGN              = 0x0208;
+
+    /**
+     * Constant for the "+" key.
+     * @since 1.2
+     */
+    public static final int VK_PLUS                     = 0x0209;
+
+    /**
+     * Constant for the ")" key.
+     * @since 1.2
+     */
+    public static final int VK_RIGHT_PARENTHESIS        = 0x020A;
+
+    /**
+     * Constant for the "_" key.
+     * @since 1.2
+     */
+    public static final int VK_UNDERSCORE               = 0x020B;
+
+    /**
+     * Constant for the Microsoft Windows "Windows" key.
+     * It is used for both the left and right version of the key.
+     * @see #getKeyLocation()
+     * @since 1.5
+     */
+    public static final int VK_WINDOWS                  = 0x020C;
+
+    /**
+     * Constant for the Microsoft Windows Context Menu key.
+     * @since 1.5
+     */
+    public static final int VK_CONTEXT_MENU             = 0x020D;
+
+    /* for input method support on Asian Keyboards */
+
+    /* not clear what this means - listed in Microsoft Windows API */
+    public static final int VK_FINAL                    = 0x0018;
+
+    /** Constant for the Convert function key. */
+    /* Japanese PC 106 keyboard, Japanese Solaris keyboard: henkan */
+    public static final int VK_CONVERT                  = 0x001C;
+
+    /** Constant for the Don't Convert function key. */
+    /* Japanese PC 106 keyboard: muhenkan */
+    public static final int VK_NONCONVERT               = 0x001D;
+
+    /** Constant for the Accept or Commit function key. */
+    /* Japanese Solaris keyboard: kakutei */
+    public static final int VK_ACCEPT                   = 0x001E;
+
+    /* not clear what this means - listed in Microsoft Windows API */
+    public static final int VK_MODECHANGE               = 0x001F;
+
+    /* replaced by VK_KANA_LOCK for Microsoft Windows and Solaris;
+       might still be used on other platforms */
+    public static final int VK_KANA                     = 0x0015;
+
+    /* replaced by VK_INPUT_METHOD_ON_OFF for Microsoft Windows and Solaris;
+       might still be used for other platforms */
+    public static final int VK_KANJI                    = 0x0019;
+
+    /**
+     * Constant for the Alphanumeric function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: eisuu */
+    public static final int VK_ALPHANUMERIC             = 0x00F0;
+
+    /**
+     * Constant for the Katakana function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: katakana */
+    public static final int VK_KATAKANA                 = 0x00F1;
+
+    /**
+     * Constant for the Hiragana function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: hiragana */
+    public static final int VK_HIRAGANA                 = 0x00F2;
+
+    /**
+     * Constant for the Full-Width Characters function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: zenkaku */
+    public static final int VK_FULL_WIDTH               = 0x00F3;
+
+    /**
+     * Constant for the Half-Width Characters function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: hankaku */
+    public static final int VK_HALF_WIDTH               = 0x00F4;
+
+    /**
+     * Constant for the Roman Characters function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: roumaji */
+    public static final int VK_ROMAN_CHARACTERS         = 0x00F5;
+
+    /**
+     * Constant for the All Candidates function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard - VK_CONVERT + ALT: zenkouho */
+    public static final int VK_ALL_CANDIDATES           = 0x0100;
+
+    /**
+     * Constant for the Previous Candidate function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard - VK_CONVERT + SHIFT: maekouho */
+    public static final int VK_PREVIOUS_CANDIDATE       = 0x0101;
+
+    /**
+     * Constant for the Code Input function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard - VK_ALPHANUMERIC + ALT: kanji bangou */
+    public static final int VK_CODE_INPUT               = 0x0102;
+
+    /**
+     * Constant for the Japanese-Katakana function key.
+     * This key switches to a Japanese input method and selects its Katakana input mode.
+     * @since 1.2
+     */
+    /* Japanese Macintosh keyboard - VK_JAPANESE_HIRAGANA + SHIFT */
+    public static final int VK_JAPANESE_KATAKANA        = 0x0103;
+
+    /**
+     * Constant for the Japanese-Hiragana function key.
+     * This key switches to a Japanese input method and selects its Hiragana input mode.
+     * @since 1.2
+     */
+    /* Japanese Macintosh keyboard */
+    public static final int VK_JAPANESE_HIRAGANA        = 0x0104;
+
+    /**
+     * Constant for the Japanese-Roman function key.
+     * This key switches to a Japanese input method and selects its Roman-Direct input mode.
+     * @since 1.2
+     */
+    /* Japanese Macintosh keyboard */
+    public static final int VK_JAPANESE_ROMAN           = 0x0105;
+
+    /**
+     * Constant for the locking Kana function key.
+     * This key locks the keyboard into a Kana layout.
+     * @since 1.3
+     */
+    /* Japanese PC 106 keyboard with special Windows driver - eisuu + Control; Japanese Solaris keyboard: kana */
+    public static final int VK_KANA_LOCK                = 0x0106;
+
+    /**
+     * Constant for the input method on/off key.
+     * @since 1.3
+     */
+    /* Japanese PC 106 keyboard: kanji. Japanese Solaris keyboard: nihongo */
+    public static final int VK_INPUT_METHOD_ON_OFF      = 0x0107;
+
+    /* for Sun keyboards */
+    /** @since 1.2 */
+    public static final int VK_CUT                      = 0xFFD1;
+    /** @since 1.2 */
+    public static final int VK_COPY                     = 0xFFCD;
+    /** @since 1.2 */
+    public static final int VK_PASTE                    = 0xFFCF;
+    /** @since 1.2 */
+    public static final int VK_UNDO                     = 0xFFCB;
+    /** @since 1.2 */
+    public static final int VK_AGAIN                    = 0xFFC9;
+    /** @since 1.2 */
+    public static final int VK_FIND                     = 0xFFD0;
+    /** @since 1.2 */
+    public static final int VK_PROPS                    = 0xFFCA;
+    /** @since 1.2 */
+    public static final int VK_STOP                     = 0xFFC8;
+
+    /**
+     * Constant for the Compose function key.
+     * @since 1.2
+     */
+    public static final int VK_COMPOSE                  = 0xFF20;
+
+    /**
+     * Constant for the AltGraph function key.
+     * @since 1.2
+     */
+    public static final int VK_ALT_GRAPH                = 0xFF7E;
+
+    /**
+     * Constant for the Begin key.
+     * @since 1.5
+     */
+    public static final int VK_BEGIN                    = 0xFF58;
+
+    /**
+     * This value is used to indicate that the keyCode is unknown.
+     * KEY_TYPED events do not have a keyCode value; this value
+     * is used instead.
+     */
+    public static final int VK_UNDEFINED      = 0x0;
+
+    /**
+     * KEY_PRESSED and KEY_RELEASED events which do not map to a
+     * valid Unicode character use this for the keyChar value.
+     */
+    public static final char CHAR_UNDEFINED   = 0xFFFF;
+
+    /**
+     * A constant indicating that the keyLocation is indeterminate
+     * or not relevant.
+     * <code>KEY_TYPED</code> events do not have a keyLocation; this value
+     * is used instead.
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_UNKNOWN  = 0;
+
+    /**
+     * A constant indicating that the key pressed or released
+     * is not distinguished as the left or right version of a key,
+     * and did not originate on the numeric keypad (or did not
+     * originate with a virtual key corresponding to the numeric
+     * keypad).
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_STANDARD = 1;
+
+    /**
+     * A constant indicating that the key pressed or released is in
+     * the left key location (there is more than one possible location
+     * for this key).  Example: the left shift key.
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_LEFT     = 2;
+
+    /**
+     * A constant indicating that the key pressed or released is in
+     * the right key location (there is more than one possible location
+     * for this key).  Example: the right shift key.
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_RIGHT    = 3;
+
+    /**
+     * A constant indicating that the key event originated on the
+     * numeric keypad or with a virtual key corresponding to the
+     * numeric keypad.
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_NUMPAD   = 4;
+
+    /**
+     * Returns a String describing the keyCode, such as "HOME", "F1" or "A".
+     * These strings can be localized by changing the awt.properties file.
+     *
+     * @return a string containing a text description for a physical key,
+     *         identified by its keyCode
+     */
+    public static String getKeyText(int keyCode) {
+        if (keyCode >= VK_0 && keyCode <= VK_9 ||
+            keyCode >= VK_A && keyCode <= VK_Z) {
+            return String.valueOf((char)keyCode);
+        }
+
+        switch(keyCode) {
+          case VK_ENTER: return getToolkitProperty("AWT.enter", "Enter");
+          case VK_BACK_SPACE: return getToolkitProperty("AWT.backSpace", "Backspace");
+          case VK_TAB: return getToolkitProperty("AWT.tab", "Tab");
+          case VK_CANCEL: return getToolkitProperty("AWT.cancel", "Cancel");
+          case VK_CLEAR: return getToolkitProperty("AWT.clear", "Clear");
+          case VK_COMPOSE: return getToolkitProperty("AWT.compose", "Compose");
+          case VK_PAUSE: return getToolkitProperty("AWT.pause", "Pause");
+          case VK_CAPS_LOCK: return getToolkitProperty("AWT.capsLock", "Caps Lock");
+          case VK_ESCAPE: return getToolkitProperty("AWT.escape", "Escape");
+          case VK_SPACE: return getToolkitProperty("AWT.space", "Space");
+          case VK_PAGE_UP: return getToolkitProperty("AWT.pgup", "Page Up");
+          case VK_PAGE_DOWN: return getToolkitProperty("AWT.pgdn", "Page Down");
+          case VK_END: return getToolkitProperty("AWT.end", "End");
+          case VK_HOME: return getToolkitProperty("AWT.home", "Home");
+          case VK_LEFT: return getToolkitProperty("AWT.left", "Left");
+          case VK_UP: return getToolkitProperty("AWT.up", "Up");
+          case VK_RIGHT: return getToolkitProperty("AWT.right", "Right");
+          case VK_DOWN: return getToolkitProperty("AWT.down", "Down");
+          case VK_BEGIN: return getToolkitProperty("AWT.begin", "Begin");
+
+          // modifiers
+          case VK_SHIFT: return getToolkitProperty("AWT.shift", "Shift");
+          case VK_CONTROL: return getToolkitProperty("AWT.control", "Control");
+          case VK_ALT: return getToolkitProperty("AWT.alt", "Alt");
+          case VK_META: return getToolkitProperty("AWT.meta", "Meta");
+          case VK_ALT_GRAPH: return getToolkitProperty("AWT.altGraph", "Alt Graph");
+
+          // punctuation
+          case VK_COMMA: return getToolkitProperty("AWT.comma", "Comma");
+          case VK_PERIOD: return getToolkitProperty("AWT.period", "Period");
+          case VK_SLASH: return getToolkitProperty("AWT.slash", "Slash");
+          case VK_SEMICOLON: return getToolkitProperty("AWT.semicolon", "Semicolon");
+          case VK_EQUALS: return getToolkitProperty("AWT.equals", "Equals");
+          case VK_OPEN_BRACKET: return getToolkitProperty("AWT.openBracket", "Open Bracket");
+          case VK_BACK_SLASH: return getToolkitProperty("AWT.backSlash", "Back Slash");
+          case VK_CLOSE_BRACKET: return getToolkitProperty("AWT.closeBracket", "Close Bracket");
+
+          // numpad numeric keys handled below
+          case VK_MULTIPLY: return getToolkitProperty("AWT.multiply", "NumPad *");
+          case VK_ADD: return getToolkitProperty("AWT.add", "NumPad +");
+          case VK_SEPARATOR: return getToolkitProperty("AWT.separator", "NumPad ,");
+          case VK_SUBTRACT: return getToolkitProperty("AWT.subtract", "NumPad -");
+          case VK_DECIMAL: return getToolkitProperty("AWT.decimal", "NumPad .");
+          case VK_DIVIDE: return getToolkitProperty("AWT.divide", "NumPad /");
+          case VK_DELETE: return getToolkitProperty("AWT.delete", "Delete");
+          case VK_NUM_LOCK: return getToolkitProperty("AWT.numLock", "Num Lock");
+          case VK_SCROLL_LOCK: return getToolkitProperty("AWT.scrollLock", "Scroll Lock");
+
+          case VK_WINDOWS: return getToolkitProperty("AWT.windows", "Windows");
+          case VK_CONTEXT_MENU: return getToolkitProperty("AWT.context", "Context Menu");
+
+          case VK_F1: return getToolkitProperty("AWT.f1", "F1");
+          case VK_F2: return getToolkitProperty("AWT.f2", "F2");
+          case VK_F3: return getToolkitProperty("AWT.f3", "F3");
+          case VK_F4: return getToolkitProperty("AWT.f4", "F4");
+          case VK_F5: return getToolkitProperty("AWT.f5", "F5");
+          case VK_F6: return getToolkitProperty("AWT.f6", "F6");
+          case VK_F7: return getToolkitProperty("AWT.f7", "F7");
+          case VK_F8: return getToolkitProperty("AWT.f8", "F8");
+          case VK_F9: return getToolkitProperty("AWT.f9", "F9");
+          case VK_F10: return getToolkitProperty("AWT.f10", "F10");
+          case VK_F11: return getToolkitProperty("AWT.f11", "F11");
+          case VK_F12: return getToolkitProperty("AWT.f12", "F12");
+          case VK_F13: return getToolkitProperty("AWT.f13", "F13");
+          case VK_F14: return getToolkitProperty("AWT.f14", "F14");
+          case VK_F15: return getToolkitProperty("AWT.f15", "F15");
+          case VK_F16: return getToolkitProperty("AWT.f16", "F16");
+          case VK_F17: return getToolkitProperty("AWT.f17", "F17");
+          case VK_F18: return getToolkitProperty("AWT.f18", "F18");
+          case VK_F19: return getToolkitProperty("AWT.f19", "F19");
+          case VK_F20: return getToolkitProperty("AWT.f20", "F20");
+          case VK_F21: return getToolkitProperty("AWT.f21", "F21");
+          case VK_F22: return getToolkitProperty("AWT.f22", "F22");
+          case VK_F23: return getToolkitProperty("AWT.f23", "F23");
+          case VK_F24: return getToolkitProperty("AWT.f24", "F24");
+
+          case VK_PRINTSCREEN: return getToolkitProperty("AWT.printScreen", "Print Screen");
+          case VK_INSERT: return getToolkitProperty("AWT.insert", "Insert");
+          case VK_HELP: return getToolkitProperty("AWT.help", "Help");
+          case VK_BACK_QUOTE: return getToolkitProperty("AWT.backQuote", "Back Quote");
+          case VK_QUOTE: return getToolkitProperty("AWT.quote", "Quote");
+
+          case VK_KP_UP: return getToolkitProperty("AWT.up", "Up");
+          case VK_KP_DOWN: return getToolkitProperty("AWT.down", "Down");
+          case VK_KP_LEFT: return getToolkitProperty("AWT.left", "Left");
+          case VK_KP_RIGHT: return getToolkitProperty("AWT.right", "Right");
+
+          case VK_DEAD_GRAVE: return getToolkitProperty("AWT.deadGrave", "Dead Grave");
+          case VK_DEAD_ACUTE: return getToolkitProperty("AWT.deadAcute", "Dead Acute");
+          case VK_DEAD_CIRCUMFLEX: return getToolkitProperty("AWT.deadCircumflex", "Dead Circumflex");
+          case VK_DEAD_TILDE: return getToolkitProperty("AWT.deadTilde", "Dead Tilde");
+          case VK_DEAD_MACRON: return getToolkitProperty("AWT.deadMacron", "Dead Macron");
+          case VK_DEAD_BREVE: return getToolkitProperty("AWT.deadBreve", "Dead Breve");
+          case VK_DEAD_ABOVEDOT: return getToolkitProperty("AWT.deadAboveDot", "Dead Above Dot");
+          case VK_DEAD_DIAERESIS: return getToolkitProperty("AWT.deadDiaeresis", "Dead Diaeresis");
+          case VK_DEAD_ABOVERING: return getToolkitProperty("AWT.deadAboveRing", "Dead Above Ring");
+          case VK_DEAD_DOUBLEACUTE: return getToolkitProperty("AWT.deadDoubleAcute", "Dead Double Acute");
+          case VK_DEAD_CARON: return getToolkitProperty("AWT.deadCaron", "Dead Caron");
+          case VK_DEAD_CEDILLA: return getToolkitProperty("AWT.deadCedilla", "Dead Cedilla");
+          case VK_DEAD_OGONEK: return getToolkitProperty("AWT.deadOgonek", "Dead Ogonek");
+          case VK_DEAD_IOTA: return getToolkitProperty("AWT.deadIota", "Dead Iota");
+          case VK_DEAD_VOICED_SOUND: return getToolkitProperty("AWT.deadVoicedSound", "Dead Voiced Sound");
+          case VK_DEAD_SEMIVOICED_SOUND: return getToolkitProperty("AWT.deadSemivoicedSound", "Dead Semivoiced Sound");
+
+          case VK_AMPERSAND: return getToolkitProperty("AWT.ampersand", "Ampersand");
+          case VK_ASTERISK: return getToolkitProperty("AWT.asterisk", "Asterisk");
+          case VK_QUOTEDBL: return getToolkitProperty("AWT.quoteDbl", "Double Quote");
+          case VK_LESS: return getToolkitProperty("AWT.Less", "Less");
+          case VK_GREATER: return getToolkitProperty("AWT.greater", "Greater");
+          case VK_BRACELEFT: return getToolkitProperty("AWT.braceLeft", "Left Brace");
+          case VK_BRACERIGHT: return getToolkitProperty("AWT.braceRight", "Right Brace");
+          case VK_AT: return getToolkitProperty("AWT.at", "At");
+          case VK_COLON: return getToolkitProperty("AWT.colon", "Colon");
+          case VK_CIRCUMFLEX: return getToolkitProperty("AWT.circumflex", "Circumflex");
+          case VK_DOLLAR: return getToolkitProperty("AWT.dollar", "Dollar");
+          case VK_EURO_SIGN: return getToolkitProperty("AWT.euro", "Euro");
+          case VK_EXCLAMATION_MARK: return getToolkitProperty("AWT.exclamationMark", "Exclamation Mark");
+          case VK_INVERTED_EXCLAMATION_MARK: return getToolkitProperty("AWT.invertedExclamationMark", "Inverted Exclamation Mark");
+          case VK_LEFT_PARENTHESIS: return getToolkitProperty("AWT.leftParenthesis", "Left Parenthesis");
+          case VK_NUMBER_SIGN: return getToolkitProperty("AWT.numberSign", "Number Sign");
+          case VK_MINUS: return getToolkitProperty("AWT.minus", "Minus");
+          case VK_PLUS: return getToolkitProperty("AWT.plus", "Plus");
+          case VK_RIGHT_PARENTHESIS: return getToolkitProperty("AWT.rightParenthesis", "Right Parenthesis");
+          case VK_UNDERSCORE: return getToolkitProperty("AWT.underscore", "Underscore");
+
+          case VK_FINAL: return getToolkitProperty("AWT.final", "Final");
+          case VK_CONVERT: return getToolkitProperty("AWT.convert", "Convert");
+          case VK_NONCONVERT: return getToolkitProperty("AWT.noconvert", "No Convert");
+          case VK_ACCEPT: return getToolkitProperty("AWT.accept", "Accept");
+          case VK_MODECHANGE: return getToolkitProperty("AWT.modechange", "Mode Change");
+          case VK_KANA: return getToolkitProperty("AWT.kana", "Kana");
+          case VK_KANJI: return getToolkitProperty("AWT.kanji", "Kanji");
+          case VK_ALPHANUMERIC: return getToolkitProperty("AWT.alphanumeric", "Alphanumeric");
+          case VK_KATAKANA: return getToolkitProperty("AWT.katakana", "Katakana");
+          case VK_HIRAGANA: return getToolkitProperty("AWT.hiragana", "Hiragana");
+          case VK_FULL_WIDTH: return getToolkitProperty("AWT.fullWidth", "Full-Width");
+          case VK_HALF_WIDTH: return getToolkitProperty("AWT.halfWidth", "Half-Width");
+          case VK_ROMAN_CHARACTERS: return getToolkitProperty("AWT.romanCharacters", "Roman Characters");
+          case VK_ALL_CANDIDATES: return getToolkitProperty("AWT.allCandidates", "All Candidates");
+          case VK_PREVIOUS_CANDIDATE: return getToolkitProperty("AWT.previousCandidate", "Previous Candidate");
+          case VK_CODE_INPUT: return getToolkitProperty("AWT.codeInput", "Code Input");
+          case VK_JAPANESE_KATAKANA: return getToolkitProperty("AWT.japaneseKatakana", "Japanese Katakana");
+          case VK_JAPANESE_HIRAGANA: return getToolkitProperty("AWT.japaneseHiragana", "Japanese Hiragana");
+          case VK_JAPANESE_ROMAN: return getToolkitProperty("AWT.japaneseRoman", "Japanese Roman");
+          case VK_KANA_LOCK: return getToolkitProperty("AWT.kanaLock", "Kana Lock");
+          case VK_INPUT_METHOD_ON_OFF: return getToolkitProperty("AWT.inputMethodOnOff", "Input Method On/Off");
+
+          case VK_AGAIN: return getToolkitProperty("AWT.again", "Again");
+          case VK_UNDO: return getToolkitProperty("AWT.undo", "Undo");
+          case VK_COPY: return getToolkitProperty("AWT.copy", "Copy");
+          case VK_PASTE: return getToolkitProperty("AWT.paste", "Paste");
+          case VK_CUT: return getToolkitProperty("AWT.cut", "Cut");
+          case VK_FIND: return getToolkitProperty("AWT.find", "Find");
+          case VK_PROPS: return getToolkitProperty("AWT.props", "Props");
+          case VK_STOP: return getToolkitProperty("AWT.stop", "Stop");
+        }
+
+        if (keyCode >= VK_NUMPAD0 && keyCode <= VK_NUMPAD9) {
+            String numpad = getToolkitProperty("AWT.numpad", "NumPad");
+            char c = (char)(keyCode - VK_NUMPAD0 + '0');
+            return numpad + "-" + c;
+        }
+
+        if ((keyCode & 0x01000000) != 0) {
+            return String.valueOf((char)(keyCode ^ 0x01000000 ));
+        }
+        String unknown = getToolkitProperty("AWT.unknown", "Unknown");
+        return unknown + " keyCode: 0x" + Integer.toString(keyCode, 16);
+    }
+
+    /**
+     * The AltGraph key modifier constant.
+     */
+    public static final int ALT_GRAPH_MASK = 1 << 5;
+
+    /**
+     * The Mouse Button1 modifier constant.
+     * It is recommended that BUTTON1_DOWN_MASK be used instead.
+     */
+    public static final int BUTTON1_MASK = 1 << 4;
+
+    /**
+     * This flag indicates that the Shift key was down when the event
+     * occurred.
+     */
+    public static final int SHIFT_MASK          = 1 << 0;
+
+    /**
+     * This flag indicates that the Control key was down when the event
+     * occurred.
+     */
+    public static final int CTRL_MASK           = 1 << 1;
+
+    /**
+     * This flag indicates that the Meta key was down when the event
+     * occurred. For mouse events, this flag indicates that the right
+     * button was pressed or released.
+     */
+    public static final int META_MASK           = 1 << 2;
+
+    /**
+     * This flag indicates that the Alt key was down when
+     * the event occurred. For mouse events, this flag indicates that the
+     * middle mouse button was pressed or released.
+     */
+    public static final int ALT_MASK            = 1 << 3;
+
+    /**
+     * Returns a <code>String</code> describing the modifier key(s),
+     * such as "Shift", or "Ctrl+Shift".  These strings can be
+     * localized by changing the <code>awt.properties</code> file.
+     * <p>
+     * Note that <code>InputEvent.ALT_MASK</code> and
+     * <code>InputEvent.BUTTON2_MASK</code> have the same value,
+     * so the string "Alt" is returned for both modifiers.  Likewise,
+     * <code>InputEvent.META_MASK</code> and
+     * <code>InputEvent.BUTTON3_MASK</code> have the same value,
+     * so the string "Meta" is returned for both modifiers.
+     *
+     * @return string a text description of the combination of modifier
+     *                keys that were held down during the event
+     * @see InputEvent#getModifiersExText(int)
+     */
+    public static String getKeyModifiersText(int modifiers) {
+        StringBuffer buf = new StringBuffer();
+        if ((modifiers & META_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.meta", "Meta"));
+            buf.append("+");
+        }
+        if ((modifiers & CTRL_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.control", "Ctrl"));
+            buf.append("+");
+        }
+        if ((modifiers & ALT_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.alt", "Alt"));
+            buf.append("+");
+        }
+        if ((modifiers & SHIFT_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.shift", "Shift"));
+            buf.append("+");
+        }
+        if ((modifiers & ALT_GRAPH_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.altGraph", "Alt Graph"));
+            buf.append("+");
+        }
+        if ((modifiers & BUTTON1_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.button1", "Button1"));
+            buf.append("+");
+        }
+        if (buf.length() > 0) {
+            buf.setLength(buf.length()-1); // remove trailing '+'
+        }
+        return buf.toString();
+    }
+
+
+	public static String getToolkitProperty(String name, String defValue)
+	{
+		return defValue;
+	}
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/MouseEvent.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/MouseEvent.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/MouseEvent.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/MouseEvent.java	2010-05-04 18:43:08.000000000 -0400
@@ -0,0 +1,1436 @@
+/*
+ * Copyright 1996-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.event;
+
+import java.awt.Point;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+
+/**
+ * An event which indicates that a mouse action occurred in a component.
+ * A mouse action is considered to occur in a particular component if and only
+ * if the mouse cursor is over the unobscured part of the component's bounds
+ * when the action happens.
+ * For lightweight components, such as Swing's components, mouse events
+ * are only dispatched to the component if the mouse event type has been
+ * enabled on the component. A mouse event type is enabled by adding the
+ * appropriate mouse-based {@code EventListener} to the component
+ * ({@link MouseListener} or {@link MouseMotionListener}), or by invoking
+ * {@link Component#enableEvents(long)} with the appropriate mask parameter
+ * ({@code AWTEvent.MOUSE_EVENT_MASK} or {@code AWTEvent.MOUSE_MOTION_EVENT_MASK}).
+ * If the mouse event type has not been enabled on the component, the
+ * corresponding mouse events are dispatched to the first ancestor that
+ * has enabled the mouse event type.
+ *<p>
+ * For example, if a {@code MouseListener} has been added to a component, or
+ * {@code enableEvents(AWTEvent.MOUSE_EVENT_MASK)} has been invoked, then all
+ * the events defined by {@code MouseListener} are dispatched to the component.
+ * On the other hand, if a {@code MouseMotionListener} has not been added and
+ * {@code enableEvents} has not been invoked with
+ * {@code AWTEvent.MOUSE_MOTION_EVENT_MASK}, then mouse motion events are not
+ * dispatched to the component. Instead the mouse motion events are
+ * dispatched to the first ancestors that has enabled mouse motion
+ * events.
+ * <P>
+ * This low-level event is generated by a component object for:
+ * <ul>
+ * <li>Mouse Events
+ *     <ul>
+ *     <li>a mouse button is pressed
+ *     <li>a mouse button is released
+ *     <li>a mouse button is clicked (pressed and released)
+ *     <li>the mouse cursor enters the unobscured part of component's geometry
+ *     <li>the mouse cursor exits the unobscured part of component's geometry
+ *     </ul>
+ * <li> Mouse Motion Events
+ *     <ul>
+ *     <li>the mouse is moved
+ *     <li>the mouse is dragged
+ *     </ul>
+ * </ul>
+ * <P>
+ * A <code>MouseEvent</code> object is passed to every
+ * <code>MouseListener</code>
+ * or <code>MouseAdapter</code> object which is registered to receive
+ * the "interesting" mouse events using the component's
+ * <code>addMouseListener</code> method.
+ * (<code>MouseAdapter</code> objects implement the
+ * <code>MouseListener</code> interface.) Each such listener object
+ * gets a <code>MouseEvent</code> containing the mouse event.
+ * <P>
+ * A <code>MouseEvent</code> object is also passed to every
+ * <code>MouseMotionListener</code> or
+ * <code>MouseMotionAdapter</code> object which is registered to receive
+ * mouse motion events using the component's
+ * <code>addMouseMotionListener</code>
+ * method. (<code>MouseMotionAdapter</code> objects implement the
+ * <code>MouseMotionListener</code> interface.) Each such listener object
+ * gets a <code>MouseEvent</code> containing the mouse motion event.
+ * <P>
+ * When a mouse button is clicked, events are generated and sent to the
+ * registered <code>MouseListener</code>s.
+ * The state of modal keys can be retrieved using {@link InputEvent#getModifiers}
+ * and {@link InputEvent#getModifiersEx}.
+ * The button mask returned by {@link InputEvent#getModifiers} reflects
+ * only the button that changed state, not the current state of all buttons.
+ * (Note: Due to overlap in the values of ALT_MASK/BUTTON2_MASK and
+ * META_MASK/BUTTON3_MASK, this is not always true for mouse events involving
+ * modifier keys).
+ * To get the state of all buttons and modifier keys, use
+ * {@link InputEvent#getModifiersEx}.
+ * The button which has changed state is returned by {@link MouseEvent#getButton}
+ * <P>
+ * For example, if the first mouse button is pressed, events are sent in the
+ * following order:
+ * <PRE>
+ *    <b   >id           </b   >   <b   >modifiers   </b   > <b   >button </b   >
+ *    <code>MOUSE_PRESSED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>
+ *    <code>MOUSE_RELEASED</code>: <code>BUTTON1_MASK</code> <code>BUTTON1</code>
+ *    <code>MOUSE_CLICKED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>
+ * </PRE>
+ * When multiple mouse buttons are pressed, each press, release, and click
+ * results in a separate event.
+ * <P>
+ * For example, if the user presses <b>button 1</b> followed by
+ * <b>button 2</b>, and then releases them in the same order,
+ * the following sequence of events is generated:
+ * <PRE>
+ *    <b   >id           </b   >   <b   >modifiers   </b   > <b   >button </b   >
+ *    <code>MOUSE_PRESSED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>
+ *    <code>MOUSE_PRESSED</code>:  <code>BUTTON2_MASK</code> <code>BUTTON2</code>
+ *    <code>MOUSE_RELEASED</code>: <code>BUTTON1_MASK</code> <code>BUTTON1</code>
+ *    <code>MOUSE_CLICKED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>
+ *    <code>MOUSE_RELEASED</code>: <code>BUTTON2_MASK</code> <code>BUTTON2</code>
+ *    <code>MOUSE_CLICKED</code>:  <code>BUTTON2_MASK</code> <code>BUTTON2</code>
+ * </PRE>
+ * If <b>button 2</b> is released first, the
+ * <code>MOUSE_RELEASED</code>/<code>MOUSE_CLICKED</code> pair
+ * for <code>BUTTON2_MASK</code> arrives first,
+ * followed by the pair for <code>BUTTON1_MASK</code>.
+ * <p>
+ * Some extra mouse buttons are added to extend the standard set of buttons
+ * represented by the following constants:{@code BUTTON1}, {@code BUTTON2}, and {@code BUTTON3}.
+ * Extra buttons have no assigned {@code BUTTONx}
+ * constants as well as their button masks have no assigned {@code BUTTONx_DOWN_MASK}
+ * constants. Nevertheless, ordinal numbers starting from 4 may be
+ * used as button numbers (button ids). Values obtained by the
+ * {@link InputEvent#getMaskForButton(int) getMaskForButton(button)} method may be used
+ * as button masks.
+ * <p>
+ * <code>MOUSE_DRAGGED</code> events are delivered to the <code>Component</code>
+ * in which the mouse button was pressed until the mouse button is released
+ * (regardless of whether the mouse position is within the bounds of the
+ * <code>Component</code>).  Due to platform-dependent Drag&Drop implementations,
+ * <code>MOUSE_DRAGGED</code> events may not be delivered during a native
+ * Drag&Drop operation.
+ *
+ * In a multi-screen environment mouse drag events are delivered to the
+ * <code>Component</code> even if the mouse position is outside the bounds of the
+ * <code>GraphicsConfiguration</code> associated with that
+ * <code>Component</code>. However, the reported position for mouse drag events
+ * in this case may differ from the actual mouse position:
+ * <ul>
+ * <li>In a multi-screen environment without a virtual device:
+ * <br>
+ * The reported coordinates for mouse drag events are clipped to fit within the
+ * bounds of the <code>GraphicsConfiguration</code> associated with
+ * the <code>Component</code>.
+ * <li>In a multi-screen environment with a virtual device:
+ * <br>
+ * The reported coordinates for mouse drag events are clipped to fit within the
+ * bounds of the virtual device associated with the <code>Component</code>.
+ * </ul>
+ * <p>
+ * An unspecified behavior will be caused if the {@code id} parameter
+ * of any particular {@code MouseEvent} instance is not
+ * in the range from {@code MOUSE_FIRST} to {@code MOUSE_LAST}-1
+ * ({@code MOUSE_WHEEL} is not acceptable).
+ *
+ * @author Carl Quinn
+ *
+ * @see MouseAdapter
+ * @see MouseListener
+ * @see MouseMotionAdapter
+ * @see MouseMotionListener
+ * @see MouseWheelListener
+ * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/mouselistener.html">Tutorial: Writing a Mouse Listener</a>
+ * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/mousemotionlistener.html">Tutorial: Writing a Mouse Motion Listener</a>
+ *
+ * @since 1.1
+ */
+public class MouseEvent extends java.util.EventObject {
+
+    /**
+     * The first number in the range of ids used for mouse events.
+     */
+    public static final int MOUSE_FIRST         = 500;
+
+    /**
+     * The last number in the range of ids used for mouse events.
+     */
+    public static final int MOUSE_LAST          = 507;
+
+    /**
+     * The "mouse clicked" event. This <code>MouseEvent</code>
+     * occurs when a mouse button is pressed and released.
+     */
+    public static final int MOUSE_CLICKED = MOUSE_FIRST;
+
+    /**
+     * The "mouse pressed" event. This <code>MouseEvent</code>
+     * occurs when a mouse button is pushed down.
+     */
+    public static final int MOUSE_PRESSED = 1 + MOUSE_FIRST; //Event.MOUSE_DOWN
+
+    /**
+     * The "mouse released" event. This <code>MouseEvent</code>
+     * occurs when a mouse button is let up.
+     */
+    public static final int MOUSE_RELEASED = 2 + MOUSE_FIRST; //Event.MOUSE_UP
+
+    /**
+     * The "mouse moved" event. This <code>MouseEvent</code>
+     * occurs when the mouse position changes.
+     */
+    public static final int MOUSE_MOVED = 3 + MOUSE_FIRST; //Event.MOUSE_MOVE
+
+    /**
+     * The "mouse entered" event. This <code>MouseEvent</code>
+     * occurs when the mouse cursor enters the unobscured part of component's
+     * geometry.
+     */
+    public static final int MOUSE_ENTERED = 4 + MOUSE_FIRST; //Event.MOUSE_ENTER
+
+    /**
+     * The "mouse exited" event. This <code>MouseEvent</code>
+     * occurs when the mouse cursor exits the unobscured part of component's
+     * geometry.
+     */
+    public static final int MOUSE_EXITED = 5 + MOUSE_FIRST; //Event.MOUSE_EXIT
+
+    /**
+     * The "mouse dragged" event. This <code>MouseEvent</code>
+     * occurs when the mouse position changes while a mouse button is pressed.
+     */
+    public static final int MOUSE_DRAGGED = 6 + MOUSE_FIRST; //Event.MOUSE_DRAG
+
+    /**
+     * The "mouse wheel" event.  This is the only <code>MouseWheelEvent</code>.
+     * It occurs when a mouse equipped with a wheel has its wheel rotated.
+     * @since 1.4
+     */
+    public static final int MOUSE_WHEEL = 7 + MOUSE_FIRST;
+
+    /**
+     * Indicates no mouse buttons; used by {@link #getButton}.
+     * @since 1.4
+     */
+    public static final int NOBUTTON = 0;
+
+    /**
+     * Indicates mouse button #1; used by {@link #getButton}.
+     * @since 1.4
+     */
+    public static final int BUTTON1 = 1;
+
+    /**
+     * Indicates mouse button #2; used by {@link #getButton}.
+     * @since 1.4
+     */
+    public static final int BUTTON2 = 2;
+
+    /**
+     * Indicates mouse button #3; used by {@link #getButton}.
+     * @since 1.4
+     */
+    public static final int BUTTON3 = 3;
+
+    /**
+     * This flag indicates that the Shift key was down when the event
+     * occurred.
+     */
+    public static final int SHIFT_MASK          = 1 << 0;
+
+    /**
+     * This flag indicates that the Control key was down when the event
+     * occurred.
+     */
+    public static final int CTRL_MASK           = 1 << 1;
+
+    /**
+     * This flag indicates that the Meta key was down when the event
+     * occurred. For mouse events, this flag indicates that the right
+     * button was pressed or released.
+     */
+    public static final int META_MASK           = 1 << 2;
+
+    /**
+     * This flag indicates that the Alt key was down when
+     * the event occurred. For mouse events, this flag indicates that the
+     * middle mouse button was pressed or released.
+     */
+    public static final int ALT_MASK            = 1 << 3;
+
+    /**
+     * The AltGraph key modifier constant.
+     */
+    public static final int ALT_GRAPH_MASK = 1 << 5;
+
+    /**
+     * The Mouse Button1 modifier constant.
+     * It is recommended that BUTTON1_DOWN_MASK be used instead.
+     */
+    public static final int BUTTON1_MASK = 1 << 4;
+
+    /**
+     * The Mouse Button2 modifier constant.
+     * It is recommended that BUTTON2_DOWN_MASK be used instead.
+     * Note that BUTTON2_MASK has the same value as ALT_MASK.
+     */
+    public static final int BUTTON2_MASK = ALT_MASK;
+
+    /**
+     * The Mouse Button3 modifier constant.
+     * It is recommended that BUTTON3_DOWN_MASK be used instead.
+     * Note that BUTTON3_MASK has the same value as META_MASK.
+     */
+    public static final int BUTTON3_MASK = META_MASK;
+
+    /**
+     * The Shift key extended modifier constant.
+     * @since 1.4
+     */
+    public static final int SHIFT_DOWN_MASK = 1 << 6;
+
+    /**
+     * The Control key extended modifier constant.
+     * @since 1.4
+     */
+    public static final int CTRL_DOWN_MASK = 1 << 7;
+
+    /**
+     * The Meta key extended modifier constant.
+     * @since 1.4
+     */
+    public static final int META_DOWN_MASK = 1 << 8;
+
+    /**
+     * The Alt key extended modifier constant.
+     * @since 1.4
+     */
+    public static final int ALT_DOWN_MASK = 1 << 9;
+
+    /**
+     * The Mouse Button1 extended modifier constant.
+     * @since 1.4
+     */
+    public static final int BUTTON1_DOWN_MASK = 1 << 10;
+
+    /**
+     * The Mouse Button2 extended modifier constant.
+     * @since 1.4
+     */
+    public static final int BUTTON2_DOWN_MASK = 1 << 11;
+
+    /**
+     * The Mouse Button3 extended modifier constant.
+     * @since 1.4
+     */
+    public static final int BUTTON3_DOWN_MASK = 1 << 12;
+
+    /**
+     * The AltGraph key extended modifier constant.
+     * @since 1.4
+     */
+    public static final int ALT_GRAPH_DOWN_MASK = 1 << 13;
+
+    // the constant below MUST be updated if any extra modifier
+    // bits are to be added!
+    // in fact, it is undesirable to add modifier bits
+    // to the same field as this may break applications
+    // see bug# 5066958
+    static final int FIRST_HIGH_BIT = 1 << 31;
+
+    static final int JDK_1_3_MODIFIERS = SHIFT_DOWN_MASK - 1;
+    static final int HIGH_MODIFIERS = ~( FIRST_HIGH_BIT - 1 );
+
+    /**
+     * An array of extended modifiers for additional buttons.
+     * @see getButtonDownMasks
+     * There are twenty buttons fit into 4byte space.
+     * one more bit is reserved for FIRST_HIGH_BIT.
+     * @since 7.0
+     */
+    private static final int [] BUTTON_DOWN_MASK = new int [] { BUTTON1_DOWN_MASK,
+                                                               BUTTON2_DOWN_MASK,
+                                                               BUTTON3_DOWN_MASK,
+                                                               1<<14, //4th phisical button (this is not a wheel!)
+                                                               1<<15, //(this is not a wheel!)
+                                                               1<<16,
+                                                               1<<17,
+                                                               1<<18,
+                                                               1<<19,
+                                                               1<<20,
+                                                               1<<21,
+                                                               1<<22,
+                                                               1<<23,
+                                                               1<<24,
+                                                               1<<25,
+                                                               1<<26,
+                                                               1<<27,
+                                                               1<<28,
+                                                               1<<29,
+                                                               1<<30};
+
+    /**
+     * The mouse event's x coordinate.
+     * The x value is relative to the component that fired the event.
+     *
+     * @serial
+     * @see #getX()
+     */
+    int x;
+
+    /**
+     * The mouse event's y coordinate.
+     * The y value is relative to the component that fired the event.
+     *
+     * @serial
+     * @see #getY()
+     */
+    int y;
+
+    /**
+     * The mouse event's x absolute coordinate.
+     * In a virtual device multi-screen environment in which the
+     * desktop area could span multiple physical screen devices,
+     * this coordinate is relative to the virtual coordinate system.
+     * Otherwise, this coordinate is relative to the coordinate system
+     * associated with the Component's GraphicsConfiguration.
+     *
+     * @serial
+   */
+    private int xAbs;
+
+    /**
+     * The mouse event's y absolute coordinate.
+     * In a virtual device multi-screen environment in which the
+     * desktop area could span multiple physical screen devices,
+     * this coordinate is relative to the virtual coordinate system.
+     * Otherwise, this coordinate is relative to the coordinate system
+     * associated with the Component's GraphicsConfiguration.
+     *
+     * @serial
+     */
+    private int yAbs;
+
+    /**
+     * Indicates the number of quick consecutive clicks of
+     * a mouse button.
+     * clickCount will be valid for only three mouse events :<BR>
+     * <code>MOUSE_CLICKED</code>,
+     * <code>MOUSE_PRESSED</code> and
+     * <code>MOUSE_RELEASED</code>.
+     * For the above, the <code>clickCount</code> will be at least 1.
+     * For all other events the count will be 0.
+     *
+     * @serial
+     * @see #getClickCount().
+     */
+    int clickCount;
+
+    /**
+     * Indicates which, if any, of the mouse buttons has changed state.
+     *
+     * The valid values are ranged from 0 to the value returned by the
+     * {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()} method.
+     * This range already includes constants {@code NOBUTTON}, {@code BUTTON1},
+     * {@code BUTTON2}, and {@code BUTTON3}
+     * if these buttons are present. So it is allowed to use these constants too.
+     * For example, for a mouse with two buttons this field may contain the following values:
+     * <ul>
+     * <li> 0 ({@code NOBUTTON})
+     * <li> 1 ({@code BUTTON1})
+     * <li> 2 ({@code BUTTON2})
+     * </ul>
+     * If a mouse has 5 buttons, this field may contain the following values:
+     * <ul>
+     * <li> 0 ({@code NOBUTTON})
+     * <li> 1 ({@code BUTTON1})
+     * <li> 2 ({@code BUTTON2})
+     * <li> 3 ({@code BUTTON3})
+     * <li> 4
+     * <li> 5
+     * </ul>
+     * If support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled()} disabled by Java
+     * then the field may not contain the value larger than {@code BUTTON3}.
+     * @serial
+     * @see #getButton()
+     * @see java.awt.Toolkit#areExtraMouseButtonsEnabled()
+     */
+    int button;
+
+    /**
+     * A property used to indicate whether a Popup Menu
+     * should appear  with a certain gestures.
+     * If <code>popupTrigger</code> = <code>false</code>,
+     * no popup menu should appear.  If it is <code>true</code>
+     * then a popup menu should appear.
+     *
+     * @serial
+     * @see java.awt.PopupMenu
+     * @see #isPopupTrigger()
+     */
+    boolean popupTrigger = false;
+
+    /**
+     * The input event's Time stamp in UTC format.  The time stamp
+     * indicates when the input event was created.
+     *
+     * @serial
+     * @see #getWhen()
+     */
+    long when;
+
+    /**
+     * The state of the modifier mask at the time the input
+     * event was fired.
+     *
+     * @serial
+     * @see #getModifiers()
+     * @see #getModifiersEx()
+     * @see java.awt.event.KeyEvent
+     * @see java.awt.event.MouseEvent
+     */
+    int modifiers;
+
+    /**
+     * The event's id.
+     * @serial
+     * @see #getID()
+     * @see #AWTEvent
+     */
+    protected int id;
+
+    /**
+     * Controls whether or not the event is sent back down to the peer once the
+     * source has processed it - false means it's sent to the peer; true means
+     * it's not. Semantic events always have a 'true' value since they were
+     * generated by the peer in response to a low-level event.
+     * @serial
+     * @see #consume
+     * @see #isConsumed
+     */
+    protected boolean consumed = false;
+
+    /*
+     * JDK 1.1 serialVersionUID
+     */
+    private static final long serialVersionUID = -991214153494842848L;
+
+    /**
+     * A number of buttons available on the mouse at the {@code Toolkit} machinery startup.
+     */
+    private static int cachedNumberOfButtons;
+
+    /**
+     * Returns the absolute x, y position of the event.
+     * In a virtual device multi-screen environment in which the
+     * desktop area could span multiple physical screen devices,
+     * these coordinates are relative to the virtual coordinate system.
+     * Otherwise, these coordinates are relative to the coordinate system
+     * associated with the Component's GraphicsConfiguration.
+     *
+     * @return a <code>Point</code> object containing the absolute  x
+     *  and y coordinates.
+     *
+     * @see java.awt.GraphicsConfiguration
+     * @since 1.6
+     */
+    public Point getLocationOnScreen(){
+      return new Point(xAbs, yAbs);
+    }
+
+    /**
+     * Returns the event type.
+     */
+    public int getID() {
+        return id;
+    }
+
+    /**
+     * Consumes this event so that it will not be processed
+     * in the default manner by the source which originated it.
+     */
+    public void consume() {
+        consumed = true;
+    }
+
+    /**
+     * Returns whether or not this event has been consumed.
+     * @see #consume
+     */
+    public boolean isConsumed() {
+        return consumed;
+    }
+
+    /**
+     * Returns the absolute horizontal x position of the event.
+     * In a virtual device multi-screen environment in which the
+     * desktop area could span multiple physical screen devices,
+     * this coordinate is relative to the virtual coordinate system.
+     * Otherwise, this coordinate is relative to the coordinate system
+     * associated with the Component's GraphicsConfiguration.
+     *
+     * @return x  an integer indicating absolute horizontal position.
+     *
+     * @see java.awt.GraphicsConfiguration
+     * @since 1.6
+     */
+    public int getXOnScreen() {
+        return xAbs;
+    }
+
+    /**
+     * Returns the difference in milliseconds between the timestamp of when this event occurred and
+     * midnight, January 1, 1970 UTC.
+     */
+    public long getWhen() {
+        return when;
+    }
+
+    /**
+     * Returns the modifier mask for this event.
+     */
+    public int getModifiers() {
+        return modifiers & (JDK_1_3_MODIFIERS | HIGH_MODIFIERS);
+    }
+
+    /**
+     * Returns the absolute vertical y position of the event.
+     * In a virtual device multi-screen environment in which the
+     * desktop area could span multiple physical screen devices,
+     * this coordinate is relative to the virtual coordinate system.
+     * Otherwise, this coordinate is relative to the coordinate system
+     * associated with the Component's GraphicsConfiguration.
+     *
+     * @return y  an integer indicating absolute vertical position.
+     *
+     * @see java.awt.GraphicsConfiguration
+     * @since 1.6
+     */
+    public int getYOnScreen() {
+        return yAbs;
+    }
+
+    /**
+     * Constructs a <code>MouseEvent</code> object with the
+     * specified source component,
+     * type, time, modifiers, coordinates, click count, popupTrigger flag,
+     * and button number.
+     * <p>
+     * Creating an invalid event (such
+     * as by using more than one of the old _MASKs, or modifier/button
+     * values which don't match) results in unspecified behavior.
+     * An invocation of the form
+     * <tt>MouseEvent(source, id, when, modifiers, x, y, clickCount, popupTrigger, button)</tt>
+     * behaves in exactly the same way as the invocation
+     * <tt> {@link #MouseEvent(Component, int, long, int, int, int,
+     * int, int, int, boolean, int) MouseEvent}(source, id, when, modifiers,
+     * x, y, xAbs, yAbs, clickCount, popupTrigger, button)</tt>
+     * where xAbs and yAbs defines as source's location on screen plus
+     * relative coordinates x and y.
+     * xAbs and yAbs are set to zero if the source is not showing.
+     * This method throws an
+     * <code>IllegalArgumentException</code> if <code>source</code>
+     * is <code>null</code>.
+     *
+     * @param source       The <code>Component</code> that originated the event
+     * @param id              An integer indicating the type of event.
+     *                     For information on allowable values, see
+     *                     the class description for {@link MouseEvent}
+     * @param when         A long integer that gives the time the event occurred.
+     *                     Passing negative or zero value
+     *                     is not recommended
+     * @param modifiers    The modifier keys down during event (e.g. shift, ctrl,
+     *                     alt, meta)
+     *                     Passing negative parameter
+     *                     is not recommended.
+     *                     Zero value means that no modifiers were passed.
+     *                     Use either an extended _DOWN_MASK or old _MASK modifiers,
+     *                     however do not mix models in the one event.
+     *                     The extended modifiers are preferred for using
+     * @param x            The horizontal x coordinate for the mouse location.
+     *                       It is allowed to pass negative values
+     * @param y            The vertical y coordinate for the mouse location.
+     *                       It is allowed to pass negative values
+     * @param clickCount   The number of mouse clicks associated with event.
+     *                       Passing negative value
+     *                       is not recommended
+     * @param popupTrigger A boolean that equals {@code true} if this event
+     *                     is a trigger for a popup menu
+     * @param button       An integer that indicates, which of the mouse buttons has
+     *                     changed its state.
+     * The following rules are applied to this parameter:
+     * <ul>
+     * <li>If support for the extended mouse buttons is
+     * {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java
+     * then it is allowed to create {@code MouseEvent} objects only with the standard buttons:
+     * {@code NOBUTTON}, {@code BUTTON1}, {@code BUTTON2}, and
+     * {@code BUTTON3}.
+     * <li> If support for the extended mouse buttons is
+     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java
+     * then it is allowed to create {@code MouseEvent} objects with
+     * the standard buttons.
+     * In case the support for extended mouse buttons is
+     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java, then
+     * in addition to the standard buttons, {@code MouseEvent} objects can be created
+     * using buttons from the range starting from 4 to
+     * {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}
+     * if the mouse has more than three buttons.
+     * </ul>
+     * @throws IllegalArgumentException if {@code button} is less then zero
+     * @throws IllegalArgumentException if <code>source</code> is null
+     * @throws IllegalArgumentException if {@code button} is greater then BUTTON3 and the support for extended mouse buttons is
+     *                                  {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java
+     * @throws IllegalArgumentException if {@code button} is greater then the
+     *                                  {@link java.awt.MouseInfo#getNumberOfButtons() current number of buttons} and the support
+     *                                  for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled}
+     *                                  by Java
+     * @throws IllegalArgumentException if an invalid <code>button</code>
+     *            value is passed in
+     * @throws IllegalArgumentException if <code>source</code> is null
+     * @see #getSource()
+     * @see #getID()
+     * @see #getWhen()
+     * @see #getModifiers()
+     * @see #getX()
+     * @see #getY()
+     * @see #getClickCount()
+     * @see #isPopupTrigger()
+     * @see #getButton()
+     * @since 1.4
+     */
+    public MouseEvent(Object source, int id, long when, int modifiers,
+                      int x, int y, int clickCount, boolean popupTrigger,
+                      int button)
+    {
+        this(source, id, when, modifiers, x, y, 0, 0, clickCount, popupTrigger, button);
+    }
+
+    /**
+     * Constructs a <code>MouseEvent</code> object with the
+     * specified source component,
+     * type, modifiers, coordinates, click count, and popupTrigger flag.
+     * An invocation of the form
+     * <tt>MouseEvent(source, id, when, modifiers, x, y, clickCount, popupTrigger)</tt>
+     * behaves in exactly the same way as the invocation
+     * <tt> {@link #MouseEvent(Component, int, long, int, int, int,
+     * int, int, int, boolean, int) MouseEvent}(source, id, when, modifiers,
+     * x, y, xAbs, yAbs, clickCount, popupTrigger, MouseEvent.NOBUTTON)</tt>
+     * where xAbs and yAbs defines as source's location on screen plus
+     * relative coordinates x and y.
+     * xAbs and yAbs are set to zero if the source is not showing.
+     * This method throws an <code>IllegalArgumentException</code>
+     * if <code>source</code> is <code>null</code>.
+     *
+     * @param source       The <code>Component</code> that originated the event
+     * @param id              An integer indicating the type of event.
+     *                     For information on allowable values, see
+     *                     the class description for {@link MouseEvent}
+     * @param when         A long integer that gives the time the event occurred.
+     *                     Passing negative or zero value
+     *                     is not recommended
+     * @param modifiers    The modifier keys down during event (e.g. shift, ctrl,
+     *                     alt, meta)
+     *                     Passing negative parameter
+     *                     is not recommended.
+     *                     Zero value means that no modifiers were passed.
+     *                     Use either an extended _DOWN_MASK or old _MASK modifiers,
+     *                     however do not mix models in the one event.
+     *                     The extended modifiers are preferred for using
+     * @param x            The horizontal x coordinate for the mouse location.
+     *                       It is allowed to pass negative values
+     * @param y            The vertical y coordinate for the mouse location.
+     *                       It is allowed to pass negative values
+     * @param clickCount   The number of mouse clicks associated with event.
+     *                       Passing negative value
+     *                       is not recommended
+     * @param popupTrigger A boolean that equals {@code true} if this event
+     *                     is a trigger for a popup menu
+     * @throws IllegalArgumentException if <code>source</code> is null
+     * @see #getSource()
+     * @see #getID()
+     * @see #getWhen()
+     * @see #getModifiers()
+     * @see #getX()
+     * @see #getY()
+     * @see #getClickCount()
+     * @see #isPopupTrigger()
+     */
+     public MouseEvent(Object source, int id, long when, int modifiers,
+                      int x, int y, int clickCount, boolean popupTrigger) {
+        this(source, id, when, modifiers, x, y, clickCount, popupTrigger, NOBUTTON);
+     }
+
+
+    /* if the button is an extra button and it is released or clicked then in Xsystem its state
+       is not modified. Exclude this button number from ExtModifiers mask.*/
+    transient private boolean shouldExcludeButtonFromExtModifiers = false;
+
+    /**
+     * Constructs a <code>MouseEvent</code> object with the
+     * specified source component,
+     * type, time, modifiers, coordinates, absolute coordinates, click count, popupTrigger flag,
+     * and button number.
+     * <p>
+     * Creating an invalid event (such
+     * as by using more than one of the old _MASKs, or modifier/button
+     * values which don't match) results in unspecified behavior.
+     * Even if inconsistent values for relative and absolute coordinates are
+     * passed to the constructor, the mouse event instance is still
+     * created and no exception is thrown.
+     * This method throws an
+     * <code>IllegalArgumentException</code> if <code>source</code>
+     * is <code>null</code>.
+     *
+     * @param source       The <code>Component</code> that originated the event
+     * @param id              An integer indicating the type of event.
+     *                     For information on allowable values, see
+     *                     the class description for {@link MouseEvent}
+     * @param when         A long integer that gives the time the event occurred.
+     *                     Passing negative or zero value
+     *                     is not recommended
+     * @param modifiers    The modifier keys down during event (e.g. shift, ctrl,
+     *                     alt, meta)
+     *                     Passing negative parameter
+     *                     is not recommended.
+     *                     Zero value means that no modifiers were passed.
+     *                     Use either an extended _DOWN_MASK or old _MASK modifiers,
+     *                     however do not mix models in the one event.
+     *                     The extended modifiers are preferred for using
+     * @param x            The horizontal x coordinate for the mouse location.
+     *                       It is allowed to pass negative values
+     * @param y            The vertical y coordinate for the mouse location.
+     *                       It is allowed to pass negative values
+     * @param xAbs           The absolute horizontal x coordinate for the mouse location
+     *                       It is allowed to pass negative values
+     * @param yAbs           The absolute vertical y coordinate for the mouse location
+     *                       It is allowed to pass negative values
+     * @param clickCount   The number of mouse clicks associated with event.
+     *                       Passing negative value
+     *                       is not recommended
+     * @param popupTrigger A boolean that equals {@code true} if this event
+     *                     is a trigger for a popup menu
+     * @param button       An integer that indicates, which of the mouse buttons has
+     *                     changed its state.
+     * The following rules are applied to this parameter:
+     * <ul>
+     * <li>If support for the extended mouse buttons is
+     * {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java
+     * then it is allowed to create {@code MouseEvent} objects only with the standard buttons:
+     * {@code NOBUTTON}, {@code BUTTON1}, {@code BUTTON2}, and
+     * {@code BUTTON3}.
+     * <li> If support for the extended mouse buttons is
+     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java
+     * then it is allowed to create {@code MouseEvent} objects with
+     * the standard buttons.
+     * In case the support for extended mouse buttons is
+     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java, then
+     * in addition to the standard buttons, {@code MouseEvent} objects can be created
+     * using buttons from the range starting from 4 to
+     * {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}
+     * if the mouse has more than three buttons.
+     * </ul>
+     * @throws IllegalArgumentException if {@code button} is less then zero
+     * @throws IllegalArgumentException if <code>source</code> is null
+     * @throws IllegalArgumentException if {@code button} is greater then BUTTON3 and the support for extended mouse buttons is
+     *                                  {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java
+     * @throws IllegalArgumentException if {@code button} is greater then the
+     *                                  {@link java.awt.MouseInfo#getNumberOfButtons() current number of buttons} and the support
+     *                                  for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled}
+     *                                  by Java
+     * @throws IllegalArgumentException if an invalid <code>button</code>
+     *            value is passed in
+     * @throws IllegalArgumentException if <code>source</code> is null
+     * @see #getSource()
+     * @see #getID()
+     * @see #getWhen()
+     * @see #getModifiers()
+     * @see #getX()
+     * @see #getY()
+     * @see #getXOnScreen()
+     * @see #getYOnScreen()
+     * @see #getClickCount()
+     * @see #isPopupTrigger()
+     * @see #getButton()
+     * @see #button
+     * @see Toolkit#areExtraMouseButtonsEnabled()
+     * @see java.awt.MouseInfo#getNumberOfButtons()
+     * @see InputEvent#getMaskForButton(int)
+     * @since 1.6
+     */
+    public MouseEvent(Object source, int id, long when, int modifiers,
+                      int x, int y, int xAbs, int yAbs,
+                      int clickCount, boolean popupTrigger, int button)
+    {
+        super(source);
+		this.id = id;
+		this.when = when;
+		this.modifiers = modifiers;
+        this.x = x;
+        this.y = y;
+        this.xAbs = xAbs;
+        this.yAbs = yAbs;
+        this.clickCount = clickCount;
+        this.popupTrigger = popupTrigger;
+        if (button < NOBUTTON){
+            throw new IllegalArgumentException("Invalid button value :" + button);
+        }
+        this.button = button;
+
+        if ((getModifiers() != 0) && (getModifiersEx() == 0)) {
+            setNewModifiers();
+        } else if ((getModifiers() == 0) &&
+                   (getModifiersEx() != 0 || button != NOBUTTON) &&
+                   (button <= BUTTON3))
+        {
+            setOldModifiers();
+        }
+    }
+
+    public int getModifiersEx() {
+        int tmpModifiers = modifiers;
+//        if (shouldExcludeButtonFromExtModifiers) {
+  //          tmpModifiers &= ~(InputEvent.getMaskForButton(getButton()));
+    //    }
+        return tmpModifiers & ~JDK_1_3_MODIFIERS;
+    }
+
+    /**
+     * Returns the horizontal x position of the event relative to the
+     * source component.
+     *
+     * @return x  an integer indicating horizontal position relative to
+     *            the component
+     */
+    public int getX() {
+        return x;
+    }
+
+    /**
+     * Returns the vertical y position of the event relative to the
+     * source component.
+     *
+     * @return y  an integer indicating vertical position relative to
+     *            the component
+     */
+    public int getY() {
+        return y;
+    }
+
+    /**
+     * Returns the x,y position of the event relative to the source component.
+     *
+     * @return a <code>Point</code> object containing the x and y coordinates
+     *         relative to the source component
+     *
+     */
+    public Point getPoint() {
+        int x;
+        int y;
+        synchronized (this) {
+            x = this.x;
+            y = this.y;
+        }
+        return new Point(x, y);
+    }
+
+    /**
+     * Translates the event's coordinates to a new position
+     * by adding specified <code>x</code> (horizontal) and <code>y</code>
+     * (vertical) offsets.
+     *
+     * @param x the horizontal x value to add to the current x
+     *          coordinate position
+     * @param y the vertical y value to add to the current y
+                coordinate position
+     */
+    public synchronized void translatePoint(int x, int y) {
+        this.x += x;
+        this.y += y;
+    }
+
+    /**
+     * Returns the number of mouse clicks associated with this event.
+     *
+     * @return integer value for the number of clicks
+     */
+    public int getClickCount() {
+        return clickCount;
+    }
+
+    /**
+     * Returns which, if any, of the mouse buttons has changed state.
+     * The returned value is ranged
+     * from 0 to the {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}
+     * value.
+     * The returned value includes at least the following constants:
+     * <ul>
+     * <li> {@code NOBUTTON}
+     * <li> {@code BUTTON1}
+     * <li> {@code BUTTON2}
+     * <li> {@code BUTTON3}
+     * </ul>
+     * It is allowed to use those constants to compare with the returned button number in the application.
+     * For example,
+     * <pre>
+     * if (anEvent.getButton() == MouseEvent.BUTTON1) {
+     * </pre>
+     * In particular, for a mouse with one, two, or three buttons this method may return the following values:
+     * <ul>
+     * <li> 0 ({@code NOBUTTON})
+     * <li> 1 ({@code BUTTON1})
+     * <li> 2 ({@code BUTTON2})
+     * <li> 3 ({@code BUTTON3})
+     * </ul>
+     * Button numbers greater then {@code BUTTON3} have no constant identifier. So if a mouse with five buttons is
+     * installed, this method may return the following values:
+     * <ul>
+     * <li> 0 ({@code NOBUTTON})
+     * <li> 1 ({@code BUTTON1})
+     * <li> 2 ({@code BUTTON2})
+     * <li> 3 ({@code BUTTON3})
+     * <li> 4
+     * <li> 5
+     * </ul>
+     * <p>
+     * Note: If support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java
+     * then the AWT event subsystem does not produce mouse events for the extended mouse
+     * buttons. So it is not expected that this method returns anything except {@code NOBUTTON}, {@code BUTTON1},
+     * {@code BUTTON2}, {@code BUTTON3}.
+     *
+     * @return one of the values from 0 to {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}
+     *         if support for the extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java.
+     *         That range includes {@code NOBUTTON}, {@code BUTTON1}, {@code BUTTON2}, {@code BUTTON3};
+     *         <br>
+     *         {@code NOBUTTON}, {@code BUTTON1}, {@code BUTTON2} or {@code BUTTON3}
+     *         if support for the extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java
+     * @since 1.4
+     * @see Toolkit#areExtraMouseButtonsEnabled()
+     * @see java.awt.MouseInfo#getNumberOfButtons()
+     * @see #MouseEvent(Component, int, long, int, int, int, int, int, int, boolean, int)
+     * @see InputEvent#getMaskForButton(int)
+     */
+    public int getButton() {
+        return button;
+    }
+
+    /**
+     * Returns whether or not this mouse event is the popup menu
+     * trigger event for the platform.
+     * <p><b>Note</b>: Popup menus are triggered differently
+     * on different systems. Therefore, <code>isPopupTrigger</code>
+     * should be checked in both <code>mousePressed</code>
+     * and <code>mouseReleased</code>
+     * for proper cross-platform functionality.
+     *
+     * @return boolean, true if this event is the popup menu trigger
+     *         for this platform
+     */
+    public boolean isPopupTrigger() {
+        return popupTrigger;
+    }
+
+    /**
+     * Returns a <code>String</code> instance describing the modifier keys and
+     * mouse buttons that were down during the event, such as "Shift",
+     * or "Ctrl+Shift". These strings can be localized by changing
+     * the <code>awt.properties</code> file.
+     * <p>
+     * Note that the <code>InputEvent.ALT_MASK</code> and
+     * <code>InputEvent.BUTTON2_MASK</code> have equal values,
+     * so the "Alt" string is returned for both modifiers.  Likewise,
+     * the <code>InputEvent.META_MASK</code> and
+     * <code>InputEvent.BUTTON3_MASK</code> have equal values,
+     * so the "Meta" string is returned for both modifiers.
+     * <p>
+     * Note that passing negative parameter is incorrect,
+     * and will cause the returning an unspecified string.
+     * Zero parameter means that no modifiers were passed and will
+     * cause the returning an empty string.
+     * <p>
+     * @param modifiers A modifier mask describing the modifier keys and
+     *                  mouse buttons that were down during the event
+     * @return string   string text description of the combination of modifier
+     *                  keys and mouse buttons that were down during the event
+     * @see InputEvent#getModifiersExText(int)
+     * @since 1.4
+     */
+    public static String getMouseModifiersText(int modifiers) {
+        StringBuffer buf = new StringBuffer();
+        if ((modifiers & ALT_MASK) != 0) {
+            buf.append("Alt");
+            buf.append("+");
+        }
+        if ((modifiers & META_MASK) != 0) {
+            buf.append("Meta");
+            buf.append("+");
+        }
+        if ((modifiers & CTRL_MASK) != 0) {
+            buf.append("Ctrl");
+            buf.append("+");
+        }
+        if ((modifiers & SHIFT_MASK) != 0) {
+            buf.append("Shift");
+            buf.append("+");
+        }
+        if ((modifiers & ALT_GRAPH_MASK) != 0) {
+            buf.append("Alt Graph");
+            buf.append("+");
+        }
+        if ((modifiers & BUTTON1_MASK) != 0) {
+            buf.append("Button1");
+            buf.append("+");
+        }
+        if ((modifiers & BUTTON2_MASK) != 0) {
+            buf.append("Button2");
+            buf.append("+");
+        }
+        if ((modifiers & BUTTON3_MASK) != 0) {
+            buf.append("Button3");
+            buf.append("+");
+        }
+
+        int mask;
+
+        // TODO: add a toolkit field that holds a number of button on the mouse.
+        // As the method getMouseModifiersText() is static and obtain
+        // an integer as a parameter then we may not restrict this with the number
+        // of buttons installed on the mouse.
+        // It's a temporary solution. We need to somehow hold the number of buttons somewhere else.
+        for (int i = 1; i <= cachedNumberOfButtons; i++){
+            mask = getMaskForButton(i);
+            if ((modifiers & mask) != 0 &&
+                buf.indexOf("Button"+i) == -1) //1,2,3 buttons may already be there; so don't duplicate it.
+            {
+                buf.append("Button"+i);
+                buf.append("+");
+            }
+        }
+
+        if (buf.length() > 0) {
+            buf.setLength(buf.length()-1); // remove trailing '+'
+        }
+        return buf.toString();
+    }
+
+    /**
+     * A method to obtain a mask for any existing mouse button.
+     * The returned mask may be used for different purposes. Following are some of them:
+     * <ul>
+     * <li> {@link java.awt.Robot#mousePress(int) mousePress(buttons)} and
+     *      {@link java.awt.Robot#mouseRelease(int) mouseRelease(buttons)}
+     * <li> as a {@code modifiers} parameter when creating a new {@link MouseEvent} instance
+     * <li> to check {@link MouseEvent#getModifiersEx() modifiersEx} of existing {@code MouseEvent}
+     * </ul>
+     * @param button is a number to represent a button starting from 1.
+     * For example,
+     * <pre>
+     * int button = InputEvent.getMaskForButton(1);
+     * </pre>
+     * will have the same meaning as
+     * <pre>
+     * int button = InputEvent.getMaskForButton(MouseEvent.BUTTON1);
+     * </pre>
+     * because {@link MouseEvent#BUTTON1 MouseEvent.BUTTON1} equals to 1.
+     * If a mouse has three enabled buttons(see {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()})
+     * then the values from the left column passed into the method will return
+     * corresponding values from the right column:
+     * <PRE>
+     *    <b>button </b>   <b>returned mask</b>
+     *    {@link MouseEvent#BUTTON1 BUTTON1}  {@link MouseEvent#BUTTON1_DOWN_MASK BUTTON1_DOWN_MASK}
+     *    {@link MouseEvent#BUTTON2 BUTTON2}  {@link MouseEvent#BUTTON2_DOWN_MASK BUTTON2_DOWN_MASK}
+     *    {@link MouseEvent#BUTTON3 BUTTON3}  {@link MouseEvent#BUTTON3_DOWN_MASK BUTTON3_DOWN_MASK}
+     * </PRE>
+     * If a mouse has more than three enabled buttons then more values
+     * are admissible (4, 5, etc.). There is no assigned constants for these extended buttons.
+     * The button masks for the extra buttons returned by this method have no assigned names like the
+     * first three button masks.
+     * <p>
+     * This method has the following implementation restriction.
+     * It returns masks for a limited number of buttons only. The maximum number is
+     * implementation dependent and may vary.
+     * This limit is defined by the relevant number
+     * of buttons that may hypothetically exist on the mouse but it is greater than the
+     * {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}.
+     * <p>
+     * @throws IllegalArgumentException if {@code button} is less than zero or greater than the number
+     *         of button masks reserved for buttons
+     * @since 7.0
+     * @see java.awt.MouseInfo#getNumberOfButtons()
+     * @see Toolkit#areExtraMouseButtonsEnabled()
+     * @see MouseEvent#getModifiers()
+     * @see MouseEvent#getModifiersEx()
+     */
+    public static int getMaskForButton(int button) {
+        if (button <= 0 || button > BUTTON_DOWN_MASK.length) {
+            throw new IllegalArgumentException("button doesn\'t exist " + button);
+        }
+        return BUTTON_DOWN_MASK[button - 1];
+    }
+    /**
+     * Returns a parameter string identifying this event.
+     * This method is useful for event-logging and for debugging.
+     *
+     * @return a string identifying the event and its attributes
+     */
+    public String paramString() {
+        StringBuffer str = new StringBuffer(80);
+
+        switch(id) {
+          case MOUSE_PRESSED:
+              str.append("MOUSE_PRESSED");
+              break;
+          case MOUSE_RELEASED:
+              str.append("MOUSE_RELEASED");
+              break;
+          case MOUSE_CLICKED:
+              str.append("MOUSE_CLICKED");
+              break;
+          case MOUSE_ENTERED:
+              str.append("MOUSE_ENTERED");
+              break;
+          case MOUSE_EXITED:
+              str.append("MOUSE_EXITED");
+              break;
+          case MOUSE_MOVED:
+              str.append("MOUSE_MOVED");
+              break;
+          case MOUSE_DRAGGED:
+              str.append("MOUSE_DRAGGED");
+              break;
+          case MOUSE_WHEEL:
+              str.append("MOUSE_WHEEL");
+              break;
+           default:
+              str.append("unknown type");
+        }
+
+        // (x,y) coordinates
+        str.append(",(").append(x).append(",").append(y).append(")");
+        str.append(",absolute(").append(xAbs).append(",").append(yAbs).append(")");
+
+        if (id != MOUSE_DRAGGED && id != MOUSE_MOVED){
+            str.append(",button=").append(getButton());
+        }
+
+        if (getModifiers() != 0) {
+            str.append(",modifiers=").append(getMouseModifiersText(modifiers));
+        }
+
+        if (getModifiersEx() != 0) {
+            //Using plain "modifiers" here does show an excluded extended buttons in the string event representation.
+            //getModifiersEx() solves the problem.
+            str.append(",extModifiers=").append(getModifiersExText(getModifiersEx()));
+        }
+
+        str.append(",clickCount=").append(clickCount);
+
+        return str.toString();
+    }
+
+    /**
+     * Returns a String describing the extended modifier keys and
+     * mouse buttons, such as "Shift", "Button1", or "Ctrl+Shift".
+     * These strings can be localized by changing the
+     * <code>awt.properties</code> file.
+     * <p>
+     * Note that passing negative parameter is incorrect,
+     * and will cause the returning an unspecified string.
+     * Zero parameter means that no modifiers were passed and will
+     * cause the returning an empty string.
+     *
+     * @param modifiers a modifier mask describing the extended
+     *                modifier keys and mouse buttons for the event
+     * @return a text description of the combination of extended
+     *         modifier keys and mouse buttons that were held down
+     *         during the event.
+     * @since 1.4
+     */
+    public static String getModifiersExText(int modifiers) {
+        StringBuffer buf = new StringBuffer();
+        if ((modifiers & META_DOWN_MASK) != 0) {
+            buf.append("Meta");
+            buf.append("+");
+        }
+        if ((modifiers & CTRL_DOWN_MASK) != 0) {
+            buf.append("Ctrl");
+            buf.append("+");
+        }
+        if ((modifiers & ALT_DOWN_MASK) != 0) {
+            buf.append("Alt");
+            buf.append("+");
+        }
+        if ((modifiers & SHIFT_DOWN_MASK) != 0) {
+            buf.append("Shift");
+            buf.append("+");
+        }
+        if ((modifiers & ALT_GRAPH_DOWN_MASK) != 0) {
+            buf.append("Alt Graph");
+            buf.append("+");
+        }
+
+        int buttonNumber = 1;
+        for (int mask = 0; mask < BUTTON_DOWN_MASK.length; mask++){
+            if ((modifiers & mask) != 0) {
+                buf.append("Button"+buttonNumber);
+                buf.append("+");
+            }
+            buttonNumber++;
+        }
+        if (buf.length() > 0) {
+            buf.setLength(buf.length()-1); // remove trailing '+'
+        }
+        return buf.toString();
+    }    /**
+     * Sets new modifiers by the old ones.
+     * Also sets button.
+     */
+    private void setNewModifiers() {
+        if ((modifiers & BUTTON1_MASK) != 0) {
+            modifiers |= BUTTON1_DOWN_MASK;
+        }
+        if ((modifiers & BUTTON2_MASK) != 0) {
+            modifiers |= BUTTON2_DOWN_MASK;
+        }
+        if ((modifiers & BUTTON3_MASK) != 0) {
+            modifiers |= BUTTON3_DOWN_MASK;
+        }
+        if (id == MOUSE_PRESSED
+            || id == MOUSE_RELEASED
+            || id == MOUSE_CLICKED)
+        {
+            if ((modifiers & BUTTON1_MASK) != 0) {
+                button = BUTTON1;
+                modifiers &= ~BUTTON2_MASK & ~BUTTON3_MASK;
+                if (id != MOUSE_PRESSED) {
+                    modifiers &= ~BUTTON1_DOWN_MASK;
+                }
+            } else if ((modifiers & BUTTON2_MASK) != 0) {
+                button = BUTTON2;
+                modifiers &= ~BUTTON1_MASK & ~BUTTON3_MASK;
+                if (id != MOUSE_PRESSED) {
+                    modifiers &= ~BUTTON2_DOWN_MASK;
+                }
+            } else if ((modifiers & BUTTON3_MASK) != 0) {
+                button = BUTTON3;
+                modifiers &= ~BUTTON1_MASK & ~BUTTON2_MASK;
+                if (id != MOUSE_PRESSED) {
+                    modifiers &= ~BUTTON3_DOWN_MASK;
+                }
+            }
+        }
+        if ((modifiers & ALT_MASK) != 0) {
+            modifiers |= ALT_DOWN_MASK;
+        }
+        if ((modifiers & META_MASK) != 0) {
+            modifiers |= META_DOWN_MASK;
+        }
+        if ((modifiers & SHIFT_MASK) != 0) {
+            modifiers |= SHIFT_DOWN_MASK;
+        }
+        if ((modifiers & CTRL_MASK) != 0) {
+            modifiers |= CTRL_DOWN_MASK;
+        }
+        if ((modifiers & ALT_GRAPH_MASK) != 0) {
+            modifiers |= ALT_GRAPH_DOWN_MASK;
+        }
+    }
+
+    /**
+     * Sets old modifiers by the new ones.
+     */
+    private void setOldModifiers() {
+        if (id == MOUSE_PRESSED
+            || id == MOUSE_RELEASED
+            || id == MOUSE_CLICKED)
+        {
+            switch(button) {
+            case BUTTON1:
+                modifiers |= BUTTON1_MASK;
+                break;
+            case BUTTON2:
+                modifiers |= BUTTON2_MASK;
+                break;
+            case BUTTON3:
+                modifiers |= BUTTON3_MASK;
+                break;
+            }
+        } else {
+            if ((modifiers & BUTTON1_DOWN_MASK) != 0) {
+                modifiers |= BUTTON1_MASK;
+            }
+            if ((modifiers & BUTTON2_DOWN_MASK) != 0) {
+                modifiers |= BUTTON2_MASK;
+            }
+            if ((modifiers & BUTTON3_DOWN_MASK) != 0) {
+                modifiers |= BUTTON3_MASK;
+            }
+        }
+        if ((modifiers & ALT_DOWN_MASK) != 0) {
+            modifiers |= ALT_MASK;
+        }
+        if ((modifiers & META_DOWN_MASK) != 0) {
+            modifiers |= META_MASK;
+        }
+        if ((modifiers & SHIFT_DOWN_MASK) != 0) {
+            modifiers |= SHIFT_MASK;
+        }
+        if ((modifiers & CTRL_DOWN_MASK) != 0) {
+            modifiers |= CTRL_MASK;
+        }
+        if ((modifiers & ALT_GRAPH_DOWN_MASK) != 0) {
+            modifiers |= ALT_GRAPH_MASK;
+        }
+    }
+
+    /**
+     * Sets new modifiers by the old ones.
+     * @serial
+     */
+    private void readObject(ObjectInputStream s)
+      throws IOException, ClassNotFoundException {
+        s.defaultReadObject();
+        if (getModifiers() != 0 && getModifiersEx() == 0) {
+            setNewModifiers();
+        }
+    }
+
+    public void setSource(Object newSource) {
+		source = newSource;
+	}
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/MouseListener.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/MouseListener.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/MouseListener.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/MouseListener.java	2010-05-04 17:07:34.000000000 -0400
@@ -0,0 +1,84 @@
+/*
+ * Copyright 1996-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.event;
+
+import java.util.EventListener;
+
+/**
+ * The listener interface for receiving "interesting" mouse events
+ * (press, release, click, enter, and exit) on a component.
+ * (To track mouse moves and mouse drags, use the
+ * <code>MouseMotionListener</code>.)
+ * <P>
+ * The class that is interested in processing a mouse event
+ * either implements this interface (and all the methods it
+ * contains) or extends the abstract <code>MouseAdapter</code> class
+ * (overriding only the methods of interest).
+ * <P>
+ * The listener object created from that class is then registered with a
+ * component using the component's <code>addMouseListener</code>
+ * method. A mouse event is generated when the mouse is pressed, released
+ * clicked (pressed and released). A mouse event is also generated when
+ * the mouse cursor enters or leaves a component. When a mouse event
+ * occurs, the relevant method in the listener object is invoked, and
+ * the <code>MouseEvent</code> is passed to it.
+ *
+ * @author Carl Quinn
+ *
+ * @see MouseAdapter
+ * @see MouseEvent
+ * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/mouselistener.html">Tutorial: Writing a Mouse Listener</a>
+ *
+ * @since 1.1
+ */
+public interface MouseListener extends EventListener {
+
+    /**
+     * Invoked when the mouse button has been clicked (pressed
+     * and released) on a component.
+     */
+    public void mouseClicked(MouseEvent e);
+
+    /**
+     * Invoked when a mouse button has been pressed on a component.
+     */
+    public void mousePressed(MouseEvent e);
+
+    /**
+     * Invoked when a mouse button has been released on a component.
+     */
+    public void mouseReleased(MouseEvent e);
+
+    /**
+     * Invoked when the mouse enters a component.
+     */
+    public void mouseEntered(MouseEvent e);
+
+    /**
+     * Invoked when the mouse exits a component.
+     */
+    public void mouseExited(MouseEvent e);
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/MouseMotionListener.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/MouseMotionListener.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/MouseMotionListener.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/event/MouseMotionListener.java	2010-05-04 17:07:38.000000000 -0400
@@ -0,0 +1,75 @@
+/*
+ * Copyright 1996-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.event;
+
+import java.util.EventListener;
+
+/**
+ * The listener interface for receiving mouse motion events on a component.
+ * (For clicks and other mouse events, use the <code>MouseListener</code>.)
+ * <P>
+ * The class that is interested in processing a mouse motion event
+ * either implements this interface (and all the methods it
+ * contains) or extends the abstract <code>MouseMotionAdapter</code> class
+ * (overriding only the methods of interest).
+ * <P>
+ * The listener object created from that class is then registered with a
+ * component using the component's <code>addMouseMotionListener</code>
+ * method. A mouse motion event is generated when the mouse is moved
+ * or dragged. (Many such events will be generated). When a mouse motion event
+ * occurs, the relevant method in the listener object is invoked, and
+ * the <code>MouseEvent</code> is passed to it.
+ *
+ * @author Amy Fowler
+ *
+ * @see MouseMotionAdapter
+ * @see MouseEvent
+ * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/mousemotionlistener.html">Tutorial: Writing a Mouse Motion Listener</a>
+ *
+ * @since 1.1
+ */
+public interface MouseMotionListener extends EventListener {
+
+    /**
+     * Invoked when a mouse button is pressed on a component and then
+     * dragged.  <code>MOUSE_DRAGGED</code> events will continue to be
+     * delivered to the component where the drag originated until the
+     * mouse button is released (regardless of whether the mouse position
+     * is within the bounds of the component).
+     * <p>
+     * Due to platform-dependent Drag&Drop implementations,
+     * <code>MOUSE_DRAGGED</code> events may not be delivered during a native
+     * Drag&Drop operation.
+     */
+    public void mouseDragged(MouseEvent e);
+
+    /**
+     * Invoked when the mouse cursor has been moved onto a component
+     * but no buttons have been pushed.
+     */
+    public void mouseMoved(MouseEvent e);
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/Dimension2D.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/Dimension2D.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/Dimension2D.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/Dimension2D.java	2009-08-13 00:47:02.000000000 -0400
@@ -0,0 +1,114 @@
+/*
+ * Copyright 1997-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.geom;
+
+/**
+ * The <code>Dimension2D</code> class is to encapsulate a width
+ * and a height dimension.
+ * <p>
+ * This class is only the abstract superclass for all objects that
+ * store a 2D dimension.
+ * The actual storage representation of the sizes is left to
+ * the subclass.
+ *
+ * @author      Jim Graham
+ * @since 1.2
+ */
+public abstract class Dimension2D implements Cloneable {
+
+    /**
+     * This is an abstract class that cannot be instantiated directly.
+     * Type-specific implementation subclasses are available for
+     * instantiation and provide a number of formats for storing
+     * the information necessary to satisfy the various accessor
+     * methods below.
+     *
+     * @see java.awt.Dimension
+     * @since 1.2
+     */
+    protected Dimension2D() {
+    }
+
+    /**
+     * Returns the width of this <code>Dimension</code> in double
+     * precision.
+     * @return the width of this <code>Dimension</code>.
+     * @since 1.2
+     */
+    public abstract double getWidth();
+
+    /**
+     * Returns the height of this <code>Dimension</code> in double
+     * precision.
+     * @return the height of this <code>Dimension</code>.
+     * @since 1.2
+     */
+    public abstract double getHeight();
+
+    /**
+     * Sets the size of this <code>Dimension</code> object to the
+     * specified width and height.
+     * This method is included for completeness, to parallel the
+     * {@link java.awt.Component#getSize getSize} method of
+     * {@link java.awt.Component}.
+     * @param width  the new width for the <code>Dimension</code>
+     * object
+     * @param height  the new height for the <code>Dimension</code>
+     * object
+     * @since 1.2
+     */
+    public abstract void setSize(double width, double height);
+
+    /**
+     * Sets the size of this <code>Dimension2D</code> object to
+     * match the specified size.
+     * This method is included for completeness, to parallel the
+     * <code>getSize</code> method of <code>Component</code>.
+     * @param d  the new size for the <code>Dimension2D</code>
+     * object
+     * @since 1.2
+     */
+    public void setSize(Dimension2D d) {
+        setSize(d.getWidth(), d.getHeight());
+    }
+
+    /**
+     * Creates a new object of the same class as this object.
+     *
+     * @return     a clone of this instance.
+     * @exception  OutOfMemoryError            if there is not enough memory.
+     * @see        java.lang.Cloneable
+     * @since      1.2
+     */
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch (CloneNotSupportedException e) {
+            // this shouldn't happen, since we are Cloneable
+            throw new InternalError();
+        }
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/Point2D.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/Point2D.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/Point2D.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/Point2D.java	2009-08-13 00:47:02.000000000 -0400
@@ -0,0 +1,428 @@
+/*
+ * Copyright 1997-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.geom;
+
+import java.io.Serializable;
+
+/**
+ * The <code>Point2D</code> class defines a point representing a location
+ * in {@code (x,y)} coordinate space.
+ * <p>
+ * This class is only the abstract superclass for all objects that
+ * store a 2D coordinate.
+ * The actual storage representation of the coordinates is left to
+ * the subclass.
+ *
+ * @author      Jim Graham
+ * @since 1.2
+ */
+public abstract class Point2D implements Cloneable {
+
+    /**
+     * The <code>Float</code> class defines a point specified in float
+     * precision.
+     * @since 1.2
+     */
+    public static class Float extends Point2D implements Serializable {
+        /**
+         * The X coordinate of this <code>Point2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public float x;
+
+        /**
+         * The Y coordinate of this <code>Point2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public float y;
+
+        /**
+         * Constructs and initializes a <code>Point2D</code> with
+         * coordinates (0,&nbsp;0).
+         * @since 1.2
+         */
+        public Float() {
+        }
+
+        /**
+         * Constructs and initializes a <code>Point2D</code> with
+         * the specified coordinates.
+         *
+         * @param x the X coordinate of the newly
+         *          constructed <code>Point2D</code>
+         * @param y the Y coordinate of the newly
+         *          constructed <code>Point2D</code>
+         * @since 1.2
+         */
+        public Float(float x, float y) {
+            this.x = x;
+            this.y = y;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getX() {
+            return (double) x;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getY() {
+            return (double) y;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public void setLocation(double x, double y) {
+            this.x = (float) x;
+            this.y = (float) y;
+        }
+
+        /**
+         * Sets the location of this <code>Point2D</code> to the
+         * specified <code>float</code> coordinates.
+         *
+         * @param x the new X coordinate of this {@code Point2D}
+         * @param y the new Y coordinate of this {@code Point2D}
+         * @since 1.2
+         */
+        public void setLocation(float x, float y) {
+            this.x = x;
+            this.y = y;
+        }
+
+        /**
+         * Returns a <code>String</code> that represents the value
+         * of this <code>Point2D</code>.
+         * @return a string representation of this <code>Point2D</code>.
+         * @since 1.2
+         */
+        public String toString() {
+            return "Point2D.Float["+x+", "+y+"]";
+        }
+
+        /*
+         * JDK 1.6 serialVersionUID
+         */
+        private static final long serialVersionUID = -2870572449815403710L;
+    }
+
+    /**
+     * The <code>Double</code> class defines a point specified in
+     * <code>double</code> precision.
+     * @since 1.2
+     */
+    public static class Double extends Point2D implements Serializable {
+        /**
+         * The X coordinate of this <code>Point2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public double x;
+
+        /**
+         * The Y coordinate of this <code>Point2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public double y;
+
+        /**
+         * Constructs and initializes a <code>Point2D</code> with
+         * coordinates (0,&nbsp;0).
+         * @since 1.2
+         */
+        public Double() {
+        }
+
+        /**
+         * Constructs and initializes a <code>Point2D</code> with the
+         * specified coordinates.
+         *
+         * @param x the X coordinate of the newly
+         *          constructed <code>Point2D</code>
+         * @param y the Y coordinate of the newly
+         *          constructed <code>Point2D</code>
+         * @since 1.2
+         */
+        public Double(double x, double y) {
+            this.x = x;
+            this.y = y;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getX() {
+            return x;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getY() {
+            return y;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public void setLocation(double x, double y) {
+            this.x = x;
+            this.y = y;
+        }
+
+        /**
+         * Returns a <code>String</code> that represents the value
+         * of this <code>Point2D</code>.
+         * @return a string representation of this <code>Point2D</code>.
+         * @since 1.2
+         */
+        public String toString() {
+            return "Point2D.Double["+x+", "+y+"]";
+        }
+
+        /*
+         * JDK 1.6 serialVersionUID
+         */
+        private static final long serialVersionUID = 6150783262733311327L;
+    }
+
+    /**
+     * This is an abstract class that cannot be instantiated directly.
+     * Type-specific implementation subclasses are available for
+     * instantiation and provide a number of formats for storing
+     * the information necessary to satisfy the various accessor
+     * methods below.
+     *
+     * @see java.awt.geom.Point2D.Float
+     * @see java.awt.geom.Point2D.Double
+     * @see java.awt.Point
+     * @since 1.2
+     */
+    protected Point2D() {
+    }
+
+    /**
+     * Returns the X coordinate of this <code>Point2D</code> in
+     * <code>double</code> precision.
+     * @return the X coordinate of this <code>Point2D</code>.
+     * @since 1.2
+     */
+    public abstract double getX();
+
+    /**
+     * Returns the Y coordinate of this <code>Point2D</code> in
+     * <code>double</code> precision.
+     * @return the Y coordinate of this <code>Point2D</code>.
+     * @since 1.2
+     */
+    public abstract double getY();
+
+    /**
+     * Sets the location of this <code>Point2D</code> to the
+     * specified <code>double</code> coordinates.
+     *
+     * @param x the new X coordinate of this {@code Point2D}
+     * @param y the new Y coordinate of this {@code Point2D}
+     * @since 1.2
+     */
+    public abstract void setLocation(double x, double y);
+
+    /**
+     * Sets the location of this <code>Point2D</code> to the same
+     * coordinates as the specified <code>Point2D</code> object.
+     * @param p the specified <code>Point2D</code> to which to set
+     * this <code>Point2D</code>
+     * @since 1.2
+     */
+    public void setLocation(Point2D p) {
+        setLocation(p.getX(), p.getY());
+    }
+
+    /**
+     * Returns the square of the distance between two points.
+     *
+     * @param x1 the X coordinate of the first specified point
+     * @param y1 the Y coordinate of the first specified point
+     * @param x2 the X coordinate of the second specified point
+     * @param y2 the Y coordinate of the second specified point
+     * @return the square of the distance between the two
+     * sets of specified coordinates.
+     * @since 1.2
+     */
+    public static double distanceSq(double x1, double y1,
+                                    double x2, double y2)
+    {
+        x1 -= x2;
+        y1 -= y2;
+        return (x1 * x1 + y1 * y1);
+    }
+
+    /**
+     * Returns the distance between two points.
+     *
+     * @param x1 the X coordinate of the first specified point
+     * @param y1 the Y coordinate of the first specified point
+     * @param x2 the X coordinate of the second specified point
+     * @param y2 the Y coordinate of the second specified point
+     * @return the distance between the two sets of specified
+     * coordinates.
+     * @since 1.2
+     */
+    public static double distance(double x1, double y1,
+                                  double x2, double y2)
+    {
+        x1 -= x2;
+        y1 -= y2;
+        return Math.sqrt(x1 * x1 + y1 * y1);
+    }
+
+    /**
+     * Returns the square of the distance from this
+     * <code>Point2D</code> to a specified point.
+     *
+     * @param px the X coordinate of the specified point to be measured
+     *           against this <code>Point2D</code>
+     * @param py the Y coordinate of the specified point to be measured
+     *           against this <code>Point2D</code>
+     * @return the square of the distance between this
+     * <code>Point2D</code> and the specified point.
+     * @since 1.2
+     */
+    public double distanceSq(double px, double py) {
+        px -= getX();
+        py -= getY();
+        return (px * px + py * py);
+    }
+
+    /**
+     * Returns the square of the distance from this
+     * <code>Point2D</code> to a specified <code>Point2D</code>.
+     *
+     * @param pt the specified point to be measured
+     *           against this <code>Point2D</code>
+     * @return the square of the distance between this
+     * <code>Point2D</code> to a specified <code>Point2D</code>.
+     * @since 1.2
+     */
+    public double distanceSq(Point2D pt) {
+        double px = pt.getX() - this.getX();
+        double py = pt.getY() - this.getY();
+        return (px * px + py * py);
+    }
+
+    /**
+     * Returns the distance from this <code>Point2D</code> to
+     * a specified point.
+     *
+     * @param px the X coordinate of the specified point to be measured
+     *           against this <code>Point2D</code>
+     * @param py the Y coordinate of the specified point to be measured
+     *           against this <code>Point2D</code>
+     * @return the distance between this <code>Point2D</code>
+     * and a specified point.
+     * @since 1.2
+     */
+    public double distance(double px, double py) {
+        px -= getX();
+        py -= getY();
+        return Math.sqrt(px * px + py * py);
+    }
+
+    /**
+     * Returns the distance from this <code>Point2D</code> to a
+     * specified <code>Point2D</code>.
+     *
+     * @param pt the specified point to be measured
+     *           against this <code>Point2D</code>
+     * @return the distance between this <code>Point2D</code> and
+     * the specified <code>Point2D</code>.
+     * @since 1.2
+     */
+    public double distance(Point2D pt) {
+        double px = pt.getX() - this.getX();
+        double py = pt.getY() - this.getY();
+        return Math.sqrt(px * px + py * py);
+    }
+
+    /**
+     * Creates a new object of the same class and with the
+     * same contents as this object.
+     * @return     a clone of this instance.
+     * @exception  OutOfMemoryError            if there is not enough memory.
+     * @see        java.lang.Cloneable
+     * @since      1.2
+     */
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch (CloneNotSupportedException e) {
+            // this shouldn't happen, since we are Cloneable
+            throw new InternalError();
+        }
+    }
+
+    /**
+     * Returns the hashcode for this <code>Point2D</code>.
+     * @return      a hash code for this <code>Point2D</code>.
+     */
+    public int hashCode() {
+        long bits = java.lang.Double.doubleToLongBits(getX());
+        bits ^= java.lang.Double.doubleToLongBits(getY()) * 31;
+        return (((int) bits) ^ ((int) (bits >> 32)));
+    }
+
+    /**
+     * Determines whether or not two points are equal. Two instances of
+     * <code>Point2D</code> are equal if the values of their
+     * <code>x</code> and <code>y</code> member fields, representing
+     * their position in the coordinate space, are the same.
+     * @param obj an object to be compared with this <code>Point2D</code>
+     * @return <code>true</code> if the object to be compared is
+     *         an instance of <code>Point2D</code> and has
+     *         the same values; <code>false</code> otherwise.
+     * @since 1.2
+     */
+    public boolean equals(Object obj) {
+        if (obj instanceof Point2D) {
+            Point2D p2d = (Point2D) obj;
+            return (getX() == p2d.getX()) && (getY() == p2d.getY());
+        }
+        return super.equals(obj);
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/Rectangle2D.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/Rectangle2D.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/Rectangle2D.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/Rectangle2D.java	2010-05-21 15:31:36.000000000 -0400
@@ -0,0 +1,930 @@
+/*
+ * Copyright 1997-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.geom;
+
+import java.io.Serializable;
+
+/**
+ * The <code>Rectangle2D</code> class describes a rectangle
+ * defined by a location {@code (x,y)} and dimension
+ * {@code (w x h)}.
+ * <p>
+ * This class is only the abstract superclass for all objects that
+ * store a 2D rectangle.
+ * The actual storage representation of the coordinates is left to
+ * the subclass.
+ *
+ * @author      Jim Graham
+ * @since 1.2
+ */
+public abstract class Rectangle2D extends RectangularShape {
+    /**
+     * The bitmask that indicates that a point lies to the left of
+     * this <code>Rectangle2D</code>.
+     * @since 1.2
+     */
+    public static final int OUT_LEFT = 1;
+
+    /**
+     * The bitmask that indicates that a point lies above
+     * this <code>Rectangle2D</code>.
+     * @since 1.2
+     */
+    public static final int OUT_TOP = 2;
+
+    /**
+     * The bitmask that indicates that a point lies to the right of
+     * this <code>Rectangle2D</code>.
+     * @since 1.2
+     */
+    public static final int OUT_RIGHT = 4;
+
+    /**
+     * The bitmask that indicates that a point lies below
+     * this <code>Rectangle2D</code>.
+     * @since 1.2
+     */
+    public static final int OUT_BOTTOM = 8;
+
+    /**
+     * The <code>Float</code> class defines a rectangle specified in float
+     * coordinates.
+     * @since 1.2
+     */
+    public static class Float extends Rectangle2D implements Serializable {
+        /**
+         * The X coordinate of this <code>Rectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public float x;
+
+        /**
+         * The Y coordinate of this <code>Rectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public float y;
+
+        /**
+         * The width of this <code>Rectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public float width;
+
+        /**
+         * The height of this <code>Rectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public float height;
+
+        /**
+         * Constructs a new <code>Rectangle2D</code>, initialized to
+         * location (0.0,&nbsp;0.0) and size (0.0,&nbsp;0.0).
+         * @since 1.2
+         */
+        public Float() {
+        }
+
+        /**
+         * Constructs and initializes a <code>Rectangle2D</code>
+         * from the specified <code>float</code> coordinates.
+         *
+         * @param x the X coordinate of the upper-left corner
+         *          of the newly constructed <code>Rectangle2D</code>
+         * @param y the Y coordinate of the upper-left corner
+         *          of the newly constructed <code>Rectangle2D</code>
+         * @param w the width of the newly constructed
+         *          <code>Rectangle2D</code>
+         * @param h the height of the newly constructed
+         *          <code>Rectangle2D</code>
+         * @since 1.2
+        */
+        public Float(float x, float y, float w, float h) {
+            setRect(x, y, w, h);
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getX() {
+            return (double) x;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getY() {
+            return (double) y;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getWidth() {
+            return (double) width;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getHeight() {
+            return (double) height;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public boolean isEmpty() {
+            return (width <= 0.0f) || (height <= 0.0f);
+        }
+
+        /**
+         * Sets the location and size of this <code>Rectangle2D</code>
+         * to the specified <code>float</code> values.
+         *
+         * @param x the X coordinate of the upper-left corner
+         *          of this <code>Rectangle2D</code>
+         * @param y the Y coordinate of the upper-left corner
+         *          of this <code>Rectangle2D</code>
+         * @param w the width of this <code>Rectangle2D</code>
+         * @param h the height of this <code>Rectangle2D</code>
+         * @since 1.2
+         */
+        public void setRect(float x, float y, float w, float h) {
+            this.x = x;
+            this.y = y;
+            this.width = w;
+            this.height = h;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public void setRect(double x, double y, double w, double h) {
+            this.x = (float) x;
+            this.y = (float) y;
+            this.width = (float) w;
+            this.height = (float) h;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public void setRect(Rectangle2D r) {
+            this.x = (float) r.getX();
+            this.y = (float) r.getY();
+            this.width = (float) r.getWidth();
+            this.height = (float) r.getHeight();
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public int outcode(double x, double y) {
+            /*
+             * Note on casts to double below.  If the arithmetic of
+             * x+w or y+h is done in float, then some bits may be
+             * lost if the binary exponents of x/y and w/h are not
+             * similar.  By converting to double before the addition
+             * we force the addition to be carried out in double to
+             * avoid rounding error in the comparison.
+             *
+             * See bug 4320890 for problems that this inaccuracy causes.
+             */
+            int out = 0;
+            if (this.width <= 0) {
+                out |= OUT_LEFT | OUT_RIGHT;
+            } else if (x < this.x) {
+                out |= OUT_LEFT;
+            } else if (x > this.x + (double) this.width) {
+                out |= OUT_RIGHT;
+            }
+            if (this.height <= 0) {
+                out |= OUT_TOP | OUT_BOTTOM;
+            } else if (y < this.y) {
+                out |= OUT_TOP;
+            } else if (y > this.y + (double) this.height) {
+                out |= OUT_BOTTOM;
+            }
+            return out;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public Rectangle2D getBounds2D() {
+            return new Float(x, y, width, height);
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public Rectangle2D createIntersection(Rectangle2D r) {
+            Rectangle2D dest;
+            if (r instanceof Float) {
+                dest = new Rectangle2D.Float();
+            } else {
+                dest = new Rectangle2D.Double();
+            }
+            Rectangle2D.intersect(this, r, dest);
+            return dest;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public Rectangle2D createUnion(Rectangle2D r) {
+            Rectangle2D dest;
+            if (r instanceof Float) {
+                dest = new Rectangle2D.Float();
+            } else {
+                dest = new Rectangle2D.Double();
+            }
+            Rectangle2D.union(this, r, dest);
+            return dest;
+        }
+
+        /**
+         * Returns the <code>String</code> representation of this
+         * <code>Rectangle2D</code>.
+         * @return a <code>String</code> representing this
+         * <code>Rectangle2D</code>.
+         * @since 1.2
+         */
+        public String toString() {
+            return getClass().getName()
+                + "[x=" + x +
+                ",y=" + y +
+                ",w=" + width +
+                ",h=" + height + "]";
+        }
+
+        /*
+         * JDK 1.6 serialVersionUID
+         */
+        private static final long serialVersionUID = 3798716824173675777L;
+    }
+
+    /**
+     * The <code>Double</code> class defines a rectangle specified in
+     * double coordinates.
+     * @since 1.2
+     */
+    public static class Double extends Rectangle2D implements Serializable {
+        /**
+         * The X coordinate of this <code>Rectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public double x;
+
+        /**
+         * The Y coordinate of this <code>Rectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public double y;
+
+        /**
+         * The width of this <code>Rectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public double width;
+
+        /**
+         * The height of this <code>Rectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public double height;
+
+        /**
+         * Constructs a new <code>Rectangle2D</code>, initialized to
+         * location (0,&nbsp;0) and size (0,&nbsp;0).
+         * @since 1.2
+         */
+        public Double() {
+        }
+
+        /**
+         * Constructs and initializes a <code>Rectangle2D</code>
+         * from the specified <code>double</code> coordinates.
+         *
+         * @param x the X coordinate of the upper-left corner
+         *          of the newly constructed <code>Rectangle2D</code>
+         * @param y the Y coordinate of the upper-left corner
+         *          of the newly constructed <code>Rectangle2D</code>
+         * @param w the width of the newly constructed
+         *          <code>Rectangle2D</code>
+         * @param h the height of the newly constructed
+         *          <code>Rectangle2D</code>
+         * @since 1.2
+         */
+        public Double(double x, double y, double w, double h) {
+            setRect(x, y, w, h);
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getX() {
+            return x;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getY() {
+            return y;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getWidth() {
+            return width;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getHeight() {
+            return height;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public boolean isEmpty() {
+            return (width <= 0.0) || (height <= 0.0);
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public void setRect(double x, double y, double w, double h) {
+            this.x = x;
+            this.y = y;
+            this.width = w;
+            this.height = h;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public void setRect(Rectangle2D r) {
+            this.x = r.getX();
+            this.y = r.getY();
+            this.width = r.getWidth();
+            this.height = r.getHeight();
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public int outcode(double x, double y) {
+            int out = 0;
+            if (this.width <= 0) {
+                out |= OUT_LEFT | OUT_RIGHT;
+            } else if (x < this.x) {
+                out |= OUT_LEFT;
+            } else if (x > this.x + this.width) {
+                out |= OUT_RIGHT;
+            }
+            if (this.height <= 0) {
+                out |= OUT_TOP | OUT_BOTTOM;
+            } else if (y < this.y) {
+                out |= OUT_TOP;
+            } else if (y > this.y + this.height) {
+                out |= OUT_BOTTOM;
+            }
+            return out;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public Rectangle2D getBounds2D() {
+            return new Double(x, y, width, height);
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public Rectangle2D createIntersection(Rectangle2D r) {
+            Rectangle2D dest = new Rectangle2D.Double();
+            Rectangle2D.intersect(this, r, dest);
+            return dest;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public Rectangle2D createUnion(Rectangle2D r) {
+            Rectangle2D dest = new Rectangle2D.Double();
+            Rectangle2D.union(this, r, dest);
+            return dest;
+        }
+
+        /**
+         * Returns the <code>String</code> representation of this
+         * <code>Rectangle2D</code>.
+         * @return a <code>String</code> representing this
+         * <code>Rectangle2D</code>.
+         * @since 1.2
+         */
+        public String toString() {
+            return getClass().getName()
+                + "[x=" + x +
+                ",y=" + y +
+                ",w=" + width +
+                ",h=" + height + "]";
+        }
+
+        /*
+         * JDK 1.6 serialVersionUID
+         */
+        private static final long serialVersionUID = 7771313791441850493L;
+    }
+
+    /**
+     * This is an abstract class that cannot be instantiated directly.
+     * Type-specific implementation subclasses are available for
+     * instantiation and provide a number of formats for storing
+     * the information necessary to satisfy the various accessor
+     * methods below.
+     *
+     * @see java.awt.geom.Rectangle2D.Float
+     * @see java.awt.geom.Rectangle2D.Double
+     * @see java.awt.Rectangle
+     * @since 1.2
+     */
+    protected Rectangle2D() {
+    }
+
+    /**
+     * Sets the location and size of this <code>Rectangle2D</code>
+     * to the specified <code>double</code> values.
+     *
+     * @param x the X coordinate of the upper-left corner
+     *          of this <code>Rectangle2D</code>
+     * @param y the Y coordinate of the upper-left corner
+     *          of this <code>Rectangle2D</code>
+     * @param w the width of this <code>Rectangle2D</code>
+     * @param h the height of this <code>Rectangle2D</code>
+     * @since 1.2
+     */
+    public abstract void setRect(double x, double y, double w, double h);
+
+    /**
+     * Sets this <code>Rectangle2D</code> to be the same as the specified
+     * <code>Rectangle2D</code>.
+     * @param r the specified <code>Rectangle2D</code>
+     * @since 1.2
+     */
+    public void setRect(Rectangle2D r) {
+        setRect(r.getX(), r.getY(), r.getWidth(), r.getHeight());
+    }
+
+    /**
+     * Tests if the specified line segment intersects the interior of this
+     * <code>Rectangle2D</code>.
+     *
+     * @param x1 the X coordinate of the start point of the specified
+     *           line segment
+     * @param y1 the Y coordinate of the start point of the specified
+     *           line segment
+     * @param x2 the X coordinate of the end point of the specified
+     *           line segment
+     * @param y2 the Y coordinate of the end point of the specified
+     *           line segment
+     * @return <code>true</code> if the specified line segment intersects
+     * the interior of this <code>Rectangle2D</code>; <code>false</code>
+     * otherwise.
+     * @since 1.2
+     */
+    public boolean intersectsLine(double x1, double y1, double x2, double y2) {
+        int out1, out2;
+        if ((out2 = outcode(x2, y2)) == 0) {
+            return true;
+        }
+        while ((out1 = outcode(x1, y1)) != 0) {
+            if ((out1 & out2) != 0) {
+                return false;
+            }
+            if ((out1 & (OUT_LEFT | OUT_RIGHT)) != 0) {
+                double x = getX();
+                if ((out1 & OUT_RIGHT) != 0) {
+                    x += getWidth();
+                }
+                y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);
+                x1 = x;
+            } else {
+                double y = getY();
+                if ((out1 & OUT_BOTTOM) != 0) {
+                    y += getHeight();
+                }
+                x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);
+                y1 = y;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Tests if the specified line segment intersects the interior of this
+     * <code>Rectangle2D</code>.
+     * @param l the specified {@link Line2D} to test for intersection
+     * with the interior of this <code>Rectangle2D</code>
+     * @return <code>true</code> if the specified <code>Line2D</code>
+     * intersects the interior of this <code>Rectangle2D</code>;
+     * <code>false</code> otherwise.
+     * @since 1.2
+     */
+/*    public boolean intersectsLine(Line2D l) {
+        return intersectsLine(l.getX1(), l.getY1(), l.getX2(), l.getY2());
+    }
+*/
+    /**
+     * Determines where the specified coordinates lie with respect
+     * to this <code>Rectangle2D</code>.
+     * This method computes a binary OR of the appropriate mask values
+     * indicating, for each side of this <code>Rectangle2D</code>,
+     * whether or not the specified coordinates are on the same side
+     * of the edge as the rest of this <code>Rectangle2D</code>.
+     * @param x the specified X coordinate
+     * @param y the specified Y coordinate
+     * @return the logical OR of all appropriate out codes.
+     * @see #OUT_LEFT
+     * @see #OUT_TOP
+     * @see #OUT_RIGHT
+     * @see #OUT_BOTTOM
+     * @since 1.2
+     */
+    public abstract int outcode(double x, double y);
+
+    /**
+     * Determines where the specified {@link Point2D} lies with
+     * respect to this <code>Rectangle2D</code>.
+     * This method computes a binary OR of the appropriate mask values
+     * indicating, for each side of this <code>Rectangle2D</code>,
+     * whether or not the specified <code>Point2D</code> is on the same
+     * side of the edge as the rest of this <code>Rectangle2D</code>.
+     * @param p the specified <code>Point2D</code>
+     * @return the logical OR of all appropriate out codes.
+     * @see #OUT_LEFT
+     * @see #OUT_TOP
+     * @see #OUT_RIGHT
+     * @see #OUT_BOTTOM
+     * @since 1.2
+     */
+    public int outcode(Point2D p) {
+        return outcode(p.getX(), p.getY());
+    }
+
+    /**
+     * Sets the location and size of the outer bounds of this
+     * <code>Rectangle2D</code> to the specified rectangular values.
+     *
+     * @param x the X coordinate of the upper-left corner
+     *          of this <code>Rectangle2D</code>
+     * @param y the Y coordinate of the upper-left corner
+     *          of this <code>Rectangle2D</code>
+     * @param w the width of this <code>Rectangle2D</code>
+     * @param h the height of this <code>Rectangle2D</code>
+     * @since 1.2
+     */
+    public void setFrame(double x, double y, double w, double h) {
+        setRect(x, y, w, h);
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public Rectangle2D getBounds2D() {
+        return (Rectangle2D) clone();
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public boolean contains(double x, double y) {
+        double x0 = getX();
+        double y0 = getY();
+        return (x >= x0 &&
+                y >= y0 &&
+                x < x0 + getWidth() &&
+                y < y0 + getHeight());
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public boolean intersects(double x, double y, double w, double h) {
+        if (isEmpty() || w <= 0 || h <= 0) {
+            return false;
+        }
+        double x0 = getX();
+        double y0 = getY();
+        return (x + w > x0 &&
+                y + h > y0 &&
+                x < x0 + getWidth() &&
+                y < y0 + getHeight());
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public boolean contains(double x, double y, double w, double h) {
+        if (isEmpty() || w <= 0 || h <= 0) {
+            return false;
+        }
+        double x0 = getX();
+        double y0 = getY();
+        return (x >= x0 &&
+                y >= y0 &&
+                (x + w) <= x0 + getWidth() &&
+                (y + h) <= y0 + getHeight());
+    }
+
+    /**
+     * Returns a new <code>Rectangle2D</code> object representing the
+     * intersection of this <code>Rectangle2D</code> with the specified
+     * <code>Rectangle2D</code>.
+     * @param r the <code>Rectangle2D</code> to be intersected with
+     * this <code>Rectangle2D</code>
+     * @return the largest <code>Rectangle2D</code> contained in both
+     *          the specified <code>Rectangle2D</code> and in this
+     *          <code>Rectangle2D</code>.
+     * @since 1.2
+     */
+    public abstract Rectangle2D createIntersection(Rectangle2D r);
+
+    /**
+     * Intersects the pair of specified source <code>Rectangle2D</code>
+     * objects and puts the result into the specified destination
+     * <code>Rectangle2D</code> object.  One of the source rectangles
+     * can also be the destination to avoid creating a third Rectangle2D
+     * object, but in this case the original points of this source
+     * rectangle will be overwritten by this method.
+     * @param src1 the first of a pair of <code>Rectangle2D</code>
+     * objects to be intersected with each other
+     * @param src2 the second of a pair of <code>Rectangle2D</code>
+     * objects to be intersected with each other
+     * @param dest the <code>Rectangle2D</code> that holds the
+     * results of the intersection of <code>src1</code> and
+     * <code>src2</code>
+     * @since 1.2
+     */
+    public static void intersect(Rectangle2D src1,
+                                 Rectangle2D src2,
+                                 Rectangle2D dest) {
+        double x1 = Math.max(src1.getMinX(), src2.getMinX());
+        double y1 = Math.max(src1.getMinY(), src2.getMinY());
+        double x2 = Math.min(src1.getMaxX(), src2.getMaxX());
+        double y2 = Math.min(src1.getMaxY(), src2.getMaxY());
+        dest.setFrame(x1, y1, x2-x1, y2-y1);
+    }
+
+    /**
+     * Returns a new <code>Rectangle2D</code> object representing the
+     * union of this <code>Rectangle2D</code> with the specified
+     * <code>Rectangle2D</code>.
+     * @param r the <code>Rectangle2D</code> to be combined with
+     * this <code>Rectangle2D</code>
+     * @return the smallest <code>Rectangle2D</code> containing both
+     * the specified <code>Rectangle2D</code> and this
+     * <code>Rectangle2D</code>.
+     * @since 1.2
+     */
+    public abstract Rectangle2D createUnion(Rectangle2D r);
+
+    /**
+     * Unions the pair of source <code>Rectangle2D</code> objects
+     * and puts the result into the specified destination
+     * <code>Rectangle2D</code> object.  One of the source rectangles
+     * can also be the destination to avoid creating a third Rectangle2D
+     * object, but in this case the original points of this source
+     * rectangle will be overwritten by this method.
+     * @param src1 the first of a pair of <code>Rectangle2D</code>
+     * objects to be combined with each other
+     * @param src2 the second of a pair of <code>Rectangle2D</code>
+     * objects to be combined with each other
+     * @param dest the <code>Rectangle2D</code> that holds the
+     * results of the union of <code>src1</code> and
+     * <code>src2</code>
+     * @since 1.2
+     */
+    public static void union(Rectangle2D src1,
+                             Rectangle2D src2,
+                             Rectangle2D dest) {
+        double x1 = Math.min(src1.getMinX(), src2.getMinX());
+        double y1 = Math.min(src1.getMinY(), src2.getMinY());
+        double x2 = Math.max(src1.getMaxX(), src2.getMaxX());
+        double y2 = Math.max(src1.getMaxY(), src2.getMaxY());
+        dest.setFrameFromDiagonal(x1, y1, x2, y2);
+    }
+
+    /**
+     * Adds a point, specified by the double precision arguments
+     * <code>newx</code> and <code>newy</code>, to this
+     * <code>Rectangle2D</code>.  The resulting <code>Rectangle2D</code>
+     * is the smallest <code>Rectangle2D</code> that
+     * contains both the original <code>Rectangle2D</code> and the
+     * specified point.
+     * <p>
+     * After adding a point, a call to <code>contains</code> with the
+     * added point as an argument does not necessarily return
+     * <code>true</code>. The <code>contains</code> method does not
+     * return <code>true</code> for points on the right or bottom
+     * edges of a rectangle. Therefore, if the added point falls on
+     * the left or bottom edge of the enlarged rectangle,
+     * <code>contains</code> returns <code>false</code> for that point.
+     * @param newx the X coordinate of the new point
+     * @param newy the Y coordinate of the new point
+     * @since 1.2
+     */
+    public void add(double newx, double newy) {
+        double x1 = Math.min(getMinX(), newx);
+        double x2 = Math.max(getMaxX(), newx);
+        double y1 = Math.min(getMinY(), newy);
+        double y2 = Math.max(getMaxY(), newy);
+        setRect(x1, y1, x2 - x1, y2 - y1);
+    }
+
+    /**
+     * Adds the <code>Point2D</code> object <code>pt</code> to this
+     * <code>Rectangle2D</code>.
+     * The resulting <code>Rectangle2D</code> is the smallest
+     * <code>Rectangle2D</code> that contains both the original
+     * <code>Rectangle2D</code> and the specified <code>Point2D</code>.
+     * <p>
+     * After adding a point, a call to <code>contains</code> with the
+     * added point as an argument does not necessarily return
+     * <code>true</code>. The <code>contains</code>
+     * method does not return <code>true</code> for points on the right
+     * or bottom edges of a rectangle. Therefore, if the added point falls
+     * on the left or bottom edge of the enlarged rectangle,
+     * <code>contains</code> returns <code>false</code> for that point.
+     * @param     pt the new <code>Point2D</code> to add to this
+     * <code>Rectangle2D</code>.
+     * @since 1.2
+     */
+    public void add(Point2D pt) {
+        add(pt.getX(), pt.getY());
+    }
+
+    /**
+     * Adds a <code>Rectangle2D</code> object to this
+     * <code>Rectangle2D</code>.  The resulting <code>Rectangle2D</code>
+     * is the union of the two <code>Rectangle2D</code> objects.
+     * @param r the <code>Rectangle2D</code> to add to this
+     * <code>Rectangle2D</code>.
+     * @since 1.2
+     */
+    public void add(Rectangle2D r) {
+        double x1 = Math.min(getMinX(), r.getMinX());
+        double x2 = Math.max(getMaxX(), r.getMaxX());
+        double y1 = Math.min(getMinY(), r.getMinY());
+        double y2 = Math.max(getMaxY(), r.getMaxY());
+        setRect(x1, y1, x2 - x1, y2 - y1);
+    }
+
+    /**
+     * Returns an iteration object that defines the boundary of this
+     * <code>Rectangle2D</code>.
+     * The iterator for this class is multi-threaded safe, which means
+     * that this <code>Rectangle2D</code> class guarantees that
+     * modifications to the geometry of this <code>Rectangle2D</code>
+     * object do not affect any iterations of that geometry that
+     * are already in process.
+     * @param at an optional <code>AffineTransform</code> to be applied to
+     * the coordinates as they are returned in the iteration, or
+     * <code>null</code> if untransformed coordinates are desired
+     * @return    the <code>PathIterator</code> object that returns the
+     *          geometry of the outline of this
+     *          <code>Rectangle2D</code>, one segment at a time.
+     * @since 1.2
+     */
+/*    public PathIterator getPathIterator(AffineTransform at) {
+        return new RectIterator(this, at);
+    }
+*/
+    /**
+     * Returns an iteration object that defines the boundary of the
+     * flattened <code>Rectangle2D</code>.  Since rectangles are already
+     * flat, the <code>flatness</code> parameter is ignored.
+     * The iterator for this class is multi-threaded safe, which means
+     * that this <code>Rectangle2D</code> class guarantees that
+     * modifications to the geometry of this <code>Rectangle2D</code>
+     * object do not affect any iterations of that geometry that
+     * are already in process.
+     * @param at an optional <code>AffineTransform</code> to be applied to
+     * the coordinates as they are returned in the iteration, or
+     * <code>null</code> if untransformed coordinates are desired
+     * @param flatness the maximum distance that the line segments used to
+     * approximate the curved segments are allowed to deviate from any
+     * point on the original curve.  Since rectangles are already flat,
+     * the <code>flatness</code> parameter is ignored.
+     * @return    the <code>PathIterator</code> object that returns the
+     *          geometry of the outline of this
+     *          <code>Rectangle2D</code>, one segment at a time.
+     * @since 1.2
+     */
+/*    public PathIterator getPathIterator(AffineTransform at, double flatness) {
+        return new RectIterator(this, at);
+    }
+*/
+    /**
+     * Returns the hashcode for this <code>Rectangle2D</code>.
+     * @return the hashcode for this <code>Rectangle2D</code>.
+     * @since 1.2
+     */
+    public int hashCode() {
+        long bits = java.lang.Double.doubleToLongBits(getX());
+        bits += java.lang.Double.doubleToLongBits(getY()) * 37;
+        bits += java.lang.Double.doubleToLongBits(getWidth()) * 43;
+        bits += java.lang.Double.doubleToLongBits(getHeight()) * 47;
+        return (((int) bits) ^ ((int) (bits >> 32)));
+    }
+
+    /**
+     * Determines whether or not the specified <code>Object</code> is
+     * equal to this <code>Rectangle2D</code>.  The specified
+     * <code>Object</code> is equal to this <code>Rectangle2D</code>
+     * if it is an instance of <code>Rectangle2D</code> and if its
+     * location and size are the same as this <code>Rectangle2D</code>.
+     * @param obj an <code>Object</code> to be compared with this
+     * <code>Rectangle2D</code>.
+     * @return     <code>true</code> if <code>obj</code> is an instance
+     *                     of <code>Rectangle2D</code> and has
+     *                     the same values; <code>false</code> otherwise.
+     * @since 1.2
+     */
+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+        if (obj instanceof Rectangle2D) {
+            Rectangle2D r2d = (Rectangle2D) obj;
+            return ((getX() == r2d.getX()) &&
+                    (getY() == r2d.getY()) &&
+                    (getWidth() == r2d.getWidth()) &&
+                    (getHeight() == r2d.getHeight()));
+        }
+        return false;
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/RectangularShape.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/RectangularShape.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/RectangularShape.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/RectangularShape.java	2010-05-18 17:18:26.000000000 -0400
@@ -0,0 +1,395 @@
+/*
+ * Copyright 1997-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.geom;
+
+import java.awt.Shape;
+import java.awt.Rectangle;
+
+/**
+ * <code>RectangularShape</code> is the base class for a number of
+ * {@link Shape} objects whose geometry is defined by a rectangular frame.
+ * This class does not directly specify any specific geometry by
+ * itself, but merely provides manipulation methods inherited by
+ * a whole category of <code>Shape</code> objects.
+ * The manipulation methods provided by this class can be used to
+ * query and modify the rectangular frame, which provides a reference
+ * for the subclasses to define their geometry.
+ *
+ * @author      Jim Graham
+ * @since 1.2
+ */
+public abstract class RectangularShape implements Shape, Cloneable {
+
+    /**
+     * This is an abstract class that cannot be instantiated directly.
+     *
+     * @see Arc2D
+     * @see Ellipse2D
+     * @see Rectangle2D
+     * @see RoundRectangle2D
+     * @since 1.2
+     */
+    protected RectangularShape() {
+    }
+
+    /**
+     * Returns the X coordinate of the upper-left corner of
+     * the framing rectangle in <code>double</code> precision.
+     * @return the X coordinate of the upper-left corner of
+     * the framing rectangle.
+     * @since 1.2
+     */
+    public abstract double getX();
+
+    /**
+     * Returns the Y coordinate of the upper-left corner of
+     * the framing rectangle in <code>double</code> precision.
+     * @return the Y coordinate of the upper-left corner of
+     * the framing rectangle.
+     * @since 1.2
+     */
+    public abstract double getY();
+
+    /**
+     * Returns the width of the framing rectangle in
+     * <code>double</code> precision.
+     * @return the width of the framing rectangle.
+     * @since 1.2
+     */
+    public abstract double getWidth();
+
+    /**
+     * Returns the height of the framing rectangle
+     * in <code>double</code> precision.
+     * @return the height of the framing rectangle.
+     * @since 1.2
+     */
+    public abstract double getHeight();
+
+    /**
+     * Returns the smallest X coordinate of the framing
+     * rectangle of the <code>Shape</code> in <code>double</code>
+     * precision.
+     * @return the smallest X coordinate of the framing
+     *          rectangle of the <code>Shape</code>.
+     * @since 1.2
+     */
+    public double getMinX() {
+        return getX();
+    }
+
+    /**
+     * Returns the smallest Y coordinate of the framing
+     * rectangle of the <code>Shape</code> in <code>double</code>
+     * precision.
+     * @return the smallest Y coordinate of the framing
+     *          rectangle of the <code>Shape</code>.
+     * @since 1.2
+     */
+    public double getMinY() {
+        return getY();
+    }
+
+    /**
+     * Returns the largest X coordinate of the framing
+     * rectangle of the <code>Shape</code> in <code>double</code>
+     * precision.
+     * @return the largest X coordinate of the framing
+     *          rectangle of the <code>Shape</code>.
+     * @since 1.2
+     */
+    public double getMaxX() {
+        return getX() + getWidth();
+    }
+
+    /**
+     * Returns the largest Y coordinate of the framing
+     * rectangle of the <code>Shape</code> in <code>double</code>
+     * precision.
+     * @return the largest Y coordinate of the framing
+     *          rectangle of the <code>Shape</code>.
+     * @since 1.2
+     */
+    public double getMaxY() {
+        return getY() + getHeight();
+    }
+
+    /**
+     * Returns the X coordinate of the center of the framing
+     * rectangle of the <code>Shape</code> in <code>double</code>
+     * precision.
+     * @return the X coordinate of the center of the framing rectangle
+     *          of the <code>Shape</code>.
+     * @since 1.2
+     */
+    public double getCenterX() {
+        return getX() + getWidth() / 2.0;
+    }
+
+    /**
+     * Returns the Y coordinate of the center of the framing
+     * rectangle of the <code>Shape</code> in <code>double</code>
+     * precision.
+     * @return the Y coordinate of the center of the framing rectangle
+     *          of the <code>Shape</code>.
+     * @since 1.2
+     */
+    public double getCenterY() {
+        return getY() + getHeight() / 2.0;
+    }
+
+    /**
+     * Returns the framing {@link Rectangle2D}
+     * that defines the overall shape of this object.
+     * @return a <code>Rectangle2D</code>, specified in
+     * <code>double</code> coordinates.
+     * @see #setFrame(double, double, double, double)
+     * @see #setFrame(Point2D, Dimension2D)
+     * @see #setFrame(Rectangle2D)
+     * @since 1.2
+     */
+    public Rectangle2D getFrame() {
+        return new Rectangle2D.Double(getX(), getY(), getWidth(), getHeight());
+    }
+
+    /**
+     * Determines whether the <code>RectangularShape</code> is empty.
+     * When the <code>RectangularShape</code> is empty, it encloses no
+     * area.
+     * @return <code>true</code> if the <code>RectangularShape</code> is empty;
+     *          <code>false</code> otherwise.
+     * @since 1.2
+     */
+    public abstract boolean isEmpty();
+
+    /**
+     * Sets the location and size of the framing rectangle of this
+     * <code>Shape</code> to the specified rectangular values.
+     *
+     * @param x the X coordinate of the upper-left corner of the
+     *          specified rectangular shape
+     * @param y the Y coordinate of the upper-left corner of the
+     *          specified rectangular shape
+     * @param w the width of the specified rectangular shape
+     * @param h the height of the specified rectangular shape
+     * @see #getFrame
+     * @since 1.2
+     */
+    public abstract void setFrame(double x, double y, double w, double h);
+
+    /**
+     * Sets the location and size of the framing rectangle of this
+     * <code>Shape</code> to the specified {@link Point2D} and
+     * {@link Dimension2D}, respectively.  The framing rectangle is used
+     * by the subclasses of <code>RectangularShape</code> to define
+     * their geometry.
+     * @param loc the specified <code>Point2D</code>
+     * @param size the specified <code>Dimension2D</code>
+     * @see #getFrame
+     * @since 1.2
+     */
+    public void setFrame(Point2D loc, Dimension2D size) {
+        setFrame(loc.getX(), loc.getY(), size.getWidth(), size.getHeight());
+    }
+
+    /**
+     * Sets the framing rectangle of this <code>Shape</code> to
+     * be the specified <code>Rectangle2D</code>.  The framing rectangle is
+     * used by the subclasses of <code>RectangularShape</code> to define
+     * their geometry.
+     * @param r the specified <code>Rectangle2D</code>
+     * @see #getFrame
+     * @since 1.2
+     */
+    public void setFrame(Rectangle2D r) {
+        setFrame(r.getX(), r.getY(), r.getWidth(), r.getHeight());
+    }
+
+    /**
+     * Sets the diagonal of the framing rectangle of this <code>Shape</code>
+     * based on the two specified coordinates.  The framing rectangle is
+     * used by the subclasses of <code>RectangularShape</code> to define
+     * their geometry.
+     *
+     * @param x1 the X coordinate of the start point of the specified diagonal
+     * @param y1 the Y coordinate of the start point of the specified diagonal
+     * @param x2 the X coordinate of the end point of the specified diagonal
+     * @param y2 the Y coordinate of the end point of the specified diagonal
+     * @since 1.2
+     */
+    public void setFrameFromDiagonal(double x1, double y1,
+                                     double x2, double y2) {
+        if (x2 < x1) {
+            double t = x1;
+            x1 = x2;
+            x2 = t;
+        }
+        if (y2 < y1) {
+            double t = y1;
+            y1 = y2;
+            y2 = t;
+        }
+        setFrame(x1, y1, x2 - x1, y2 - y1);
+    }
+
+    /**
+     * Sets the diagonal of the framing rectangle of this <code>Shape</code>
+     * based on two specified <code>Point2D</code> objects.  The framing
+     * rectangle is used by the subclasses of <code>RectangularShape</code>
+     * to define their geometry.
+     *
+     * @param p1 the start <code>Point2D</code> of the specified diagonal
+     * @param p2 the end <code>Point2D</code> of the specified diagonal
+     * @since 1.2
+     */
+    public void setFrameFromDiagonal(Point2D p1, Point2D p2) {
+        setFrameFromDiagonal(p1.getX(), p1.getY(), p2.getX(), p2.getY());
+    }
+
+    /**
+     * Sets the framing rectangle of this <code>Shape</code>
+     * based on the specified center point coordinates and corner point
+     * coordinates.  The framing rectangle is used by the subclasses of
+     * <code>RectangularShape</code> to define their geometry.
+     *
+     * @param centerX the X coordinate of the specified center point
+     * @param centerY the Y coordinate of the specified center point
+     * @param cornerX the X coordinate of the specified corner point
+     * @param cornerY the Y coordinate of the specified corner point
+     * @since 1.2
+     */
+    public void setFrameFromCenter(double centerX, double centerY,
+                                   double cornerX, double cornerY) {
+        double halfW = Math.abs(cornerX - centerX);
+        double halfH = Math.abs(cornerY - centerY);
+        setFrame(centerX - halfW, centerY - halfH, halfW * 2.0, halfH * 2.0);
+    }
+
+    /**
+     * Sets the framing rectangle of this <code>Shape</code> based on a
+     * specified center <code>Point2D</code> and corner
+     * <code>Point2D</code>.  The framing rectangle is used by the subclasses
+     * of <code>RectangularShape</code> to define their geometry.
+     * @param center the specified center <code>Point2D</code>
+     * @param corner the specified corner <code>Point2D</code>
+     * @since 1.2
+     */
+    public void setFrameFromCenter(Point2D center, Point2D corner) {
+        setFrameFromCenter(center.getX(), center.getY(),
+                           corner.getX(), corner.getY());
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public boolean contains(Point2D p) {
+        return contains(p.getX(), p.getY());
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public boolean intersects(Rectangle2D r) {
+        return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public boolean contains(Rectangle2D r) {
+        return contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public Rectangle getBounds() {
+        double width = getWidth();
+        double height = getHeight();
+        if (width < 0 || height < 0) {
+            return new Rectangle();
+        }
+        double x = getX();
+        double y = getY();
+        double x1 = Math.floor(x);
+        double y1 = Math.floor(y);
+        double x2 = Math.ceil(x + width);
+        double y2 = Math.ceil(y + height);
+        return new Rectangle((int) x1, (int) y1,
+                                      (int) (x2 - x1), (int) (y2 - y1));
+    }
+
+    /**
+     * Returns an iterator object that iterates along the
+     * <code>Shape</code> object's boundary and provides access to a
+     * flattened view of the outline of the <code>Shape</code>
+     * object's geometry.
+     * <p>
+     * Only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types will
+     * be returned by the iterator.
+     * <p>
+     * The amount of subdivision of the curved segments is controlled
+     * by the <code>flatness</code> parameter, which specifies the
+     * maximum distance that any point on the unflattened transformed
+     * curve can deviate from the returned flattened path segments.
+     * An optional {@link AffineTransform} can
+     * be specified so that the coordinates returned in the iteration are
+     * transformed accordingly.
+     * @param at an optional <code>AffineTransform</code> to be applied to the
+     *          coordinates as they are returned in the iteration,
+     *          or <code>null</code> if untransformed coordinates are desired.
+     * @param flatness the maximum distance that the line segments used to
+     *          approximate the curved segments are allowed to deviate
+     *          from any point on the original curve
+     * @return a <code>PathIterator</code> object that provides access to
+     *          the <code>Shape</code> object's flattened geometry.
+     * @since 1.2
+     */
+/*    public PathIterator getPathIterator(AffineTransform at, double flatness) {
+        return new FlatteningPathIterator(getPathIterator(at), flatness);
+    }
+*/
+    /**
+     * Creates a new object of the same class and with the same
+     * contents as this object.
+     * @return     a clone of this instance.
+     * @exception  OutOfMemoryError            if there is not enough memory.
+     * @see        java.lang.Cloneable
+     * @since      1.2
+     */
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch (CloneNotSupportedException e) {
+            // this shouldn't happen, since we are Cloneable
+            throw new InternalError();
+        }
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/RoundRectangle2D.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/RoundRectangle2D.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/RoundRectangle2D.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/geom/RoundRectangle2D.java	2010-05-19 14:49:30.000000000 -0400
@@ -0,0 +1,681 @@
+/*
+ * Copyright 1997-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.geom;
+
+import java.io.Serializable;
+
+/**
+ * The <code>RoundRectangle2D</code> class defines a rectangle with
+ * rounded corners defined by a location {@code (x,y)}, a
+ * dimension {@code (w x h)}, and the width and height of an arc
+ * with which to round the corners.
+ * <p>
+ * This class is the abstract superclass for all objects that
+ * store a 2D rounded rectangle.
+ * The actual storage representation of the coordinates is left to
+ * the subclass.
+ *
+ * @author      Jim Graham
+ * @since 1.2
+ */
+public abstract class RoundRectangle2D extends RectangularShape {
+
+    /**
+     * The <code>Float</code> class defines a rectangle with rounded
+     * corners all specified in <code>float</code> coordinates.
+     * @since 1.2
+     */
+    public static class Float extends RoundRectangle2D
+        implements Serializable
+    {
+        /**
+         * The X coordinate of this <code>RoundRectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public float x;
+
+        /**
+         * The Y coordinate of this <code>RoundRectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public float y;
+
+        /**
+         * The width of this <code>RoundRectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public float width;
+
+        /**
+         * The height of this <code>RoundRectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public float height;
+
+        /**
+         * The width of the arc that rounds off the corners.
+         * @since 1.2
+         * @serial
+         */
+        public float arcwidth;
+
+        /**
+         * The height of the arc that rounds off the corners.
+         * @since 1.2
+         * @serial
+         */
+        public float archeight;
+
+        /**
+         * Constructs a new <code>RoundRectangle2D</code>, initialized to
+         * location (0.0,&nbsp;0.0), size (0.0,&nbsp;0.0), and corner arcs
+         * of radius 0.0.
+         * @since 1.2
+         */
+        public Float() {
+        }
+
+        /**
+         * Constructs and initializes a <code>RoundRectangle2D</code>
+         * from the specified <code>float</code> coordinates.
+         *
+         * @param x the X coordinate of the newly
+         *          constructed <code>RoundRectangle2D</code>
+         * @param y the Y coordinate of the newly
+         *          constructed <code>RoundRectangle2D</code>
+         * @param w the width to which to set the newly
+         *          constructed <code>RoundRectangle2D</code>
+         * @param h the height to which to set the newly
+         *          constructed <code>RoundRectangle2D</code>
+         * @param arcw the width of the arc to use to round off the
+         *             corners of the newly constructed
+         *             <code>RoundRectangle2D</code>
+         * @param arch the height of the arc to use to round off the
+         *             corners of the newly constructed
+         *             <code>RoundRectangle2D</code>
+         * @since 1.2
+         */
+        public Float(float x, float y, float w, float h,
+                     float arcw, float arch)
+        {
+            setRoundRect(x, y, w, h, arcw, arch);
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getX() {
+            return (double) x;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getY() {
+            return (double) y;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getWidth() {
+            return (double) width;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getHeight() {
+            return (double) height;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getArcWidth() {
+            return (double) arcwidth;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getArcHeight() {
+            return (double) archeight;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public boolean isEmpty() {
+            return (width <= 0.0f) || (height <= 0.0f);
+        }
+
+        /**
+         * Sets the location, size, and corner radii of this
+         * <code>RoundRectangle2D</code> to the specified
+         * <code>float</code> values.
+         *
+         * @param x the X coordinate to which to set the
+         *          location of this <code>RoundRectangle2D</code>
+         * @param y the Y coordinate to which to set the
+         *          location of this <code>RoundRectangle2D</code>
+         * @param w the width to which to set this
+         *          <code>RoundRectangle2D</code>
+         * @param h the height to which to set this
+         *          <code>RoundRectangle2D</code>
+         * @param arcw the width to which to set the arc of this
+         *             <code>RoundRectangle2D</code>
+         * @param arch the height to which to set the arc of this
+         *             <code>RoundRectangle2D</code>
+         * @since 1.2
+         */
+        public void setRoundRect(float x, float y, float w, float h,
+                                 float arcw, float arch)
+        {
+            this.x = x;
+            this.y = y;
+            this.width = w;
+            this.height = h;
+            this.arcwidth = arcw;
+            this.archeight = arch;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public void setRoundRect(double x, double y, double w, double h,
+                                 double arcw, double arch)
+        {
+            this.x = (float) x;
+            this.y = (float) y;
+            this.width = (float) w;
+            this.height = (float) h;
+            this.arcwidth = (float) arcw;
+            this.archeight = (float) arch;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public void setRoundRect(RoundRectangle2D rr) {
+            this.x = (float) rr.getX();
+            this.y = (float) rr.getY();
+            this.width = (float) rr.getWidth();
+            this.height = (float) rr.getHeight();
+            this.arcwidth = (float) rr.getArcWidth();
+            this.archeight = (float) rr.getArcHeight();
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public Rectangle2D getBounds2D() {
+            return new Rectangle2D.Float(x, y, width, height);
+        }
+
+        /*
+         * JDK 1.6 serialVersionUID
+         */
+        private static final long serialVersionUID = -3423150618393866922L;
+    }
+
+    /**
+     * The <code>Double</code> class defines a rectangle with rounded
+     * corners all specified in <code>double</code> coordinates.
+     * @since 1.2
+     */
+    public static class Double extends RoundRectangle2D
+        implements Serializable
+    {
+        /**
+         * The X coordinate of this <code>RoundRectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public double x;
+
+        /**
+         * The Y coordinate of this <code>RoundRectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public double y;
+
+        /**
+         * The width of this <code>RoundRectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public double width;
+
+        /**
+         * The height of this <code>RoundRectangle2D</code>.
+         * @since 1.2
+         * @serial
+         */
+        public double height;
+
+        /**
+         * The width of the arc that rounds off the corners.
+         * @since 1.2
+         * @serial
+         */
+        public double arcwidth;
+
+        /**
+         * The height of the arc that rounds off the corners.
+         * @since 1.2
+         * @serial
+         */
+        public double archeight;
+
+        /**
+         * Constructs a new <code>RoundRectangle2D</code>, initialized to
+         * location (0.0,&nbsp;0.0), size (0.0,&nbsp;0.0), and corner arcs
+         * of radius 0.0.
+         * @since 1.2
+         */
+        public Double() {
+        }
+
+        /**
+         * Constructs and initializes a <code>RoundRectangle2D</code>
+         * from the specified <code>double</code> coordinates.
+         *
+         * @param x the X coordinate of the newly
+         *          constructed <code>RoundRectangle2D</code>
+         * @param y the Y coordinate of the newly
+         *          constructed <code>RoundRectangle2D</code>
+         * @param w the width to which to set the newly
+         *          constructed <code>RoundRectangle2D</code>
+         * @param h the height to which to set the newly
+         *          constructed <code>RoundRectangle2D</code>
+         * @param arcw the width of the arc to use to round off the
+         *             corners of the newly constructed
+         *             <code>RoundRectangle2D</code>
+         * @param arch the height of the arc to use to round off the
+         *             corners of the newly constructed
+         *             <code>RoundRectangle2D</code>
+         * @since 1.2
+         */
+        public Double(double x, double y, double w, double h,
+                      double arcw, double arch)
+        {
+            setRoundRect(x, y, w, h, arcw, arch);
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getX() {
+            return x;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getY() {
+            return y;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getWidth() {
+            return width;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getHeight() {
+            return height;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getArcWidth() {
+            return arcwidth;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public double getArcHeight() {
+            return archeight;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public boolean isEmpty() {
+            return (width <= 0.0f) || (height <= 0.0f);
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public void setRoundRect(double x, double y, double w, double h,
+                                 double arcw, double arch)
+        {
+            this.x = x;
+            this.y = y;
+            this.width = w;
+            this.height = h;
+            this.arcwidth = arcw;
+            this.archeight = arch;
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public void setRoundRect(RoundRectangle2D rr) {
+            this.x = rr.getX();
+            this.y = rr.getY();
+            this.width = rr.getWidth();
+            this.height = rr.getHeight();
+            this.arcwidth = rr.getArcWidth();
+            this.archeight = rr.getArcHeight();
+        }
+
+        /**
+         * {@inheritDoc}
+         * @since 1.2
+         */
+        public Rectangle2D getBounds2D() {
+            return new Rectangle2D.Double(x, y, width, height);
+        }
+
+        /*
+         * JDK 1.6 serialVersionUID
+         */
+        private static final long serialVersionUID = 1048939333485206117L;
+    }
+
+    /**
+     * This is an abstract class that cannot be instantiated directly.
+     * Type-specific implementation subclasses are available for
+     * instantiation and provide a number of formats for storing
+     * the information necessary to satisfy the various accessor
+     * methods below.
+     *
+     * @see java.awt.geom.RoundRectangle2D.Float
+     * @see java.awt.geom.RoundRectangle2D.Double
+     * @since 1.2
+     */
+    protected RoundRectangle2D() {
+    }
+
+    /**
+     * Gets the width of the arc that rounds off the corners.
+     * @return the width of the arc that rounds off the corners
+     * of this <code>RoundRectangle2D</code>.
+     * @since 1.2
+     */
+    public abstract double getArcWidth();
+
+    /**
+     * Gets the height of the arc that rounds off the corners.
+     * @return the height of the arc that rounds off the corners
+     * of this <code>RoundRectangle2D</code>.
+     * @since 1.2
+     */
+    public abstract double getArcHeight();
+
+    /**
+     * Sets the location, size, and corner radii of this
+     * <code>RoundRectangle2D</code> to the specified
+     * <code>double</code> values.
+     *
+     * @param x the X coordinate to which to set the
+     *          location of this <code>RoundRectangle2D</code>
+     * @param y the Y coordinate to which to set the
+     *          location of this <code>RoundRectangle2D</code>
+     * @param w the width to which to set this
+     *          <code>RoundRectangle2D</code>
+     * @param h the height to which to set this
+     *          <code>RoundRectangle2D</code>
+     * @param arcWidth the width to which to set the arc of this
+     *                 <code>RoundRectangle2D</code>
+     * @param arcHeight the height to which to set the arc of this
+     *                  <code>RoundRectangle2D</code>
+     * @since 1.2
+     */
+    public abstract void setRoundRect(double x, double y, double w, double h,
+                                      double arcWidth, double arcHeight);
+
+    /**
+     * Sets this <code>RoundRectangle2D</code> to be the same as the
+     * specified <code>RoundRectangle2D</code>.
+     * @param rr the specified <code>RoundRectangle2D</code>
+     * @since 1.2
+     */
+    public void setRoundRect(RoundRectangle2D rr) {
+        setRoundRect(rr.getX(), rr.getY(), rr.getWidth(), rr.getHeight(),
+                     rr.getArcWidth(), rr.getArcHeight());
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public void setFrame(double x, double y, double w, double h) {
+        setRoundRect(x, y, w, h, getArcWidth(), getArcHeight());
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public boolean contains(double x, double y) {
+        if (isEmpty()) {
+            return false;
+        }
+        double rrx0 = getX();
+        double rry0 = getY();
+        double rrx1 = rrx0 + getWidth();
+        double rry1 = rry0 + getHeight();
+        // Check for trivial rejection - point is outside bounding rectangle
+        if (x < rrx0 || y < rry0 || x >= rrx1 || y >= rry1) {
+            return false;
+        }
+        double aw = Math.min(getWidth(), Math.abs(getArcWidth())) / 2.0;
+        double ah = Math.min(getHeight(), Math.abs(getArcHeight())) / 2.0;
+        // Check which corner point is in and do circular containment
+        // test - otherwise simple acceptance
+        if (x >= (rrx0 += aw) && x < (rrx0 = rrx1 - aw)) {
+            return true;
+        }
+        if (y >= (rry0 += ah) && y < (rry0 = rry1 - ah)) {
+            return true;
+        }
+        x = (x - rrx0) / aw;
+        y = (y - rry0) / ah;
+        return (x * x + y * y <= 1.0);
+    }
+
+    private int classify(double coord, double left, double right,
+                         double arcsize)
+    {
+        if (coord < left) {
+            return 0;
+        } else if (coord < left + arcsize) {
+            return 1;
+        } else if (coord < right - arcsize) {
+            return 2;
+        } else if (coord < right) {
+            return 3;
+        } else {
+            return 4;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public boolean intersects(double x, double y, double w, double h) {
+        if (isEmpty() || w <= 0 || h <= 0) {
+            return false;
+        }
+        double rrx0 = getX();
+        double rry0 = getY();
+        double rrx1 = rrx0 + getWidth();
+        double rry1 = rry0 + getHeight();
+        // Check for trivial rejection - bounding rectangles do not intersect
+        if (x + w <= rrx0 || x >= rrx1 || y + h <= rry0 || y >= rry1) {
+            return false;
+        }
+        double aw = Math.min(getWidth(), Math.abs(getArcWidth())) / 2.0;
+        double ah = Math.min(getHeight(), Math.abs(getArcHeight())) / 2.0;
+        int x0class = classify(x, rrx0, rrx1, aw);
+        int x1class = classify(x + w, rrx0, rrx1, aw);
+        int y0class = classify(y, rry0, rry1, ah);
+        int y1class = classify(y + h, rry0, rry1, ah);
+        // Trivially accept if any point is inside inner rectangle
+        if (x0class == 2 || x1class == 2 || y0class == 2 || y1class == 2) {
+            return true;
+        }
+        // Trivially accept if either edge spans inner rectangle
+        if ((x0class < 2 && x1class > 2) || (y0class < 2 && y1class > 2)) {
+            return true;
+        }
+        // Since neither edge spans the center, then one of the corners
+        // must be in one of the rounded edges.  We detect this case if
+        // a [xy]0class is 3 or a [xy]1class is 1.  One of those two cases
+        // must be true for each direction.
+        // We now find a "nearest point" to test for being inside a rounded
+        // corner.
+        x = (x1class == 1) ? (x = x + w - (rrx0 + aw)) : (x = x - (rrx1 - aw));
+        y = (y1class == 1) ? (y = y + h - (rry0 + ah)) : (y = y - (rry1 - ah));
+        x = x / aw;
+        y = y / ah;
+        return (x * x + y * y <= 1.0);
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public boolean contains(double x, double y, double w, double h) {
+        if (isEmpty() || w <= 0 || h <= 0) {
+            return false;
+        }
+        return (contains(x, y) &&
+                contains(x + w, y) &&
+                contains(x, y + h) &&
+                contains(x + w, y + h));
+    }
+
+    /**
+     * Returns an iteration object that defines the boundary of this
+     * <code>RoundRectangle2D</code>.
+     * The iterator for this class is multi-threaded safe, which means
+     * that this <code>RoundRectangle2D</code> class guarantees that
+     * modifications to the geometry of this <code>RoundRectangle2D</code>
+     * object do not affect any iterations of that geometry that
+     * are already in process.
+     * @param at an optional <code>AffineTransform</code> to be applied to
+     * the coordinates as they are returned in the iteration, or
+     * <code>null</code> if untransformed coordinates are desired
+     * @return    the <code>PathIterator</code> object that returns the
+     *          geometry of the outline of this
+     *          <code>RoundRectangle2D</code>, one segment at a time.
+     * @since 1.2
+     */
+//    public PathIterator getPathIterator(AffineTransform at) {
+  //      return new RoundRectIterator(this, at);
+    //}
+
+    /**
+     * Returns the hashcode for this <code>RoundRectangle2D</code>.
+     * @return the hashcode for this <code>RoundRectangle2D</code>.
+     * @since 1.6
+     */
+    public int hashCode() {
+        long bits = java.lang.Double.doubleToLongBits(getX());
+        bits += java.lang.Double.doubleToLongBits(getY()) * 37;
+        bits += java.lang.Double.doubleToLongBits(getWidth()) * 43;
+        bits += java.lang.Double.doubleToLongBits(getHeight()) * 47;
+        bits += java.lang.Double.doubleToLongBits(getArcWidth()) * 53;
+        bits += java.lang.Double.doubleToLongBits(getArcHeight()) * 59;
+        return (((int) bits) ^ ((int) (bits >> 32)));
+    }
+
+    /**
+     * Determines whether or not the specified <code>Object</code> is
+     * equal to this <code>RoundRectangle2D</code>.  The specified
+     * <code>Object</code> is equal to this <code>RoundRectangle2D</code>
+     * if it is an instance of <code>RoundRectangle2D</code> and if its
+     * location, size, and corner arc dimensions are the same as this
+     * <code>RoundRectangle2D</code>.
+     * @param obj  an <code>Object</code> to be compared with this
+     *             <code>RoundRectangle2D</code>.
+     * @return  <code>true</code> if <code>obj</code> is an instance
+     *          of <code>RoundRectangle2D</code> and has the same values;
+     *          <code>false</code> otherwise.
+     * @since 1.6
+     */
+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+        if (obj instanceof RoundRectangle2D) {
+            RoundRectangle2D rr2d = (RoundRectangle2D) obj;
+            return ((getX() == rr2d.getX()) &&
+                    (getY() == rr2d.getY()) &&
+                    (getWidth() == rr2d.getWidth()) &&
+                    (getHeight() == rr2d.getHeight()) &&
+                    (getArcWidth() == rr2d.getArcWidth()) &&
+                    (getArcHeight() == rr2d.getArcHeight()));
+        }
+        return false;
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Insets.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Insets.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Insets.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Insets.java	2010-05-18 17:14:16.000000000 -0400
@@ -0,0 +1,126 @@
+/*
+ * @(#)Insets.java	1.22 06/10/10
+ *
+ * Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 only, as published by the Free Software Foundation. 
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License version 2 for more details (a copy is
+ * included at /legal/license.txt). 
+ * 
+ * You should have received a copy of the GNU General Public License
+ * version 2 along with this work; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA 
+ * 
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+ * Clara, CA 95054 or visit www.sun.com if you need additional
+ * information or have any questions. 
+ *
+ */
+
+package java.awt;
+
+/**
+ * An <code>Insets</code> object is a representation of the borders 
+ * of a container. It specifies the space that a container must leave 
+ * at each of its edges. The space can be a border, a blank space, or 
+ * a title. 
+ *
+ * @version 	1.18, 08/19/02
+ * @author 	Arthur van Hoff
+ * @author 	Sami Shaio
+ * @see         sage.awt.LayoutManager
+ * @see         sage.awt.Container
+ * @since       JDK1.0
+ */
+public class Insets implements Cloneable, java.io.Serializable {
+    /**
+     * The inset from the top.
+     * @since JDK1.0
+     */
+    public int top;
+    /**
+     * The inset from the left.
+     * @since JDK1.0
+     */
+    public int left;
+    /**
+     * The inset from the bottom.
+     * @since JDK1.0
+     */
+    public int bottom;
+    /**
+     * The inset from the right.
+     * @since JDK1.0
+     */
+    public int right;
+    /*
+     * JDK 1.1 serialVersionUID 
+     */
+    private static final long serialVersionUID = -2272572637695466749L;
+    /**
+     * Creates and initializes a new <code>Insets</code> object with the 
+     * specified top, left, bottom, and right insets. 
+     * @param       top   the inset from the top.
+     * @param       left   the inset from the left.
+     * @param       bottom   the inset from the bottom.
+     * @param       right   the inset from the right.
+     * @since       JDK1.0
+     */
+    public Insets(int top, int left, int bottom, int right) {
+        this.top = top;
+        this.left = left;
+        this.bottom = bottom;
+        this.right = right;
+    }
+
+    /**
+     * Checks whether two insets objects are equal. Two instances 
+     * of <code>Insets</code> are equal if the four integer values
+     * of the fields <code>top</code>, <code>left</code>, 
+     * <code>bottom</code>, and <code>right</code> are all equal.
+     * @return      <code>true</code> if the two insets are equal;
+     *                          otherwise <code>false</code>.
+     * @since       JDK1.1
+     */
+    public boolean equals(Object obj) {
+        if (obj instanceof Insets) {
+            Insets insets = (Insets) obj;
+            return ((top == insets.top) && (left == insets.left) &&
+                    (bottom == insets.bottom) && (right == insets.right));
+        }
+        return false;
+    }
+
+    /**
+     * Returns a <code>String</code> object representing this 
+     * <code>Insets</code> object's values.
+     * @return    a string representation of this <code>Insets</code> object, 
+     *                           including the values of its member fields.
+     * @since     JDK1.0
+     */
+    public String toString() {
+        return getClass().getName() + "[top=" + top + ",left=" + left + ",bottom=" + bottom + ",right=" + right + "]";
+    }
+
+    /**
+     * Create a copy of this object.
+     * @return     a copy of this <code>Insets</code> object.
+     * @since      JDK1.0
+     */
+    public Object clone() { 
+        try { 
+            return super.clone();
+        } catch (CloneNotSupportedException e) { 
+            // this shouldn't happen, since we are Cloneable
+            throw new InternalError();
+        }
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Panel.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Panel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Panel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Panel.java	2010-05-18 17:14:34.000000000 -0400
@@ -0,0 +1,23 @@
+package java.awt;
+
+public class Panel
+{
+public void setBounds(int x, int y, int width, int height)
+{
+this.x = x;
+this.y = y;
+this.width = width;
+this.height = height;
+}
+public int getX()
+{ return x; }
+public int getY()
+{ return y; }
+public int getHeight()
+{ return height; }
+public int getWidth()
+{ return width; }
+int x; int y; int width; int height;
+
+public java.awt.Dimension getSize() { return new java.awt.Dimension(width, height); }
+}
\ No newline at end of file
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Point.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Point.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Point.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Point.java	2010-05-04 18:43:11.000000000 -0400
@@ -0,0 +1,216 @@
+/*
+ * @(#)Point.java	1.23 06/10/10
+ *
+ * Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 only, as published by the Free Software Foundation. 
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License version 2 for more details (a copy is
+ * included at /legal/license.txt). 
+ * 
+ * You should have received a copy of the GNU General Public License
+ * version 2 along with this work; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA 
+ * 
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+ * Clara, CA 95054 or visit www.sun.com if you need additional
+ * information or have any questions. 
+ *
+ */
+package java.awt;
+
+/**
+ * The <code>Point</code> class represents a location in a
+ * two-dimensional (<i>x</i>,&nbsp;<i>y</i>) coordinate space.
+ *
+ * @version 	1.18, 08/19/02
+ * @author 	Sami Shaio
+ * @since       JDK1.0
+ */
+public class Point implements java.io.Serializable, Cloneable {
+    /**
+     * The <i>x</i> coordinate. 
+     * @since   JDK1.0
+     */
+    public int x;
+    /**
+     * The <i>y</i> coordinate. 
+     * @since   JDK1.0
+     */
+    public int y;
+    /*
+     * JDK 1.1 serialVersionUID 
+     */
+    private static final long serialVersionUID = -5276940640259749850L;
+    /**
+     * Constructs and initializes a point at the origin 
+     * (0,&nbsp;0) of the coordinate space. 
+     * @param       x   the <i>x</i> coordinate.
+     * @param       y   the <i>y</i> coordinate.
+     * @since       JDK1.1
+     */
+    public Point() {
+        this(0, 0);
+    }
+
+    /**
+     * Constructs and initializes a point with the same location as
+     * the specified <code>Point</code> object.
+     * @param       p a point.
+     * @since       JDK1.1
+     */
+    public Point(Point p) {
+        this(p.x, p.y);
+    }
+
+    /**
+     * Constructs and initializes a point at the specified 
+     * (<i>x</i>,&nbsp;<i>y</i>) location in the coordinate space. 
+     * @param       x   the <i>x</i> coordinate.
+     * @param       y   the <i>y</i> coordinate.
+     * @since       JDK1.0
+     */
+    public Point(int x, int y) {
+        this.x = x;
+        this.y = y;
+    }
+
+    /**
+     * Returns the location of this point.
+     * This method is included for completeness, to parallel the
+     * <code>getLocation</code> method of <code>Component</code>.
+     * @return      a copy of this point, at the same location.
+     * @see         sage.awt.Component#getLocation
+     * @see         sage.awt.Point#setLocation(sage.awt.Point)
+     * @see         sage.awt.Point#setLocation(int, int)
+     * @since       JDK1.1
+     */
+    public Point getLocation() {
+        return new Point(x, y);
+    }	
+
+    /**
+     * Sets the location of the point to the specificed location.
+     * This method is included for completeness, to parallel the
+     * <code>setLocation</code> method of <code>Component</code>.
+     * @param       p  a point, the new location for this point.
+     * @see         sage.awt.Component#setLocation(sage.awt.Point)
+     * @see         sage.awt.Point#getLocation
+     * @since       JDK1.1
+     */
+    public void setLocation(Point p) {
+        setLocation(p.x, p.y);
+    }	
+
+    /**
+     * Changes the point to have the specificed location.
+     * <p>
+     * This method is included for completeness, to parallel the
+     * <code>setLocation</code> method of <code>Component</code>.
+     * Its behavior is identical with <code>move(int,&nbsp;int)</code>.
+     * @param       x  the <i>x</i> coordinate of the new location.
+     * @param       y  the <i>y</i> coordinate of the new location.
+     * @see         sage.awt.Component#setLocation(int, int)
+     * @see         sage.awt.Point#getLocation
+     * @see         sage.awt.Point#move(int, int)
+     * @since       JDK1.1
+     */
+    public void setLocation(int x, int y) {
+        move(x, y);
+    }	
+
+    /**
+     * Moves this point to the specificed location in the 
+     * (<i>x</i>,&nbsp;<i>y</i>) coordinate plane. This method
+     * is identical with <code>setLocation(int,&nbsp;int)</code>.
+     * @param       x  the <i>x</i> coordinate of the new location.
+     * @param       y  the <i>y</i> coordinate of the new location.
+     * @see         sage.awt.Component#setLocation(int, int)
+     * @since       JDK1.0
+     */
+    public void move(int x, int y) {
+        this.x = x;
+        this.y = y;
+    }	
+
+    /**
+     * Translates this point, at location (<i>x</i>,&nbsp;<i>y</i>), 
+     * by <code>dx</code> along the <i>x</i> axis and <code>dy</code> 
+     * along the <i>y</i> axis so that it now represents the point 
+     * (<code>x</code>&nbsp;<code>+</code>&nbsp;<code>dx</code>, 
+     * <code>y</code>&nbsp;<code>+</code>&nbsp;<code>dy</code>). 
+     * @param       dx   the distance to move this point 
+     *                            along the <i>x</i> axis.
+     * @param       dy    the distance to move this point 
+     *                            along the <i>y</i> axis.
+     * @since       JDK1.0
+     */
+    public void translate(int x, int y) {
+        this.x += x;
+        this.y += y;
+    }	
+
+    /**
+     * Returns the hashcode for this point.
+     * @return      a hash code for this point.
+     * @since       JDK1.0
+     */
+    public int hashCode() {
+        return x ^ (y * 31);
+    }
+
+    /**
+     * Determines whether two points are equal. Two instances of
+     * <code>Point</code> are equal if the values of their 
+     * <code>x</code> and <code>y</code> member fields, representing
+     * their position in the coordinate space, are the same.
+     * @param      obj   an object to be compared with this point.
+     * @return     <code>true</code> if the object to be compared is
+     *                     an instance of <code>Point</code> and has
+     *                     the same values; <code>false</code> otherwise.
+     * @since      JDK1.0
+     */
+    public boolean equals(Object obj) {
+        if (obj instanceof Point) {
+            Point pt = (Point) obj;
+            return (x == pt.x) && (y == pt.y);
+        }
+        return false;
+    }
+
+    /**
+     * Returns a representation of this point and its location
+     * in the (<i>x</i>,&nbsp;<i>y</i>) coordinate space as a string.
+     * @return    a string representation of this point, 
+     *                 including the values of its member fields.
+     * @since     JDK1.0
+     */
+    public String toString() {
+        return getClass().getName() + "[x=" + x + ",y=" + y + "]";
+    }
+
+    /**
+     * Creates a new object of the same class and with the
+     * same contents as this object.
+     * @return     a clone of this instance.
+     * @exception  OutOfMemoryError            if there is not enough memory.
+     * @see        java.lang.Cloneable
+     * @since      1.2
+     */
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch (CloneNotSupportedException e) {
+            // this shouldn't happen, since we are Cloneable
+            throw new InternalError();
+        }
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Rectangle.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Rectangle.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Rectangle.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Rectangle.java	2010-05-21 15:42:04.000000000 -0400
@@ -0,0 +1,1197 @@
+/*
+ * Copyright 1995-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt;
+
+import java.awt.geom.Rectangle2D;
+
+/**
+ * A <code>Rectangle</code> specifies an area in a coordinate space that is
+ * enclosed by the <code>Rectangle</code> object's upper-left point
+ * {@code (x,y)}
+ * in the coordinate space, its width, and its height.
+ * <p>
+ * A <code>Rectangle</code> object's <code>width</code> and
+ * <code>height</code> are <code>public</code> fields. The constructors
+ * that create a <code>Rectangle</code>, and the methods that can modify
+ * one, do not prevent setting a negative value for width or height.
+ * <p>
+ * <a name="Empty">
+ * A {@code Rectangle} whose width or height is exactly zero has location
+ * along those axes with zero dimension, but is otherwise considered empty.
+ * The {@link #isEmpty} method will return true for such a {@code Rectangle}.
+ * Methods which test if an empty {@code Rectangle} contains or intersects
+ * a point or rectangle will always return false if either dimension is zero.
+ * Methods which combine such a {@code Rectangle} with a point or rectangle
+ * will include the location of the {@code Rectangle} on that axis in the
+ * result as if the {@link #add(Point)} method were being called.
+ * </a>
+ * <p>
+ * <a name="NonExistant">
+ * A {@code Rectangle} whose width or height is negative has neither
+ * location nor dimension along those axes with negative dimensions.
+ * Such a {@code Rectangle} is treated as non-existant along those axes.
+ * Such a {@code Rectangle} is also empty with respect to containment
+ * calculations and methods which test if it contains or intersects a
+ * point or rectangle will always return false.
+ * Methods which combine such a {@code Rectangle} with a point or rectangle
+ * will ignore the {@code Rectangle} entirely in generating the result.
+ * If two {@code Rectangle} objects are combined and each has a negative
+ * dimension, the result will have at least one negative dimension.
+ * </a>
+ * <p>
+ * Methods which affect only the location of a {@code Rectangle} will
+ * operate on its location regardless of whether or not it has a negative
+ * or zero dimension along either axis.
+ * <p>
+ * Note that a {@code Rectangle} constructed with the default no-argument
+ * constructor will have dimensions of {@code 0x0} and therefore be empty.
+ * That {@code Rectangle} will still have a location of {@code (0,0)} and
+ * will contribute that location to the union and add operations.
+ * Code attempting to accumulate the bounds of a set of points should
+ * therefore initially construct the {@code Rectangle} with a specifically
+ * negative width and height or it should use the first point in the set
+ * to construct the {@code Rectangle}.
+ * For example:
+ * <pre>
+ *     Rectangle bounds = new Rectangle(0, 0, -1, -1);
+ *     for (int i = 0; i < points.length; i++) {
+ *         bounds.add(points[i]);
+ *     }
+ * </pre>
+ * or if we know that the points array contains at least one point:
+ * <pre>
+ *     Rectangle bounds = new Rectangle(points[0]);
+ *     for (int i = 1; i < points.length; i++) {
+ *         bounds.add(points[i]);
+ *     }
+ * </pre>
+ * <p>
+ * This class uses 32-bit integers to store its location and dimensions.
+ * Frequently operations may produce a result that exceeds the range of
+ * a 32-bit integer.
+ * The methods will calculate their results in a way that avoids any
+ * 32-bit overflow for intermediate results and then choose the best
+ * representation to store the final results back into the 32-bit fields
+ * which hold the location and dimensions.
+ * The location of the result will be stored into the {@link #x} and
+ * {@link #y} fields by clipping the true result to the nearest 32-bit value.
+ * The values stored into the {@link #width} and {@link #height} dimension
+ * fields will be chosen as the 32-bit values that encompass the largest
+ * part of the true result as possible.
+ * Generally this means that the dimension will be clipped independently
+ * to the range of 32-bit integers except that if the location had to be
+ * moved to store it into its pair of 32-bit fields then the dimensions
+ * will be adjusted relative to the "best representation" of the location.
+ * If the true result had a negative dimension and was therefore
+ * non-existant along one or both axes, the stored dimensions will be
+ * negative numbers in those axes.
+ * If the true result had a location that could be represented within
+ * the range of 32-bit integers, but zero dimension along one or both
+ * axes, then the stored dimensions will be zero in those axes.
+ *
+ * @author      Sami Shaio
+ * @since 1.0
+ */
+public class Rectangle extends Rectangle2D
+    implements Shape, java.io.Serializable
+{
+
+    /**
+     * The X coordinate of the upper-left corner of the <code>Rectangle</code>.
+     *
+     * @serial
+     * @see #setLocation(int, int)
+     * @see #getLocation()
+     * @since 1.0
+     */
+    public int x;
+
+    /**
+     * The Y coordinate of the upper-left corner of the <code>Rectangle</code>.
+     *
+     * @serial
+     * @see #setLocation(int, int)
+     * @see #getLocation()
+     * @since 1.0
+     */
+    public int y;
+
+    /**
+     * The width of the <code>Rectangle</code>.
+     * @serial
+     * @see #setSize(int, int)
+     * @see #getSize()
+     * @since 1.0
+     */
+    public int width;
+
+    /**
+     * The height of the <code>Rectangle</code>.
+     *
+     * @serial
+     * @see #setSize(int, int)
+     * @see #getSize()
+     * @since 1.0
+     */
+    public int height;
+
+    /*
+     * JDK 1.1 serialVersionUID
+     */
+     private static final long serialVersionUID = -4345857070255674764L;
+
+    /**
+     * Constructs a new <code>Rectangle</code> whose upper-left corner
+     * is at (0,&nbsp;0) in the coordinate space, and whose width and
+     * height are both zero.
+     */
+    public Rectangle() {
+        this(0, 0, 0, 0);
+    }
+
+    /**
+     * Constructs a new <code>Rectangle</code>, initialized to match
+     * the values of the specified <code>Rectangle</code>.
+     * @param r  the <code>Rectangle</code> from which to copy initial values
+     *           to a newly constructed <code>Rectangle</code>
+     * @since 1.1
+     */
+    public Rectangle(Rectangle r) {
+        this(r.x, r.y, r.width, r.height);
+    }
+
+    /**
+     * Constructs a new <code>Rectangle</code> whose upper-left corner is
+     * specified as
+     * {@code (x,y)} and whose width and height
+     * are specified by the arguments of the same name.
+     * @param     x the specified X coordinate
+     * @param     y the specified Y coordinate
+     * @param     width    the width of the <code>Rectangle</code>
+     * @param     height   the height of the <code>Rectangle</code>
+     * @since 1.0
+     */
+    public Rectangle(int x, int y, int width, int height) {
+        this.x = x;
+        this.y = y;
+        this.width = width;
+        this.height = height;
+    }
+
+    /**
+     * Constructs a new <code>Rectangle</code> whose upper-left corner
+     * is at (0,&nbsp;0) in the coordinate space, and whose width and
+     * height are specified by the arguments of the same name.
+     * @param width the width of the <code>Rectangle</code>
+     * @param height the height of the <code>Rectangle</code>
+     */
+    public Rectangle(int width, int height) {
+        this(0, 0, width, height);
+    }
+
+    /**
+     * Constructs a new <code>Rectangle</code> whose upper-left corner is
+     * specified by the {@link Point} argument, and
+     * whose width and height are specified by the
+     * {@link Dimension} argument.
+     * @param p a <code>Point</code> that is the upper-left corner of
+     * the <code>Rectangle</code>
+     * @param d a <code>Dimension</code>, representing the
+     * width and height of the <code>Rectangle</code>
+     */
+    public Rectangle(Point p, Dimension d) {
+        this(p.x, p.y, d.width, d.height);
+    }
+
+    /**
+     * Constructs a new <code>Rectangle</code> whose upper-left corner is the
+     * specified <code>Point</code>, and whose width and height are both zero.
+     * @param p a <code>Point</code> that is the top left corner
+     * of the <code>Rectangle</code>
+     */
+    public Rectangle(Point p) {
+        this(p.x, p.y, 0, 0);
+    }
+
+    /**
+     * Constructs a new <code>Rectangle</code> whose top left corner is
+     * (0,&nbsp;0) and whose width and height are specified
+     * by the <code>Dimension</code> argument.
+     * @param d a <code>Dimension</code>, specifying width and height
+     */
+    public Rectangle(Dimension d) {
+        this(0, 0, d.width, d.height);
+    }
+
+    /**
+     * Returns the X coordinate of the bounding <code>Rectangle</code> in
+     * <code>double</code> precision.
+     * @return the X coordinate of the bounding <code>Rectangle</code>.
+     */
+    public double getX() {
+        return x;
+    }
+
+    /**
+     * Returns the Y coordinate of the bounding <code>Rectangle</code> in
+     * <code>double</code> precision.
+     * @return the Y coordinate of the bounding <code>Rectangle</code>.
+     */
+    public double getY() {
+        return y;
+    }
+
+    /**
+     * Returns the width of the bounding <code>Rectangle</code> in
+     * <code>double</code> precision.
+     * @return the width of the bounding <code>Rectangle</code>.
+     */
+    public double getWidth() {
+        return width;
+    }
+
+    /**
+     * Returns the height of the bounding <code>Rectangle</code> in
+     * <code>double</code> precision.
+     * @return the height of the bounding <code>Rectangle</code>.
+     */
+    public double getHeight() {
+        return height;
+    }
+
+    /**
+     * Gets the bounding <code>Rectangle</code> of this <code>Rectangle</code>.
+     * <p>
+     * This method is included for completeness, to parallel the
+     * <code>getBounds</code> method of
+     * {@link Component}.
+     * @return    a new <code>Rectangle</code>, equal to the
+     * bounding <code>Rectangle</code> for this <code>Rectangle</code>.
+     * @see       java.awt.Component#getBounds
+     * @see       #setBounds(Rectangle)
+     * @see       #setBounds(int, int, int, int)
+     * @since     1.1
+     */
+    public Rectangle getBounds() {
+        return new Rectangle(x, y, width, height);
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public Rectangle2D getBounds2D() {
+        return new Rectangle(x, y, width, height);
+    }
+
+    /**
+     * Sets the bounding <code>Rectangle</code> of this <code>Rectangle</code>
+     * to match the specified <code>Rectangle</code>.
+     * <p>
+     * This method is included for completeness, to parallel the
+     * <code>setBounds</code> method of <code>Component</code>.
+     * @param r the specified <code>Rectangle</code>
+     * @see       #getBounds
+     * @see       java.awt.Component#setBounds(java.awt.Rectangle)
+     * @since     1.1
+     */
+    public void setBounds(Rectangle r) {
+        setBounds(r.x, r.y, r.width, r.height);
+    }
+
+    /**
+     * Sets the bounding <code>Rectangle</code> of this
+     * <code>Rectangle</code> to the specified
+     * <code>x</code>, <code>y</code>, <code>width</code>,
+     * and <code>height</code>.
+     * <p>
+     * This method is included for completeness, to parallel the
+     * <code>setBounds</code> method of <code>Component</code>.
+     * @param x the new X coordinate for the upper-left
+     *                    corner of this <code>Rectangle</code>
+     * @param y the new Y coordinate for the upper-left
+     *                    corner of this <code>Rectangle</code>
+     * @param width the new width for this <code>Rectangle</code>
+     * @param height the new height for this <code>Rectangle</code>
+     * @see       #getBounds
+     * @see       java.awt.Component#setBounds(int, int, int, int)
+     * @since     1.1
+     */
+    public void setBounds(int x, int y, int width, int height) {
+        reshape(x, y, width, height);
+    }
+
+    /**
+     * Sets the bounds of this {@code Rectangle} to the integer bounds
+     * which encompass the specified {@code x}, {@code y}, {@code width},
+     * and {@code height}.
+     * If the parameters specify a {@code Rectangle} that exceeds the
+     * maximum range of integers, the result will be the best
+     * representation of the specified {@code Rectangle} intersected
+     * with the maximum integer bounds.
+     * @param x the X coordinate of the upper-left corner of
+     *                  the specified rectangle
+     * @param y the Y coordinate of the upper-left corner of
+     *                  the specified rectangle
+     * @param width the width of the specified rectangle
+     * @param height the new height of the specified rectangle
+     */
+    public void setRect(double x, double y, double width, double height) {
+        int newx, newy, neww, newh;
+
+        if (x > 2.0 * Integer.MAX_VALUE) {
+            // Too far in positive X direction to represent...
+            // We cannot even reach the left side of the specified
+            // rectangle even with both x & width set to MAX_VALUE.
+            // The intersection with the "maximal integer rectangle"
+            // is non-existant so we should use a width < 0.
+            // REMIND: Should we try to determine a more "meaningful"
+            // adjusted value for neww than just "-1"?
+            newx = Integer.MAX_VALUE;
+            neww = -1;
+        } else {
+            newx = clip(x, false);
+            if (width >= 0) width += x-newx;
+            neww = clip(width, width >= 0);
+        }
+
+        if (y > 2.0 * Integer.MAX_VALUE) {
+            // Too far in positive Y direction to represent...
+            newy = Integer.MAX_VALUE;
+            newh = -1;
+        } else {
+            newy = clip(y, false);
+            if (height >= 0) height += y-newy;
+            newh = clip(height, height >= 0);
+        }
+
+        reshape(newx, newy, neww, newh);
+    }
+    // Return best integer representation for v, clipped to integer
+    // range and floor-ed or ceiling-ed, depending on the boolean.
+    private static int clip(double v, boolean doceil) {
+        if (v <= Integer.MIN_VALUE) {
+            return Integer.MIN_VALUE;
+        }
+        if (v >= Integer.MAX_VALUE) {
+            return Integer.MAX_VALUE;
+        }
+        return (int) (doceil ? Math.ceil(v) : Math.floor(v));
+    }
+
+    /**
+     * Sets the bounding <code>Rectangle</code> of this
+     * <code>Rectangle</code> to the specified
+     * <code>x</code>, <code>y</code>, <code>width</code>,
+     * and <code>height</code>.
+     * <p>
+     * @param x the new X coordinate for the upper-left
+     *                    corner of this <code>Rectangle</code>
+     * @param y the new Y coordinate for the upper-left
+     *                    corner of this <code>Rectangle</code>
+     * @param width the new width for this <code>Rectangle</code>
+     * @param height the new height for this <code>Rectangle</code>
+     * @deprecated As of JDK version 1.1,
+     * replaced by <code>setBounds(int, int, int, int)</code>.
+     */
+    public void reshape(int x, int y, int width, int height) {
+        this.x = x;
+        this.y = y;
+        this.width = width;
+        this.height = height;
+    }
+
+    /**
+     * Returns the location of this <code>Rectangle</code>.
+     * <p>
+     * This method is included for completeness, to parallel the
+     * <code>getLocation</code> method of <code>Component</code>.
+     * @return the <code>Point</code> that is the upper-left corner of
+     *                  this <code>Rectangle</code>.
+     * @see       java.awt.Component#getLocation
+     * @see       #setLocation(Point)
+     * @see       #setLocation(int, int)
+     * @since     1.1
+     */
+    public Point getLocation() {
+        return new Point(x, y);
+    }
+
+    /**
+     * Moves this <code>Rectangle</code> to the specified location.
+     * <p>
+     * This method is included for completeness, to parallel the
+     * <code>setLocation</code> method of <code>Component</code>.
+     * @param p the <code>Point</code> specifying the new location
+     *                for this <code>Rectangle</code>
+     * @see       java.awt.Component#setLocation(java.awt.Point)
+     * @see       #getLocation
+     * @since     1.1
+     */
+    public void setLocation(Point p) {
+        setLocation(p.x, p.y);
+    }
+
+    /**
+     * Moves this <code>Rectangle</code> to the specified location.
+     * <p>
+     * This method is included for completeness, to parallel the
+     * <code>setLocation</code> method of <code>Component</code>.
+     * @param x the X coordinate of the new location
+     * @param y the Y coordinate of the new location
+     * @see       #getLocation
+     * @see       java.awt.Component#setLocation(int, int)
+     * @since     1.1
+     */
+    public void setLocation(int x, int y) {
+        move(x, y);
+    }
+
+    /**
+     * Moves this <code>Rectangle</code> to the specified location.
+     * <p>
+     * @param x the X coordinate of the new location
+     * @param y the Y coordinate of the new location
+     * @deprecated As of JDK version 1.1,
+     * replaced by <code>setLocation(int, int)</code>.
+     */
+    public void move(int x, int y) {
+        this.x = x;
+        this.y = y;
+    }
+
+    /**
+     * Translates this <code>Rectangle</code> the indicated distance,
+     * to the right along the X coordinate axis, and
+     * downward along the Y coordinate axis.
+     * @param dx the distance to move this <code>Rectangle</code>
+     *                 along the X axis
+     * @param dy the distance to move this <code>Rectangle</code>
+     *                 along the Y axis
+     * @see       java.awt.Rectangle#setLocation(int, int)
+     * @see       java.awt.Rectangle#setLocation(java.awt.Point)
+     */
+    public void translate(int dx, int dy) {
+        int oldv = this.x;
+        int newv = oldv + dx;
+        if (dx < 0) {
+            // moving leftward
+            if (newv > oldv) {
+                // negative overflow
+                // Only adjust width if it was valid (>= 0).
+                if (width >= 0) {
+                    // The right edge is now conceptually at
+                    // newv+width, but we may move newv to prevent
+                    // overflow.  But we want the right edge to
+                    // remain at its new location in spite of the
+                    // clipping.  Think of the following adjustment
+                    // conceptually the same as:
+                    // width += newv; newv = MIN_VALUE; width -= newv;
+                    width += newv - Integer.MIN_VALUE;
+                    // width may go negative if the right edge went past
+                    // MIN_VALUE, but it cannot overflow since it cannot
+                    // have moved more than MIN_VALUE and any non-negative
+                    // number + MIN_VALUE does not overflow.
+                }
+                newv = Integer.MIN_VALUE;
+            }
+        } else {
+            // moving rightward (or staying still)
+            if (newv < oldv) {
+                // positive overflow
+                if (width >= 0) {
+                    // Conceptually the same as:
+                    // width += newv; newv = MAX_VALUE; width -= newv;
+                    width += newv - Integer.MAX_VALUE;
+                    // With large widths and large displacements
+                    // we may overflow so we need to check it.
+                    if (width < 0) width = Integer.MAX_VALUE;
+                }
+                newv = Integer.MAX_VALUE;
+            }
+        }
+        this.x = newv;
+
+        oldv = this.y;
+        newv = oldv + dy;
+        if (dy < 0) {
+            // moving upward
+            if (newv > oldv) {
+                // negative overflow
+                if (height >= 0) {
+                    height += newv - Integer.MIN_VALUE;
+                    // See above comment about no overflow in this case
+                }
+                newv = Integer.MIN_VALUE;
+            }
+        } else {
+            // moving downward (or staying still)
+            if (newv < oldv) {
+                // positive overflow
+                if (height >= 0) {
+                    height += newv - Integer.MAX_VALUE;
+                    if (height < 0) height = Integer.MAX_VALUE;
+                }
+                newv = Integer.MAX_VALUE;
+            }
+        }
+        this.y = newv;
+    }
+
+    /**
+     * Gets the size of this <code>Rectangle</code>, represented by
+     * the returned <code>Dimension</code>.
+     * <p>
+     * This method is included for completeness, to parallel the
+     * <code>getSize</code> method of <code>Component</code>.
+     * @return a <code>Dimension</code>, representing the size of
+     *            this <code>Rectangle</code>.
+     * @see       java.awt.Component#getSize
+     * @see       #setSize(Dimension)
+     * @see       #setSize(int, int)
+     * @since     1.1
+     */
+    public Dimension getSize() {
+        return new Dimension(width, height);
+    }
+
+    /**
+     * Sets the size of this <code>Rectangle</code> to match the
+     * specified <code>Dimension</code>.
+     * <p>
+     * This method is included for completeness, to parallel the
+     * <code>setSize</code> method of <code>Component</code>.
+     * @param d the new size for the <code>Dimension</code> object
+     * @see       java.awt.Component#setSize(java.awt.Dimension)
+     * @see       #getSize
+     * @since     1.1
+     */
+    public void setSize(Dimension d) {
+        setSize(d.width, d.height);
+    }
+
+    /**
+     * Sets the size of this <code>Rectangle</code> to the specified
+     * width and height.
+     * <p>
+     * This method is included for completeness, to parallel the
+     * <code>setSize</code> method of <code>Component</code>.
+     * @param width the new width for this <code>Rectangle</code>
+     * @param height the new height for this <code>Rectangle</code>
+     * @see       java.awt.Component#setSize(int, int)
+     * @see       #getSize
+     * @since     1.1
+     */
+    public void setSize(int width, int height) {
+        resize(width, height);
+    }
+
+    /**
+     * Sets the size of this <code>Rectangle</code> to the specified
+     * width and height.
+     * <p>
+     * @param width the new width for this <code>Rectangle</code>
+     * @param height the new height for this <code>Rectangle</code>
+     * @deprecated As of JDK version 1.1,
+     * replaced by <code>setSize(int, int)</code>.
+     */
+    public void resize(int width, int height) {
+        this.width = width;
+        this.height = height;
+    }
+
+    /**
+     * Checks whether or not this <code>Rectangle</code> contains the
+     * specified <code>Point</code>.
+     * @param p the <code>Point</code> to test
+     * @return    <code>true</code> if the specified <code>Point</code>
+     *            is inside this <code>Rectangle</code>;
+     *            <code>false</code> otherwise.
+     * @since     1.1
+     */
+    public boolean contains(Point p) {
+        return contains(p.x, p.y);
+    }
+
+    /**
+     * Checks whether or not this <code>Rectangle</code> contains the
+     * point at the specified location {@code (x,y)}.
+     *
+     * @param  x the specified X coordinate
+     * @param  y the specified Y coordinate
+     * @return    <code>true</code> if the point
+     *            {@code (x,y)} is inside this
+     *            <code>Rectangle</code>;
+     *            <code>false</code> otherwise.
+     * @since     1.1
+     */
+    public boolean contains(int x, int y) {
+        return inside(x, y);
+    }
+
+    /**
+     * Checks whether or not this <code>Rectangle</code> entirely contains
+     * the specified <code>Rectangle</code>.
+     *
+     * @param     r   the specified <code>Rectangle</code>
+     * @return    <code>true</code> if the <code>Rectangle</code>
+     *            is contained entirely inside this <code>Rectangle</code>;
+     *            <code>false</code> otherwise
+     * @since     1.2
+     */
+    public boolean contains(Rectangle r) {
+        return contains(r.x, r.y, r.width, r.height);
+    }
+
+    /**
+     * Checks whether this <code>Rectangle</code> entirely contains
+     * the <code>Rectangle</code>
+     * at the specified location {@code (X,Y)} with the
+     * specified dimensions {@code (W,H)}.
+     * @param     X the specified X coordinate
+     * @param     Y the specified Y coordinate
+     * @param     W   the width of the <code>Rectangle</code>
+     * @param     H   the height of the <code>Rectangle</code>
+     * @return    <code>true</code> if the <code>Rectangle</code> specified by
+     *            {@code (X, Y, W, H)}
+     *            is entirely enclosed inside this <code>Rectangle</code>;
+     *            <code>false</code> otherwise.
+     * @since     1.1
+     */
+    public boolean contains(int X, int Y, int W, int H) {
+        int w = this.width;
+        int h = this.height;
+        if ((w | h | W | H) < 0) {
+            // At least one of the dimensions is negative...
+            return false;
+        }
+        // Note: if any dimension is zero, tests below must return false...
+        int x = this.x;
+        int y = this.y;
+        if (X < x || Y < y) {
+            return false;
+        }
+        w += x;
+        W += X;
+        if (W <= X) {
+            // X+W overflowed or W was zero, return false if...
+            // either original w or W was zero or
+            // x+w did not overflow or
+            // the overflowed x+w is smaller than the overflowed X+W
+            if (w >= x || W > w) return false;
+        } else {
+            // X+W did not overflow and W was not zero, return false if...
+            // original w was zero or
+            // x+w did not overflow and x+w is smaller than X+W
+            if (w >= x && W > w) return false;
+        }
+        h += y;
+        H += Y;
+        if (H <= Y) {
+            if (h >= y || H > h) return false;
+        } else {
+            if (h >= y && H > h) return false;
+        }
+        return true;
+    }
+
+    /**
+     * Checks whether or not this <code>Rectangle</code> contains the
+     * point at the specified location {@code (X,Y)}.
+     *
+     * @param  X the specified X coordinate
+     * @param  Y the specified Y coordinate
+     * @return    <code>true</code> if the point
+     *            {@code (X,Y)} is inside this
+     *            <code>Rectangle</code>;
+     *            <code>false</code> otherwise.
+     * @deprecated As of JDK version 1.1,
+     * replaced by <code>contains(int, int)</code>.
+     */
+    public boolean inside(int X, int Y) {
+        int w = this.width;
+        int h = this.height;
+        if ((w | h) < 0) {
+            // At least one of the dimensions is negative...
+            return false;
+        }
+        // Note: if either dimension is zero, tests below must return false...
+        int x = this.x;
+        int y = this.y;
+        if (X < x || Y < y) {
+            return false;
+        }
+        w += x;
+        h += y;
+        //    overflow || intersect
+        return ((w < x || w > X) &&
+                (h < y || h > Y));
+    }
+
+    /**
+     * Determines whether or not this <code>Rectangle</code> and the specified
+     * <code>Rectangle</code> intersect. Two rectangles intersect if
+     * their intersection is nonempty.
+     *
+     * @param r the specified <code>Rectangle</code>
+     * @return    <code>true</code> if the specified <code>Rectangle</code>
+     *            and this <code>Rectangle</code> intersect;
+     *            <code>false</code> otherwise.
+     */
+    public boolean intersects(Rectangle r) {
+        int tw = this.width;
+        int th = this.height;
+        int rw = r.width;
+        int rh = r.height;
+        if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {
+            return false;
+        }
+        int tx = this.x;
+        int ty = this.y;
+        int rx = r.x;
+        int ry = r.y;
+        rw += rx;
+        rh += ry;
+        tw += tx;
+        th += ty;
+        //      overflow || intersect
+        return ((rw < rx || rw > tx) &&
+                (rh < ry || rh > ty) &&
+                (tw < tx || tw > rx) &&
+                (th < ty || th > ry));
+    }
+
+    /**
+     * Computes the intersection of this <code>Rectangle</code> with the
+     * specified <code>Rectangle</code>. Returns a new <code>Rectangle</code>
+     * that represents the intersection of the two rectangles.
+     * If the two rectangles do not intersect, the result will be
+     * an empty rectangle.
+     *
+     * @param     r   the specified <code>Rectangle</code>
+     * @return    the largest <code>Rectangle</code> contained in both the
+     *            specified <code>Rectangle</code> and in
+     *            this <code>Rectangle</code>; or if the rectangles
+     *            do not intersect, an empty rectangle.
+     */
+    public Rectangle intersection(Rectangle r) {
+        int tx1 = this.x;
+        int ty1 = this.y;
+        int rx1 = r.x;
+        int ry1 = r.y;
+        long tx2 = tx1; tx2 += this.width;
+        long ty2 = ty1; ty2 += this.height;
+        long rx2 = rx1; rx2 += r.width;
+        long ry2 = ry1; ry2 += r.height;
+        if (tx1 < rx1) tx1 = rx1;
+        if (ty1 < ry1) ty1 = ry1;
+        if (tx2 > rx2) tx2 = rx2;
+        if (ty2 > ry2) ty2 = ry2;
+        tx2 -= tx1;
+        ty2 -= ty1;
+        // tx2,ty2 will never overflow (they will never be
+        // larger than the smallest of the two source w,h)
+        // they might underflow, though...
+        if (tx2 < Integer.MIN_VALUE) tx2 = Integer.MIN_VALUE;
+        if (ty2 < Integer.MIN_VALUE) ty2 = Integer.MIN_VALUE;
+        return new Rectangle(tx1, ty1, (int) tx2, (int) ty2);
+    }
+
+    /**
+     * Computes the union of this <code>Rectangle</code> with the
+     * specified <code>Rectangle</code>. Returns a new
+     * <code>Rectangle</code> that
+     * represents the union of the two rectangles.
+     * <p>
+     * If either {@code Rectangle} has any dimension less than zero
+     * the rules for <a href=#NonExistant>non-existant</a> rectangles
+     * apply.
+     * If only one has a dimension less than zero, then the result
+     * will be a copy of the other {@code Rectangle}.
+     * If both have dimension less than zero, then the result will
+     * have at least one dimension less than zero.
+     * <p>
+     * If the resulting {@code Rectangle} would have a dimension
+     * too large to be expressed as an {@code int}, the result
+     * will have a dimension of {@code Integer.MAX_VALUE} along
+     * that dimension.
+     * @param r the specified <code>Rectangle</code>
+     * @return    the smallest <code>Rectangle</code> containing both
+     *            the specified <code>Rectangle</code> and this
+     *            <code>Rectangle</code>.
+     */
+    public Rectangle union(Rectangle r) {
+        long tx2 = this.width;
+        long ty2 = this.height;
+        if ((tx2 | ty2) < 0) {
+            // This rectangle has negative dimensions...
+            // If r has non-negative dimensions then it is the answer.
+            // If r is non-existant (has a negative dimension), then both
+            // are non-existant and we can return any non-existant rectangle
+            // as an answer.  Thus, returning r meets that criterion.
+            // Either way, r is our answer.
+            return new Rectangle(r);
+        }
+        long rx2 = r.width;
+        long ry2 = r.height;
+        if ((rx2 | ry2) < 0) {
+            return new Rectangle(this);
+        }
+        int tx1 = this.x;
+        int ty1 = this.y;
+        tx2 += tx1;
+        ty2 += ty1;
+        int rx1 = r.x;
+        int ry1 = r.y;
+        rx2 += rx1;
+        ry2 += ry1;
+        if (tx1 > rx1) tx1 = rx1;
+        if (ty1 > ry1) ty1 = ry1;
+        if (tx2 < rx2) tx2 = rx2;
+        if (ty2 < ry2) ty2 = ry2;
+        tx2 -= tx1;
+        ty2 -= ty1;
+        // tx2,ty2 will never underflow since both original rectangles
+        // were already proven to be non-empty
+        // they might overflow, though...
+        if (tx2 > Integer.MAX_VALUE) tx2 = Integer.MAX_VALUE;
+        if (ty2 > Integer.MAX_VALUE) ty2 = Integer.MAX_VALUE;
+        return new Rectangle(tx1, ty1, (int) tx2, (int) ty2);
+    }
+
+    /**
+     * Adds a point, specified by the integer arguments {@code newx,newy}
+     * to the bounds of this {@code Rectangle}.
+     * <p>
+     * If this {@code Rectangle} has any dimension less than zero,
+     * the rules for <a href=#NonExistant>non-existant</a>
+     * rectangles apply.
+     * In that case, the new bounds of this {@code Rectangle} will
+     * have a location equal to the specified coordinates and
+     * width and height equal to zero.
+     * <p>
+     * After adding a point, a call to <code>contains</code> with the
+     * added point as an argument does not necessarily return
+     * <code>true</code>. The <code>contains</code> method does not
+     * return <code>true</code> for points on the right or bottom
+     * edges of a <code>Rectangle</code>. Therefore, if the added point
+     * falls on the right or bottom edge of the enlarged
+     * <code>Rectangle</code>, <code>contains</code> returns
+     * <code>false</code> for that point.
+     * If the specified point must be contained within the new
+     * {@code Rectangle}, a 1x1 rectangle should be added instead:
+     * <pre>
+     *     r.add(newx, newy, 1, 1);
+     * </pre>
+     * @param newx the X coordinate of the new point
+     * @param newy the Y coordinate of the new point
+     */
+    public void add(int newx, int newy) {
+        if ((width | height) < 0) {
+            this.x = newx;
+            this.y = newy;
+            this.width = this.height = 0;
+            return;
+        }
+        int x1 = this.x;
+        int y1 = this.y;
+        long x2 = this.width;
+        long y2 = this.height;
+        x2 += x1;
+        y2 += y1;
+        if (x1 > newx) x1 = newx;
+        if (y1 > newy) y1 = newy;
+        if (x2 < newx) x2 = newx;
+        if (y2 < newy) y2 = newy;
+        x2 -= x1;
+        y2 -= y1;
+        if (x2 > Integer.MAX_VALUE) x2 = Integer.MAX_VALUE;
+        if (y2 > Integer.MAX_VALUE) y2 = Integer.MAX_VALUE;
+        reshape(x1, y1, (int) x2, (int) y2);
+    }
+
+    /**
+     * Adds the specified {@code Point} to the bounds of this
+     * {@code Rectangle}.
+     * <p>
+     * If this {@code Rectangle} has any dimension less than zero,
+     * the rules for <a href=#NonExistant>non-existant</a>
+     * rectangles apply.
+     * In that case, the new bounds of this {@code Rectangle} will
+     * have a location equal to the coordinates of the specified
+     * {@code Point} and width and height equal to zero.
+     * <p>
+     * After adding a <code>Point</code>, a call to <code>contains</code>
+     * with the added <code>Point</code> as an argument does not
+     * necessarily return <code>true</code>. The <code>contains</code>
+     * method does not return <code>true</code> for points on the right
+     * or bottom edges of a <code>Rectangle</code>. Therefore if the added
+     * <code>Point</code> falls on the right or bottom edge of the
+     * enlarged <code>Rectangle</code>, <code>contains</code> returns
+     * <code>false</code> for that <code>Point</code>.
+     * If the specified point must be contained within the new
+     * {@code Rectangle}, a 1x1 rectangle should be added instead:
+     * <pre>
+     *     r.add(pt.x, pt.y, 1, 1);
+     * </pre>
+     * @param pt the new <code>Point</code> to add to this
+     *           <code>Rectangle</code>
+     */
+    public void add(Point pt) {
+        add(pt.x, pt.y);
+    }
+
+    /**
+     * Adds a <code>Rectangle</code> to this <code>Rectangle</code>.
+     * The resulting <code>Rectangle</code> is the union of the two
+     * rectangles.
+     * <p>
+     * If either {@code Rectangle} has any dimension less than 0, the
+     * result will have the dimensions of the other {@code Rectangle}.
+     * If both {@code Rectangle}s have at least one dimension less
+     * than 0, the result will have at least one dimension less than 0.
+     * <p>
+     * If either {@code Rectangle} has one or both dimensions equal
+     * to 0, the result along those axes with 0 dimensions will be
+     * equivalent to the results obtained by adding the corresponding
+     * origin coordinate to the result rectangle along that axis,
+     * similar to the operation of the {@link #add(Point)} method,
+     * but contribute no further dimension beyond that.
+     * <p>
+     * If the resulting {@code Rectangle} would have a dimension
+     * too large to be expressed as an {@code int}, the result
+     * will have a dimension of {@code Integer.MAX_VALUE} along
+     * that dimension.
+     * @param  r the specified <code>Rectangle</code>
+     */
+    public void add(Rectangle r) {
+        long tx2 = this.width;
+        long ty2 = this.height;
+        if ((tx2 | ty2) < 0) {
+            reshape(r.x, r.y, r.width, r.height);
+        }
+        long rx2 = r.width;
+        long ry2 = r.height;
+        if ((rx2 | ry2) < 0) {
+            return;
+        }
+        int tx1 = this.x;
+        int ty1 = this.y;
+        tx2 += tx1;
+        ty2 += ty1;
+        int rx1 = r.x;
+        int ry1 = r.y;
+        rx2 += rx1;
+        ry2 += ry1;
+        if (tx1 > rx1) tx1 = rx1;
+        if (ty1 > ry1) ty1 = ry1;
+        if (tx2 < rx2) tx2 = rx2;
+        if (ty2 < ry2) ty2 = ry2;
+        tx2 -= tx1;
+        ty2 -= ty1;
+        // tx2,ty2 will never underflow since both original
+        // rectangles were non-empty
+        // they might overflow, though...
+        if (tx2 > Integer.MAX_VALUE) tx2 = Integer.MAX_VALUE;
+        if (ty2 > Integer.MAX_VALUE) ty2 = Integer.MAX_VALUE;
+        reshape(tx1, ty1, (int) tx2, (int) ty2);
+    }
+
+    /**
+     * Resizes the <code>Rectangle</code> both horizontally and vertically.
+     * <p>
+     * This method modifies the <code>Rectangle</code> so that it is
+     * <code>h</code> units larger on both the left and right side,
+     * and <code>v</code> units larger at both the top and bottom.
+     * <p>
+     * The new <code>Rectangle</code> has {@code (x - h, y - v)}
+     * as its upper-left corner,
+     * width of {@code (width + 2h)},
+     * and a height of {@code (height + 2v)}.
+     * <p>
+     * If negative values are supplied for <code>h</code> and
+     * <code>v</code>, the size of the <code>Rectangle</code>
+     * decreases accordingly.
+     * The {@code grow} method will check for integer overflow
+     * and underflow, but does not check whether the resulting
+     * values of {@code width} and {@code height} grow
+     * from negative to non-negative or shrink from non-negative
+     * to negative.
+     * @param h the horizontal expansion
+     * @param v the vertical expansion
+     */
+    public void grow(int h, int v) {
+        long x0 = this.x;
+        long y0 = this.y;
+        long x1 = this.width;
+        long y1 = this.height;
+        x1 += x0;
+        y1 += y0;
+
+        x0 -= h;
+        y0 -= v;
+        x1 += h;
+        y1 += v;
+
+        if (x1 < x0) {
+            // Non-existant in X direction
+            // Final width must remain negative so subtract x0 before
+            // it is clipped so that we avoid the risk that the clipping
+            // of x0 will reverse the ordering of x0 and x1.
+            x1 -= x0;
+            if (x1 < Integer.MIN_VALUE) x1 = Integer.MIN_VALUE;
+            if (x0 < Integer.MIN_VALUE) x0 = Integer.MIN_VALUE;
+            else if (x0 > Integer.MAX_VALUE) x0 = Integer.MAX_VALUE;
+        } else { // (x1 >= x0)
+            // Clip x0 before we subtract it from x1 in case the clipping
+            // affects the representable area of the rectangle.
+            if (x0 < Integer.MIN_VALUE) x0 = Integer.MIN_VALUE;
+            else if (x0 > Integer.MAX_VALUE) x0 = Integer.MAX_VALUE;
+            x1 -= x0;
+            // The only way x1 can be negative now is if we clipped
+            // x0 against MIN and x1 is less than MIN - in which case
+            // we want to leave the width negative since the result
+            // did not intersect the representable area.
+            if (x1 < Integer.MIN_VALUE) x1 = Integer.MIN_VALUE;
+            else if (x1 > Integer.MAX_VALUE) x1 = Integer.MAX_VALUE;
+        }
+
+        if (y1 < y0) {
+            // Non-existant in Y direction
+            y1 -= y0;
+            if (y1 < Integer.MIN_VALUE) y1 = Integer.MIN_VALUE;
+            if (y0 < Integer.MIN_VALUE) y0 = Integer.MIN_VALUE;
+            else if (y0 > Integer.MAX_VALUE) y0 = Integer.MAX_VALUE;
+        } else { // (y1 >= y0)
+            if (y0 < Integer.MIN_VALUE) y0 = Integer.MIN_VALUE;
+            else if (y0 > Integer.MAX_VALUE) y0 = Integer.MAX_VALUE;
+            y1 -= y0;
+            if (y1 < Integer.MIN_VALUE) y1 = Integer.MIN_VALUE;
+            else if (y1 > Integer.MAX_VALUE) y1 = Integer.MAX_VALUE;
+        }
+
+        reshape((int) x0, (int) y0, (int) x1, (int) y1);
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public boolean isEmpty() {
+        return (width <= 0) || (height <= 0);
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public int outcode(double x, double y) {
+        /*
+         * Note on casts to double below.  If the arithmetic of
+         * x+w or y+h is done in int, then we may get integer
+         * overflow. By converting to double before the addition
+         * we force the addition to be carried out in double to
+         * avoid overflow in the comparison.
+         *
+         * See bug 4320890 for problems that this can cause.
+         */
+        int out = 0;
+        if (this.width <= 0) {
+            out |= OUT_LEFT | OUT_RIGHT;
+        } else if (x < this.x) {
+            out |= OUT_LEFT;
+        } else if (x > this.x + (double) this.width) {
+            out |= OUT_RIGHT;
+        }
+        if (this.height <= 0) {
+            out |= OUT_TOP | OUT_BOTTOM;
+        } else if (y < this.y) {
+            out |= OUT_TOP;
+        } else if (y > this.y + (double) this.height) {
+            out |= OUT_BOTTOM;
+        }
+        return out;
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public Rectangle2D createIntersection(Rectangle2D r) {
+        if (r instanceof Rectangle) {
+            return intersection((Rectangle) r);
+        }
+        Rectangle2D dest = new Rectangle2D.Double();
+        Rectangle2D.intersect(this, r, dest);
+        return dest;
+    }
+
+    /**
+     * {@inheritDoc}
+     * @since 1.2
+     */
+    public Rectangle2D createUnion(Rectangle2D r) {
+        if (r instanceof Rectangle) {
+            return union((Rectangle) r);
+        }
+        Rectangle2D dest = new Rectangle2D.Double();
+        Rectangle2D.union(this, r, dest);
+        return dest;
+    }
+
+    /**
+     * Checks whether two rectangles are equal.
+     * <p>
+     * The result is <code>true</code> if and only if the argument is not
+     * <code>null</code> and is a <code>Rectangle</code> object that has the
+     * same upper-left corner, width, and height as
+     * this <code>Rectangle</code>.
+     * @param obj the <code>Object</code> to compare with
+     *                this <code>Rectangle</code>
+     * @return    <code>true</code> if the objects are equal;
+     *            <code>false</code> otherwise.
+     */
+    public boolean equals(Object obj) {
+        if (obj instanceof Rectangle) {
+            Rectangle r = (Rectangle)obj;
+            return ((x == r.x) &&
+                    (y == r.y) &&
+                    (width == r.width) &&
+                    (height == r.height));
+        }
+        return super.equals(obj);
+    }
+
+    /**
+     * Returns a <code>String</code> representing this
+     * <code>Rectangle</code> and its values.
+     * @return a <code>String</code> representing this
+     *               <code>Rectangle</code> object's coordinate and size values.
+     */
+    public String toString() {
+        return getClass().getName() + "[x=" + x + ",y=" + y + ",width=" + width + ",height=" + height + "]";
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Shape.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Shape.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Shape.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Shape.java	2010-05-21 15:37:40.000000000 -0400
@@ -0,0 +1,356 @@
+/*
+ * Copyright 1996-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt;
+
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+
+/**
+ * The <code>Shape</code> interface provides definitions for objects
+ * that represent some form of geometric shape.  The <code>Shape</code>
+ * is described by a {@link PathIterator} object, which can express the
+ * outline of the <code>Shape</code> as well as a rule for determining
+ * how the outline divides the 2D plane into interior and exterior
+ * points.  Each <code>Shape</code> object provides callbacks to get the
+ * bounding box of the geometry, determine whether points or
+ * rectangles lie partly or entirely within the interior
+ * of the <code>Shape</code>, and retrieve a <code>PathIterator</code>
+ * object that describes the trajectory path of the <code>Shape</code>
+ * outline.
+ * <p>
+ * <b>Definition of insideness:</b>
+ * A point is considered to lie inside a
+ * <code>Shape</code> if and only if:
+ * <ul>
+ * <li> it lies completely
+ * inside the<code>Shape</code> boundary <i>or</i>
+ * <li>
+ * it lies exactly on the <code>Shape</code> boundary <i>and</i> the
+ * space immediately adjacent to the
+ * point in the increasing <code>X</code> direction is
+ * entirely inside the boundary <i>or</i>
+ * <li>
+ * it lies exactly on a horizontal boundary segment <b>and</b> the
+ * space immediately adjacent to the point in the
+ * increasing <code>Y</code> direction is inside the boundary.
+ * </ul>
+ * <p>The <code>contains</code> and <code>intersects</code> methods
+ * consider the interior of a <code>Shape</code> to be the area it
+ * encloses as if it were filled.  This means that these methods
+ * consider
+ * unclosed shapes to be implicitly closed for the purpose of
+ * determining if a shape contains or intersects a rectangle or if a
+ * shape contains a point.
+ *
+ * @see java.awt.geom.PathIterator
+ * @see java.awt.geom.AffineTransform
+ * @see java.awt.geom.FlatteningPathIterator
+ * @see java.awt.geom.GeneralPath
+ *
+ * @author Jim Graham
+ * @since 1.2
+ */
+public interface Shape {
+    /**
+     * Returns an integer {@link Rectangle} that completely encloses the
+     * <code>Shape</code>.  Note that there is no guarantee that the
+     * returned <code>Rectangle</code> is the smallest bounding box that
+     * encloses the <code>Shape</code>, only that the <code>Shape</code>
+     * lies entirely within the indicated  <code>Rectangle</code>.  The
+     * returned <code>Rectangle</code> might also fail to completely
+     * enclose the <code>Shape</code> if the <code>Shape</code> overflows
+     * the limited range of the integer data type.  The
+     * <code>getBounds2D</code> method generally returns a
+     * tighter bounding box due to its greater flexibility in
+     * representation.
+     * @return an integer <code>Rectangle</code> that completely encloses
+     *                 the <code>Shape</code>.
+     * @see #getBounds2D
+     * @since 1.2
+     */
+    public Rectangle getBounds();
+
+    /**
+     * Returns a high precision and more accurate bounding box of
+     * the <code>Shape</code> than the <code>getBounds</code> method.
+     * Note that there is no guarantee that the returned
+     * {@link Rectangle2D} is the smallest bounding box that encloses
+     * the <code>Shape</code>, only that the <code>Shape</code> lies
+     * entirely within the indicated <code>Rectangle2D</code>.  The
+     * bounding box returned by this method is usually tighter than that
+     * returned by the <code>getBounds</code> method and never fails due
+     * to overflow problems since the return value can be an instance of
+     * the <code>Rectangle2D</code> that uses double precision values to
+     * store the dimensions.
+     * @return an instance of <code>Rectangle2D</code> that is a
+     *                 high-precision bounding box of the <code>Shape</code>.
+     * @see #getBounds
+     * @since 1.2
+     */
+    public Rectangle2D getBounds2D();
+
+    /**
+     * Tests if the specified coordinates are inside the boundary of the
+     * <code>Shape</code>.
+     * @param x the specified X coordinate to be tested
+     * @param y the specified Y coordinate to be tested
+     * @return <code>true</code> if the specified coordinates are inside
+     *         the <code>Shape</code> boundary; <code>false</code>
+     *         otherwise.
+     * @since 1.2
+     */
+    public boolean contains(double x, double y);
+
+    /**
+     * Tests if a specified {@link Point2D} is inside the boundary
+     * of the <code>Shape</code>.
+     * @param p the specified <code>Point2D</code> to be tested
+     * @return <code>true</code> if the specified <code>Point2D</code> is
+     *          inside the boundary of the <code>Shape</code>;
+     *          <code>false</code> otherwise.
+     * @since 1.2
+     */
+    public boolean contains(Point2D p);
+
+    /**
+     * Tests if the interior of the <code>Shape</code> intersects the
+     * interior of a specified rectangular area.
+     * The rectangular area is considered to intersect the <code>Shape</code>
+     * if any point is contained in both the interior of the
+     * <code>Shape</code> and the specified rectangular area.
+     * <p>
+     * The {@code Shape.intersects()} method allows a {@code Shape}
+     * implementation to conservatively return {@code true} when:
+     * <ul>
+     * <li>
+     * there is a high probability that the rectangular area and the
+     * <code>Shape</code> intersect, but
+     * <li>
+     * the calculations to accurately determine this intersection
+     * are prohibitively expensive.
+     * </ul>
+     * This means that for some {@code Shapes} this method might
+     * return {@code true} even though the rectangular area does not
+     * intersect the {@code Shape}.
+     * The {@link java.awt.geom.Area Area} class performs
+     * more accurate computations of geometric intersection than most
+     * {@code Shape} objects and therefore can be used if a more precise
+     * answer is required.
+     *
+     * @param x the X coordinate of the upper-left corner
+     *          of the specified rectangular area
+     * @param y the Y coordinate of the upper-left corner
+     *          of the specified rectangular area
+     * @param w the width of the specified rectangular area
+     * @param h the height of the specified rectangular area
+     * @return <code>true</code> if the interior of the <code>Shape</code> and
+     *          the interior of the rectangular area intersect, or are
+     *          both highly likely to intersect and intersection calculations
+     *          would be too expensive to perform; <code>false</code> otherwise.
+     * @see java.awt.geom.Area
+     * @since 1.2
+     */
+    public boolean intersects(double x, double y, double w, double h);
+
+    /**
+     * Tests if the interior of the <code>Shape</code> intersects the
+     * interior of a specified <code>Rectangle2D</code>.
+     * The {@code Shape.intersects()} method allows a {@code Shape}
+     * implementation to conservatively return {@code true} when:
+     * <ul>
+     * <li>
+     * there is a high probability that the <code>Rectangle2D</code> and the
+     * <code>Shape</code> intersect, but
+     * <li>
+     * the calculations to accurately determine this intersection
+     * are prohibitively expensive.
+     * </ul>
+     * This means that for some {@code Shapes} this method might
+     * return {@code true} even though the {@code Rectangle2D} does not
+     * intersect the {@code Shape}.
+     * The {@link java.awt.geom.Area Area} class performs
+     * more accurate computations of geometric intersection than most
+     * {@code Shape} objects and therefore can be used if a more precise
+     * answer is required.
+     *
+     * @param r the specified <code>Rectangle2D</code>
+     * @return <code>true</code> if the interior of the <code>Shape</code> and
+     *          the interior of the specified <code>Rectangle2D</code>
+     *          intersect, or are both highly likely to intersect and intersection
+     *          calculations would be too expensive to perform; <code>false</code>
+     *          otherwise.
+     * @see #intersects(double, double, double, double)
+     * @since 1.2
+     */
+    public boolean intersects(Rectangle2D r);
+
+    /**
+     * Tests if the interior of the <code>Shape</code> entirely contains
+     * the specified rectangular area.  All coordinates that lie inside
+     * the rectangular area must lie within the <code>Shape</code> for the
+     * entire rectanglar area to be considered contained within the
+     * <code>Shape</code>.
+     * <p>
+     * The {@code Shape.contains()} method allows a {@code Shape}
+     * implementation to conservatively return {@code false} when:
+     * <ul>
+     * <li>
+     * the <code>intersect</code> method returns <code>true</code> and
+     * <li>
+     * the calculations to determine whether or not the
+     * <code>Shape</code> entirely contains the rectangular area are
+     * prohibitively expensive.
+     * </ul>
+     * This means that for some {@code Shapes} this method might
+     * return {@code false} even though the {@code Shape} contains
+     * the rectangular area.
+     * The {@link java.awt.geom.Area Area} class performs
+     * more accurate geometric computations than most
+     * {@code Shape} objects and therefore can be used if a more precise
+     * answer is required.
+     *
+     * @param x the X coordinate of the upper-left corner
+     *          of the specified rectangular area
+     * @param y the Y coordinate of the upper-left corner
+     *          of the specified rectangular area
+     * @param w the width of the specified rectangular area
+     * @param h the height of the specified rectangular area
+     * @return <code>true</code> if the interior of the <code>Shape</code>
+     *          entirely contains the specified rectangular area;
+     *          <code>false</code> otherwise or, if the <code>Shape</code>
+     *          contains the rectangular area and the
+     *          <code>intersects</code> method returns <code>true</code>
+     *          and the containment calculations would be too expensive to
+     *          perform.
+     * @see java.awt.geom.Area
+     * @see #intersects
+     * @since 1.2
+     */
+    public boolean contains(double x, double y, double w, double h);
+
+    /**
+     * Tests if the interior of the <code>Shape</code> entirely contains the
+     * specified <code>Rectangle2D</code>.
+     * The {@code Shape.contains()} method allows a {@code Shape}
+     * implementation to conservatively return {@code false} when:
+     * <ul>
+     * <li>
+     * the <code>intersect</code> method returns <code>true</code> and
+     * <li>
+     * the calculations to determine whether or not the
+     * <code>Shape</code> entirely contains the <code>Rectangle2D</code>
+     * are prohibitively expensive.
+     * </ul>
+     * This means that for some {@code Shapes} this method might
+     * return {@code false} even though the {@code Shape} contains
+     * the {@code Rectangle2D}.
+     * The {@link java.awt.geom.Area Area} class performs
+     * more accurate geometric computations than most
+     * {@code Shape} objects and therefore can be used if a more precise
+     * answer is required.
+     *
+     * @param r The specified <code>Rectangle2D</code>
+     * @return <code>true</code> if the interior of the <code>Shape</code>
+     *          entirely contains the <code>Rectangle2D</code>;
+     *          <code>false</code> otherwise or, if the <code>Shape</code>
+     *          contains the <code>Rectangle2D</code> and the
+     *          <code>intersects</code> method returns <code>true</code>
+     *          and the containment calculations would be too expensive to
+     *          perform.
+     * @see #contains(double, double, double, double)
+     * @since 1.2
+     */
+    public boolean contains(Rectangle2D r);
+
+    /**
+     * Returns an iterator object that iterates along the
+     * <code>Shape</code> boundary and provides access to the geometry of the
+     * <code>Shape</code> outline.  If an optional {@link AffineTransform}
+     * is specified, the coordinates returned in the iteration are
+     * transformed accordingly.
+     * <p>
+     * Each call to this method returns a fresh <code>PathIterator</code>
+     * object that traverses the geometry of the <code>Shape</code> object
+     * independently from any other <code>PathIterator</code> objects in use
+     * at the same time.
+     * <p>
+     * It is recommended, but not guaranteed, that objects
+     * implementing the <code>Shape</code> interface isolate iterations
+     * that are in process from any changes that might occur to the original
+     * object's geometry during such iterations.
+     *
+     * @param at an optional <code>AffineTransform</code> to be applied to the
+     *          coordinates as they are returned in the iteration, or
+     *          <code>null</code> if untransformed coordinates are desired
+     * @return a new <code>PathIterator</code> object, which independently
+     *          traverses the geometry of the <code>Shape</code>.
+     * @since 1.2
+     */
+//    public PathIterator getPathIterator(AffineTransform at);
+
+    /**
+     * Returns an iterator object that iterates along the <code>Shape</code>
+     * boundary and provides access to a flattened view of the
+     * <code>Shape</code> outline geometry.
+     * <p>
+     * Only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types are
+     * returned by the iterator.
+     * <p>
+     * If an optional <code>AffineTransform</code> is specified,
+     * the coordinates returned in the iteration are transformed
+     * accordingly.
+     * <p>
+     * The amount of subdivision of the curved segments is controlled
+     * by the <code>flatness</code> parameter, which specifies the
+     * maximum distance that any point on the unflattened transformed
+     * curve can deviate from the returned flattened path segments.
+     * Note that a limit on the accuracy of the flattened path might be
+     * silently imposed, causing very small flattening parameters to be
+     * treated as larger values.  This limit, if there is one, is
+     * defined by the particular implementation that is used.
+     * <p>
+     * Each call to this method returns a fresh <code>PathIterator</code>
+     * object that traverses the <code>Shape</code> object geometry
+     * independently from any other <code>PathIterator</code> objects in use at
+     * the same time.
+     * <p>
+     * It is recommended, but not guaranteed, that objects
+     * implementing the <code>Shape</code> interface isolate iterations
+     * that are in process from any changes that might occur to the original
+     * object's geometry during such iterations.
+     *
+     * @param at an optional <code>AffineTransform</code> to be applied to the
+     *          coordinates as they are returned in the iteration, or
+     *          <code>null</code> if untransformed coordinates are desired
+     * @param flatness the maximum distance that the line segments used to
+     *          approximate the curved segments are allowed to deviate
+     *          from any point on the original curve
+     * @return a new <code>PathIterator</code> that independently traverses
+     *         a flattened view of the geometry of the  <code>Shape</code>.
+     * @since 1.2
+     */
+//    public PathIterator getPathIterator(AffineTransform at, double flatness);
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Transparency.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Transparency.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Transparency.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/java/awt/Transparency.java	2010-05-18 17:15:26.000000000 -0400
@@ -0,0 +1,58 @@
+/*
+ * @(#)Transparency.java	1.23 06/10/10
+ *
+ * Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 only, as published by the Free Software Foundation. 
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License version 2 for more details (a copy is
+ * included at /legal/license.txt). 
+ * 
+ * You should have received a copy of the GNU General Public License
+ * version 2 along with this work; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA 
+ * 
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+ * Clara, CA 95054 or visit www.sun.com if you need additional
+ * information or have any questions. 
+ *
+ */
+
+package java.awt;
+
+/**
+ * The <code>Transparency</code> interface defines the common transparency
+ * modes for implementing classes.
+ * @version 1.19, 08/19/02
+ */
+public interface Transparency {
+    /**
+     * Represents image data that is guaranteed to be completely opaque,
+     * meaning that all pixels have an alpha value of 1.0.
+     */
+    public final static int OPAQUE = 1;
+    /**
+     * Represents image data that is guaranteed to be either completely
+     * opaque, with an alpha value of 1.0, or completely transparent,
+     * with an alpha value of 0.0.
+     */
+    public final static int BITMASK = 2;
+    /**
+     * Represents image data that contains or might contain arbitrary
+     * alpha values between and including 0.0 and 1.0.
+     */
+    public final static int TRANSLUCENT = 3;
+    /**
+     * Returns the type of this <code>Transparency</code>.
+     * @return the field type of this <code>Transparency</code>, which is
+     *		either OPAQUE, BITMASK or TRANSLUCENT. 
+     */
+    public int getTransparency();
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/jsr172.zip.b64 phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/jsr172.zip.b64
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/builtinsage/jsr172.zip.b64	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/builtinsage/jsr172.zip.b64	2011-06-14 16:14:49.000000000 -0400
@@ -0,0 +1,589 @@
+UEsDBAoAAAAAALFUyj4AAAAAAAAAAAAAAAAEABwAY29tL1VUCQADLizyTUws8k11
+eAsAAQToAwAABOgDAABQSwMECgAAAAAAsVTKPgAAAAAAAAAAAAAAAAgAHABjb20v
+c3VuL1VUCQADLizyTUws8k11eAsAAQToAwAABOgDAABQSwMECgAAAAAAsVTKPgAA
+AAAAAAAAAAAAAA0AHABjb20vc3VuL3VraXQvVVQJAAMuLPJNTCzyTXV4CwABBOgD
+AAAE6AMAAFBLAwQKAAAAAACxVMo+AAAAAAAAAAAAAAAAEgAcAGNvbS9zdW4vdWtp
+dC9qYXhwL1VUCQADLizyTUws8k11eAsAAQToAwAABOgDAABQSwMEFAAAAAgAsVTK
+PtiVZY2IOgAAjmoAAB4AHABjb20vc3VuL3VraXQvamF4cC9QYXJzZXIuY2xhc3NV
+VAkAAy4s8k1MLPJNdXgLAAEE6AMAAAToAwAArbwHfFXFEjA+s6fec0/gJhAwJEik
+k0LonQAJQSJJQCAUEU0IAaIhCSk0FbE89VmeiuATUEAULwqiIElUFDtgV+y9F3wW
+7A2S/8yevTc3Mbzn9/++/HJ298zuzs7Ozs7O7O65zzQ8uB8A+om5DhzEyT44gFM4
+ON3CqQ7oHmQaB9MdCvJtnOGDJ3EmB7MYPJtTZ3Bqjo2jbDyTk3M5OIuDs32QgAUc
+FFo4z4EOWGThfAdOwmLGt4DLLLRwkUMlShhyDgfnWljqQKLX+mIOyjgoZzyyrQoH
+l2AlB1X8Ws2VajSAxkZOLeVgGQfLOVjBwUoOzuPgfK52AVdbxbRfyLDV/HoRpy7m
+Ni5x8FL8h4WX2Xg5A69w4AL8J6eu5OAqDq5mNNdwvX/x67UcXGfj9Qxewx28gYO1
+Dq7Df3DejRz8m4ObOFjPwQYONnJwM3f3FubCZE5tYthmRr7FwVtxK2fcxhm327iN
+W7iDCwQ52M7BndyTuzi1g3N3OvR6N1ffxbB7OHUvB7v5dQ8XuY9f9/JrLQd1HNRz
+cD/nPsDBg4x0H6N6iEXhYR8Fe23cb+MjNj5q42M2Pm7jEzY+aeNTNh6w8CDz6RBj
+eZqrPcNYnmXYcxw8z68v2PiijS9x6y9zwcMOvoKvWvga8/11hrxh4ZsOXIOTbXyL
+47c5eIez37XxPa74PiP/gFF+yK8fWfixAzfhJ4z/U0bxmY2f2/iFjV/aeMTGrzjj
+PxZ+zXnf8LB8y5W/s/EoQ77n4Acbf2TgT5z9Mwe/8ND9auFvDuzCYgt/d+Be/MPC
+Px3YQ6NEEvKrjcdsPM7VG2xstAXYAm0hbKHZQreE4cB+YRLlwiI6hU11hI9TjiX8
+3IfJlnAtEWWJNgjGhHH5OdMRYnLOKVxamFZaWLYwbVp1ZUnZwpEIUZnlZVXVhWXV
+MwpLa4oR2mbkT5gwLfuMrLOnZo0bnzUVAbNJ/AVEZk0ZN3Va1lQCw2oELWvyNCqV
+SQ0tzivPo/RJOUXli9OqasrSas4tqU47p3B5RdqUwpJKak5fPGtxKZecWFg2H6F7
+TnnlwrTli0vTqgqXpy0qLq0orqxKG1+8oLCmtJqLlBZ7tbLKqhFivQ7UVJeUpk0s
+rFpUXTivtHgkY5si832Ls6umjSstL6N+4BkIDr3nTRu3rLCSANriaVQEp0lsnDQW
+Z9QsWIAg5hDptnzJnr9cYqssXiCLlS7m13HV1Tn8ml1WgRDXSt8oo6Zakjm+vAjB
+XJy5qLCyykvkFJd5CYnbZGSc1RoamTWSC2VXFy+mQu3mtDZitsShSB1fWk1s1PMm
+M9+1WblEqEEhv5mFVUXVKyq4gxn0Vra4Wr6Zo0rKSqrTqVLvM/rMoCizfD6Pe05J
+WXFezeJ5xZXTma0I/oXF1VNq5pWWFGVTE+1792mNGC40bUUV0cuFouitCQ8R1LtP
+NqEmaGZ5ac3ishA8UFKVV7i4uKqisKg4NDy9+9CIuSVVJIcl8wurCT11pYL4SJmj
+enttl5R7vKbmiwsXj/w7wsNddLKWFxVXVJeQpFuiLcLY3s1qeijLayqLiv82yl69
+/25JbT6PEHWP0ialq2rmeYliFlmZYDGzKFFYXV3qgSiFEN/7RPMohKusnIppsr5O
+VYizOtWgN1FRwmnCQ1EZsZomDw13ayNoLPHyDcrnmWBW1MyrWkHSl9Ba856oc/vx
+vTP7nHieG8VLqpieWC7VSqua7L1OuSyCFR4vSqrmFxcRB1JP2PG/omKp0SurSpci
+dOg9p/XGzGVVVeeWVMhRyJRSVVZSxLS1go7IMeYpjswrqy4/lybcvHOLVywrr5zP
+IK9b5rwFpaSAaNjmFVYQ9ZzVOzPTq11UXrGC37Oz+d0qDpUwq4pJrCskZ08kf1Ji
+5pXTEPZuXeZDPSTw1OLC+VI9astZp3bv3TLnRJynvg9vpe+tttdKc3pFDXddqyin
+vhhFi6Ra4aHMZGErXs4DO6+wiDhnUI+LqKi+oIQZMOiE4zrnv8mSXkExwoATT4cT
+19VodtEIjioqVVrP8Rg9oUSquCmsXyr7chdd+B2jXHgP3nXhI/gYoeMJNLQL38C3
+LnwKr7qYjachgIud4BlXBCiAH+FjV0RTAK/AqzQoi6qrK0akpS1btqzvsoF9edhJ
+Paf1Hz58WFpZSAW68BNXeI0wwhfwpStiGF07eAaha9MoZZeWFi8sLB1XubBmMc2X
+sE5jwlOJ3BOIFGWL9i6a6LjwOrzRar9kcS4Y6+IwHM6l/bT8tLLauvA2vOXCmxwc
+IVLhK/jYEh1c0VGc5Io45uD78IGL4zHZxQzMdPEkgmEWBx05cDlIwVQXYyklOnGN
+z6njIp75OQlPc+EzTo3j3ATR2RInu6ILRoXIYfGcHO47Ta/xkzOnz56SRWOA8a5I
+FKe4mMSNn4yJLrZhLF1FNxfeoXHFCdjdxbHYhSRzDqnPua7oTpSIHqKnK3qJ3pbo
+42IaE9iPMbTlVDQHAQ7ac9CDMIgkakQkixQX+9MrfALPW4LQ9BVpzMN+rugvBlAT
+eePHTR/nioFikIsJ2NnFU3GiizHYzhWD4bCLfeEPVwwRQ10xDBpc+J5hHSgXvobn
+XfgPBdgb+7hiuBjhwndw1MWBTP8ApqMbp5jdYiQjGMUMHc9sHC3SXTEGu1P7mdw+
+rQXZ4+kle/zUrAmkg2TM1kFW3vTs6bNpbshEdhbBrLzc6ZMnZeURUKWmcXLy9HHT
+sycTNNBSZXB3x7rYE3tRD6kPYpzIcEUmoivG82uWYMtjSn5GTjavLNNmT5uelevC
+h9zTodjdEhNccaqYiNClCbNnI0wor1xcGCHj1Lkvuf+DSM23pIItN7YqsIcrssVp
+rpjEbefA89RtmhBlNGN/5lmZy6zJE5Nd+A1+RegcOWGmjZsldUHkrBJTXHG6mOri
+YBzCVnT2rCzipJWdOyUnW6bGTZ+ekz2NLGsrKycrl/hI3JqadXp+9tSs8a6YJsaG
+hFYSG9GZUTjaFdOZynxoIMbkT5+Q2n+IiyNwpIvpOIZaY9AwV8wQM104zuLRyMVn
+IdLy8dcJ7OlmqjOM+vVfsqkR6heNevfQZMovq6qpqCivrC6en1VWVD6f+Bk5u5aS
+VSNTWv++/Vw8BbtSH4tVQdKm7DrML/RMbm1FMZkNoqycing9yskKJzMoGdfKAuOR
+xlSd4Yo5LPi/wK/UUXGmCz+wBu3Qum4nL6O1DFbnZJtwQ8vl4EoLkiyz0ABTbrvI
+gc8pLyqsLmd0LcQhggvGUs83orVO2vUGmUglvOSTncTxSa0v1dK06S2NgK7/21gk
+/4xWS3IgpHZvIqu5raDgEncUMb8yXINWM7Iymt700pIqtg6rKmm5D/x1FW/THMK9
+Ky1nY9ssXlJTWFrVwj6aPO+c4qJqaW5FVRZXlZcuLSafq6SaLJ0xJ7QlmllWJ7R5
+uCdknlWwBHoYY9hjIF4XFlUXV3rcJGDvVmwR9jgyVlQXhwp1jCgUORaRy0cTmHhW
+VF5WXVhSVjWpeAWbNDXEsmGt9LsVTvwV1FxDSq+InNLCysrCFZ5NmNQK5uxWQFJm
+DDZn2RykLiL0bG0wWiMhpqZMyrxi5nhpUU/6W0P0t4aRKBIs9C45H4U8P7wWTmxQ
+/m98RilJNeFwpUBnlRZ7Enz6/1+iIwWNTbaSeTXVxVWeK0hzJNxAgF7Y1y9Znks2
+ulRoJPwhd4i4T8Luo0lJPvzCajb2CeaNTYyktEXdXn9vHrDvVqow+qvLc8qXFVdm
+FvLMi62oLC8qrqqiYtll5GfUFHn6JzrCCCyrLl7Is9WWg5zN3ejQSrvZ7HibIc8j
+pTVP5y8gbx3lHYbqcg8iVZ63cVG8pELuithqapJ+sMnDIYZwh5Ja6/qJ9JazoLC6
+sDSrspL1W9fm+u0v67BXoyikDKq8LYes8ApEHMynXioOOnJcqmaWMHNb9e+ku0ja
+g1ajEzlYEf1pueHQuvgWebs8SjyyoT8cgIOAcAgSIQ6ehmco/SzwJpoPOsFz8Hz4
+/QV6fzHi/SUq/zIcDr8n00N+hEy/pmIy4mVMNriM31YxWbgyfk/FZIfLmKwtGZNT
+I2MyV2X8qcL3mYo/VzF5IDI+ouKvVL3/qHpfq5i8IBmTZSrj71U7P0g8ndgTkvFP
+Kv5ZxbS+y/g3GQ+jvv4Of1D4J729ABphAFiVVA+YFF8LIikaVj9k1IKWtA/02fVA
+STMpKWkvWPVg14LFqRhfLTihhJ8Te8CthShZrBba/KV821D5QLh8dFP5mN1EAcIx
+CtOhLYWfgU7c8RFHYogbnannfajvA6jnI6nvWdTzXOrtbOrpPOrludTDGurbBdRD
+ZNtN9S2ZYnIWoR210u4AtUbRXmgfBB3vDTdochG0KWz8HxVjW6uYAGQf8r+s2ElV
+FGJni3J9qJD4G+WGUDkNdVWusypnEAV/KZpBRY1w0TBKrWW5PCpnokXDzOXGE2t5
+Hzkx+QBYKQchah90mB3jq4eOj9CAnzQ7uR7iUuqgU9OQxFANwEKwcR7EYBF0wfnE
+L8Yu0EcDwtgdhb1AYe/XCvaUWoinJhJmRwuoh861xF5q7OSklHro0tTayWBRcim1
+toxaWwEd8TzogedDEl4AabiqWcuC3WavZfE0tWtSzaepiUQS21NqoWtTshtLWrta
+6J7kjWWPWuhJqfikOujFcR30TtJroQ/NgqTZo2OSN8ONSQn1kLID+O8fcpoRz+i5
+mJ5R9MRz0dEJskC6yj9FPWN4PCg/Ndi4WxajoG9CIHULTYJ6SAs2bqSoX7BxLTXd
+x94CviRmUX8ulWR5VAxIornTJ9i4JNhY5uUGG4tl8c2h4tvBDcK7edvBSH1khO71
+YiBFgw5ALkd7YfABGKRS8iUmqemtHobM5LcQiN5rYXCw8ZCcu4Pk66Bg4x56GSpr
+ckJChwYbv+F5S0/MNpVjyRwr2HjEmzLcz2HBxp/prfsBSOBoLwxnPF6qDkYEwRhh
+JCEPE/IAIY8Osoxo1PM79d1SkL6mOQ/0/MgxbsLtuINFTorK6zCYYNeCH6+DDng9
+nIxroA+ug/54IwzDf8NovAkm4npYhBthMd4MV+AmuBo3w7W4FdbibXAT3g6bcBts
+wyDcidthJ+HeizvhQdwF+/EeeIJm+0HcDc/hHngR74fDuA/ewf3wCT4CR/BR+Brf
+hO/wMXIoH6eJ+AS2xScxAZ/CZDyAY/EQTsZncAY+i8X4HFbg83ghvoCX4Yt4Db5E
+PXkZ78ZXcA++ivX4Gj6Er+Nj+AbVequFiLsY5Ym4lkKTi/LwJ8zFPByhx4xK0uph
+dB2k62GhSCJ13UcbYsQaG2kqkOyNijXuojp14P1pUqt4IrqWnveS4knMA4mbG1+S
+4seKhnDm0cuYmfoQI9h4vyzBcn6qqs/iPpqecUrc59AzUNYOJNbD2BG6wfVWM0Sm
+lnLK5FRpSJSLwkjpb6TCmyhXJw9/X4W3O9UdJ+v2C2PpGWzsFkLUKQLRsxHT9JDC
+Ex+nH4BtPDni9L3gcOCvg4wRZpx5AC4geOYGGOvRPrcexkfop3rISoozWUGRRMvK
+tdA+lPbXQixTFoQMxh0zoQ5OjTPrYOIBCMhYCbjFL9k0A2RcB6cFIXqEFQQ3XCsp
+TuepKKhjDbnBhtNUxxrGhRLDkkwa0t0kCZvwDrwTRuJ9uI+kUM0C7EDrIeBnlP85
+rU9fgIVHIBa/gnj8DyTi19Abv4FU/BZy8CjMwO/hDPwBivBHmhU/QRn+TjPhT5oJ
+x2ALHofbsAHuEAh3CQF3Cw3uFSbsFRbUCxseFH54VETBEyIAX4t2cFS0hx9FLPwi
+4uAP0QmOi3hyVLqgJrqiT3RHV/TCFNEH+4tkHC9SMFuk4hSRhtNFPzxDDMBFYiCW
+iUG4UgzGy8RQvEaMwBvFKNwk0vEOMRbvFGNwh8jA+8R43Ccm4H6RhY9S/ISYhM+J
+XHxFTMbXxRR8S0zHd8VM/FjMxs/EmfitOBt/FAUtZlGb0CwSkygmacPztNEJG3GZ
+nCOeGgcsVhLEfwlySQLsGiFhv/FarCTsI3p60POKWhAG0nMGPZ/SM5eedyXmeFnx
++hMvEKtkMZbA+IgFYhFFk+jJ8drlmUeLMBTSM4AepnM4PWXAxgpAOT0sxblBEtd6
+yAtCR4omByFA0ZRgSDnoo4ONbUIzx5Cz9fRgwzExOtjwa7DhJ6YkMDesShj8YUgK
+35AdGa7676NnCD2OiqNUnKhinnn9Naq/JdhwSwjF2lDiqqbVfj+kEWdKwRSLwS/K
+oLeogAJRCcWiClaLGrhULIXLxQq4WqyE68R5cKM4HzaIC+AWsRpuFRfBS+ISeFVc
+Cm+Iy+EdcQW8L66Cj8XV8Jm4Fo6I60hQb4AfxI3wk/g3/Co2kJBuJCG9FU2xlYT0
+DvSLILYROzBa3IOdxL2YKHZjV7EHe4haTBb12Fc8iAXiIZwnHsZi8SQJ7UES2kO4
+RDxPgvtSCyFrGxIy3SYo2THifsxRylobYsaaG8WdzGRSz6YcWLEuQuDilcDNSYo1
+lMRhUoRK66QErjPrZIlF6i1ZOJC4BX6QOlsuCTlJnFZIXlHqtSs9y+jppWKpvkMq
+m8sH0rfAYFJMXZPrYOoG6Me6sB6m5aWGtF9qWPVxodQ6mD4zLFthPWYGG+OSAvPr
+IZ9KzdALHjLYGtH0FD1lvz7/fpiZogUS85uaSeFmyAaclZeqDHRuSZnczdpi3A0P
+h6Rob0h+d0g2yG7rXGJjBP+S1cQh/mFvxYMkxYMkxYOrPfWvKO5GVM0+CKcx8WHS
+tZT9RLjK/Xs0d4ug2Re5ODKn5eCvUGObrsY2j56cpjbm/lf2dwuxf0jMGWErYAvZ
+UlIGaHFJblrvVP6c1sbq+OLg8XMUS48XhhKzwjMU02EykfkeuSrvgy4+oJn6IfjE
+xxAtPoGO4lMYJD6H6eIIzBTfwFzxLRSK76BUfA9LxA+wTPwIW8QvsF38CrvF7/CQ
++AOeFH/C8+IYvC6Owycklkc0AUc1DX7UdPhF88ExzY+G5mI7rQ2epAWwmxaNKVoM
+DtXaYYbWHnO0DjhZ64hTtU44S4vHOVoXLNROwflad1yk9cAyrScu0XphtZaCt2tp
+uF3rh7u0/viANhAf1Qbhc9oQfEMbih9qw/A/2nD8RRtB68FooWnpwtTGCUfLEDFa
+puinZYmR2gSRqZ0qcrSJIl/LFvO0PFGhTRY12hRxtTZVXKvli3XaLHGzNlts1s4Q
+W7WzxDatUOzQ5old2kJRr53TQkMEQhoCKimWo++NmLK7ZkYsGp6UhiQkgW/EyRlL
+srQ7pMRfCWvSrmwaaivB0M6DNtqF0E5bDf20i2GQdgkM1i6Dkdo/W9ASHaIFeRPA
+YOeTtZU2RI/VN2IKU5IeqxMpGBehpeI8LQV3JXUOL4uX0GMpLbVMaamV9IygJ1PN
+Mo5nqfhsFfNylhlhdp6ZI30P8grn5pLz2EF5InZuSjJvFpADOUgfogcb5wUbz1az
+v3FGiBW5TQQVRtCTr+iZpejJUPRkKFiGoidD1cuQ9NDcPkupxIafdgcbjoaUzRch
+9fN+KPFa02p2GS/u2gbywTeCrt0CrrYJorXNkKLdCtVaEJZrd8JF2l1wlbYDriU/
+/SbtbrhF2wVbtXthm7Ybtmt7YQdN1t3a/bBX2wcPag/Bw9pjqGsH0dYOYZT2NHbQ
+nsGO2gvYSXsZE7XDND9ewz7a6zRH3sEB2rs4WPugxTjHYDtvnM07CEo+sl7Ha5Ln
+JOg75VKiSy+BleVNapx5mWeNeZg6R0wV59DzE/XuYFKsHuLzxgg+36T4fO3/EZ/V
+uOcmJZMLSkyfm5d6EOLkG417XioNeVRyKjumZHtjGJQaKKqFs5t8lOEhaSCnOjUk
+EN0jKPVMtJCTMVzR2k/1sXtqoIbwsbPS8G1opD8LNnwsaSRLLJVNMSqRuhfOVvhY
+vn1Ka7P5NVXF01VcpOISFZepOFSmUqWrOZai1ntzxEYADYkkx+ukxcnpIYmbFNkx
+3pByVL/uVv26nZ5U8ByokCM1QsXjVDxLxWeruFDF8znmfkf0lfkkFL3d6KmhJ4H5
+EqQ5KmphBq8wBcEI8sfMZE/t+K2KmcdvCh5fF1pcrpZKhf8uVGPCNC+lpw+PBT3n
+05MW7vjxOTL5f0lP8Hj7EDH+ECVCUXKQHluN5z7FT46jVJyoYrYedqs2T1N085Vr
+1tO7m1vsMEP1bYLqUzY9U+g5neOwDeDhFCpOULgSbOr2sfnsEx47S4azFMnHJvPQ
+yOys4LEM1aNjwxkqC6aFmHsgAm+8whvfZOmkytlEE4vYyk/UfjZ4CswC3vqNYoCe
+KjeKojSZKy03BVGAwOj8SECsni+NpWaFChhri5qyIb2Ayv8FahSQacj9+HOh6vCf
+Z4US+U02yfu8ymhHSc9+T3r2R9KzP0GM9jOM0n6FS7XjcIXWCNeT2bdRR9isa7Bd
+1+Fu3YBassv36T54VHfggO7Cs3oUvKC3gZf1aHhDj4G39Vh4Tz8JPtHj4HP9ZAzo
+idhBPwXj9K6YoPfArnpP7KH3wd56CqboqdhP74vD9DS8Tu+P6/UBuFkfiNv0Qbhd
+H4w79DF4rz4W79PHYZ0+Hh/Ss/ARPUck6vmiuz5DjNdniYn6bDFJP1NM0eeKfP0s
+MUsvFGfp80WRXiwW6AtEiV4iyvVzRKW+WNToFeI8fYlYpS8Vt+vLxZ36CrFTXynu
+0S8Qe/VV4lV9tXhTv0i8o18qPtT/IT7TLxNf6v8U3+pXix/1a8Qv+nXimH69aNTX
+aoa+TrP1Ddp0/WZtln6LtlrfrG3Rt2q36bdpd+h3aHfqQW2nfrd2j75L26PTaqTv
+0fbp92uP6A9oj+sPak/pj2qH9Ce0F/QntZf1g9pr+iHtTf1p7R39Be03/WXtmH5Y
+F/orul9/TU/UX9eH6m/qE/W39Jn62/oS/V39cv09/Rb9fX2L/oF+m/6xfqf+ib5T
+/1Lfox/Ra/WvW6xf7cM201lqd7lvpKcjk4E8sq1zpd2bQmZvitzlKeRlfMjMFnvL
++h9g6H+CXz8GAf04dNQboJfeCKkGtGg3NuzN/UCrIVtXlbzTmRPaCqXZM5RToUWs
+Vh4USFAdzOMDD7m/Sq8k32zS8MZmUWgVOyCpHMxnCjQLk1LrYT4HQ2ZKBeYtzmIT
+1eZd3wVbSbHthZ5Js+n9DL2gFooHBcGKWLrJh/b+Qht8/NTy9pBSCNcofZCm9Kv0
+Ophy8hoGhrrhUbrQO6OJ9wB+L3JifJQw62BRkBZo3r3ySQhnqQzevS2JNTaAZVC3
+eBo3jo411od3HxiQElqduym62D4LbSkMULp3gNK9I5Xu5Xdev0+XC985wYbP5VaF
+s1mygDSaI6G8g3luaJew4XHPdp0EngdI+DCF4p5qnRnl4WWbGkmPLq+H0mDDvxSG
+JE+HvqX4yVs2axXvWPfz9s1hb6Hxxr5A8Y63Ffd7bu8W7rAVy7vkM26DrnFmrMWy
+oFEUXudjLb1gzRAr2PhOs7UqkN7CEmBWykWD0ty/kI7vo8Y0Vel4Xr+7yg0kGS0O
+0hh67IYYudtEg+lZNAMk9bGG2Hx8A9sZx9e2xtHjq0IrZY3i/PHQDu7xIiU7nVuT
+lDooC0o3NVJKCBh5isBzKXkbJKr6lixR3vw04f0mnV/GvTOiwTDaQbTRHhKNWOhr
+dIR0Iw4yjU6QbcTDbCMBzjI6w3yjC5QYp8ASoyusM7rBXqMnvGT0gTeNJPjKSEbb
+6I8nG0OxmzEM04zhOMAYhUON0TjaSMexxhjMNDIw2xiPOcapuNqYhJcZOfhPYzKu
+MabgjcbpeLMxFTcbs/A2Yw4GjTPxLmMu3m3MwzeN+fi+UYwfGYvwM6NEuEapiDYW
+izijTHQ1ykVfo0KMMJaIbKNSTKb0mUaNmGcsF+caK8QSY6VYZpwnVhrniwuMC8Ul
+xmpxuXGRuN24RGw3LhU7jMvFPcYVYo9xlbjfuEbsM64TjxjXi8eNteKAsU48Y9wk
+XjTWi9eMDeIdY5P41NgsvjS2iG+NW8X3xu3iV2Ob+MPYTo7enZpm7NJcY4/W3rhP
+62vUamONei3HeECbbjyozTP2aUuMh1vowg4hH0I/j2YrzVHRiLmBovQmQ2Z9hH6J
+V/olnu14b6v9zDhTHkGdRqCKEVacdQBOjrMYGFUHS0iOzCBExVkyM9j4SZx1ELrI
+zXhZT6qlWbwjT77h/O1i6W4GV4wwg428t2/SU1QHlSw7BK8iNbRdTN2dHKGZk5M9
+nRxTPcJgqg5gP+llJHu6WRKJnRnr2dIRQj6GzlO25Rvee+iBJ1T8n+bw/6PH1zoc
+7mkFxsf/jRHvD6iYt6B/jqkZYQRK0oNwdsxSlcqPWaZSk2KWq9S4mBUqNTRmpUql
+xpynUt3CsLiY81WqLY1vcxta6ojRTcqJHO78fXDBbGn3saKrh1XyJFKsp7UwmXeZ
+LtwAN/CqVUSajle/ZM+dJ87zqpfCq57MnS9zKWUuXzOEx7Mk1tQLaNBWT/NejAIP
+r0N1nSAYMT6VYRbE6SppFcQZKqkV8Mhqg9ZDmyRvjBd6lYKQHKFxvIhshYtaoWw7
+tCF+jLC3gxlnPzLCR2u2zzMp7vTtpkXFgAsE39hYBbfKeKv4jGPxpfhGvnuK6zR2
+DY3DIIxXSHm9Ad2NdyHNeA+GGh/AaONDyDA+ginGxzDN+ATmGp/BPOMLqDG+hJXG
+EVhFZa8wvoUbjO9gk3EUtho/wS7jZ6gzfoEHjV/hMeM3eNH4HV41/sArjGN4tXEc
+rzUacI2JeKMpcL2p4c2miVtMC28zbbzD9ONdpot3m1F4rxnAvWY01psx+KAZi/vN
+DviY2RGfNDvhITMenzUT8AWzCx42E/E18xR80+yO75o98AOzJ35s9sHPzCT80kzF
+b80B+KM5EI+Zg4QwBwvLHCLizGEiyRwhBpujxEhztMg008VEc4yYZo4TZ5oZosTM
+FBeb48U1Zpa4yZwo6s1s8aCZI14088Rr5mTxnjlFfGzmi8/MWeJLc4b4xZwpGszZ
+LZRSx/AG1hk0FrxQv80n5BvAlmf5fL4Dz/xvC2pUgpzxG5QBpSunic8x2MnjDa3L
+5NmMzecnu0IGzDYPZhBsQwh2fXyrC7PcuEs0qWRFqOTCYON8icCyyFZiJPnxvP9u
+C0qGDgEbQ4eAjcOajNgyxmjOB8ssBtdcCDHmIhhslsAs81w4yyylGVQGJWY5lJqV
+UGlWwTKzBi4wl8JqcwXcbJ4Hm8zz4VbzQgiaq+Eu8xK427wCHjD/CQ+ZV8Pj5jVw
+0LwWnjevg5fMG+At88YWPD8pfI7WkUxivhhyNuZ6Jmt65404XTK0813yeor3x3yI
+8xQbfBBxlnaFxOttTLChN07Fs1TMZ2m8QXC2eucNipHhrf7clDq4eL20MWLY4K+D
+S7wd8JBuihAEb58oXVIZbDwzxNNpocRpctRCm61jPHrlmJ1spAcbk0Pl5EngOcHG
+TrL8VGg6DQ+d6Y1V9bJZxaSEVKPmWYSkHOvgUpEebHgrKTBGWaxqS+egB5EN6FSi
+PpSxq2ng72CxMreCMG+jwb8dosxtNPh3QIq5nQZ7F1SY98BScw9cS4vYOrLHbzbr
+aaDvhzvMB2C7+SAN9D6419wPdeYjNOCPwyPmkzTgB+Fd82l433wGPjKfhy/MF+Ar
+82X4zjwMP5hvYHvzbexrvov9zPdwoPkhDjc/wlHmp5hhfoZZ5pc4yTyCU8yvcKr5
+H8w3j+JZ5o8tBCYuPEnfJu+LD147eeLCp6/REfOPVzj5Z6jBGKkmH3suW+jZFx+Y
+oybhwdCQ7PeuL4zbQsanNzg7Y6pb43vkFQm+l0BILiZ8TUCmiWdoaTwfgYawnWUR
+aLYEtZM3BLwh4oKZNgXpasKnQtNOPe/28AFwvFeBj8PIq+B5HVAomiFq+CM01t83
+jfUuPtY1G8Egh9VvIQQsAcMsHdItAzItC7ItG3IsP8ywXDjLagMrrABcaEXDJVYM
+/MNqD1dYHeFf1kmw1oqD9VYn2GjFwybrZLjd6gI7rVNgl9UVdls9oN7qCQ9bveBx
+qzcctJLgaSsFnrPS4EurP3xrDYDvrcHwszUEfrWGwh/WCARrJJrWKPRbozHKSseA
+lYlx1oQWY94J45XHPpJGU0heSG+JulzQ0mBoulHXhsXDmkWdng2OdUYLpAnYWSHN
+JajcNmxC2uyoUUtRI8+HjU3oO7BkWeWEvoLQL4F2ViV0s6paNHMydlHNTPAuCsDJ
+3sldrtxZqIX2HMtTuBa7Cx7+1aTRL4K21sXQ0boEOluX/gV/opoPHQnKi819cksg
+V6q1vJh/pHp6bHFSoITMq5SW7KqVVwRCu4fDoZXdQ0lvazX9QWgfH8gLC30KOez+
+lHtjLlNtdmeAc+LqKfd69SJuQU6F9tTp68G01oBr3QAdrLWQYK2DftaNMMVaTwK6
+Ac6xNsJiaxNUWZtJULfAKus2WG3dDlda2+Ba6w5YR0vgndZ22GHdRUK5owXDTsGu
+akDmKmHqHx8YvUXecPirSRpIbcUmbSK3Ey851mNE7uM0r56A9taT0Il8kUTrYItm
+u2F3r1nyJ025+1PiCVU6jtBxhJEUjVALlycFetI09g73tez/bWyMjjVJ22knKV0X
+sVuDB2goq5tuHSKfrvBuSDdKXwmt7+gvU3pyrVpAF6oFdKFaOBeqhZNjubNPVnUT
+sxJYDVFwBZ+bN471DOzWM7tR5uXU5a1wUlJnfb7a+ricysgTf+Z0H2MLtE0KjFSw
+hqOhYejsbQN3ns/uAV9l7RZn1MHsRyGBnAUPGd/SWsaH1T0OwoLQba32HMTybS3p
+Lw5oeTnLiric1T7ichafwAflgcC58YHlmyNMgnhu+NQgaQ72TbL+WyHZhdRYM8wQ
+gwEJIV3drmmgtqhx5HFIUvy+WvG7q2Rj8PinrfEi4NwP/+Q9opjkW5u2hNaMDoJ/
+hBVysSR7EgKJm0PXkK86AG5SAim9q4Nk3yQobh+/WKKlEUgILCcryGRY6Obo8eKI
+y6xwI3hGLtM7SMlNiqI7RdGdouhOaZXuwP87uo89EzrZeCyUuH83CDFKLBLnwpXi
+Jy1R6wZXKl9qDRNnvUUq9m1S4e9AlPUuTeH3aAq/D12tDyDL+hDmW5/Ak9YX8Iz1
+JbxkfQOvWd/C29Z38J51FD60foQvrJ/gG+tn+MH6hZa1X2lZ+w2OW3+iZR3HNlYD
+drAaMc4GTLARu9s6JtkGptom9rN9OMF2cLrt4hw7CgvsNrjIDuB5djSutmPwX3Y7
+XGu3xy12LN5jn4T32XH4gN0JH7Hj8ZDdGZ+1u+Crdjd80+6O79s98FO7J35j98aj
+dh/80U7B3+xUbLD7CrTThG4PEI49SETZQ8Uge7gYbo8Qo+wxYqY9TpxlZ4j5dqZY
+ZE8Q59rjxWI7S1TZE8VKO1tcaZ8mbrBzxE12rtho54lN9lSx054m7rGniz32THG/
+PVvss88UX9sF4nu7UPxkL9Da2ou0DnaJlmCfoyXai7Vu9rlaD7tUS7bLtQF2hZZh
+L9Em2VXaFLtam2bXaDPs5dqZ9krtbPsCbZG9uoXa7BFSm7jDuwKF8c3VZqAH6xXW
+FptB3y0P6sIyZigZ05WmYN0+MnJqdm1VcWxRiqP6r4pD7j2lk6PFWHhdO+e/3fD8
+qxLhrPh9cM3sevhXzLV1cB0TcF0dXC/VSIb04Nw4nbyMNUFWftxCnK7Ra0jD/DcM
+TbbDKugCYF8Plr0GHPsGiLLXQjt7HcTbN0KCfROcYq+H4fYGyLA3wkT7Zphhb4K5
+9maYZ2+Bc+ytcIF9G1xs3w5X2NvgX/YdcLO9Hbbad8Iu+y542L4b3rTvgXfs3fCR
+fR98ZdfBUbsefrEfgEb7YexkP9JiEHtiL/VVwa+05LKu2OztpmyA4TE3JMudWrYX
+rmz5nUeK+roj/H2I91mIvjN5D6ytg3VUZ4ZX/eL0E9VNllaWrN1Z944jvV2aKFZC
+a/I5X+usQHod3KjvjPjkYQJEEyNfAJ/9InSwX4au9mFIsl+BgfarMNp+DcbYb8Jp
+9tsw1X4HzrLfhQX2e7DEfp8Y+AFcaX8IG+2P4Bb7U2JCb+yj7I5rlCHIxqWVm3IA
+4lKSvc7YbAreS0FFbrDxSLI2SF7BCpdSPGte6i8mVF/wE8lHieTvIcb+ATpSuov9
+E/S0f4Y0+xcYZv9KpP8MWfYfMMn+U46VDkhjJfjDe0XkVWoLZNrf2PDQRsdHw+qt
+ELUH/h0/kBV32/iY5LDvnGBubnxI1uMpVhzfxN2efEzjawvdfAHo4YuGFF8MDPG1
+g1G+9pDh6wCn+jrC6b6TWohTCqYqIgepA7z2++Cm2clEy3p5Zkfe+4aUR5r7Ab4e
+4Ph6QoyvV7MO94U/1P5DT28jGucxpTO4gzNYe/DtpSFGrK4XsE02hEWreIgdTwNj
+abzTcsMQX4hDt0L3pFg7lmSQv8dImtnUZa+Sqt6MhaO19IQw7xIGruF90oQI3sX6
+2Jl9poV5VxSKO3tr8Cj4y7VP6H2pibE+vYAI5OtNYVrCsEkhpzeD91fkxQKApv2V
+LhwTjmBjVwqpw42dYokPTYdNpj6fGOOjDDQIX8OfEf0NsYEPqHSuNn9NfuiSWcPh
+8MjsYQPBl04jMwYCvrHQ3jcOOvky4GRfJnT3jYf+vlNJFibCeF82ZPtOg2m+STDb
+lwNzfXlQ5psMFb4psMx3OlzkmwqX+6bBNb4ZsNM3Gw755sCzvjPhsG8uvOYrgA98
+hfC5bx4c8RXDd76F8IPvXHR9ZdjWV44xvkriUxV28lXjKb4a7OVbiqm+ZTjQtxyH
++y7ATN8qnOS7EGf5VuNs3z9ayGJa+DD5VnUBb3H4xsg53lXsiC8T+KKOrUzvHGV6
+5yjTO0eZTjnK5M5RJneOMqVylCmVo7YStsmLe2FWyvt6vhvB8P2b2Lke2vo2QIHv
+Nij23Q6LfEEo9W1vQXq/0FwXZZ4jhL+0dHRySC9d7J1fvK9Eg3Eke+8SNlpZrJ/z
+1ImpSfY0uR0oCYIRGLNTYhukun+GEmG+qzdEidxE8O6ydI9ZGq5b6dWNqQ5DihTk
+5jBkggcJ4rimJkYrGrM8GiXeuJhl4TpTFZblYUiZwgJ/RhJapSxaHo7JCl+hwsd4
++RxndMwtYSzZCu/KMKRaQTaFIYUKsjkMKQ61fSG3bbRoO9RmrupXnmqb6ZkcsyKM
+JU/hPS8Mma4g54ch5QqyJQw5PdS2RmFYhhbwxPcdgmjf0zDW9yxM9b0A5/tegn/5
+DsMW36uwx/c61PregVd979F0+gB+830Ef/o+xxTfl5ju+wqn+L7Geb5vsdp3FJf5
+fsbtvl/xQd/v+JzvT3zfdxyP+hrxR8dsIYf9QyYeOYuGvDf6PBtNuU3zSF0h3fC/
+l6L0WN3b/MOSCJWZqN75bly1UpmngbddzPcE2HNxVBx5T2AkeDsh48HbCUkPNq40
++MJotclh04d0Cud/wLu/yDieVXV5CvO9Lv5kg+8KnKdw8Rxgtb1dbfE+FasbWyCa
+e55yB/gENxDFJ2I01Ul/mi3yGr738hqOxAfmq/3F0mDDOwr6CkHJkpTbF6cHG55U
+4Ic8y1Vm+hVse0gtb/YS8exjdVY+1kFo1+wgP+CkJ3WWPldD6OihYWF8oGSLPAGT
+22SD+NuBKG8RZYu6SUU9yPrO6QiGcxI4Thy0deKho5MAI5zOcKbTBW5yusNGpxds
+cnrDrU4y3O6kQNBJg7udfnCvMwR+coahcIaj7YzEKGcUBpwxeLIzFrs7GdjHycQU
+ZwIOcE7FEU42jnFOwwwnFyc6eXi6MwVnOKfjbGc6Fjv5uNiZiVXOLFzqzMHznbPw
+audsXOcU4HqnEG925uNWpxi3OefgLqccH3cq8DlnSQuRHRDW+pkksLzaduGub5Q3
+YOIj9orr4FYpxi2+fnVWgOWcB3HO+XCys6qZQTIQB3m2MiaQ7LL0HlJfE61V2q1I
+zlTvJmh8fPMPenxKSzgqjlIxSzOfU87YBB0jBirsxewO0sB7M0fuOfhU3e7qSVJP
+90DiqCCfrWvNrSTGuX8rBEK44/P5ikhYBuSS1cSDDAgQiVdCgnM1THSuh7nOGihy
+boD5zo2w0NkIV5O4XetsgTXObbDOuQs2Oztgh7MT7nd2wePOPXDQ2S051V15FSuV
+V5Eum/cIO6PWoyJFbuHu15c/ZOTJgUnVJIC/v0itldQqinfLgYyG9rA1ck119kG0
+8zi0dx6CWGc/dHEegb7OozDQeQxGO08QHYP5I2tJx8We/gJuqDh+fnpC5wK5zaHt
+Z9OQ487kgMgTbU0jty5MSJzuUdJTyk5CZ4ZxNzoXNJMdj54XSHZeJHpeJloOQ5rz
+Cgx2XoNM53XIdd4geoaG+CLmeB/j4yu8taY+SXuBgraebsKDnk6ScS8Vj1Jxuhcz
+S+BS4E/SgT//R5bAXynmkxeXHj6yo3UcWW/PoYe/mV5CD7vql4G8A4c3q/sJe5S0
+ToOmz8/4mIt3EwfTU6qklepDdlI0Yi1cHsSOlBIyFUUpTaY0Slmcgt+TyPmWqe+S
+4gPVvLixhIaAb4eA6RHApxQdaWpGLQbPbK5gXU2YdVlqM6UMmVoXbuMqQlfB6HpG
+oFtKwHKy2KPRjIAWELSKi/aKAE4iYI0sakdAB4cR+CKgXUKkd40AOoqUJqFYyp6A
+8wlc4XwGe53PYb/zBRxyvoTDzhF41/kKPne+hd+c7+BP53vSmj+Q1vyJNOXPOMT5
+Bcc6v+Jpzp94pnMMz3YasNJpxBo/4uV+gVf6dbzFb+AWv4X3+W2s8zt4yO/HZ/3R
+eNgfS4I2DIervZmlJGg8oF+hvJRYzMGC5p/Gt6PBHB46RaXszGT5dWs0R7l89HHb
+zCD8K1l+3XoRRbcfgMEc1cG2vNSYO8hwWU8rIOcH8ushmBukNSaVX+the7h+nlcg
+kQukHIR+STF3NiviYbqraVM6jIHVlULStD3ULsWjuR2V2qH2cii5sxZim/i/Ek4G
+8JMJ4+8Blr8nuP5e0NHfG7r4+0BPfxIk+5NhgD8Vhvr7wlh/Gpzq7w95/oEwwz8I
+zvYPhsX+obDMPwxW+0fCVf5RcK0/HTb4x8AW/1i40z8O7vFnwEP+LHjKfxo868+B
+V/y58L4/D474J7dYlUbgSDUe73kKEecStXene9YJbxDojY3S2ODPBL9TKr1BGSkM
+X5kQyA+7nlw3GvZtbv7+SPh9H+ziX3e4514vozEi497ZyYF59bBbZTW0yCrlrBYW
+XExyfhhhJBWdo+Hoqh3g/VACy9ij4N2HeEnFH4LnG/FvmKxsgbRzoMuqgMnm/t2B
+MatWr8nnGdiySNtVATdUhAqvjizdeR/smV0P9z3Sstaa/IgdF3mFwj8PDH8R9PMX
+wxD/AhjlXwgT/Isgx19CQ30OnOk/F4r9ZVDuL4cafwUNdxVc6a+G6/w1sNG/HO72
+r4A6//k01BfA4/4L4aj/Ygz4L8F2/ssw3X8FjvNfhdn+f+Ec//Uthn0UjlYnSxNp
+2EnvalswN+ZOuQitl3dre2qDAqO2gKXzNdobhrCW8k6YcIsyqXvu34prqeN7Zw8x
+NoIv1ljDt5uSh+gt+h2r58sDJ8ACz1iQ9i67sf8E7/sd/maEt15epjJ+eoaqy6XT
+lK5lm7cTSZ28wiKPglaesF25ncBN6s3Jb5SnKY3jCD5mi7odLOFpBFlOEDMM6UyQ
+xepWjAfxE6SUIHYI0vB76P7rgL9jRQX4KKThKXme84hXs7WrHokBi0vcEmjg6MZg
+ww1e2URoOtkPlY3zCi3xUIc+n2woZA1azJqUdWqsKbaAkXov/5BHsRq++9WNbdPz
+0W9XY8J94HvFw5oezPc+8uFfZjjElrxk/f7wlz/YBpo+Rf9Z9YU/T2cfuL9SEf3V
+mt0/fG2mDi7JjalN8dzKpMjDwJi6pMDoeqhvdlWCz7was2PuVxW6xJpGxFGrV3xb
+nikPCGMeUKWmSLS8gdtnfcvCl+SmxDzoFfPz3ZzMIMSnxOwLQTQJUXXkeDwXYu4T
+wYZHCXGzH0uRJe4Klbi12fdeY6Hpy+nRij8J0jdKjzxRCF8SkvJxVrBhTgjd1FAi
+OzWsOfBG/vTefzstHttIe9xFi8dO6OrfBT3895IW2Q2n+feQ5rgPrvbXwnZ/Pezw
+3w+7/PtIQzwEL/ofpoVgP3zkfww+9T8OX/gPwi/+Q/C7/1m0/c+h3/8idvK/hJ39
+r2CK/1VM87+BZ/rfxQL/e1jk/xAX+D/CEv/neKn/S7zCfwSv8n+N1/q/wTX+o7jO
+/zPe6/8N9/p/x3r/MdznP477XYFPuhoedE180bXwVdeHb7sOvuu6+JHbBo+4bfE7
+NyDauzGii9tOdHPbiz5uvChwu4j5bqJY7J4ilrldxQVuN3GJ212scXuIm9yeYpPb
+S2x3e4tdbh+x100S+91k8aSbIl5wU8U7bl/xkZsm/uP2Fz+7A8Rxd6BmuYO0tu4Q
+LdYdpsW7I7RT3FFad3eM1svN0FLdTG2gO14b6mZpI9wJ2mg3W8t0J2kT3DxtkTtF
+W+Keri1zp2qr3GnaJe507TI3X/unO0u72p2jrXHnauvcAm2TW9RCw6bjGOXuVasN
+5/HJMXdKk8TlRStFroIxD0lIG17jUrw1Ljnm4UiYXBL3wf7ZKbTMPdK0fsjvSNxK
+8LlVEONWQ7xbAz3dpZDmLoMR7oqQfwh7iJax2EV5GxVqw3EUmyW8LVILj6okKY01
+7O61qyWLNVn+MpIyxCh+lDUKxWtIj7TwLdxLwO9eCh3cf8DJ7mXQzb0ckt0rYKD7
+TxjpXkmtjyPH12t9j2p9gWflDT8gV5p2od/i0XPCNp/aSqgN/fxVr0jD0Es+2mQu
+MlVsjCHnaiHlx76ZQ55Zx/CP9QwA8j7c68Fx18BJ7g2Q6K4jWm+EAe6/YbR7E0x0
+18MMdyPMcW+GAvcWKHY3E/0ZmKlGcpSiP8E7unD2wGPxA9fsjOffarIDs3h/7Iym
+nTF5hODWg+XeD23cB5p57OPDZyaPqwslS5tOBOYqphwEl3/CiBXGTgWSC7Nce+vg
+8VHxN8tfjmIedd/WvHBPjYwjVioL+KQ7PsSTlltgTdSOIHrBfZLG8imIdWlk3IM0
+ns/QOD4LQ93nIMN9Hia4L8Ak9yWY5r5MPHqNePQ68ejNsKyx3GeFtzlGUf/ZAzyJ
+e3ZLWN+FN/xb7G+4nxKnPoMo93Po6H7RjFsTwl57L/VTcf7QWh/f9Eke8A+AgXuU
+hvd7qnQqTlSVePh4eYtPzks9AB1SU7zb/rQupu6Firxg49fY4oaWewxM9zi0dRsg
+mtJxtJgL/tlvhXCqOoxjCp44IPn/BDkLhKwWnggC6donyQB8Sn4yXpHS4uZPVBRY
+UW3AjWoLHaOioUtUO+gexa7RpDD+MxX+3vyhQm4yX4jiwM9BFAeDeaI+Qch5oj4R
+0YKckVGJYER1BSeqG7SN6g7to3pQD3rCKVG9oGdUH7AxJzQjxSveVhS+oT9k3Afu
+HnA1Ld/idPQeiNasfArJPOLICCzmyAyU5gdMLrF2D6zVAiYB13pF1npF1nIRiqxA
+GUd2oCpfG8k/6GffB491CiRuhRiaOJ066QU3jAysnB5s/JZeA75A4nSOo1TsUNwp
+0C9UWJa+ngt3Cgy/LRLDfA84rrWSZzQrOc4DFrZWcmWzkoUSKCd5i6LfqI78Wxsp
+qSM2/buTmC7zg43fSeIkTEKM6RI2bmsETDAsMGekJKRF9cB5I71Wm8OJQf8OnK1N
+52iELqO+hoxSvSjRlJHPi6K8yDGnN82Nr+R50fkkgBeQEryQptxqOAkugi7kI/WE
+SyAV/gGD4DKawpdDBlwB2WScT4ErYSZcBWeR4i6AvbAIasltqSMM9VT6frgGHiCv
+8EEy4ffBXfAQeYsPkxm/H56i8FXyud6Gx+AIKbjv4AnyGJ9EHZ7CdnAAO8FB7ANP
+Y394BofDs7RQPoOnwnOYC8/jHHgBC+FFLIeXcTkcxlUUXwav4nXwGhk+r+ImeB23
+wRu4E97E++AtfBDexsfgHTwE7+KL8B6+Du+T0uADEIF5/x9QSwMEFAAAAAgAsVTK
+PjMr10YoAwAAgQYAAB0AHABjb20vc3VuL3VraXQvamF4cC9BdHRycy5jbGFzc1VU
+CQADLizyTUws8k11eAsAAQToAwAABOgDAACNk01PE1EUht9LpzNQiuJHkdIOoqK2
+gzKKkWiAqiHR1BCNgi50w4CTWuyHtlNT/Afqzp1hJTFhwwITQWOia8Vo/AF+xo1/
+QJfqe6cDKIyRxZw5c+45z3nvuXcWfz57AeAAekIIYbeGPQ1owF5pEiHUIRmiZ0jT
+Jc0+Dfs1dGswBdR82rHzZYEtl4cmrJuWmbMKGXPYKWULmT4BLT9kFzLOVQExyOT+
+bCHrpAQCieRFAWWweMUW2DiULdhnKvkxuzRijeUYaSjbzlKdkhiUuQ2ZlRCr04Qx
+cuE8nUginfTrHZYlxXErd8bKE1rPz3M1V6M7MnndC160chXPTReu2FWBvYm1vLWR
+pNvbP35kfQQ/2Xv8kH6JoeFipTRun8zKkYVOOE6p3C3TwmjGJoHm1SVhhNEUxgZs
+DPOoD4YRQzSMdmyXpkNg23gxb5YrBbNyLeuYE1b1uulC/0KdHZuwxx2BlmIpY1bz
+ObNsVd207FjFsZmr2jcqVq68ajS1sr7kJXTwAoUg0Mh7BamItk6K4nsDH2rn6mZ6
+3YwLGTWeQBjNx5+jbh6BR4zwtrnZAdqjUNBHSj/9rYh4tce5JvnxmPEYgRfqrXsP
+0WTE1GoNYsTmoayQNpMBnKSaU2hBmoM5zZUWbPNoOt9SSZAwZXa5THWDl2lbEfVS
+D3qNo7EptMjmyjQ3QA3s3TMDRcytKs/Sti2XH/LKYyxv9cqbvfLgqC9gkja2DDj6
+R/9GF/AAQTHnIZTRnrlV87vNXd+hf5fR+DKm18O0ExNbmuGKFM1fykNafV17Uf0B
+T2l5IT1AkYAg38dkbSrQq0QUfRo9EhFROM6uBQTvo3Xpm/PZ50bUiDIbUZTRe73K
+zK+3dSsH1g6N9iWhr1CPRe76Nf+EN1T6FgN45zbv8JqPULu8FZ2y+UAgpcenETX0
+Bai1tkF9VmeL1Myvb2s6vGeHD/Q+crafeDk+84S/YCe+ujPe8ceMZYc2o4u6tZQ+
+VRuP7jPfkDvJ72T+cBk7PcZhMuQpRg2qqh+Ie4j4vxBChSo095jWIWPNKdUYrdBE
+1GX8X8Y/EEnKMBjZ5f79nb8BUEsDBBQAAAAIALFUyj6Dh0WlHQMAAKcFAAAlABwA
+Y29tL3N1bi91a2l0L2pheHAvUGFyc2VyRmFjdG9yeS5jbGFzc1VUCQADLizyTUws
+8k11eAsAAQToAwAABOgDAACNVMtSE0EUPZ2ETBgHgaiIgCDIIwTJ4FvxiRRZUYgJ
+UMDGGuIQB5OZcR4a/QEf5RewcufGhVapqdIq3ftRlqcDhAhouUhP+va595zT9878
+/PX1O4AJ3FLRhtFmtCItlzEFZ1TEMK4gk4CuIo4JiTibwDkV53EhgYsKLqlowYSC
+ywquCKjZmamFxdzM/bm8QHJ2w3hi6CXDLur5wLPs4jWBlmnH9gPDDpaMUmgKaDsZ
+87mZLAvYRtn0XaNg+gJiVSDheua6VZHb+HXLtoKbAtHU6JJAbNp5wAKts5ZtzoXl
+NdNbMNZKsqRtPs1PLc8bnm96An2p0ZqQil4pl3S3FvX1OoCa1JlKwXQDi8oUXBVo
+981gbkfH1FPDY9FYalWSqjzKmkYQylhHar9DohRMElhsAB47ADhKc2reCb2CmbWk
+7OSWnqxRCBzvWUYmaOjECQ3H0KHhODoEOgtOWfdDWw8fWYG+YVRcfStLIvsFMvuN
+bp3z1tetYugZ0mXdrgBk4jUNp2T28MMgcCd1mZ5xvKLus9T6lgdf322MgusaboCN
+yPxXwvhuC4ckSqqTSLZgzglyZsEp2tZz80GDrL6/+dy+HYGBf7S0DurcQ9fAMLhf
+ST50XccL/hByYOc4B217oxxP83FolPw9OXfXNsxCwG6jn+9UG1+0GE6gHUkIHOEu
+ApX7ow17jT92vPb/eO3ZxDMOAtcu7nTG2Ti0pqsQ6ehnRNKxz4h+ZEigm+thRLmm
+SJRBM+ECPTjJJJm8xjOZPJn+hEjsLY7wGd2E9g2xlVgVTR9kfBNHZZjHtXhUxr8h
+vpJUqkj8qPN0UBg4CK24SXm3MILb/IrcQS+jcfLF0UckJ2tbeI6xCJ8D6e4qmrtZ
+vk0qj0gP0XdoOchLLxSu82S6x4vKkSvPS1mkoyXWXSZqAKe3va3Sm3SeSapjX3CI
+9Q+le1jyHXqTWmOEZDTWsjJWxeEfu1xdVAyUyWOzHQ45XAzCwziCmqcEq8f5tRsk
+fgjD26x3GZWuRuqsCXmH7+uUcht9X+fbc30vSPeStl6xv69J82Yf1UhtElK/AVBL
+AwQUAAAACACxVMo+OpIp+WsCAADsAwAAIgAcAGNvbS9zdW4vdWtpdC9qYXhwL1Jl
+YWRlclVURjguY2xhc3NVVAkAAy4s8k1MLPJNdXgLAAEE6AMAAAToAwAAhZJNTxNR
+FIbfO53plOlIizCItogQYtpiHFeNSmMXBJJGhEhbTTUm9mNiho+Z2k6xMaSy6F7D
+joSVMenCsjAqGE3UtSt/Aj+BX4CeGaYtqImTnHvuOXPOufd5c38cff4K4BomJPgw
+0gcR5yVcQEhEWAKPETsYFXFRxBgDp1cZlPnl/Hpe1U01ZZRrVtqqaPm1aQZvQjd0
+6xbDSOSfFdF7DPyMWdIYAvO6oS3U1gpaJZMvrFKGp5ISgxh5OJNKRVMM0my9qJUt
+3TSqIi4xeCJ2ViiumlXNiWialDZrlaI2p9sTAks0QatkM3PXr9rHy/BDkdEHScS4
+jAAGGSY798oa1Vq5bFYsrTRrFM2SbjzpnidjCApDuGiuqdWaodZWdEtdztfLau8E
+hv7OqOMkw2CXebE76mS2pwTGSWUfqU6C2vejHU97P2Raz1AUozxHXortg8WmPoJ7
+51T309oPD603qOMm9U5TNoAgVdt9RxDgJb/nifMKP/oau7EP4PbgycWFHQQUfhs+
+hW+B59qKMIDDxls434ZzA+A72RWyn64/IEuRHZJZU+EmxxQhONYIeuvu3GCysbmV
+bSHZ+RloBOUTP6ly84/SoS/gc/sQvrktW9kmz1q/0grf7jLGHZoUkd4mxnkM4w4m
+sIAM7sLAEp4ii23cxw4e4A0eYReP8R4FDLhKnnVUGXRV+URzbDU7N8kldiBw7VBH
+gJUT9FGXPurSJ136Yugv7kQLaug/wFTj7/CGenyXiQpEIaNCcRUJrGMRz4jsOUUb
+FL1AA81TPPQmXZ5Jihh53/FB3t7bkBzOl/S6Xp3qHaY9h3O/AVBLAwQUAAAACACx
+VMo+hYvB+H8CAAD3AwAAIwAcAGNvbS9zdW4vdWtpdC9qYXhwL1JlYWRlclVURjE2
+LmNsYXNzVVQJAAMuLPJNTCzyTXV4CwABBOgDAAAE6AMAAH1SS08TURT+7nSmU8YB
+CnXk0fIoILbFOBq1ibRBTCNJExTloVaMybRM6uB0BvvQrpAFMXHrzoSFcdOF3ZiI
+JJrozoU7/5B4ZpiWR4hzc8+dc+55fOc79/ffbz8AXEZCgoSIiKEAhiVwGOlAB0Yd
+EZUwhnFHTIg4L2KSgTMqDMr8uvZSUw1bzVobtepStaxrpRRd5m0GlmHwpw3LqM4w
+DMROdc3EHzDwGXtNZ+ieNyz9bq2U18vLWt4kC08+awxibDWTzcazDNLtekHfqBq2
+VRFxgcEXc6xCwbQruqtRNmnJrpUL+pzhZAguUga9vLI8dyV5yQEgoxsDDGMuGFOz
+imrWNPWiZt4qF2sl3aq2KzDAcY7J6ESXjDOQRcRlhNAno9/JMVSwS2qlZqm150ZV
+XdfqG+qRagxdrYYPrAyhNgMLR6ooHjMuGKLFsIopp4/QKXwhSsOQaFgcLULk/hE8
+OnkQgwiS7CHNho8WkErsgUU+wfmirjeQpz1M26QdbiDYQOd3cLle3x74n4nILoTE
+1C78n+maoZfkGAIkr1KJaxhFEuO4gUmk6cXM4DpuYhqz5BnCWUrvFP8DAX463/qS
+fOILhGD+A2YVfugjXpHq/woxlxR20K3w7xFQ+AZ4rjkV2eaYIgQDdc+lB/ubW+9W
+tnnW2P/lBk//P9i7pQyKcCK42W4lSWwBd4ibBWLvHtnuYwSLmMISMlhGFg/p5hGe
+IIdneIwtrOINnkLxGD7nNtrnNWpSHofR2Ray9A4ErtnquT98sp10A8ohzrBnDB/i
+G3SJMwlbiaZqUSUbF/GCiK4cw0AP0MMwQRo9VQQO8gYOxya52DYh4vWx2EH3HYT/
+AVBLAwQUAAAACACxVMo+bDEYTCgCAAC5AwAAHAAcAGNvbS9zdW4vdWtpdC9qYXhw
+L1BhaXIuY2xhc3NVVAkAAy4s8k1MLPJNdXgLAAEE6AMAAAToAwAAlZLPahNRFMa/
+ycxkmhjbGqOm2qltbGv+SKdIdrURCQiRoEIlUruwk2SaTpxM2klSU0V8h+5cWdy4
+yUJBKCjkAXwSn0L95k8DDUVwMeece+45v+/ce+fn7+9DAKu4HYWCmwrmIwhjIYoQ
+UhO4pWBRwZIAydZbhoB4uakf6Jql2w1to+uYdmNNgHygWz1uyrVd3ekICG0Vacy6
+AIGBZJmdroBkudZuaZ2erfVemV2tqff3tKe66ay5bKPPivA90za7BQFiOlNhttiu
+EzpVNm3jca9VNZxnetVyZfb9WRLpzLnTWO2abrF/zzF2SDX2/UBObxUzL7yE3x/d
+aPecmvHQdKERd5YVFxdDHJcFTI+jY7iAmLu5LAACrp5/nDONT6pNo8aTKZQulTIV
+zPNqFd52mIAJROCCooEn3fMXMen5KUx7/pLnw/w4F9cJRio9p4CcPYHw1Su7EmCB
+RXc6XAtK7wTZxA+ENrPfIEquGUr1E0hfxjrv0yZHnS85qpd1G8T8ByydIvyEtO2R
+/EXdB/5TZBIibYnnfYQcyszOjMQeBCMsnIolz6Co5rHi8jiuQtxzzGGT2eu4EeB2
+uSfR5/3mnJg/RsaP16WCOvsJM+5KzefU/EfI4kCVto8Kn//8kgbiYKSQ4iMBdT6M
+wavfIb+BZbLTjFfRxF1YrJwdqVYD1RXv9Efrs7nhMVLif+q95r33+RsckvmGv8xb
+5g+RxTu+5XtWqqwJYe4vUEsDBBQAAAAIALFUyj5r/Nh8awEAADcCAAAdABwAY29t
+L3N1bi91a2l0L2pheHAvSW5wdXQuY2xhc3NVVAkAAy4s8k1MLPJNdXgLAAEE6AMA
+AAToAwAAfZBdSwJBFIbf2XUzty1NMzP7vDODtruIohtLEBatjAq82o/B1nSV/Qj7
+WUESRPgD+lHR2Wmhq2Lgfc+ZOeeZM/P59T4DcIhtFQrWM0ihEstGGptpbDEo48hy
+HYa80TefTH1gej29E/qu1zuhw+A5iA/lwLcZcj8l7ki/5qbD/bjAfjD9gEHq1kVi
+cI+BNUXcdCYMKY9PQoayYY+GehB5evTohnrfnIz1pjeOQmLMnbqeG55RbbW5d0tW
+HzmcIWu4Hm9FQ4v7N6Y1oB2l2q3HBXI1VrUzinybN9z4SBWwg3g+DXmUNCxA07CI
+JYbSH1fTg36f3Lb63A6xQ1+j0H+lQXORgnw+8QxU4UQWTnDh2cRzWCaXKcqjQLpC
+2TEkWkCx9gZWq3woU0i12iuk2RTyi2grkubpWqBOek74C2ptCMxqgjlKMAWB2f8P
+0iJt06yXlF8JSCmB7JIzciWG/LapgnxHbfe0s0axhPI3UEsDBAoAAAAAAAhVyj4A
+AAAAAAAAAAAAAAAGABwAamF2YXgvVVQJAAPPLPJN0SzyTXV4CwABBOgDAAAE6AMA
+AFBLAwQKAAAAAAAIVco+AAAAAAAAAAAAAAAACgAcAGphdmF4L3htbC9VVAkAA88s
+8k3gLPJNdXgLAAEE6AMAAAToAwAAUEsDBAoAAAAAAAhVyj4AAAAAAAAAAAAAAAAS
+ABwAamF2YXgveG1sL3BhcnNlcnMvVVQJAAPPLPJN4CzyTXV4CwABBOgDAAAE6AMA
+AFBLAwQUAAAACAAIVco+wHGjWkkBAAAEAgAAIQAcAGphdmF4L3htbC9wYXJzZXJz
+L1NBWFBhcnNlci5jbGFzc1VUCQADzyzyTeAs8k11eAsAAQToAwAABOgDAACNUctO
+wkAUPQOFakVA8UHiih26sO5BIvERTRowwRDjbigjDukr01b7W65MXPgBfpTxTkka
+jRtnce+dM2fumXPn8+v9A8AJ2hbKaJnYMbHLUO3LQCYDhnL3cMpgnIdzwdBwZCBG
+qT8T6o7PPEIqEVcx5X7XWfJnbsvQvgmiNJkkSnC/54RqYWe+Z8c8s5+EFwkV2xfi
+kadecs2DuSdUT/e3LjNXRIkMg9jEnol9hrPur8urrmGqXPHvrk0Zj7gv4oi7YvjC
+lcjtPDDUZDzlnpzzRAYLUl/1vZLaUX0yvL/VptSxdlSDgQrDga6zXDR3TIIFj4Ry
+7x4PFvZ4thRuwtD++UaiFgYZWsWkxgVqdFCi+etVIUXSBH0C7TqUmUaP3sBeqWAw
+KVpEB06JODAY1rBOuEVIlfAN1HJs8w9WRwOg3NSZTrcolrD9DVBLAwQUAAAACAAI
+Vco+T/+TpMcAAAASAQAANAAcAGphdmF4L3htbC9wYXJzZXJzL1BhcnNlckNvbmZp
+Z3VyYXRpb25FeGNlcHRpb24uY2xhc3NVVAkAA88s8k3gLPJNdXgLAAEE6AMAAATo
+AwAAfY/PDsFAEMa/LVqKOIgH4OBvYt2Ji3ASkRD3xWpWaiurlb6Wk8TBA3goMe2B
+m91k5pvfzDfZfb0fTwADlF1k4DooOigx2COlVThmqLXnR3EV3Bfa46vQKO0NOxuG
+7CTYS4bKXGm5iE5badZi6xNxV0FkdnKmkqK+FOYizSTQB+VFRoQq0NN4J8+J6CeL
+S8gix5DqmMcnn59Ty4X/szJUf6/6UtRh0SeSw+jSYoo2VQ3iFmW727uD3dK+Q9FN
+aZPmWkTypC0UPlBLAwQUAAAACAAIVco+H9eSYsoAAAAIAQAAMQAcAGphdmF4L3ht
+bC9wYXJzZXJzL0ZhY3RvcnlDb25maWd1cmF0aW9uRXJyb3IuY2xhc3NVVAkAA88s
+8k3gLPJNdXgLAAEE6AMAAAToAwAAdY7NToNAEMf/ixSU1vTk1URPAonbe00vTXsi
+XjDeF1zJGtg1AzT1sXoy8eAD9KEaBy49OZPMx28+j6efXwALXEe4QBRiGmImEDwZ
+a7qVwM1D9qF2StbKVjLvyNhqGb8K+Gv3pgXmmbH6uW8KTS+qqJlEueup1FszJLdb
+VXaOvtbOvpuqJ9UZZzdEjh6HrTP4mAikQ7yX+6aWn4paTa38d45Pnv8ZCe7g8euD
+CFbeyDbg7J65xz5I0m+Iw1gP2UYjjbkvYXLJsYerP1BLAwQUAAAACAAIVco+Hm/d
+B1UCAAB8BAAAKAAcAGphdmF4L3htbC9wYXJzZXJzL1NBWFBhcnNlckZhY3Rvcnku
+Y2xhc3NVVAkAA88s8k3gLPJNdXgLAAEE6AMAAAToAwAAhVNdTxNBFD3TXVi6VKEo
+iCIWELAUZUl8MKbEhBBITAgSa4jyNmzHZrDdbfYDqu/6A/wH+qyJJhoSTfwB/ijj
+2bVCWYi2yb1z7z333I+Z/fnr2w8Ay1i2YWEuj37MJ+KWhbINE3MWFixUBC56sqXC
+tnTV6qEMlIDYFbAPZFPXZaS9hkD/ivZ09EDAKC/sCJhrfp2woU3tqa24taeCJ3Kv
+Sc+gpw4femEkPZfWfHlhc18eyI7TaTWdtgxCFYRObfXpdnrckG7kBy+rrLXecVU7
+0r4XWlgUKJDmGCZQ+jdP1cJtC3cEiqGKtjKjmOXdpONhHWYjHIVjXmDOTs+kBR32
+mjbDG0pGcZIxVk7bcJrSazi1KCCiSnYLSxYcYhs92NFzsEk9u+bHgas2dLKu0ewu
+lpKcAgZRKGAA+QJs5Dm/67ecMPac+IWOnH3ZaTunsgRm/r9m7uCkoUd7+8qNBBbP
+5nXha773XDfiQCa3sh4EPu9h6Sz6T4nT4L93KTDuB40UHjKNDfWE5jKhLT96rFy/
+4elXqt6Dmz2Lq8Xtth9EPTBzms/a4lvP8c+9pSc71Xk+dK4TvGlad+kX1EOVI4iK
+8RW5RBif6eJnQDlCOFClvMfU+/StUA9hmIkJwRR18hv4DvPZEfo+HWf2p8QaRUqT
+5xFT4BIu81RMozmMYozWFYx3m5lJ22WsMsFGTnqwU+9r9OENPVdxrYufpE5q9FW+
+IPchU/gt5cQxdYk6ITGMlSzvO8r39Fw/l9fI8n7kGJO40R1jAAbHKGGK3mkOkPHS
+vpnufvY3UEsDBAoAAAAAALVUyj4AAAAAAAAAAAAAAAAEABwAb3JnL1VUCQADNizy
+TUws8k11eAsAAQToAwAABOgDAABQSwMECgAAAAAAtFTKPgAAAAAAAAAAAAAAAAgA
+HABvcmcveG1sL1VUCQADMyzyTUws8k11eAsAAQToAwAABOgDAABQSwMECgAAAAAA
+tFTKPgAAAAAAAAAAAAAAAAwAHABvcmcveG1sL3NheC9VVAkAAzMs8k1MLPJNdXgL
+AAEE6AMAAAToAwAAUEsDBAoAAAAAALRUyj4AAAAAAAAAAAAAAAAUABwAb3JnL3ht
+bC9zYXgvaGVscGVycy9VVAkAAzMs8k1MLPJNdXgLAAEE6AMAAAToAwAAUEsDBBQA
+AAAIALRUyj7d4WFChAIAAAMHAAAoABwAb3JnL3htbC9zYXgvaGVscGVycy9EZWZh
+dWx0SGFuZGxlci5jbGFzc1VUCQADMyzyTUws8k11eAsAAQToAwAABOgDAACdk91u
+EkEUx8/wqRRsBVGsVm39KNREvDIxGE1TMJKi1mDU6IUZlgG2LrPr7GzFVzA+g/ER
+1JiYeKE3XvkCPoMvYTyzIDB07TbdZGd3zp7f/3zM2Z9/vn4DgKuwloIoXErCahKK
+BBI3TG7KmwSixdIjArENu80IzDdMzu55/RYTD2nLQktGMNe2dliNS1O+JnCr2Nim
+O7RsUd4tN6Uwebey21Jq2KJbHvStsksH5Tp3PNm0PWGwCoFUbWAwR5o2d5NQIpDm
+tqRqW2WGReD6vgIEhMQqsh53qHBZe5jtUHDzgIL/CeEyWbUNr8+4bNgGlbYgUChq
+9Y7svn/GlVSMCQJzjLcnu6z/dUuwjjm4Sx0HoxBY3V+LUXwBxWbgfACsXNN+pJrF
+hoEfHLQp03WuSzS2PMlcP0QKsxkHSBk9KqghmXAJJIvPNup15ZMzu9wWarQe90wE
+HWrgkOUdYRvMdTFCnbtSeIaaB9W8F6bj/DtO1HlFBffLXNE73lx/sqUOfjxafkJx
+JoQ6nlSHSmrVRpvhIN421XTnqqxDPUveobxtMXFF1ZuGGMQxwrR+j1kOVlLW3fEA
+Jg2639pmBhZemMlrnBIsQwT/QHVlgagguCZwt4RPgs/42hcgH/EFC8U14RsruB6C
+w4gq10XcKYkI+TDj9xRSuMbwfQ7vNGRGxEnfCruFPQ04AvNTQDwIeKsBC3B0lL4C
+IkHAe1yzqDXRJUFunzTdXDjwQwOOQX4KiAYBvzTgOJyYAgIz/60BBXTcuzckqQGL
+od0nyxpwCk6HAdc0YCkc2NSAM6FdIs814Gxol8hLDTjnz/eewBsNWAkH3mnA+TGg
+fgMFRC5/nyE+a8QFX/jiX1BLAwQUAAAACAC0VMo+7neE5bMAAADmAAAAGQAcAG9y
+Zy94bWwvc2F4L0xvY2F0b3IuY2xhc3NVVAkAAzMs8k1MLPJNdXgLAAEE6AMAAATo
+AwAARY3RCoJAEEXvlGWlUlAfYS9t7z0GgSAV+AWrLWKsLmxr2K/10Af0UdFaRvMw
+d+bOYe7zdX8AWCNw4bnwCV4uzLFOZZFFJ8IiXMZnfuVM8ipnidFFlW++UHK7GFG2
+UGC3uKjEvi5ToQn9cBkRptbdKlmX1c+fJKrWmdgVUhD8WGXcKL1q3xPmSuesKSW7
+8IZ1J8Lsn31IzyIzQwKhh7YcxybBsQNh0OkQ7kdHrVpybHsPkzdQSwMEFAAAAAgA
+tFTKPsLlqtO7AAAA7AAAAB4AHABvcmcveG1sL3NheC9TQVhFeGNlcHRpb24uY2xh
+c3NVVAkAAzMs8k1MLPJNdXgLAAEE6AMAAAToAwAAO/Vv1z4GBgYDBl4uBmYGLnYG
+bnYGHkYGNpvMvMwSO0YGUQ2frMSyRP2cxLx0/eCSosy8dGvNMEYGFuf8lFRGBn6f
+zLxUv9LcpNSikMSkHKAIV3B+aVFyqlsmiCMY7BjhWpGcWlCSmZ+nBzKIh4GFgZWR
+QSK/KF2/IjdHvzixQh9ZESODMMI+uCiDIgMT0HkgwAiEQCOAJBuQpwQUZwLSbFra
+2xkYN4Ll2YEkF1jUGajOFSjCAWQzMXACAFBLAwQUAAAACAC0VMo++TXhtc0BAABY
+AwAAIwAcAG9yZy94bWwvc2F4L1NBWFBhcnNlRXhjZXB0aW9uLmNsYXNzVVQJAAMz
+LPJNTCzyTXV4CwABBOgDAAAE6AMAAG2Ry07bYBCFz5+bceI0gQBNoSmlBZI4UdxF
+NxUoFYpaKcLcGlR16zhWZOTYyHEg7HgE3oJNF63UqmoXLFnwUFVnrDZKgzdnPs+M
+Zo7nv//96xbAK9TTyOBZBmt4LiONdaYXTC+ZNpg2mbaYyhIqEqoCc2ejrmOb7Z7A
+gn5qnBuaY7h9rRP4ttvfpvrwchhYA66nHdu1DkaDruULiLaAYnrOaOD+S6V2bNcO
+mgJq5eEk3fP72njgaENjrOmeaQSev139KJBoeT1LIKdPhp8YXYcymb4VHE3MLVaq
+Ufa4qTNxmKUvfcpkvFIlmznKtv5zmu54I9+03tu8Z7mz++nI8IfWu7FpnQW25zZ4
+kYIFqBJqCpbxWIGCrIIi0yOmJ1hRkENewSrTPPICpelffDBUoDhTnyotRVyMj1OI
+uBrWwS8NJBBjW0QxNhVGshTG+TAmQa+KAukifV1QPk7xrVr7AVG/Q0Ot/0RM4Dvi
+TAmmJFOKSWKaY5JvkFVjnCGRv9IIcky6BZm0TWv2iHRatI8SDlDGIV7jGG/wAU2c
+UDed8K+JEkXB1tRviH+ZjEqFSYO0GNmanG31SekRIlqlzzOtV6Srka3ybOs16dPw
+gKU/UEsDBBQAAAAIALRUyj5TaEoHyAAAAAsBAAArABwAb3JnL3htbC9zYXgvU0FY
+Tm90UmVjb2duaXplZEV4Y2VwdGlvbi5jbGFzc1VUCQADMyzyTUws8k11eAsAAQTo
+AwAABOgDAAA79W/XPgYGBgMGXi4GZgYudgZudgYeRgY2m8y8zBI7RgZRDZ+sxLJE
+/ZzEvHT94JKizLx0a80wRgYW5/yUVEYGfp/MvFS/0tyk1KKQxKQcoAhXcH5pUXKq
+WyaIIxfsGOGXXxKUmpyfnpdZlZriWpGcWlCSmZ+nBzKVh4GFgZWRQTW/KF2/IjdH
+vzixQh+nDkYGCTR1cCkGRQYmoOtBgBEIgYYCSTYgTwkozgSk2bS0tzMwbgTLswNJ
+LrCoDVCdLVCEA8hmYuAEAFBLAwQUAAAACAC0VMo+q/nAp8cAAAAJAQAAKgAcAG9y
+Zy94bWwvc2F4L1NBWE5vdFN1cHBvcnRlZEV4Y2VwdGlvbi5jbGFzc1VUCQADMyzy
+TUws8k11eAsAAQToAwAABOgDAAA79W/XPgYGBgMGXi4GZgYudgZudgYeRgY2m8y8
+zBI7RgZRDZ+sxLJE/ZzEvHT94JKizLx0a80wRgYW5/yUVEYGfp/MvFS/0tyk1KKQ
+xKQcoAhXcH5pUXKqWyaIIxvsGOGXXxJcWlCQX1SSmuJakZxaUJKZn6cHMpSHgYWB
+lZFBJb8oXb8iN0e/OLFCH5cGRgYJNGVwKQZFBiag20GAEQiBZgJJNiBPCSjOBKTZ
+tLS3MzBuBMuzA0kusKgtUJ0dUIQDyGZi4AQAUEsDBBQAAAAIALRUyj7i7642TAIA
+AGgFAAAdABwAb3JnL3htbC9zYXgvSW5wdXRTb3VyY2UuY2xhc3NVVAkAAzMs8k1M
+LPJNdXgLAAEE6AMAAAToAwAAdZLLbtNAFIZ/5x7HSdO0gfRKAxRygbrcVq1YUAGq
+VAEihb2TjIxD4lSOg9oN8AzAK8CaSlwkFjwAErwCbwE7xDlO6iQTd/OP5z/n/2Z8
+7B//vn0HsIlbKlKoqFBRZbnCcjVJssGis2yyXGO5HseNOG4qSBz0622rsdtUkNtr
+GS8MvW3Ypl5zHcs2t6jeO+q5osN1tX7kCioIo6MgP2i2uvqufdB3Bzb3C7vRbVJW
+wUzjmeEYDVc4J6GsH3osjKZwqD+2bdmWe1tBuFR+qiCy020Kiu5ZtnjQ79SFs2/U
+2+TkS9O340ChFHgRLs2V5OPYTfWE+8h/55Q5vpsvlYNmwJGaPwaOjHZpqt0Zm0va
+nNyfPUFOTYqpd/1hMXW0y1FtR55ezgwyx/j+UNVat+80xD2LJ5cdHOs5G9yqYR55
+DasoaFjDgoZ1LGrQkNaQYZlBVsMsP+UwR2/QdUz9sNPWe8ahPsYi8mhWD+st0XBR
+BP+EQBQhBtJTiJneSlhvnR3uCU5rBgpfh/QM7Yq0KpyvfIVyTA90PKlK7cA+Inji
+tReG7RXyuaJye6X6BaFRJoMwqUWZFpJ47uUWTsuF5dxLyr2i3Gsvt3haLiLn3lDu
+LeXekbvk3/P8MBerVD8jKr/XexrXB3KWsTLsX/HH8AnRj357zDOPSVeD0TEZ/ZPQ
+v8g5F4iOyejfpGv+lCbQcRn9h9B/ySlS3zQ6LqEV1gvBt05IaGUJUWWZnIuBt07I
+6DLpuv+NJtBJGb1F6G1yLuFyADopo++Tlry/tfwfUEsDBBQAAAAIALRUyj4iOSvb
+8AAAAOQBAAAcABwAb3JnL3htbC9zYXgvQXR0cmlidXRlcy5jbGFzc1VUCQADMyzy
+TUws8k11eAsAAQToAwAABOgDAACNkM9OwkAQxr9BbAEr4N9H0PbiejTh5MWkCcEo
+6n2pmwpZWlO2pr6aBx/AhzJMcRIO9OAe9vfNN7Mzk/35/foGcI1TH8c+Tgjd1Lix
+yVL3RtgLo5jgsfP8yOIsjKPxQn9oZXWWqqkr5lk6IgT1kzzRdqKXhtDh8OFP+iyf
+Pt/FfNG2FBlnr6YiXIa7/XadaDO72b/5X4emtS+aWjYV9qZ5WSTmbm55+8GtY39W
+OrO6qmsJ53mRqmpp1UpXapslDLe97mcLkziPQGihPkGbvxdtgLkPb0Nf2BF2hT3h
+AQLhoeT7woHU9YUc86Qh3y0crQFQSwECHgMKAAAAAACxVMo+AAAAAAAAAAAAAAAA
+BAAYAAAAAAAAABAA7UEAAAAAY29tL1VUBQADLizyTXV4CwABBOgDAAAE6AMAAFBL
+AQIeAwoAAAAAALFUyj4AAAAAAAAAAAAAAAAIABgAAAAAAAAAEADtQT4AAABjb20v
+c3VuL1VUBQADLizyTXV4CwABBOgDAAAE6AMAAFBLAQIeAwoAAAAAALFUyj4AAAAA
+AAAAAAAAAAANABgAAAAAAAAAEADtQYAAAABjb20vc3VuL3VraXQvVVQFAAMuLPJN
+dXgLAAEE6AMAAAToAwAAUEsBAh4DCgAAAAAAsVTKPgAAAAAAAAAAAAAAABIAGAAA
+AAAAAAAQAO1BxwAAAGNvbS9zdW4vdWtpdC9qYXhwL1VUBQADLizyTXV4CwABBOgD
+AAAE6AMAAFBLAQIeAxQAAAAIALFUyj7YlWWNiDoAAI5qAAAeABgAAAAAAAAAAACk
+gRMBAABjb20vc3VuL3VraXQvamF4cC9QYXJzZXIuY2xhc3NVVAUAAy4s8k11eAsA
+AQToAwAABOgDAABQSwECHgMUAAAACACxVMo+MyvXRigDAACBBgAAHQAYAAAAAAAA
+AAAApIHzOwAAY29tL3N1bi91a2l0L2pheHAvQXR0cnMuY2xhc3NVVAUAAy4s8k11
+eAsAAQToAwAABOgDAABQSwECHgMUAAAACACxVMo+g4dFpR0DAACnBQAAJQAYAAAA
+AAAAAAAApIFyPwAAY29tL3N1bi91a2l0L2pheHAvUGFyc2VyRmFjdG9yeS5jbGFz
+c1VUBQADLizyTXV4CwABBOgDAAAE6AMAAFBLAQIeAxQAAAAIALFUyj46kin5awIA
+AOwDAAAiABgAAAAAAAAAAACkge5CAABjb20vc3VuL3VraXQvamF4cC9SZWFkZXJV
+VEY4LmNsYXNzVVQFAAMuLPJNdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgAsVTK
+PoWLwfh/AgAA9wMAACMAGAAAAAAAAAAAAKSBtUUAAGNvbS9zdW4vdWtpdC9qYXhw
+L1JlYWRlclVURjE2LmNsYXNzVVQFAAMuLPJNdXgLAAEE6AMAAAToAwAAUEsBAh4D
+FAAAAAgAsVTKPmwxGEwoAgAAuQMAABwAGAAAAAAAAAAAAKSBkUgAAGNvbS9zdW4v
+dWtpdC9qYXhwL1BhaXIuY2xhc3NVVAUAAy4s8k11eAsAAQToAwAABOgDAABQSwEC
+HgMUAAAACACxVMo+a/zYfGsBAAA3AgAAHQAYAAAAAAAAAAAApIEPSwAAY29tL3N1
+bi91a2l0L2pheHAvSW5wdXQuY2xhc3NVVAUAAy4s8k11eAsAAQToAwAABOgDAABQ
+SwECHgMKAAAAAAAIVco+AAAAAAAAAAAAAAAABgAYAAAAAAAAABAA7UHRTAAAamF2
+YXgvVVQFAAPPLPJNdXgLAAEE6AMAAAToAwAAUEsBAh4DCgAAAAAACFXKPgAAAAAA
+AAAAAAAAAAoAGAAAAAAAAAAQAO1BEU0AAGphdmF4L3htbC9VVAUAA88s8k11eAsA
+AQToAwAABOgDAABQSwECHgMKAAAAAAAIVco+AAAAAAAAAAAAAAAAEgAYAAAAAAAA
+ABAA7UFVTQAAamF2YXgveG1sL3BhcnNlcnMvVVQFAAPPLPJNdXgLAAEE6AMAAATo
+AwAAUEsBAh4DFAAAAAgACFXKPsBxo1pJAQAABAIAACEAGAAAAAAAAAAAAKSBoU0A
+AGphdmF4L3htbC9wYXJzZXJzL1NBWFBhcnNlci5jbGFzc1VUBQADzyzyTXV4CwAB
+BOgDAAAE6AMAAFBLAQIeAxQAAAAIAAhVyj5P/5OkxwAAABIBAAA0ABgAAAAAAAAA
+AACkgUVPAABqYXZheC94bWwvcGFyc2Vycy9QYXJzZXJDb25maWd1cmF0aW9uRXhj
+ZXB0aW9uLmNsYXNzVVQFAAPPLPJNdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgA
+CFXKPh/XkmLKAAAACAEAADEAGAAAAAAAAAAAAKSBelAAAGphdmF4L3htbC9wYXJz
+ZXJzL0ZhY3RvcnlDb25maWd1cmF0aW9uRXJyb3IuY2xhc3NVVAUAA88s8k11eAsA
+AQToAwAABOgDAABQSwECHgMUAAAACAAIVco+Hm/dB1UCAAB8BAAAKAAYAAAAAAAA
+AAAApIGvUQAAamF2YXgveG1sL3BhcnNlcnMvU0FYUGFyc2VyRmFjdG9yeS5jbGFz
+c1VUBQADzyzyTXV4CwABBOgDAAAE6AMAAFBLAQIeAwoAAAAAALVUyj4AAAAAAAAA
+AAAAAAAEABgAAAAAAAAAEADtQWZUAABvcmcvVVQFAAM2LPJNdXgLAAEE6AMAAATo
+AwAAUEsBAh4DCgAAAAAAtFTKPgAAAAAAAAAAAAAAAAgAGAAAAAAAAAAQAO1BpFQA
+AG9yZy94bWwvVVQFAAMzLPJNdXgLAAEE6AMAAAToAwAAUEsBAh4DCgAAAAAAtFTK
+PgAAAAAAAAAAAAAAAAwAGAAAAAAAAAAQAO1B5lQAAG9yZy94bWwvc2F4L1VUBQAD
+MyzyTXV4CwABBOgDAAAE6AMAAFBLAQIeAwoAAAAAALRUyj4AAAAAAAAAAAAAAAAU
+ABgAAAAAAAAAEADtQSxVAABvcmcveG1sL3NheC9oZWxwZXJzL1VUBQADMyzyTXV4
+CwABBOgDAAAE6AMAAFBLAQIeAxQAAAAIALRUyj7d4WFChAIAAAMHAAAoABgAAAAA
+AAAAAACkgXpVAABvcmcveG1sL3NheC9oZWxwZXJzL0RlZmF1bHRIYW5kbGVyLmNs
+YXNzVVQFAAMzLPJNdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgAtFTKPu53hOWz
+AAAA5gAAABkAGAAAAAAAAAAAAKSBYFgAAG9yZy94bWwvc2F4L0xvY2F0b3IuY2xh
+c3NVVAUAAzMs8k11eAsAAQToAwAABOgDAABQSwECHgMUAAAACAC0VMo+wuWq07sA
+AADsAAAAHgAYAAAAAAAAAAAApIFmWQAAb3JnL3htbC9zYXgvU0FYRXhjZXB0aW9u
+LmNsYXNzVVQFAAMzLPJNdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgAtFTKPvk1
+4bXNAQAAWAMAACMAGAAAAAAAAAAAAKSBeVoAAG9yZy94bWwvc2F4L1NBWFBhcnNl
+RXhjZXB0aW9uLmNsYXNzVVQFAAMzLPJNdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAA
+AAgAtFTKPlNoSgfIAAAACwEAACsAGAAAAAAAAAAAAKSBo1wAAG9yZy94bWwvc2F4
+L1NBWE5vdFJlY29nbml6ZWRFeGNlcHRpb24uY2xhc3NVVAUAAzMs8k11eAsAAQTo
+AwAABOgDAABQSwECHgMUAAAACAC0VMo+q/nAp8cAAAAJAQAAKgAYAAAAAAAAAAAA
+pIHQXQAAb3JnL3htbC9zYXgvU0FYTm90U3VwcG9ydGVkRXhjZXB0aW9uLmNsYXNz
+VVQFAAMzLPJNdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgAtFTKPuLvrjZMAgAA
+aAUAAB0AGAAAAAAAAAAAAKSB+14AAG9yZy94bWwvc2F4L0lucHV0U291cmNlLmNs
+YXNzVVQFAAMzLPJNdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgAtFTKPiI5K9vw
+AAAA5AEAABwAGAAAAAAAAAAAAKSBnmEAAG9yZy94bWwvc2F4L0F0dHJpYnV0ZXMu
+Y2xhc3NVVAUAAzMs8k11eAsAAQToAwAABOgDAABQSwUGAAAAAB4AHgBJCwAA5GIA
+AAAA
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/GNUmakefile phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/GNUmakefile
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-sigmafloat/GNUmakefile	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-sigmafloat/GNUmakefile	2011-06-14 16:09:49.000000000 -0400
@@ -0,0 +1,95 @@
+#
+# Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
+# 
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License version
+# 2 only, as published by the Free Software Foundation. 
+# 
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License version 2 for more details (a copy is
+# included at /legal/license.txt). 
+# 
+# You should have received a copy of the GNU General Public License
+# version 2 along with this work; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+# 02110-1301 USA 
+# 
+# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+# Clara, CA 95054 or visit www.sun.com if you need additional
+# information or have any questions. 
+#
+# @(#)GNUmakefile	1.6 06/10/10
+#
+
+#
+# GNUmakefile for linux-arm-strongarm target using GCC 3.x and VFP
+#
+
+#
+# platform specific architecture flags
+#
+# NOTE: -msoft-float is enabled in linux-arm/defs.mk automatically if
+# CVM_FORCE_HARD_FLOAT is not true, which is the default.
+#
+CVM_FORCE_HARD_FLOAT	= true
+ASM_ARCH_FLAGS		= -EL -mips32r2
+CC_ARCH_FLAGS		= -EL -mips32r2
+CC_ARCH_FLAGS_FDLIB	=
+CC_ARCH_FLAGS_LOOP 	=
+LINK_ARCH_FLAGS		= -EL
+LINK_ARCH_LIBS		= -lm
+
+# assume the JIT is enabled for this device unless told otherwise
+CVM_JIT ?= true
+CVM_JIT_USE_FP_HARDWARE ?= true
+#CVM_JIT_PROFILE ?= true
+#CVM_TRACE_JIT ?= true
+#CVM_DEBUG ?= true
+
+CVM_JCC_INPUT += builtinsage/builtinclass.zip
+CVM_JCC_INPUT += builtinsage/jsr172.zip
+
+#builtinsage/java/awt/event/KeyEvent.class \
+#builtinsage/java/awt/event/MouseEvent.class \
+#builtinsage/java/awt/event/MouseListener.class \
+#builtinsage/java/awt/event/MouseMotionListener.class \
+#builtinsage/java/awt/Point.class \
+#builtinsage/java/awt/Transparency.class \
+#builtinsage/java/awt/Panel.class \
+#builtinsage/java/awt/color/ColorSpace.class \
+#builtinsage/java/awt/color/RGBColorSpace.class \
+#builtinsage/java/awt/AlphaComposite.class \
+#builtinsage/java/awt/geom/RectangularShape.class \
+#builtinsage/java/awt/geom/RoundRectangle2D.class \
+#builtinsage/java/awt/geom/Dimension2D.class \
+#builtinsage/java/awt/geom/Point2D.class \
+#builtinsage/java/awt/geom/Rectangle2D.class \
+#builtinsage/java/awt/Shape.class \
+#builtinsage/java/awt/Canvas.class \
+#builtinsage/java/awt/Color.class \
+#builtinsage/java/awt/Insets.class \
+#builtinsage/java/awt/Dimension.class \
+#builtinsage/java/awt/Rectangle.class \
+#builtinsage/java/awt/geom/Rectangle2D$$Float.class \
+#builtinsage/java/awt/geom/RoundRectangle2D$$Float.class \
+#builtinsage/java/awt/geom/Point2D$$Float.class \
+#builtinsage/java/awt/geom/Point2D$$Double.class \
+#builtinsage/java/awt/geom/Rectangle2D$$Double.class \
+#builtinsage/java/awt/geom/RoundRectangle2D$$Double.class
+
+#CVM_SRCDIRS += builtinsage
+#CVM_BUILDDIRS += builtinsage
+#CLASSLIB_CLASSES = java.awt.event.KeyEvent
+
+CCFLAGS_SPEED_OPTIONS ?= -Os
+CCFLAGS_SPACE_OPTIONS ?= -Os
+
+USE_VERBOSE_MAKE = true
+
+# Only enable USE_GCC2 if GCC 3.x or later is *not* being used
+# USE_GCC2 ?= false
+
+include ../share/top.mk
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/buildscript.sh phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/buildscript.sh
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/buildscript.sh	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/buildscript.sh	2010-02-05 15:27:45.000000000 -0500
@@ -0,0 +1,4 @@
+make J2ME_CLASSLIB=foundation CVM_PRELOAD_LIB=true CVM_TARGET_TOOLS_PREFIX=mips-linux-gnu- CVM_COMPILER_INCOMPATIBLE=false CVM_DEBUG_DUMPSTACK=true 
+#CVM_TRACE_JIT=true
+#USE_JSR_172=true USE_JUMP=false 
+# CVM_JVMTI=true
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/builtinsage/KeyEvent.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/builtinsage/KeyEvent.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/builtinsage/KeyEvent.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/builtinsage/KeyEvent.java	2010-02-05 11:29:42.000000000 -0500
@@ -0,0 +1,1130 @@
+/*
+ * Copyright 1996-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.awt.event;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+
+/**
+ * An event which indicates that a keystroke occurred in a component.
+ * <p>
+ * This low-level event is generated by a component object (such as a text
+ * field) when a key is pressed, released, or typed.
+ * The event is passed to every <code>KeyListener</code>
+ * or <code>KeyAdapter</code> object which registered to receive such
+ * events using the component's <code>addKeyListener</code> method.
+ * (<code>KeyAdapter</code> objects implement the
+ * <code>KeyListener</code> interface.)  Each such listener object
+ * gets this <code>KeyEvent</code> when the event occurs.
+ * <p>
+ * <em>"Key typed" events</em> are higher-level and generally do not depend on
+ * the platform or keyboard layout.  They are generated when a Unicode character
+ * is entered, and are the preferred way to find out about character input.
+ * In the simplest case, a key typed event is produced by a single key press
+ * (e.g., 'a').  Often, however, characters are produced by series of key
+ * presses (e.g., 'shift' + 'a'), and the mapping from key pressed events to
+ * key typed events may be many-to-one or many-to-many.  Key releases are not
+ * usually necessary to generate a key typed event, but there are some cases
+ * where the key typed event is not generated until a key is released (e.g.,
+ * entering ASCII sequences via the Alt-Numpad method in Windows).
+ * No key typed events are generated for keys that don't generate Unicode
+ * characters (e.g., action keys, modifier keys, etc.).
+ * <p>
+ * The getKeyChar method always returns a valid Unicode character or
+ * CHAR_UNDEFINED.  Character input is reported by KEY_TYPED events:
+ * KEY_PRESSED and KEY_RELEASED events are not necessarily associated
+ * with character input.  Therefore, the result of the getKeyChar method
+ * is guaranteed to be meaningful only for KEY_TYPED events.
+ * <p>
+ * For key pressed and key released events, the getKeyCode method returns
+ * the event's keyCode.  For key typed events, the getKeyCode method
+ * always returns {@code VK_UNDEFINED}. The {@code getExtendedKeyCode} method
+ * may also be used with many international keyboard layouts.
+ *
+ * <p>
+ * <em>"Key pressed" and "key released" events</em> are lower-level and depend
+ * on the platform and keyboard layout. They are generated whenever a key is
+ * pressed or released, and are the only way to find out about keys that don't
+ * generate character input (e.g., action keys, modifier keys, etc.). The key
+ * being pressed or released is indicated by the {@code getKeyCode} and {@code getExtendedKeyCode}
+ * methods, which return a virtual key code.
+ *
+ * <p>
+ * <em>Virtual key codes</em> are used to report which keyboard key has
+ * been pressed, rather than a character generated by the combination
+ * of one or more keystrokes (such as "A", which comes from shift and "a").
+ *
+ * <p>
+ * For example, pressing the Shift key will cause a KEY_PRESSED event
+ * with a VK_SHIFT keyCode, while pressing the 'a' key will result in
+ * a VK_A keyCode.  After the 'a' key is released, a KEY_RELEASED event
+ * will be fired with VK_A. Separately, a KEY_TYPED event with a keyChar
+ * value of 'A' is generated.
+ *
+ * <p>
+ * Pressing and releasing a key on the keyboard results in the generating
+ * the following key events (in order):
+ * <PRE>
+ *    {@code KEY_PRESSED}
+ *    {@code KEY_TYPED} (is only generated if a valid Unicode character could be generated.)
+ *    {@code KEY_RELEASED}
+ * </PRE>
+ *
+ * But in some cases (e.g. auto-repeat or input method is activated) the order
+ * could be different (and platform dependent).
+ *
+ * <p>
+ * Notes:
+ * <ul>
+ * <li>Key combinations which do not result in Unicode characters, such as action
+ * keys like F1 and the HELP key, do not generate KEY_TYPED events.
+ * <li>Not all keyboards or systems are capable of generating all
+ * virtual key codes.  No attempt is made in Java to generate these keys
+ * artificially.
+ * <li>Virtual key codes do not identify a physical key: they depend on the
+ * platform and keyboard layout. For example, the key that generates VK_Q
+ * when using a U.S. keyboard layout will generate VK_A when using a French
+ * keyboard layout.
+ * <li>The key that generates {@code VK_Q} when using a U.S. keyboard layout also
+ * generates a unique code for Russian or Hebrew layout. There is no a
+ * {@code VK_} constant for these and many other codes in various layouts. These codes
+ * may be obtained by using {@code getExtendedKeyCode} and are used whenever
+ * a {@code VK_} constant is used.
+ * <li>Not all characters have a keycode associated with them.  For example,
+ * there is no keycode for the question mark because there is no keyboard
+ * for which it appears on the primary layer.
+ * <li>In order to support the platform-independent handling of action keys,
+ * the Java platform uses a few additional virtual key constants for functions
+ * that would otherwise have to be recognized by interpreting virtual key codes
+ * and modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES
+ * is returned instead of VK_CONVERT with the ALT modifier.
+ * <li>As specified in <a href="../doc-files/FocusSpec.html">Focus Specification</a>
+ * key events are dispatched to the focus owner by default.
+ * </ul>
+ *
+ * <p>
+ * WARNING: Aside from those keys that are defined by the Java language
+ * (VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_
+ * constants.  Sun reserves the right to change these values as needed
+ * to accomodate a wider range of keyboards in the future.
+ * <p>
+ * An unspecified behavior will be caused if the {@code id} parameter
+ * of any particular {@code KeyEvent} instance is not
+ * in the range from {@code KEY_FIRST} to {@code KEY_LAST}.
+ *
+ * @author Carl Quinn
+ * @author Amy Fowler
+ * @author Norbert Lindenberg
+ *
+ * @see KeyAdapter
+ * @see KeyListener
+ * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/keylistener.html">Tutorial: Writing a Key Listener</a>
+ *
+ * @since 1.1
+ */
+public class KeyEvent{
+
+    /**
+     * Stores the state of native event dispatching system
+     * - true, if when the event was created event proxying
+     *         mechanism was active
+     * - false, if it was inactive
+     * Used in Component.dispatchEventImpl to correctly dispatch
+     * events when proxy is active
+     */
+    private boolean isProxyActive = false;
+
+    /**
+     * The first number in the range of ids used for key events.
+     */
+    public static final int KEY_FIRST = 400;
+
+    /**
+     * The last number in the range of ids used for key events.
+     */
+    public static final int KEY_LAST  = 402;
+
+    /**
+     * The "key typed" event.  This event is generated when a character is
+     * entered.  In the simplest case, it is produced by a single key press.
+     * Often, however, characters are produced by series of key presses, and
+     * the mapping from key pressed events to key typed events may be
+     * many-to-one or many-to-many.
+     */
+    public static final int KEY_TYPED = KEY_FIRST;
+
+    /**
+     * The "key pressed" event. This event is generated when a key
+     * is pushed down.
+     */
+    public static final int KEY_PRESSED = 1 + KEY_FIRST; //Event.KEY_PRESS
+
+    /**
+     * The "key released" event. This event is generated when a key
+     * is let up.
+     */
+    public static final int KEY_RELEASED = 2 + KEY_FIRST; //Event.KEY_RELEASE
+
+    /* Virtual key codes. */
+
+    public static final int VK_ENTER          = '\n';
+    public static final int VK_BACK_SPACE     = '\b';
+    public static final int VK_TAB            = '\t';
+    public static final int VK_CANCEL         = 0x03;
+    public static final int VK_CLEAR          = 0x0C;
+    public static final int VK_SHIFT          = 0x10;
+    public static final int VK_CONTROL        = 0x11;
+    public static final int VK_ALT            = 0x12;
+    public static final int VK_PAUSE          = 0x13;
+    public static final int VK_CAPS_LOCK      = 0x14;
+    public static final int VK_ESCAPE         = 0x1B;
+    public static final int VK_SPACE          = 0x20;
+    public static final int VK_PAGE_UP        = 0x21;
+    public static final int VK_PAGE_DOWN      = 0x22;
+    public static final int VK_END            = 0x23;
+    public static final int VK_HOME           = 0x24;
+
+    /**
+     * Constant for the non-numpad <b>left</b> arrow key.
+     * @see #VK_KP_LEFT
+     */
+    public static final int VK_LEFT           = 0x25;
+
+    /**
+     * Constant for the non-numpad <b>up</b> arrow key.
+     * @see #VK_KP_UP
+     */
+    public static final int VK_UP             = 0x26;
+
+    /**
+     * Constant for the non-numpad <b>right</b> arrow key.
+     * @see #VK_KP_RIGHT
+     */
+    public static final int VK_RIGHT          = 0x27;
+
+    /**
+     * Constant for the non-numpad <b>down</b> arrow key.
+     * @see #VK_KP_DOWN
+     */
+    public static final int VK_DOWN           = 0x28;
+
+    /**
+     * Constant for the comma key, ","
+     */
+    public static final int VK_COMMA          = 0x2C;
+
+    /**
+     * Constant for the minus key, "-"
+     * @since 1.2
+     */
+    public static final int VK_MINUS          = 0x2D;
+
+    /**
+     * Constant for the period key, "."
+     */
+    public static final int VK_PERIOD         = 0x2E;
+
+    /**
+     * Constant for the forward slash key, "/"
+     */
+    public static final int VK_SLASH          = 0x2F;
+
+    /** VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
+    public static final int VK_0              = 0x30;
+    public static final int VK_1              = 0x31;
+    public static final int VK_2              = 0x32;
+    public static final int VK_3              = 0x33;
+    public static final int VK_4              = 0x34;
+    public static final int VK_5              = 0x35;
+    public static final int VK_6              = 0x36;
+    public static final int VK_7              = 0x37;
+    public static final int VK_8              = 0x38;
+    public static final int VK_9              = 0x39;
+
+    /**
+     * Constant for the semicolon key, ";"
+     */
+    public static final int VK_SEMICOLON      = 0x3B;
+
+    /**
+     * Constant for the equals key, "="
+     */
+    public static final int VK_EQUALS         = 0x3D;
+
+    /** VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */
+    public static final int VK_A              = 0x41;
+    public static final int VK_B              = 0x42;
+    public static final int VK_C              = 0x43;
+    public static final int VK_D              = 0x44;
+    public static final int VK_E              = 0x45;
+    public static final int VK_F              = 0x46;
+    public static final int VK_G              = 0x47;
+    public static final int VK_H              = 0x48;
+    public static final int VK_I              = 0x49;
+    public static final int VK_J              = 0x4A;
+    public static final int VK_K              = 0x4B;
+    public static final int VK_L              = 0x4C;
+    public static final int VK_M              = 0x4D;
+    public static final int VK_N              = 0x4E;
+    public static final int VK_O              = 0x4F;
+    public static final int VK_P              = 0x50;
+    public static final int VK_Q              = 0x51;
+    public static final int VK_R              = 0x52;
+    public static final int VK_S              = 0x53;
+    public static final int VK_T              = 0x54;
+    public static final int VK_U              = 0x55;
+    public static final int VK_V              = 0x56;
+    public static final int VK_W              = 0x57;
+    public static final int VK_X              = 0x58;
+    public static final int VK_Y              = 0x59;
+    public static final int VK_Z              = 0x5A;
+
+    /**
+     * Constant for the open bracket key, "["
+     */
+    public static final int VK_OPEN_BRACKET   = 0x5B;
+
+    /**
+     * Constant for the back slash key, "\"
+     */
+    public static final int VK_BACK_SLASH     = 0x5C;
+
+    /**
+     * Constant for the close bracket key, "]"
+     */
+    public static final int VK_CLOSE_BRACKET  = 0x5D;
+
+    public static final int VK_NUMPAD0        = 0x60;
+    public static final int VK_NUMPAD1        = 0x61;
+    public static final int VK_NUMPAD2        = 0x62;
+    public static final int VK_NUMPAD3        = 0x63;
+    public static final int VK_NUMPAD4        = 0x64;
+    public static final int VK_NUMPAD5        = 0x65;
+    public static final int VK_NUMPAD6        = 0x66;
+    public static final int VK_NUMPAD7        = 0x67;
+    public static final int VK_NUMPAD8        = 0x68;
+    public static final int VK_NUMPAD9        = 0x69;
+    public static final int VK_MULTIPLY       = 0x6A;
+    public static final int VK_ADD            = 0x6B;
+
+    /**
+     * This constant is obsolete, and is included only for backwards
+     * compatibility.
+     * @see #VK_SEPARATOR
+     */
+    public static final int VK_SEPARATER      = 0x6C;
+
+    /**
+     * Constant for the Numpad Separator key.
+     * @since 1.4
+     */
+    public static final int VK_SEPARATOR      = VK_SEPARATER;
+
+    public static final int VK_SUBTRACT       = 0x6D;
+    public static final int VK_DECIMAL        = 0x6E;
+    public static final int VK_DIVIDE         = 0x6F;
+    public static final int VK_DELETE         = 0x7F; /* ASCII DEL */
+    public static final int VK_NUM_LOCK       = 0x90;
+    public static final int VK_SCROLL_LOCK    = 0x91;
+
+    /** Constant for the F1 function key. */
+    public static final int VK_F1             = 0x70;
+
+    /** Constant for the F2 function key. */
+    public static final int VK_F2             = 0x71;
+
+    /** Constant for the F3 function key. */
+    public static final int VK_F3             = 0x72;
+
+    /** Constant for the F4 function key. */
+    public static final int VK_F4             = 0x73;
+
+    /** Constant for the F5 function key. */
+    public static final int VK_F5             = 0x74;
+
+    /** Constant for the F6 function key. */
+    public static final int VK_F6             = 0x75;
+
+    /** Constant for the F7 function key. */
+    public static final int VK_F7             = 0x76;
+
+    /** Constant for the F8 function key. */
+    public static final int VK_F8             = 0x77;
+
+    /** Constant for the F9 function key. */
+    public static final int VK_F9             = 0x78;
+
+    /** Constant for the F10 function key. */
+    public static final int VK_F10            = 0x79;
+
+    /** Constant for the F11 function key. */
+    public static final int VK_F11            = 0x7A;
+
+    /** Constant for the F12 function key. */
+    public static final int VK_F12            = 0x7B;
+
+    /**
+     * Constant for the F13 function key.
+     * @since 1.2
+     */
+    /* F13 - F24 are used on IBM 3270 keyboard; use random range for constants. */
+    public static final int VK_F13            = 0xF000;
+
+    /**
+     * Constant for the F14 function key.
+     * @since 1.2
+     */
+    public static final int VK_F14            = 0xF001;
+
+    /**
+     * Constant for the F15 function key.
+     * @since 1.2
+     */
+    public static final int VK_F15            = 0xF002;
+
+    /**
+     * Constant for the F16 function key.
+     * @since 1.2
+     */
+    public static final int VK_F16            = 0xF003;
+
+    /**
+     * Constant for the F17 function key.
+     * @since 1.2
+     */
+    public static final int VK_F17            = 0xF004;
+
+    /**
+     * Constant for the F18 function key.
+     * @since 1.2
+     */
+    public static final int VK_F18            = 0xF005;
+
+    /**
+     * Constant for the F19 function key.
+     * @since 1.2
+     */
+    public static final int VK_F19            = 0xF006;
+
+    /**
+     * Constant for the F20 function key.
+     * @since 1.2
+     */
+    public static final int VK_F20            = 0xF007;
+
+    /**
+     * Constant for the F21 function key.
+     * @since 1.2
+     */
+    public static final int VK_F21            = 0xF008;
+
+    /**
+     * Constant for the F22 function key.
+     * @since 1.2
+     */
+    public static final int VK_F22            = 0xF009;
+
+    /**
+     * Constant for the F23 function key.
+     * @since 1.2
+     */
+    public static final int VK_F23            = 0xF00A;
+
+    /**
+     * Constant for the F24 function key.
+     * @since 1.2
+     */
+    public static final int VK_F24            = 0xF00B;
+
+    public static final int VK_PRINTSCREEN    = 0x9A;
+    public static final int VK_INSERT         = 0x9B;
+    public static final int VK_HELP           = 0x9C;
+    public static final int VK_META           = 0x9D;
+
+    public static final int VK_BACK_QUOTE     = 0xC0;
+    public static final int VK_QUOTE          = 0xDE;
+
+    /**
+     * Constant for the numeric keypad <b>up</b> arrow key.
+     * @see #VK_UP
+     * @since 1.2
+     */
+    public static final int VK_KP_UP          = 0xE0;
+
+    /**
+     * Constant for the numeric keypad <b>down</b> arrow key.
+     * @see #VK_DOWN
+     * @since 1.2
+     */
+    public static final int VK_KP_DOWN        = 0xE1;
+
+    /**
+     * Constant for the numeric keypad <b>left</b> arrow key.
+     * @see #VK_LEFT
+     * @since 1.2
+     */
+    public static final int VK_KP_LEFT        = 0xE2;
+
+    /**
+     * Constant for the numeric keypad <b>right</b> arrow key.
+     * @see #VK_RIGHT
+     * @since 1.2
+     */
+    public static final int VK_KP_RIGHT       = 0xE3;
+
+    /* For European keyboards */
+    /** @since 1.2 */
+    public static final int VK_DEAD_GRAVE               = 0x80;
+    /** @since 1.2 */
+    public static final int VK_DEAD_ACUTE               = 0x81;
+    /** @since 1.2 */
+    public static final int VK_DEAD_CIRCUMFLEX          = 0x82;
+    /** @since 1.2 */
+    public static final int VK_DEAD_TILDE               = 0x83;
+    /** @since 1.2 */
+    public static final int VK_DEAD_MACRON              = 0x84;
+    /** @since 1.2 */
+    public static final int VK_DEAD_BREVE               = 0x85;
+    /** @since 1.2 */
+    public static final int VK_DEAD_ABOVEDOT            = 0x86;
+    /** @since 1.2 */
+    public static final int VK_DEAD_DIAERESIS           = 0x87;
+    /** @since 1.2 */
+    public static final int VK_DEAD_ABOVERING           = 0x88;
+    /** @since 1.2 */
+    public static final int VK_DEAD_DOUBLEACUTE         = 0x89;
+    /** @since 1.2 */
+    public static final int VK_DEAD_CARON               = 0x8a;
+    /** @since 1.2 */
+    public static final int VK_DEAD_CEDILLA             = 0x8b;
+    /** @since 1.2 */
+    public static final int VK_DEAD_OGONEK              = 0x8c;
+    /** @since 1.2 */
+    public static final int VK_DEAD_IOTA                = 0x8d;
+    /** @since 1.2 */
+    public static final int VK_DEAD_VOICED_SOUND        = 0x8e;
+    /** @since 1.2 */
+    public static final int VK_DEAD_SEMIVOICED_SOUND    = 0x8f;
+
+    /** @since 1.2 */
+    public static final int VK_AMPERSAND                = 0x96;
+    /** @since 1.2 */
+    public static final int VK_ASTERISK                 = 0x97;
+    /** @since 1.2 */
+    public static final int VK_QUOTEDBL                 = 0x98;
+    /** @since 1.2 */
+    public static final int VK_LESS                     = 0x99;
+
+    /** @since 1.2 */
+    public static final int VK_GREATER                  = 0xa0;
+    /** @since 1.2 */
+    public static final int VK_BRACELEFT                = 0xa1;
+    /** @since 1.2 */
+    public static final int VK_BRACERIGHT               = 0xa2;
+
+    /**
+     * Constant for the "@" key.
+     * @since 1.2
+     */
+    public static final int VK_AT                       = 0x0200;
+
+    /**
+     * Constant for the ":" key.
+     * @since 1.2
+     */
+    public static final int VK_COLON                    = 0x0201;
+
+    /**
+     * Constant for the "^" key.
+     * @since 1.2
+     */
+    public static final int VK_CIRCUMFLEX               = 0x0202;
+
+    /**
+     * Constant for the "$" key.
+     * @since 1.2
+     */
+    public static final int VK_DOLLAR                   = 0x0203;
+
+    /**
+     * Constant for the Euro currency sign key.
+     * @since 1.2
+     */
+    public static final int VK_EURO_SIGN                = 0x0204;
+
+    /**
+     * Constant for the "!" key.
+     * @since 1.2
+     */
+    public static final int VK_EXCLAMATION_MARK         = 0x0205;
+
+    /**
+     * Constant for the inverted exclamation mark key.
+     * @since 1.2
+     */
+    public static final int VK_INVERTED_EXCLAMATION_MARK = 0x0206;
+
+    /**
+     * Constant for the "(" key.
+     * @since 1.2
+     */
+    public static final int VK_LEFT_PARENTHESIS         = 0x0207;
+
+    /**
+     * Constant for the "#" key.
+     * @since 1.2
+     */
+    public static final int VK_NUMBER_SIGN              = 0x0208;
+
+    /**
+     * Constant for the "+" key.
+     * @since 1.2
+     */
+    public static final int VK_PLUS                     = 0x0209;
+
+    /**
+     * Constant for the ")" key.
+     * @since 1.2
+     */
+    public static final int VK_RIGHT_PARENTHESIS        = 0x020A;
+
+    /**
+     * Constant for the "_" key.
+     * @since 1.2
+     */
+    public static final int VK_UNDERSCORE               = 0x020B;
+
+    /**
+     * Constant for the Microsoft Windows "Windows" key.
+     * It is used for both the left and right version of the key.
+     * @see #getKeyLocation()
+     * @since 1.5
+     */
+    public static final int VK_WINDOWS                  = 0x020C;
+
+    /**
+     * Constant for the Microsoft Windows Context Menu key.
+     * @since 1.5
+     */
+    public static final int VK_CONTEXT_MENU             = 0x020D;
+
+    /* for input method support on Asian Keyboards */
+
+    /* not clear what this means - listed in Microsoft Windows API */
+    public static final int VK_FINAL                    = 0x0018;
+
+    /** Constant for the Convert function key. */
+    /* Japanese PC 106 keyboard, Japanese Solaris keyboard: henkan */
+    public static final int VK_CONVERT                  = 0x001C;
+
+    /** Constant for the Don't Convert function key. */
+    /* Japanese PC 106 keyboard: muhenkan */
+    public static final int VK_NONCONVERT               = 0x001D;
+
+    /** Constant for the Accept or Commit function key. */
+    /* Japanese Solaris keyboard: kakutei */
+    public static final int VK_ACCEPT                   = 0x001E;
+
+    /* not clear what this means - listed in Microsoft Windows API */
+    public static final int VK_MODECHANGE               = 0x001F;
+
+    /* replaced by VK_KANA_LOCK for Microsoft Windows and Solaris;
+       might still be used on other platforms */
+    public static final int VK_KANA                     = 0x0015;
+
+    /* replaced by VK_INPUT_METHOD_ON_OFF for Microsoft Windows and Solaris;
+       might still be used for other platforms */
+    public static final int VK_KANJI                    = 0x0019;
+
+    /**
+     * Constant for the Alphanumeric function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: eisuu */
+    public static final int VK_ALPHANUMERIC             = 0x00F0;
+
+    /**
+     * Constant for the Katakana function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: katakana */
+    public static final int VK_KATAKANA                 = 0x00F1;
+
+    /**
+     * Constant for the Hiragana function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: hiragana */
+    public static final int VK_HIRAGANA                 = 0x00F2;
+
+    /**
+     * Constant for the Full-Width Characters function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: zenkaku */
+    public static final int VK_FULL_WIDTH               = 0x00F3;
+
+    /**
+     * Constant for the Half-Width Characters function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: hankaku */
+    public static final int VK_HALF_WIDTH               = 0x00F4;
+
+    /**
+     * Constant for the Roman Characters function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard: roumaji */
+    public static final int VK_ROMAN_CHARACTERS         = 0x00F5;
+
+    /**
+     * Constant for the All Candidates function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard - VK_CONVERT + ALT: zenkouho */
+    public static final int VK_ALL_CANDIDATES           = 0x0100;
+
+    /**
+     * Constant for the Previous Candidate function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard - VK_CONVERT + SHIFT: maekouho */
+    public static final int VK_PREVIOUS_CANDIDATE       = 0x0101;
+
+    /**
+     * Constant for the Code Input function key.
+     * @since 1.2
+     */
+    /* Japanese PC 106 keyboard - VK_ALPHANUMERIC + ALT: kanji bangou */
+    public static final int VK_CODE_INPUT               = 0x0102;
+
+    /**
+     * Constant for the Japanese-Katakana function key.
+     * This key switches to a Japanese input method and selects its Katakana input mode.
+     * @since 1.2
+     */
+    /* Japanese Macintosh keyboard - VK_JAPANESE_HIRAGANA + SHIFT */
+    public static final int VK_JAPANESE_KATAKANA        = 0x0103;
+
+    /**
+     * Constant for the Japanese-Hiragana function key.
+     * This key switches to a Japanese input method and selects its Hiragana input mode.
+     * @since 1.2
+     */
+    /* Japanese Macintosh keyboard */
+    public static final int VK_JAPANESE_HIRAGANA        = 0x0104;
+
+    /**
+     * Constant for the Japanese-Roman function key.
+     * This key switches to a Japanese input method and selects its Roman-Direct input mode.
+     * @since 1.2
+     */
+    /* Japanese Macintosh keyboard */
+    public static final int VK_JAPANESE_ROMAN           = 0x0105;
+
+    /**
+     * Constant for the locking Kana function key.
+     * This key locks the keyboard into a Kana layout.
+     * @since 1.3
+     */
+    /* Japanese PC 106 keyboard with special Windows driver - eisuu + Control; Japanese Solaris keyboard: kana */
+    public static final int VK_KANA_LOCK                = 0x0106;
+
+    /**
+     * Constant for the input method on/off key.
+     * @since 1.3
+     */
+    /* Japanese PC 106 keyboard: kanji. Japanese Solaris keyboard: nihongo */
+    public static final int VK_INPUT_METHOD_ON_OFF      = 0x0107;
+
+    /* for Sun keyboards */
+    /** @since 1.2 */
+    public static final int VK_CUT                      = 0xFFD1;
+    /** @since 1.2 */
+    public static final int VK_COPY                     = 0xFFCD;
+    /** @since 1.2 */
+    public static final int VK_PASTE                    = 0xFFCF;
+    /** @since 1.2 */
+    public static final int VK_UNDO                     = 0xFFCB;
+    /** @since 1.2 */
+    public static final int VK_AGAIN                    = 0xFFC9;
+    /** @since 1.2 */
+    public static final int VK_FIND                     = 0xFFD0;
+    /** @since 1.2 */
+    public static final int VK_PROPS                    = 0xFFCA;
+    /** @since 1.2 */
+    public static final int VK_STOP                     = 0xFFC8;
+
+    /**
+     * Constant for the Compose function key.
+     * @since 1.2
+     */
+    public static final int VK_COMPOSE                  = 0xFF20;
+
+    /**
+     * Constant for the AltGraph function key.
+     * @since 1.2
+     */
+    public static final int VK_ALT_GRAPH                = 0xFF7E;
+
+    /**
+     * Constant for the Begin key.
+     * @since 1.5
+     */
+    public static final int VK_BEGIN                    = 0xFF58;
+
+    /**
+     * This value is used to indicate that the keyCode is unknown.
+     * KEY_TYPED events do not have a keyCode value; this value
+     * is used instead.
+     */
+    public static final int VK_UNDEFINED      = 0x0;
+
+    /**
+     * KEY_PRESSED and KEY_RELEASED events which do not map to a
+     * valid Unicode character use this for the keyChar value.
+     */
+    public static final char CHAR_UNDEFINED   = 0xFFFF;
+
+    /**
+     * A constant indicating that the keyLocation is indeterminate
+     * or not relevant.
+     * <code>KEY_TYPED</code> events do not have a keyLocation; this value
+     * is used instead.
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_UNKNOWN  = 0;
+
+    /**
+     * A constant indicating that the key pressed or released
+     * is not distinguished as the left or right version of a key,
+     * and did not originate on the numeric keypad (or did not
+     * originate with a virtual key corresponding to the numeric
+     * keypad).
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_STANDARD = 1;
+
+    /**
+     * A constant indicating that the key pressed or released is in
+     * the left key location (there is more than one possible location
+     * for this key).  Example: the left shift key.
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_LEFT     = 2;
+
+    /**
+     * A constant indicating that the key pressed or released is in
+     * the right key location (there is more than one possible location
+     * for this key).  Example: the right shift key.
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_RIGHT    = 3;
+
+    /**
+     * A constant indicating that the key event originated on the
+     * numeric keypad or with a virtual key corresponding to the
+     * numeric keypad.
+     * @since 1.4
+     */
+    public static final int KEY_LOCATION_NUMPAD   = 4;
+
+    /**
+     * Returns a String describing the keyCode, such as "HOME", "F1" or "A".
+     * These strings can be localized by changing the awt.properties file.
+     *
+     * @return a string containing a text description for a physical key,
+     *         identified by its keyCode
+     */
+    public static String getKeyText(int keyCode) {
+        if (keyCode >= VK_0 && keyCode <= VK_9 ||
+            keyCode >= VK_A && keyCode <= VK_Z) {
+            return String.valueOf((char)keyCode);
+        }
+
+        switch(keyCode) {
+          case VK_ENTER: return getToolkitProperty("AWT.enter", "Enter");
+          case VK_BACK_SPACE: return getToolkitProperty("AWT.backSpace", "Backspace");
+          case VK_TAB: return getToolkitProperty("AWT.tab", "Tab");
+          case VK_CANCEL: return getToolkitProperty("AWT.cancel", "Cancel");
+          case VK_CLEAR: return getToolkitProperty("AWT.clear", "Clear");
+          case VK_COMPOSE: return getToolkitProperty("AWT.compose", "Compose");
+          case VK_PAUSE: return getToolkitProperty("AWT.pause", "Pause");
+          case VK_CAPS_LOCK: return getToolkitProperty("AWT.capsLock", "Caps Lock");
+          case VK_ESCAPE: return getToolkitProperty("AWT.escape", "Escape");
+          case VK_SPACE: return getToolkitProperty("AWT.space", "Space");
+          case VK_PAGE_UP: return getToolkitProperty("AWT.pgup", "Page Up");
+          case VK_PAGE_DOWN: return getToolkitProperty("AWT.pgdn", "Page Down");
+          case VK_END: return getToolkitProperty("AWT.end", "End");
+          case VK_HOME: return getToolkitProperty("AWT.home", "Home");
+          case VK_LEFT: return getToolkitProperty("AWT.left", "Left");
+          case VK_UP: return getToolkitProperty("AWT.up", "Up");
+          case VK_RIGHT: return getToolkitProperty("AWT.right", "Right");
+          case VK_DOWN: return getToolkitProperty("AWT.down", "Down");
+          case VK_BEGIN: return getToolkitProperty("AWT.begin", "Begin");
+
+          // modifiers
+          case VK_SHIFT: return getToolkitProperty("AWT.shift", "Shift");
+          case VK_CONTROL: return getToolkitProperty("AWT.control", "Control");
+          case VK_ALT: return getToolkitProperty("AWT.alt", "Alt");
+          case VK_META: return getToolkitProperty("AWT.meta", "Meta");
+          case VK_ALT_GRAPH: return getToolkitProperty("AWT.altGraph", "Alt Graph");
+
+          // punctuation
+          case VK_COMMA: return getToolkitProperty("AWT.comma", "Comma");
+          case VK_PERIOD: return getToolkitProperty("AWT.period", "Period");
+          case VK_SLASH: return getToolkitProperty("AWT.slash", "Slash");
+          case VK_SEMICOLON: return getToolkitProperty("AWT.semicolon", "Semicolon");
+          case VK_EQUALS: return getToolkitProperty("AWT.equals", "Equals");
+          case VK_OPEN_BRACKET: return getToolkitProperty("AWT.openBracket", "Open Bracket");
+          case VK_BACK_SLASH: return getToolkitProperty("AWT.backSlash", "Back Slash");
+          case VK_CLOSE_BRACKET: return getToolkitProperty("AWT.closeBracket", "Close Bracket");
+
+          // numpad numeric keys handled below
+          case VK_MULTIPLY: return getToolkitProperty("AWT.multiply", "NumPad *");
+          case VK_ADD: return getToolkitProperty("AWT.add", "NumPad +");
+          case VK_SEPARATOR: return getToolkitProperty("AWT.separator", "NumPad ,");
+          case VK_SUBTRACT: return getToolkitProperty("AWT.subtract", "NumPad -");
+          case VK_DECIMAL: return getToolkitProperty("AWT.decimal", "NumPad .");
+          case VK_DIVIDE: return getToolkitProperty("AWT.divide", "NumPad /");
+          case VK_DELETE: return getToolkitProperty("AWT.delete", "Delete");
+          case VK_NUM_LOCK: return getToolkitProperty("AWT.numLock", "Num Lock");
+          case VK_SCROLL_LOCK: return getToolkitProperty("AWT.scrollLock", "Scroll Lock");
+
+          case VK_WINDOWS: return getToolkitProperty("AWT.windows", "Windows");
+          case VK_CONTEXT_MENU: return getToolkitProperty("AWT.context", "Context Menu");
+
+          case VK_F1: return getToolkitProperty("AWT.f1", "F1");
+          case VK_F2: return getToolkitProperty("AWT.f2", "F2");
+          case VK_F3: return getToolkitProperty("AWT.f3", "F3");
+          case VK_F4: return getToolkitProperty("AWT.f4", "F4");
+          case VK_F5: return getToolkitProperty("AWT.f5", "F5");
+          case VK_F6: return getToolkitProperty("AWT.f6", "F6");
+          case VK_F7: return getToolkitProperty("AWT.f7", "F7");
+          case VK_F8: return getToolkitProperty("AWT.f8", "F8");
+          case VK_F9: return getToolkitProperty("AWT.f9", "F9");
+          case VK_F10: return getToolkitProperty("AWT.f10", "F10");
+          case VK_F11: return getToolkitProperty("AWT.f11", "F11");
+          case VK_F12: return getToolkitProperty("AWT.f12", "F12");
+          case VK_F13: return getToolkitProperty("AWT.f13", "F13");
+          case VK_F14: return getToolkitProperty("AWT.f14", "F14");
+          case VK_F15: return getToolkitProperty("AWT.f15", "F15");
+          case VK_F16: return getToolkitProperty("AWT.f16", "F16");
+          case VK_F17: return getToolkitProperty("AWT.f17", "F17");
+          case VK_F18: return getToolkitProperty("AWT.f18", "F18");
+          case VK_F19: return getToolkitProperty("AWT.f19", "F19");
+          case VK_F20: return getToolkitProperty("AWT.f20", "F20");
+          case VK_F21: return getToolkitProperty("AWT.f21", "F21");
+          case VK_F22: return getToolkitProperty("AWT.f22", "F22");
+          case VK_F23: return getToolkitProperty("AWT.f23", "F23");
+          case VK_F24: return getToolkitProperty("AWT.f24", "F24");
+
+          case VK_PRINTSCREEN: return getToolkitProperty("AWT.printScreen", "Print Screen");
+          case VK_INSERT: return getToolkitProperty("AWT.insert", "Insert");
+          case VK_HELP: return getToolkitProperty("AWT.help", "Help");
+          case VK_BACK_QUOTE: return getToolkitProperty("AWT.backQuote", "Back Quote");
+          case VK_QUOTE: return getToolkitProperty("AWT.quote", "Quote");
+
+          case VK_KP_UP: return getToolkitProperty("AWT.up", "Up");
+          case VK_KP_DOWN: return getToolkitProperty("AWT.down", "Down");
+          case VK_KP_LEFT: return getToolkitProperty("AWT.left", "Left");
+          case VK_KP_RIGHT: return getToolkitProperty("AWT.right", "Right");
+
+          case VK_DEAD_GRAVE: return getToolkitProperty("AWT.deadGrave", "Dead Grave");
+          case VK_DEAD_ACUTE: return getToolkitProperty("AWT.deadAcute", "Dead Acute");
+          case VK_DEAD_CIRCUMFLEX: return getToolkitProperty("AWT.deadCircumflex", "Dead Circumflex");
+          case VK_DEAD_TILDE: return getToolkitProperty("AWT.deadTilde", "Dead Tilde");
+          case VK_DEAD_MACRON: return getToolkitProperty("AWT.deadMacron", "Dead Macron");
+          case VK_DEAD_BREVE: return getToolkitProperty("AWT.deadBreve", "Dead Breve");
+          case VK_DEAD_ABOVEDOT: return getToolkitProperty("AWT.deadAboveDot", "Dead Above Dot");
+          case VK_DEAD_DIAERESIS: return getToolkitProperty("AWT.deadDiaeresis", "Dead Diaeresis");
+          case VK_DEAD_ABOVERING: return getToolkitProperty("AWT.deadAboveRing", "Dead Above Ring");
+          case VK_DEAD_DOUBLEACUTE: return getToolkitProperty("AWT.deadDoubleAcute", "Dead Double Acute");
+          case VK_DEAD_CARON: return getToolkitProperty("AWT.deadCaron", "Dead Caron");
+          case VK_DEAD_CEDILLA: return getToolkitProperty("AWT.deadCedilla", "Dead Cedilla");
+          case VK_DEAD_OGONEK: return getToolkitProperty("AWT.deadOgonek", "Dead Ogonek");
+          case VK_DEAD_IOTA: return getToolkitProperty("AWT.deadIota", "Dead Iota");
+          case VK_DEAD_VOICED_SOUND: return getToolkitProperty("AWT.deadVoicedSound", "Dead Voiced Sound");
+          case VK_DEAD_SEMIVOICED_SOUND: return getToolkitProperty("AWT.deadSemivoicedSound", "Dead Semivoiced Sound");
+
+          case VK_AMPERSAND: return getToolkitProperty("AWT.ampersand", "Ampersand");
+          case VK_ASTERISK: return getToolkitProperty("AWT.asterisk", "Asterisk");
+          case VK_QUOTEDBL: return getToolkitProperty("AWT.quoteDbl", "Double Quote");
+          case VK_LESS: return getToolkitProperty("AWT.Less", "Less");
+          case VK_GREATER: return getToolkitProperty("AWT.greater", "Greater");
+          case VK_BRACELEFT: return getToolkitProperty("AWT.braceLeft", "Left Brace");
+          case VK_BRACERIGHT: return getToolkitProperty("AWT.braceRight", "Right Brace");
+          case VK_AT: return getToolkitProperty("AWT.at", "At");
+          case VK_COLON: return getToolkitProperty("AWT.colon", "Colon");
+          case VK_CIRCUMFLEX: return getToolkitProperty("AWT.circumflex", "Circumflex");
+          case VK_DOLLAR: return getToolkitProperty("AWT.dollar", "Dollar");
+          case VK_EURO_SIGN: return getToolkitProperty("AWT.euro", "Euro");
+          case VK_EXCLAMATION_MARK: return getToolkitProperty("AWT.exclamationMark", "Exclamation Mark");
+          case VK_INVERTED_EXCLAMATION_MARK: return getToolkitProperty("AWT.invertedExclamationMark", "Inverted Exclamation Mark");
+          case VK_LEFT_PARENTHESIS: return getToolkitProperty("AWT.leftParenthesis", "Left Parenthesis");
+          case VK_NUMBER_SIGN: return getToolkitProperty("AWT.numberSign", "Number Sign");
+          case VK_MINUS: return getToolkitProperty("AWT.minus", "Minus");
+          case VK_PLUS: return getToolkitProperty("AWT.plus", "Plus");
+          case VK_RIGHT_PARENTHESIS: return getToolkitProperty("AWT.rightParenthesis", "Right Parenthesis");
+          case VK_UNDERSCORE: return getToolkitProperty("AWT.underscore", "Underscore");
+
+          case VK_FINAL: return getToolkitProperty("AWT.final", "Final");
+          case VK_CONVERT: return getToolkitProperty("AWT.convert", "Convert");
+          case VK_NONCONVERT: return getToolkitProperty("AWT.noconvert", "No Convert");
+          case VK_ACCEPT: return getToolkitProperty("AWT.accept", "Accept");
+          case VK_MODECHANGE: return getToolkitProperty("AWT.modechange", "Mode Change");
+          case VK_KANA: return getToolkitProperty("AWT.kana", "Kana");
+          case VK_KANJI: return getToolkitProperty("AWT.kanji", "Kanji");
+          case VK_ALPHANUMERIC: return getToolkitProperty("AWT.alphanumeric", "Alphanumeric");
+          case VK_KATAKANA: return getToolkitProperty("AWT.katakana", "Katakana");
+          case VK_HIRAGANA: return getToolkitProperty("AWT.hiragana", "Hiragana");
+          case VK_FULL_WIDTH: return getToolkitProperty("AWT.fullWidth", "Full-Width");
+          case VK_HALF_WIDTH: return getToolkitProperty("AWT.halfWidth", "Half-Width");
+          case VK_ROMAN_CHARACTERS: return getToolkitProperty("AWT.romanCharacters", "Roman Characters");
+          case VK_ALL_CANDIDATES: return getToolkitProperty("AWT.allCandidates", "All Candidates");
+          case VK_PREVIOUS_CANDIDATE: return getToolkitProperty("AWT.previousCandidate", "Previous Candidate");
+          case VK_CODE_INPUT: return getToolkitProperty("AWT.codeInput", "Code Input");
+          case VK_JAPANESE_KATAKANA: return getToolkitProperty("AWT.japaneseKatakana", "Japanese Katakana");
+          case VK_JAPANESE_HIRAGANA: return getToolkitProperty("AWT.japaneseHiragana", "Japanese Hiragana");
+          case VK_JAPANESE_ROMAN: return getToolkitProperty("AWT.japaneseRoman", "Japanese Roman");
+          case VK_KANA_LOCK: return getToolkitProperty("AWT.kanaLock", "Kana Lock");
+          case VK_INPUT_METHOD_ON_OFF: return getToolkitProperty("AWT.inputMethodOnOff", "Input Method On/Off");
+
+          case VK_AGAIN: return getToolkitProperty("AWT.again", "Again");
+          case VK_UNDO: return getToolkitProperty("AWT.undo", "Undo");
+          case VK_COPY: return getToolkitProperty("AWT.copy", "Copy");
+          case VK_PASTE: return getToolkitProperty("AWT.paste", "Paste");
+          case VK_CUT: return getToolkitProperty("AWT.cut", "Cut");
+          case VK_FIND: return getToolkitProperty("AWT.find", "Find");
+          case VK_PROPS: return getToolkitProperty("AWT.props", "Props");
+          case VK_STOP: return getToolkitProperty("AWT.stop", "Stop");
+        }
+
+        if (keyCode >= VK_NUMPAD0 && keyCode <= VK_NUMPAD9) {
+            String numpad = getToolkitProperty("AWT.numpad", "NumPad");
+            char c = (char)(keyCode - VK_NUMPAD0 + '0');
+            return numpad + "-" + c;
+        }
+
+        if ((keyCode & 0x01000000) != 0) {
+            return String.valueOf((char)(keyCode ^ 0x01000000 ));
+        }
+        String unknown = getToolkitProperty("AWT.unknown", "Unknown");
+        return unknown + " keyCode: 0x" + Integer.toString(keyCode, 16);
+    }
+
+    /**
+     * The AltGraph key modifier constant.
+     */
+    public static final int ALT_GRAPH_MASK = 1 << 5;
+
+    /**
+     * The Mouse Button1 modifier constant.
+     * It is recommended that BUTTON1_DOWN_MASK be used instead.
+     */
+    public static final int BUTTON1_MASK = 1 << 4;
+
+    /**
+     * This flag indicates that the Shift key was down when the event
+     * occurred.
+     */
+    public static final int SHIFT_MASK          = 1 << 0;
+
+    /**
+     * This flag indicates that the Control key was down when the event
+     * occurred.
+     */
+    public static final int CTRL_MASK           = 1 << 1;
+
+    /**
+     * This flag indicates that the Meta key was down when the event
+     * occurred. For mouse events, this flag indicates that the right
+     * button was pressed or released.
+     */
+    public static final int META_MASK           = 1 << 2;
+
+    /**
+     * This flag indicates that the Alt key was down when
+     * the event occurred. For mouse events, this flag indicates that the
+     * middle mouse button was pressed or released.
+     */
+    public static final int ALT_MASK            = 1 << 3;
+
+    /**
+     * Returns a <code>String</code> describing the modifier key(s),
+     * such as "Shift", or "Ctrl+Shift".  These strings can be
+     * localized by changing the <code>awt.properties</code> file.
+     * <p>
+     * Note that <code>InputEvent.ALT_MASK</code> and
+     * <code>InputEvent.BUTTON2_MASK</code> have the same value,
+     * so the string "Alt" is returned for both modifiers.  Likewise,
+     * <code>InputEvent.META_MASK</code> and
+     * <code>InputEvent.BUTTON3_MASK</code> have the same value,
+     * so the string "Meta" is returned for both modifiers.
+     *
+     * @return string a text description of the combination of modifier
+     *                keys that were held down during the event
+     * @see InputEvent#getModifiersExText(int)
+     */
+    public static String getKeyModifiersText(int modifiers) {
+        StringBuffer buf = new StringBuffer();
+        if ((modifiers & META_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.meta", "Meta"));
+            buf.append("+");
+        }
+        if ((modifiers & CTRL_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.control", "Ctrl"));
+            buf.append("+");
+        }
+        if ((modifiers & ALT_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.alt", "Alt"));
+            buf.append("+");
+        }
+        if ((modifiers & SHIFT_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.shift", "Shift"));
+            buf.append("+");
+        }
+        if ((modifiers & ALT_GRAPH_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.altGraph", "Alt Graph"));
+            buf.append("+");
+        }
+        if ((modifiers & BUTTON1_MASK) != 0) {
+            buf.append(getToolkitProperty("AWT.button1", "Button1"));
+            buf.append("+");
+        }
+        if (buf.length() > 0) {
+            buf.setLength(buf.length()-1); // remove trailing '+'
+        }
+        return buf.toString();
+    }
+
+
+	public static String getToolkitProperty(String name, String defValue)
+	{
+		return defValue;
+	}
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/ASCII.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/ASCII.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/ASCII.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/ASCII.java	2010-02-05 14:24:15.000000000 -0500
@@ -0,0 +1,274 @@
+/*
+ * Copyright 1999-2000 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.util.regex;
+
+
+/**
+ * Utility class that implements the standard C ctype functionality.
+ *
+ * @author Hong Zhang
+ */
+
+final class ASCII {
+
+    static final int UPPER   = 0x00000100;
+
+    static final int LOWER   = 0x00000200;
+
+    static final int DIGIT   = 0x00000400;
+
+    static final int SPACE   = 0x00000800;
+
+    static final int PUNCT   = 0x00001000;
+
+    static final int CNTRL   = 0x00002000;
+
+    static final int BLANK   = 0x00004000;
+
+    static final int HEX     = 0x00008000;
+
+    static final int UNDER   = 0x00010000;
+
+    static final int ASCII   = 0x0000FF00;
+
+    static final int ALPHA   = (UPPER|LOWER);
+
+    static final int ALNUM   = (UPPER|LOWER|DIGIT);
+
+    static final int GRAPH   = (PUNCT|UPPER|LOWER|DIGIT);
+
+    static final int WORD    = (UPPER|LOWER|UNDER|DIGIT);
+
+    static final int XDIGIT  = (HEX);
+
+    private static final int[] ctype = new int[] {
+        CNTRL,                  /* 00 (NUL) */
+        CNTRL,                  /* 01 (SOH) */
+        CNTRL,                  /* 02 (STX) */
+        CNTRL,                  /* 03 (ETX) */
+        CNTRL,                  /* 04 (EOT) */
+        CNTRL,                  /* 05 (ENQ) */
+        CNTRL,                  /* 06 (ACK) */
+        CNTRL,                  /* 07 (BEL) */
+        CNTRL,                  /* 08 (BS)  */
+        SPACE+CNTRL+BLANK,      /* 09 (HT)  */
+        SPACE+CNTRL,            /* 0A (LF)  */
+        SPACE+CNTRL,            /* 0B (VT)  */
+        SPACE+CNTRL,            /* 0C (FF)  */
+        SPACE+CNTRL,            /* 0D (CR)  */
+        CNTRL,                  /* 0E (SI)  */
+        CNTRL,                  /* 0F (SO)  */
+        CNTRL,                  /* 10 (DLE) */
+        CNTRL,                  /* 11 (DC1) */
+        CNTRL,                  /* 12 (DC2) */
+        CNTRL,                  /* 13 (DC3) */
+        CNTRL,                  /* 14 (DC4) */
+        CNTRL,                  /* 15 (NAK) */
+        CNTRL,                  /* 16 (SYN) */
+        CNTRL,                  /* 17 (ETB) */
+        CNTRL,                  /* 18 (CAN) */
+        CNTRL,                  /* 19 (EM)  */
+        CNTRL,                  /* 1A (SUB) */
+        CNTRL,                  /* 1B (ESC) */
+        CNTRL,                  /* 1C (FS)  */
+        CNTRL,                  /* 1D (GS)  */
+        CNTRL,                  /* 1E (RS)  */
+        CNTRL,                  /* 1F (US)  */
+        SPACE+BLANK,            /* 20 SPACE */
+        PUNCT,                  /* 21 !     */
+        PUNCT,                  /* 22 "     */
+        PUNCT,                  /* 23 #     */
+        PUNCT,                  /* 24 $     */
+        PUNCT,                  /* 25 %     */
+        PUNCT,                  /* 26 &     */
+        PUNCT,                  /* 27 '     */
+        PUNCT,                  /* 28 (     */
+        PUNCT,                  /* 29 )     */
+        PUNCT,                  /* 2A *     */
+        PUNCT,                  /* 2B +     */
+        PUNCT,                  /* 2C ,     */
+        PUNCT,                  /* 2D -     */
+        PUNCT,                  /* 2E .     */
+        PUNCT,                  /* 2F /     */
+        DIGIT+HEX+0,            /* 30 0     */
+        DIGIT+HEX+1,            /* 31 1     */
+        DIGIT+HEX+2,            /* 32 2     */
+        DIGIT+HEX+3,            /* 33 3     */
+        DIGIT+HEX+4,            /* 34 4     */
+        DIGIT+HEX+5,            /* 35 5     */
+        DIGIT+HEX+6,            /* 36 6     */
+        DIGIT+HEX+7,            /* 37 7     */
+        DIGIT+HEX+8,            /* 38 8     */
+        DIGIT+HEX+9,            /* 39 9     */
+        PUNCT,                  /* 3A :     */
+        PUNCT,                  /* 3B ;     */
+        PUNCT,                  /* 3C <     */
+        PUNCT,                  /* 3D =     */
+        PUNCT,                  /* 3E >     */
+        PUNCT,                  /* 3F ?     */
+        PUNCT,                  /* 40 @     */
+        UPPER+HEX+10,           /* 41 A     */
+        UPPER+HEX+11,           /* 42 B     */
+        UPPER+HEX+12,           /* 43 C     */
+        UPPER+HEX+13,           /* 44 D     */
+        UPPER+HEX+14,           /* 45 E     */
+        UPPER+HEX+15,           /* 46 F     */
+        UPPER+16,               /* 47 G     */
+        UPPER+17,               /* 48 H     */
+        UPPER+18,               /* 49 I     */
+        UPPER+19,               /* 4A J     */
+        UPPER+20,               /* 4B K     */
+        UPPER+21,               /* 4C L     */
+        UPPER+22,               /* 4D M     */
+        UPPER+23,               /* 4E N     */
+        UPPER+24,               /* 4F O     */
+        UPPER+25,               /* 50 P     */
+        UPPER+26,               /* 51 Q     */
+        UPPER+27,               /* 52 R     */
+        UPPER+28,               /* 53 S     */
+        UPPER+29,               /* 54 T     */
+        UPPER+30,               /* 55 U     */
+        UPPER+31,               /* 56 V     */
+        UPPER+32,               /* 57 W     */
+        UPPER+33,               /* 58 X     */
+        UPPER+34,               /* 59 Y     */
+        UPPER+35,               /* 5A Z     */
+        PUNCT,                  /* 5B [     */
+        PUNCT,                  /* 5C \     */
+        PUNCT,                  /* 5D ]     */
+        PUNCT,                  /* 5E ^     */
+        PUNCT|UNDER,            /* 5F _     */
+        PUNCT,                  /* 60 `     */
+        LOWER+HEX+10,           /* 61 a     */
+        LOWER+HEX+11,           /* 62 b     */
+        LOWER+HEX+12,           /* 63 c     */
+        LOWER+HEX+13,           /* 64 d     */
+        LOWER+HEX+14,           /* 65 e     */
+        LOWER+HEX+15,           /* 66 f     */
+        LOWER+16,               /* 67 g     */
+        LOWER+17,               /* 68 h     */
+        LOWER+18,               /* 69 i     */
+        LOWER+19,               /* 6A j     */
+        LOWER+20,               /* 6B k     */
+        LOWER+21,               /* 6C l     */
+        LOWER+22,               /* 6D m     */
+        LOWER+23,               /* 6E n     */
+        LOWER+24,               /* 6F o     */
+        LOWER+25,               /* 70 p     */
+        LOWER+26,               /* 71 q     */
+        LOWER+27,               /* 72 r     */
+        LOWER+28,               /* 73 s     */
+        LOWER+29,               /* 74 t     */
+        LOWER+30,               /* 75 u     */
+        LOWER+31,               /* 76 v     */
+        LOWER+32,               /* 77 w     */
+        LOWER+33,               /* 78 x     */
+        LOWER+34,               /* 79 y     */
+        LOWER+35,               /* 7A z     */
+        PUNCT,                  /* 7B {     */
+        PUNCT,                  /* 7C |     */
+        PUNCT,                  /* 7D }     */
+        PUNCT,                  /* 7E ~     */
+        CNTRL,                  /* 7F (DEL) */
+    };
+
+    static int getType(int ch) {
+        return ((ch & 0xFFFFFF80) == 0 ? ctype[ch] : 0);
+    }
+
+    static boolean isType(int ch, int type) {
+        return (getType(ch) & type) != 0;
+    }
+
+    static boolean isAscii(int ch) {
+        return ((ch & 0xFFFFFF80) == 0);
+    }
+
+    static boolean isAlpha(int ch) {
+        return isType(ch, ALPHA);
+    }
+
+    static boolean isDigit(int ch) {
+        return ((ch-'0')|('9'-ch)) >= 0;
+    }
+
+    static boolean isAlnum(int ch) {
+        return isType(ch, ALNUM);
+    }
+
+    static boolean isGraph(int ch) {
+        return isType(ch, GRAPH);
+    }
+
+    static boolean isPrint(int ch) {
+        return ((ch-0x20)|(0x7E-ch)) >= 0;
+    }
+
+    static boolean isPunct(int ch) {
+        return isType(ch, PUNCT);
+    }
+
+    static boolean isSpace(int ch) {
+        return isType(ch, SPACE);
+    }
+
+    static boolean isHexDigit(int ch) {
+        return isType(ch, HEX);
+    }
+
+    static boolean isOctDigit(int ch) {
+        return ((ch-'0')|('7'-ch)) >= 0;
+    }
+
+    static boolean isCntrl(int ch) {
+        return isType(ch, CNTRL);
+    }
+
+    static boolean isLower(int ch) {
+        return ((ch-'a')|('z'-ch)) >= 0;
+    }
+
+    static boolean isUpper(int ch) {
+        return ((ch-'A')|('Z'-ch)) >= 0;
+    }
+
+    static boolean isWord(int ch) {
+        return isType(ch, WORD);
+    }
+
+    static int toDigit(int ch) {
+        return (ctype[ch & 0x7F] & 0x3F);
+    }
+
+    static int toLower(int ch) {
+        return isUpper(ch) ? (ch + 0x20) : ch;
+    }
+
+    static int toUpper(int ch) {
+        return isLower(ch) ? (ch - 0x20) : ch;
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/Matcher.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/Matcher.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/Matcher.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/Matcher.java	2010-02-05 14:24:15.000000000 -0500
@@ -0,0 +1,1174 @@
+/*
+ * Copyright 1999-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.util.regex;
+
+
+/**
+ * An engine that performs match operations on a {@link java.lang.CharSequence
+ * </code>character sequence<code>} by interpreting a {@link Pattern}.
+ *
+ * <p> A matcher is created from a pattern by invoking the pattern's {@link
+ * Pattern#matcher matcher} method.  Once created, a matcher can be used to
+ * perform three different kinds of match operations:
+ *
+ * <ul>
+ *
+ *   <li><p> The {@link #matches matches} method attempts to match the entire
+ *   input sequence against the pattern.  </p></li>
+ *
+ *   <li><p> The {@link #lookingAt lookingAt} method attempts to match the
+ *   input sequence, starting at the beginning, against the pattern.  </p></li>
+ *
+ *   <li><p> The {@link #find find} method scans the input sequence looking for
+ *   the next subsequence that matches the pattern.  </p></li>
+ *
+ * </ul>
+ *
+ * <p> Each of these methods returns a boolean indicating success or failure.
+ * More information about a successful match can be obtained by querying the
+ * state of the matcher.
+ *
+ * <p> A matcher finds matches in a subset of its input called the
+ * <i>region</i>. By default, the region contains all of the matcher's input.
+ * The region can be modified via the{@link #region region} method and queried
+ * via the {@link #regionStart regionStart} and {@link #regionEnd regionEnd}
+ * methods. The way that the region boundaries interact with some pattern
+ * constructs can be changed. See {@link #useAnchoringBounds
+ * useAnchoringBounds} and {@link #useTransparentBounds useTransparentBounds}
+ * for more details.
+ *
+ * <p> This class also defines methods for replacing matched subsequences with
+ * new strings whose contents can, if desired, be computed from the match
+ * result.  The {@link #appendReplacement appendReplacement} and {@link
+ * #appendTail appendTail} methods can be used in tandem in order to collect
+ * the result into an existing string buffer, or the more convenient {@link
+ * #replaceAll replaceAll} method can be used to create a string in which every
+ * matching subsequence in the input sequence is replaced.
+ *
+ * <p> The explicit state of a matcher includes the start and end indices of
+ * the most recent successful match.  It also includes the start and end
+ * indices of the input subsequence captured by each <a
+ * href="Pattern.html#cg">capturing group</a> in the pattern as well as a total
+ * count of such subsequences.  As a convenience, methods are also provided for
+ * returning these captured subsequences in string form.
+ *
+ * <p> The explicit state of a matcher is initially undefined; attempting to
+ * query any part of it before a successful match will cause an {@link
+ * IllegalStateException} to be thrown.  The explicit state of a matcher is
+ * recomputed by every match operation.
+ *
+ * <p> The implicit state of a matcher includes the input character sequence as
+ * well as the <i>append position</i>, which is initially zero and is updated
+ * by the {@link #appendReplacement appendReplacement} method.
+ *
+ * <p> A matcher may be reset explicitly by invoking its {@link #reset()}
+ * method or, if a new input sequence is desired, its {@link
+ * #reset(java.lang.CharSequence) reset(CharSequence)} method.  Resetting a
+ * matcher discards its explicit state information and sets the append position
+ * to zero.
+ *
+ * <p> Instances of this class are not safe for use by multiple concurrent
+ * threads. </p>
+ *
+ *
+ * @author      Mike McCloskey
+ * @author      Mark Reinhold
+ * @author      JSR-51 Expert Group
+ * @since       1.4
+ * @spec        JSR-51
+ */
+
+public final class Matcher implements MatchResult {
+
+    /**
+     * The Pattern object that created this Matcher.
+     */
+    Pattern parentPattern;
+
+    /**
+     * The storage used by groups. They may contain invalid values if
+     * a group was skipped during the matching.
+     */
+    int[] groups;
+
+    /**
+     * The range within the sequence that is to be matched. Anchors
+     * will match at these "hard" boundaries. Changing the region
+     * changes these values.
+     */
+    int from, to;
+
+    /**
+     * Lookbehind uses this value to ensure that the subexpression
+     * match ends at the point where the lookbehind was encountered.
+     */
+    int lookbehindTo;
+
+    /**
+     * The original string being matched.
+     */
+    CharSequence text;
+
+    /**
+     * Matcher state used by the last node. NOANCHOR is used when a
+     * match does not have to consume all of the input. ENDANCHOR is
+     * the mode used for matching all the input.
+     */
+    static final int ENDANCHOR = 1;
+    static final int NOANCHOR = 0;
+    int acceptMode = NOANCHOR;
+
+    /**
+     * The range of string that last matched the pattern. If the last
+     * match failed then first is -1; last initially holds 0 then it
+     * holds the index of the end of the last match (which is where the
+     * next search starts).
+     */
+    int first = -1, last = 0;
+
+    /**
+     * The end index of what matched in the last match operation.
+     */
+    int oldLast = -1;
+
+    /**
+     * The index of the last position appended in a substitution.
+     */
+    int lastAppendPosition = 0;
+
+    /**
+     * Storage used by nodes to tell what repetition they are on in
+     * a pattern, and where groups begin. The nodes themselves are stateless,
+     * so they rely on this field to hold state during a match.
+     */
+    int[] locals;
+
+    /**
+     * Boolean indicating whether or not more input could change
+     * the results of the last match.
+     *
+     * If hitEnd is true, and a match was found, then more input
+     * might cause a different match to be found.
+     * If hitEnd is true and a match was not found, then more
+     * input could cause a match to be found.
+     * If hitEnd is false and a match was found, then more input
+     * will not change the match.
+     * If hitEnd is false and a match was not found, then more
+     * input will not cause a match to be found.
+     */
+    boolean hitEnd;
+
+    /**
+     * Boolean indicating whether or not more input could change
+     * a positive match into a negative one.
+     *
+     * If requireEnd is true, and a match was found, then more
+     * input could cause the match to be lost.
+     * If requireEnd is false and a match was found, then more
+     * input might change the match but the match won't be lost.
+     * If a match was not found, then requireEnd has no meaning.
+     */
+    boolean requireEnd;
+
+    /**
+     * If transparentBounds is true then the boundaries of this
+     * matcher's region are transparent to lookahead, lookbehind,
+     * and boundary matching constructs that try to see beyond them.
+     */
+    boolean transparentBounds = false;
+
+    /**
+     * If anchoringBounds is true then the boundaries of this
+     * matcher's region match anchors such as ^ and $.
+     */
+    boolean anchoringBounds = true;
+
+    /**
+     * No default constructor.
+     */
+    Matcher() {
+    }
+
+    /**
+     * All matchers have the state used by Pattern during a match.
+     */
+    Matcher(Pattern parent, CharSequence text) {
+        this.parentPattern = parent;
+        this.text = text;
+
+        // Allocate state storage
+        int parentGroupCount = Math.max(parent.capturingGroupCount, 10);
+        groups = new int[parentGroupCount * 2];
+        locals = new int[parent.localCount];
+
+        // Put fields into initial states
+        reset();
+    }
+
+    /**
+     * Returns the pattern that is interpreted by this matcher.
+     *
+     * @return  The pattern for which this matcher was created
+     */
+    public Pattern pattern() {
+        return parentPattern;
+    }
+
+    /**
+     * Returns the match state of this matcher as a {@link MatchResult}.
+     * The result is unaffected by subsequent operations performed upon this
+     * matcher.
+     *
+     * @return  a <code>MatchResult</code> with the state of this matcher
+     * @since 1.5
+     */
+    public MatchResult toMatchResult() {
+        Matcher result = new Matcher(this.parentPattern, text.toString());
+        result.first = this.first;
+        result.last = this.last;
+        result.groups = this.groups.clone();
+        return result;
+    }
+
+    /**
+      * Changes the <tt>Pattern</tt> that this <tt>Matcher</tt> uses to
+      * find matches with.
+      *
+      * <p> This method causes this matcher to lose information
+      * about the groups of the last match that occurred. The
+      * matcher's position in the input is maintained and its
+      * last append position is unaffected.</p>
+      *
+      * @param  newPattern
+      *         The new pattern used by this matcher
+      * @return  This matcher
+      * @throws  IllegalArgumentException
+      *          If newPattern is <tt>null</tt>
+      * @since 1.5
+      */
+    public Matcher usePattern(Pattern newPattern) {
+        if (newPattern == null)
+            throw new IllegalArgumentException("Pattern cannot be null");
+        parentPattern = newPattern;
+
+        // Reallocate state storage
+        int parentGroupCount = Math.max(newPattern.capturingGroupCount, 10);
+        groups = new int[parentGroupCount * 2];
+        locals = new int[newPattern.localCount];
+        for (int i = 0; i < groups.length; i++)
+            groups[i] = -1;
+        for (int i = 0; i < locals.length; i++)
+            locals[i] = -1;
+        return this;
+    }
+
+    /**
+     * Resets this matcher.
+     *
+     * <p> Resetting a matcher discards all of its explicit state information
+     * and sets its append position to zero. The matcher's region is set to the
+     * default region, which is its entire character sequence. The anchoring
+     * and transparency of this matcher's region boundaries are unaffected.
+     *
+     * @return  This matcher
+     */
+    public Matcher reset() {
+        first = -1;
+        last = 0;
+        oldLast = -1;
+        for(int i=0; i<groups.length; i++)
+            groups[i] = -1;
+        for(int i=0; i<locals.length; i++)
+            locals[i] = -1;
+        lastAppendPosition = 0;
+        from = 0;
+        to = getTextLength();
+        return this;
+    }
+
+    /**
+     * Resets this matcher with a new input sequence.
+     *
+     * <p> Resetting a matcher discards all of its explicit state information
+     * and sets its append position to zero.  The matcher's region is set to
+     * the default region, which is its entire character sequence.  The
+     * anchoring and transparency of this matcher's region boundaries are
+     * unaffected.
+     *
+     * @param  input
+     *         The new input character sequence
+     *
+     * @return  This matcher
+     */
+    public Matcher reset(CharSequence input) {
+        text = input;
+        return reset();
+    }
+
+    /**
+     * Returns the start index of the previous match.  </p>
+     *
+     * @return  The index of the first character matched
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     */
+    public int start() {
+        if (first < 0)
+            throw new IllegalStateException("No match available");
+        return first;
+    }
+
+    /**
+     * Returns the start index of the subsequence captured by the given group
+     * during the previous match operation.
+     *
+     * <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left
+     * to right, starting at one.  Group zero denotes the entire pattern, so
+     * the expression <i>m.</i><tt>start(0)</tt> is equivalent to
+     * <i>m.</i><tt>start()</tt>.  </p>
+     *
+     * @param  group
+     *         The index of a capturing group in this matcher's pattern
+     *
+     * @return  The index of the first character captured by the group,
+     *          or <tt>-1</tt> if the match was successful but the group
+     *          itself did not match anything
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If there is no capturing group in the pattern
+     *          with the given index
+     */
+    public int start(int group) {
+        if (first < 0)
+            throw new IllegalStateException("No match available");
+        if (group > groupCount())
+            throw new IndexOutOfBoundsException("No group " + group);
+        return groups[group * 2];
+    }
+
+    /**
+     * Returns the offset after the last character matched.  </p>
+     *
+     * @return  The offset after the last character matched
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     */
+    public int end() {
+        if (first < 0)
+            throw new IllegalStateException("No match available");
+        return last;
+    }
+
+    /**
+     * Returns the offset after the last character of the subsequence
+     * captured by the given group during the previous match operation.
+     *
+     * <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left
+     * to right, starting at one.  Group zero denotes the entire pattern, so
+     * the expression <i>m.</i><tt>end(0)</tt> is equivalent to
+     * <i>m.</i><tt>end()</tt>.  </p>
+     *
+     * @param  group
+     *         The index of a capturing group in this matcher's pattern
+     *
+     * @return  The offset after the last character captured by the group,
+     *          or <tt>-1</tt> if the match was successful
+     *          but the group itself did not match anything
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If there is no capturing group in the pattern
+     *          with the given index
+     */
+    public int end(int group) {
+        if (first < 0)
+            throw new IllegalStateException("No match available");
+        if (group > groupCount())
+            throw new IndexOutOfBoundsException("No group " + group);
+        return groups[group * 2 + 1];
+    }
+
+    /**
+     * Returns the input subsequence matched by the previous match.
+     *
+     * <p> For a matcher <i>m</i> with input sequence <i>s</i>,
+     * the expressions <i>m.</i><tt>group()</tt> and
+     * <i>s.</i><tt>substring(</tt><i>m.</i><tt>start(),</tt>&nbsp;<i>m.</i><tt>end())</tt>
+     * are equivalent.  </p>
+     *
+     * <p> Note that some patterns, for example <tt>a*</tt>, match the empty
+     * string.  This method will return the empty string when the pattern
+     * successfully matches the empty string in the input.  </p>
+     *
+     * @return The (possibly empty) subsequence matched by the previous match,
+     *         in string form
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     */
+    public String group() {
+        return group(0);
+    }
+
+    /**
+     * Returns the input subsequence captured by the given group during the
+     * previous match operation.
+     *
+     * <p> For a matcher <i>m</i>, input sequence <i>s</i>, and group index
+     * <i>g</i>, the expressions <i>m.</i><tt>group(</tt><i>g</i><tt>)</tt> and
+     * <i>s.</i><tt>substring(</tt><i>m.</i><tt>start(</tt><i>g</i><tt>),</tt>&nbsp;<i>m.</i><tt>end(</tt><i>g</i><tt>))</tt>
+     * are equivalent.  </p>
+     *
+     * <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left
+     * to right, starting at one.  Group zero denotes the entire pattern, so
+     * the expression <tt>m.group(0)</tt> is equivalent to <tt>m.group()</tt>.
+     * </p>
+     *
+     * <p> If the match was successful but the group specified failed to match
+     * any part of the input sequence, then <tt>null</tt> is returned. Note
+     * that some groups, for example <tt>(a*)</tt>, match the empty string.
+     * This method will return the empty string when such a group successfully
+     * matches the empty string in the input.  </p>
+     *
+     * @param  group
+     *         The index of a capturing group in this matcher's pattern
+     *
+     * @return  The (possibly empty) subsequence captured by the group
+     *          during the previous match, or <tt>null</tt> if the group
+     *          failed to match part of the input
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If there is no capturing group in the pattern
+     *          with the given index
+     */
+    public String group(int group) {
+        if (first < 0)
+            throw new IllegalStateException("No match found");
+        if (group < 0 || group > groupCount())
+            throw new IndexOutOfBoundsException("No group " + group);
+        if ((groups[group*2] == -1) || (groups[group*2+1] == -1))
+            return null;
+        return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();
+    }
+
+    /**
+     * Returns the number of capturing groups in this matcher's pattern.
+     *
+     * <p> Group zero denotes the entire pattern by convention. It is not
+     * included in this count.
+     *
+     * <p> Any non-negative integer smaller than or equal to the value
+     * returned by this method is guaranteed to be a valid group index for
+     * this matcher.  </p>
+     *
+     * @return The number of capturing groups in this matcher's pattern
+     */
+    public int groupCount() {
+        return parentPattern.capturingGroupCount - 1;
+    }
+
+    /**
+     * Attempts to match the entire region against the pattern.
+     *
+     * <p> If the match succeeds then more information can be obtained via the
+     * <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if, the entire region sequence
+     *          matches this matcher's pattern
+     */
+    public boolean matches() {
+        return match(from, ENDANCHOR);
+    }
+
+    /**
+     * Attempts to find the next subsequence of the input sequence that matches
+     * the pattern.
+     *
+     * <p> This method starts at the beginning of this matcher's region, or, if
+     * a previous invocation of the method was successful and the matcher has
+     * not since been reset, at the first character not matched by the previous
+     * match.
+     *
+     * <p> If the match succeeds then more information can be obtained via the
+     * <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if, a subsequence of the input
+     *          sequence matches this matcher's pattern
+     */
+    public boolean find() {
+        int nextSearchIndex = last;
+        if (nextSearchIndex == first)
+            nextSearchIndex++;
+
+        // If next search starts before region, start it at region
+        if (nextSearchIndex < from)
+            nextSearchIndex = from;
+
+        // If next search starts beyond region then it fails
+        if (nextSearchIndex > to) {
+            for (int i = 0; i < groups.length; i++)
+                groups[i] = -1;
+            return false;
+        }
+        return search(nextSearchIndex);
+    }
+
+    /**
+     * Resets this matcher and then attempts to find the next subsequence of
+     * the input sequence that matches the pattern, starting at the specified
+     * index.
+     *
+     * <p> If the match succeeds then more information can be obtained via the
+     * <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods, and subsequent
+     * invocations of the {@link #find()} method will start at the first
+     * character not matched by this match.  </p>
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If start is less than zero or if start is greater than the
+     *          length of the input sequence.
+     *
+     * @return  <tt>true</tt> if, and only if, a subsequence of the input
+     *          sequence starting at the given index matches this matcher's
+     *          pattern
+     */
+    public boolean find(int start) {
+        int limit = getTextLength();
+        if ((start < 0) || (start > limit))
+            throw new IndexOutOfBoundsException("Illegal start index");
+        reset();
+        return search(start);
+    }
+
+    /**
+     * Attempts to match the input sequence, starting at the beginning of the
+     * region, against the pattern.
+     *
+     * <p> Like the {@link #matches matches} method, this method always starts
+     * at the beginning of the region; unlike that method, it does not
+     * require that the entire region be matched.
+     *
+     * <p> If the match succeeds then more information can be obtained via the
+     * <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if, a prefix of the input
+     *          sequence matches this matcher's pattern
+     */
+    public boolean lookingAt() {
+        return match(from, NOANCHOR);
+    }
+
+    /**
+     * Returns a literal replacement <code>String</code> for the specified
+     * <code>String</code>.
+     *
+     * This method produces a <code>String</code> that will work
+     * as a literal replacement <code>s</code> in the
+     * <code>appendReplacement</code> method of the {@link Matcher} class.
+     * The <code>String</code> produced will match the sequence of characters
+     * in <code>s</code> treated as a literal sequence. Slashes ('\') and
+     * dollar signs ('$') will be given no special meaning.
+     *
+     * @param  s The string to be literalized
+     * @return  A literal string replacement
+     * @since 1.5
+     */
+    public static String quoteReplacement(String s) {
+        if ((s.indexOf('\\') == -1) && (s.indexOf('$') == -1))
+            return s;
+        StringBuilder sb = new StringBuilder();
+        for (int i=0; i<s.length(); i++) {
+            char c = s.charAt(i);
+            if (c == '\\' || c == '$') {
+                sb.append('\\');
+            }
+            sb.append(c);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Implements a non-terminal append-and-replace step.
+     *
+     * <p> This method performs the following actions: </p>
+     *
+     * <ol>
+     *
+     *   <li><p> It reads characters from the input sequence, starting at the
+     *   append position, and appends them to the given string buffer.  It
+     *   stops after reading the last character preceding the previous match,
+     *   that is, the character at index {@link
+     *   #start()}&nbsp;<tt>-</tt>&nbsp;<tt>1</tt>.  </p></li>
+     *
+     *   <li><p> It appends the given replacement string to the string buffer.
+     *   </p></li>
+     *
+     *   <li><p> It sets the append position of this matcher to the index of
+     *   the last character matched, plus one, that is, to {@link #end()}.
+     *   </p></li>
+     *
+     * </ol>
+     *
+     * <p> The replacement string may contain references to subsequences
+     * captured during the previous match: Each occurrence of
+     * <tt>$</tt><i>g</i><tt></tt> will be replaced by the result of
+     * evaluating {@link #group(int) group}<tt>(</tt><i>g</i><tt>)</tt>.
+     * The first number after the <tt>$</tt> is always treated as part of
+     * the group reference. Subsequent numbers are incorporated into g if
+     * they would form a legal group reference. Only the numerals '0'
+     * through '9' are considered as potential components of the group
+     * reference. If the second group matched the string <tt>"foo"</tt>, for
+     * example, then passing the replacement string <tt>"$2bar"</tt> would
+     * cause <tt>"foobar"</tt> to be appended to the string buffer. A dollar
+     * sign (<tt>$</tt>) may be included as a literal in the replacement
+     * string by preceding it with a backslash (<tt>\$</tt>).
+     *
+     * <p> Note that backslashes (<tt>\</tt>) and dollar signs (<tt>$</tt>) in
+     * the replacement string may cause the results to be different than if it
+     * were being treated as a literal replacement string. Dollar signs may be
+     * treated as references to captured subsequences as described above, and
+     * backslashes are used to escape literal characters in the replacement
+     * string.
+     *
+     * <p> This method is intended to be used in a loop together with the
+     * {@link #appendTail appendTail} and {@link #find find} methods.  The
+     * following code, for example, writes <tt>one dog two dogs in the
+     * yard</tt> to the standard-output stream: </p>
+     *
+     * <blockquote><pre>
+     * Pattern p = Pattern.compile("cat");
+     * Matcher m = p.matcher("one cat two cats in the yard");
+     * StringBuffer sb = new StringBuffer();
+     * while (m.find()) {
+     *     m.appendReplacement(sb, "dog");
+     * }
+     * m.appendTail(sb);
+     * System.out.println(sb.toString());</pre></blockquote>
+     *
+     * @param  sb
+     *         The target string buffer
+     *
+     * @param  replacement
+     *         The replacement string
+     *
+     * @return  This matcher
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If the replacement string refers to a capturing group
+     *          that does not exist in the pattern
+     */
+    public Matcher appendReplacement(StringBuffer sb, String replacement) {
+
+        // If no match, return error
+        if (first < 0)
+            throw new IllegalStateException("No match available");
+
+        // Process substitution string to replace group references with groups
+        int cursor = 0;
+        StringBuilder result = new StringBuilder();
+
+        while (cursor < replacement.length()) {
+            char nextChar = replacement.charAt(cursor);
+            if (nextChar == '\\') {
+                cursor++;
+                nextChar = replacement.charAt(cursor);
+                result.append(nextChar);
+                cursor++;
+            } else if (nextChar == '$') {
+                // Skip past $
+                cursor++;
+                // The first number is always a group
+                int refNum = (int)replacement.charAt(cursor) - '0';
+                if ((refNum < 0)||(refNum > 9))
+                    throw new IllegalArgumentException(
+                        "Illegal group reference");
+                cursor++;
+
+                // Capture the largest legal group string
+                boolean done = false;
+                while (!done) {
+                    if (cursor >= replacement.length()) {
+                        break;
+                    }
+                    int nextDigit = replacement.charAt(cursor) - '0';
+                    if ((nextDigit < 0)||(nextDigit > 9)) { // not a number
+                        break;
+                    }
+                    int newRefNum = (refNum * 10) + nextDigit;
+                    if (groupCount() < newRefNum) {
+                        done = true;
+                    } else {
+                        refNum = newRefNum;
+                        cursor++;
+                    }
+                }
+                // Append group
+                if (start(refNum) != -1 && end(refNum) != -1)
+                    result.append(text, start(refNum), end(refNum));
+            } else {
+                result.append(nextChar);
+                cursor++;
+            }
+        }
+        // Append the intervening text
+        sb.append(text, lastAppendPosition, first);
+        // Append the match substitution
+        sb.append(result);
+
+        lastAppendPosition = last;
+        return this;
+    }
+
+    /**
+     * Implements a terminal append-and-replace step.
+     *
+     * <p> This method reads characters from the input sequence, starting at
+     * the append position, and appends them to the given string buffer.  It is
+     * intended to be invoked after one or more invocations of the {@link
+     * #appendReplacement appendReplacement} method in order to copy the
+     * remainder of the input sequence.  </p>
+     *
+     * @param  sb
+     *         The target string buffer
+     *
+     * @return  The target string buffer
+     */
+    public StringBuffer appendTail(StringBuffer sb) {
+        sb.append(text, lastAppendPosition, getTextLength());
+        return sb;
+    }
+
+    /**
+     * Replaces every subsequence of the input sequence that matches the
+     * pattern with the given replacement string.
+     *
+     * <p> This method first resets this matcher.  It then scans the input
+     * sequence looking for matches of the pattern.  Characters that are not
+     * part of any match are appended directly to the result string; each match
+     * is replaced in the result by the replacement string.  The replacement
+     * string may contain references to captured subsequences as in the {@link
+     * #appendReplacement appendReplacement} method.
+     *
+     * <p> Note that backslashes (<tt>\</tt>) and dollar signs (<tt>$</tt>) in
+     * the replacement string may cause the results to be different than if it
+     * were being treated as a literal replacement string. Dollar signs may be
+     * treated as references to captured subsequences as described above, and
+     * backslashes are used to escape literal characters in the replacement
+     * string.
+     *
+     * <p> Given the regular expression <tt>a*b</tt>, the input
+     * <tt>"aabfooaabfooabfoob"</tt>, and the replacement string
+     * <tt>"-"</tt>, an invocation of this method on a matcher for that
+     * expression would yield the string <tt>"-foo-foo-foo-"</tt>.
+     *
+     * <p> Invoking this method changes this matcher's state.  If the matcher
+     * is to be used in further matching operations then it should first be
+     * reset.  </p>
+     *
+     * @param  replacement
+     *         The replacement string
+     *
+     * @return  The string constructed by replacing each matching subsequence
+     *          by the replacement string, substituting captured subsequences
+     *          as needed
+     */
+    public String replaceAll(String replacement) {
+        reset();
+        boolean result = find();
+        if (result) {
+            StringBuffer sb = new StringBuffer();
+            do {
+                appendReplacement(sb, replacement);
+                result = find();
+            } while (result);
+            appendTail(sb);
+            return sb.toString();
+        }
+        return text.toString();
+    }
+
+    /**
+     * Replaces the first subsequence of the input sequence that matches the
+     * pattern with the given replacement string.
+     *
+     * <p> This method first resets this matcher.  It then scans the input
+     * sequence looking for a match of the pattern.  Characters that are not
+     * part of the match are appended directly to the result string; the match
+     * is replaced in the result by the replacement string.  The replacement
+     * string may contain references to captured subsequences as in the {@link
+     * #appendReplacement appendReplacement} method.
+     *
+     * <p>Note that backslashes (<tt>\</tt>) and dollar signs (<tt>$</tt>) in
+     * the replacement string may cause the results to be different than if it
+     * were being treated as a literal replacement string. Dollar signs may be
+     * treated as references to captured subsequences as described above, and
+     * backslashes are used to escape literal characters in the replacement
+     * string.
+     *
+     * <p> Given the regular expression <tt>dog</tt>, the input
+     * <tt>"zzzdogzzzdogzzz"</tt>, and the replacement string
+     * <tt>"cat"</tt>, an invocation of this method on a matcher for that
+     * expression would yield the string <tt>"zzzcatzzzdogzzz"</tt>.  </p>
+     *
+     * <p> Invoking this method changes this matcher's state.  If the matcher
+     * is to be used in further matching operations then it should first be
+     * reset.  </p>
+     *
+     * @param  replacement
+     *         The replacement string
+     * @return  The string constructed by replacing the first matching
+     *          subsequence by the replacement string, substituting captured
+     *          subsequences as needed
+     */
+    public String replaceFirst(String replacement) {
+        if (replacement == null)
+            throw new NullPointerException("replacement");
+        reset();
+        if (!find())
+            return text.toString();
+        StringBuffer sb = new StringBuffer();
+        appendReplacement(sb, replacement);
+        appendTail(sb);
+        return sb.toString();
+    }
+
+    /**
+     * Sets the limits of this matcher's region. The region is the part of the
+     * input sequence that will be searched to find a match. Invoking this
+     * method resets the matcher, and then sets the region to start at the
+     * index specified by the <code>start</code> parameter and end at the
+     * index specified by the <code>end</code> parameter.
+     *
+     * <p>Depending on the transparency and anchoring being used (see
+     * {@link #useTransparentBounds useTransparentBounds} and
+     * {@link #useAnchoringBounds useAnchoringBounds}), certain constructs such
+     * as anchors may behave differently at or around the boundaries of the
+     * region.
+     *
+     * @param  start
+     *         The index to start searching at (inclusive)
+     * @param  end
+     *         The index to end searching at (exclusive)
+     * @throws  IndexOutOfBoundsException
+     *          If start or end is less than zero, if
+     *          start is greater than the length of the input sequence, if
+     *          end is greater than the length of the input sequence, or if
+     *          start is greater than end.
+     * @return  this matcher
+     * @since 1.5
+     */
+    public Matcher region(int start, int end) {
+        if ((start < 0) || (start > getTextLength()))
+            throw new IndexOutOfBoundsException("start");
+        if ((end < 0) || (end > getTextLength()))
+            throw new IndexOutOfBoundsException("end");
+        if (start > end)
+            throw new IndexOutOfBoundsException("start > end");
+        reset();
+        from = start;
+        to = end;
+        return this;
+    }
+
+    /**
+     * Reports the start index of this matcher's region. The
+     * searches this matcher conducts are limited to finding matches
+     * within {@link #regionStart regionStart} (inclusive) and
+     * {@link #regionEnd regionEnd} (exclusive).
+     *
+     * @return  The starting point of this matcher's region
+     * @since 1.5
+     */
+    public int regionStart() {
+        return from;
+    }
+
+    /**
+     * Reports the end index (exclusive) of this matcher's region.
+     * The searches this matcher conducts are limited to finding matches
+     * within {@link #regionStart regionStart} (inclusive) and
+     * {@link #regionEnd regionEnd} (exclusive).
+     *
+     * @return  the ending point of this matcher's region
+     * @since 1.5
+     */
+    public int regionEnd() {
+        return to;
+    }
+
+    /**
+     * Queries the transparency of region bounds for this matcher.
+     *
+     * <p> This method returns <tt>true</tt> if this matcher uses
+     * <i>transparent</i> bounds, <tt>false</tt> if it uses <i>opaque</i>
+     * bounds.
+     *
+     * <p> See {@link #useTransparentBounds useTransparentBounds} for a
+     * description of transparent and opaque bounds.
+     *
+     * <p> By default, a matcher uses opaque region boundaries.
+     *
+     * @return <tt>true</tt> iff this matcher is using transparent bounds,
+     *         <tt>false</tt> otherwise.
+     * @see java.util.regex.Matcher#useTransparentBounds(boolean)
+     * @since 1.5
+     */
+    public boolean hasTransparentBounds() {
+        return transparentBounds;
+    }
+
+    /**
+     * Sets the transparency of region bounds for this matcher.
+     *
+     * <p> Invoking this method with an argument of <tt>true</tt> will set this
+     * matcher to use <i>transparent</i> bounds. If the boolean
+     * argument is <tt>false</tt>, then <i>opaque</i> bounds will be used.
+     *
+     * <p> Using transparent bounds, the boundaries of this
+     * matcher's region are transparent to lookahead, lookbehind,
+     * and boundary matching constructs. Those constructs can see beyond the
+     * boundaries of the region to see if a match is appropriate.
+     *
+     * <p> Using opaque bounds, the boundaries of this matcher's
+     * region are opaque to lookahead, lookbehind, and boundary matching
+     * constructs that may try to see beyond them. Those constructs cannot
+     * look past the boundaries so they will fail to match anything outside
+     * of the region.
+     *
+     * <p> By default, a matcher uses opaque bounds.
+     *
+     * @param  b a boolean indicating whether to use opaque or transparent
+     *         regions
+     * @return this matcher
+     * @see java.util.regex.Matcher#hasTransparentBounds
+     * @since 1.5
+     */
+    public Matcher useTransparentBounds(boolean b) {
+        transparentBounds = b;
+        return this;
+    }
+
+    /**
+     * Queries the anchoring of region bounds for this matcher.
+     *
+     * <p> This method returns <tt>true</tt> if this matcher uses
+     * <i>anchoring</i> bounds, <tt>false</tt> otherwise.
+     *
+     * <p> See {@link #useAnchoringBounds useAnchoringBounds} for a
+     * description of anchoring bounds.
+     *
+     * <p> By default, a matcher uses anchoring region boundaries.
+     *
+     * @return <tt>true</tt> iff this matcher is using anchoring bounds,
+     *         <tt>false</tt> otherwise.
+     * @see java.util.regex.Matcher#useAnchoringBounds(boolean)
+     * @since 1.5
+     */
+    public boolean hasAnchoringBounds() {
+        return anchoringBounds;
+    }
+
+    /**
+     * Sets the anchoring of region bounds for this matcher.
+     *
+     * <p> Invoking this method with an argument of <tt>true</tt> will set this
+     * matcher to use <i>anchoring</i> bounds. If the boolean
+     * argument is <tt>false</tt>, then <i>non-anchoring</i> bounds will be
+     * used.
+     *
+     * <p> Using anchoring bounds, the boundaries of this
+     * matcher's region match anchors such as ^ and $.
+     *
+     * <p> Without anchoring bounds, the boundaries of this
+     * matcher's region will not match anchors such as ^ and $.
+     *
+     * <p> By default, a matcher uses anchoring region boundaries.
+     *
+     * @param  b a boolean indicating whether or not to use anchoring bounds.
+     * @return this matcher
+     * @see java.util.regex.Matcher#hasAnchoringBounds
+     * @since 1.5
+     */
+    public Matcher useAnchoringBounds(boolean b) {
+        anchoringBounds = b;
+        return this;
+    }
+
+    /**
+     * <p>Returns the string representation of this matcher. The
+     * string representation of a <code>Matcher</code> contains information
+     * that may be useful for debugging. The exact format is unspecified.
+     *
+     * @return  The string representation of this matcher
+     * @since 1.5
+     */
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("java.util.regex.Matcher");
+        sb.append("[pattern=" + pattern());
+        sb.append(" region=");
+        sb.append(regionStart() + "," + regionEnd());
+        sb.append(" lastmatch=");
+        if ((first >= 0) && (group() != null)) {
+            sb.append(group());
+        }
+        sb.append("]");
+        return sb.toString();
+    }
+
+    /**
+     * <p>Returns true if the end of input was hit by the search engine in
+     * the last match operation performed by this matcher.
+     *
+     * <p>When this method returns true, then it is possible that more input
+     * would have changed the result of the last search.
+     *
+     * @return  true iff the end of input was hit in the last match; false
+     *          otherwise
+     * @since 1.5
+     */
+    public boolean hitEnd() {
+        return hitEnd;
+    }
+
+    /**
+     * <p>Returns true if more input could change a positive match into a
+     * negative one.
+     *
+     * <p>If this method returns true, and a match was found, then more
+     * input could cause the match to be lost. If this method returns false
+     * and a match was found, then more input might change the match but the
+     * match won't be lost. If a match was not found, then requireEnd has no
+     * meaning.
+     *
+     * @return  true iff more input could change a positive match into a
+     *          negative one.
+     * @since 1.5
+     */
+    public boolean requireEnd() {
+        return requireEnd;
+    }
+
+    /**
+     * Initiates a search to find a Pattern within the given bounds.
+     * The groups are filled with default values and the match of the root
+     * of the state machine is called. The state machine will hold the state
+     * of the match as it proceeds in this matcher.
+     *
+     * Matcher.from is not set here, because it is the "hard" boundary
+     * of the start of the search which anchors will set to. The from param
+     * is the "soft" boundary of the start of the search, meaning that the
+     * regex tries to match at that index but ^ won't match there. Subsequent
+     * calls to the search methods start at a new "soft" boundary which is
+     * the end of the previous match.
+     */
+    boolean search(int from) {
+        this.hitEnd = false;
+        this.requireEnd = false;
+        from        = from < 0 ? 0 : from;
+        this.first  = from;
+        this.oldLast = oldLast < 0 ? from : oldLast;
+        for (int i = 0; i < groups.length; i++)
+            groups[i] = -1;
+        acceptMode = NOANCHOR;
+        boolean result = parentPattern.root.match(this, from, text);
+        if (!result)
+            this.first = -1;
+        this.oldLast = this.last;
+        return result;
+    }
+
+    /**
+     * Initiates a search for an anchored match to a Pattern within the given
+     * bounds. The groups are filled with default values and the match of the
+     * root of the state machine is called. The state machine will hold the
+     * state of the match as it proceeds in this matcher.
+     */
+    boolean match(int from, int anchor) {
+        this.hitEnd = false;
+        this.requireEnd = false;
+        from        = from < 0 ? 0 : from;
+        this.first  = from;
+        this.oldLast = oldLast < 0 ? from : oldLast;
+        for (int i = 0; i < groups.length; i++)
+            groups[i] = -1;
+        acceptMode = anchor;
+        boolean result = parentPattern.matchRoot.match(this, from, text);
+        if (!result)
+            this.first = -1;
+        this.oldLast = this.last;
+        return result;
+    }
+
+    /**
+     * Returns the end index of the text.
+     *
+     * @return the index after the last character in the text
+     */
+    int getTextLength() {
+        return text.length();
+    }
+
+    /**
+     * Generates a String from this Matcher's input in the specified range.
+     *
+     * @param  beginIndex   the beginning index, inclusive
+     * @param  endIndex     the ending index, exclusive
+     * @return A String generated from this Matcher's input
+     */
+    CharSequence getSubSequence(int beginIndex, int endIndex) {
+        return text.subSequence(beginIndex, endIndex);
+    }
+
+    /**
+     * Returns this Matcher's input character at index i.
+     *
+     * @return A char from the specified index
+     */
+    char charAt(int i) {
+        return text.charAt(i);
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/MatchResult.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/MatchResult.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/MatchResult.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/MatchResult.java	2010-02-05 14:24:15.000000000 -0500
@@ -0,0 +1,188 @@
+/*
+ * Copyright 2003-2004 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.util.regex;
+
+/**
+ * The result of a match operation.
+ *
+ * <p>This interface contains query methods used to determine the
+ * results of a match against a regular expression. The match boundaries,
+ * groups and group boundaries can be seen but not modified through
+ * a <code>MatchResult</code>.
+ *
+ * @author  Michael McCloskey
+ * @see Matcher
+ * @since 1.5
+ */
+public interface MatchResult {
+
+    /**
+     * Returns the start index of the match.
+     *
+     * @return  The index of the first character matched
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     */
+    public int start();
+
+    /**
+     * Returns the start index of the subsequence captured by the given group
+     * during this match.
+     *
+     * <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left
+     * to right, starting at one.  Group zero denotes the entire pattern, so
+     * the expression <i>m.</i><tt>start(0)</tt> is equivalent to
+     * <i>m.</i><tt>start()</tt>.  </p>
+     *
+     * @param  group
+     *         The index of a capturing group in this matcher's pattern
+     *
+     * @return  The index of the first character captured by the group,
+     *          or <tt>-1</tt> if the match was successful but the group
+     *          itself did not match anything
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If there is no capturing group in the pattern
+     *          with the given index
+     */
+    public int start(int group);
+
+    /**
+     * Returns the offset after the last character matched.  </p>
+     *
+     * @return  @return  The offset after the last character matched
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     */
+    public int end();
+
+    /**
+     * Returns the offset after the last character of the subsequence
+     * captured by the given group during this match.
+     *
+     * <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left
+     * to right, starting at one.  Group zero denotes the entire pattern, so
+     * the expression <i>m.</i><tt>end(0)</tt> is equivalent to
+     * <i>m.</i><tt>end()</tt>.  </p>
+     *
+     * @param  group
+     *         The index of a capturing group in this matcher's pattern
+     *
+     * @return  The offset after the last character captured by the group,
+     *          or <tt>-1</tt> if the match was successful
+     *          but the group itself did not match anything
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If there is no capturing group in the pattern
+     *          with the given index
+     */
+    public int end(int group);
+
+    /**
+     * Returns the input subsequence matched by the previous match.
+     *
+     * <p> For a matcher <i>m</i> with input sequence <i>s</i>,
+     * the expressions <i>m.</i><tt>group()</tt> and
+     * <i>s.</i><tt>substring(</tt><i>m.</i><tt>start(),</tt>&nbsp;<i>m.</i><tt>end())</tt>
+     * are equivalent.  </p>
+     *
+     * <p> Note that some patterns, for example <tt>a*</tt>, match the empty
+     * string.  This method will return the empty string when the pattern
+     * successfully matches the empty string in the input.  </p>
+     *
+     * @return The (possibly empty) subsequence matched by the previous match,
+     *         in string form
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     */
+    public String group();
+
+    /**
+     * Returns the input subsequence captured by the given group during the
+     * previous match operation.
+     *
+     * <p> For a matcher <i>m</i>, input sequence <i>s</i>, and group index
+     * <i>g</i>, the expressions <i>m.</i><tt>group(</tt><i>g</i><tt>)</tt> and
+     * <i>s.</i><tt>substring(</tt><i>m.</i><tt>start(</tt><i>g</i><tt>),</tt>&nbsp;<i>m.</i><tt>end(</tt><i>g</i><tt>))</tt>
+     * are equivalent.  </p>
+     *
+     * <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left
+     * to right, starting at one.  Group zero denotes the entire pattern, so
+     * the expression <tt>m.group(0)</tt> is equivalent to <tt>m.group()</tt>.
+     * </p>
+     *
+     * <p> If the match was successful but the group specified failed to match
+     * any part of the input sequence, then <tt>null</tt> is returned. Note
+     * that some groups, for example <tt>(a*)</tt>, match the empty string.
+     * This method will return the empty string when such a group successfully
+     * matches the empty string in the input.  </p>
+     *
+     * @param  group
+     *         The index of a capturing group in this matcher's pattern
+     *
+     * @return  The (possibly empty) subsequence captured by the group
+     *          during the previous match, or <tt>null</tt> if the group
+     *          failed to match part of the input
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If there is no capturing group in the pattern
+     *          with the given index
+     */
+    public String group(int group);
+
+    /**
+     * Returns the number of capturing groups in this match result's pattern.
+     *
+     * <p> Group zero denotes the entire pattern by convention. It is not
+     * included in this count.
+     *
+     * <p> Any non-negative integer smaller than or equal to the value
+     * returned by this method is guaranteed to be a valid group index for
+     * this matcher.  </p>
+     *
+     * @return The number of capturing groups in this matcher's pattern
+     */
+    public int groupCount();
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/Pattern.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/Pattern.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/Pattern.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/Pattern.java	2010-02-05 14:24:15.000000000 -0500
@@ -0,0 +1,5285 @@
+/*
+ * Copyright 1999-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.util.regex;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.CharacterIterator;
+import java.text.Normalizer;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Arrays;
+
+
+/**
+ * A compiled representation of a regular expression.
+ *
+ * <p> A regular expression, specified as a string, must first be compiled into
+ * an instance of this class.  The resulting pattern can then be used to create
+ * a {@link Matcher} object that can match arbitrary {@link
+ * java.lang.CharSequence </code>character sequences<code>} against the regular
+ * expression.  All of the state involved in performing a match resides in the
+ * matcher, so many matchers can share the same pattern.
+ *
+ * <p> A typical invocation sequence is thus
+ *
+ * <blockquote><pre>
+ * Pattern p = Pattern.{@link #compile compile}("a*b");
+ * Matcher m = p.{@link #matcher matcher}("aaaaab");
+ * boolean b = m.{@link Matcher#matches matches}();</pre></blockquote>
+ *
+ * <p> A {@link #matches matches} method is defined by this class as a
+ * convenience for when a regular expression is used just once.  This method
+ * compiles an expression and matches an input sequence against it in a single
+ * invocation.  The statement
+ *
+ * <blockquote><pre>
+ * boolean b = Pattern.matches("a*b", "aaaaab");</pre></blockquote>
+ *
+ * is equivalent to the three statements above, though for repeated matches it
+ * is less efficient since it does not allow the compiled pattern to be reused.
+ *
+ * <p> Instances of this class are immutable and are safe for use by multiple
+ * concurrent threads.  Instances of the {@link Matcher} class are not safe for
+ * such use.
+ *
+ *
+ * <a name="sum">
+ * <h4> Summary of regular-expression constructs </h4>
+ *
+ * <table border="0" cellpadding="1" cellspacing="0"
+ *  summary="Regular expression constructs, and what they match">
+ *
+ * <tr align="left">
+ * <th bgcolor="#CCCCFF" align="left" id="construct">Construct</th>
+ * <th bgcolor="#CCCCFF" align="left" id="matches">Matches</th>
+ * </tr>
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2" id="characters">Characters</th></tr>
+ *
+ * <tr><td valign="top" headers="construct characters"><i>x</i></td>
+ *     <td headers="matches">The character <i>x</i></td></tr>
+ * <tr><td valign="top" headers="construct characters"><tt>\\</tt></td>
+ *     <td headers="matches">The backslash character</td></tr>
+ * <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>n</i></td>
+ *     <td headers="matches">The character with octal value <tt>0</tt><i>n</i>
+ *         (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
+ * <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>nn</i></td>
+ *     <td headers="matches">The character with octal value <tt>0</tt><i>nn</i>
+ *         (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
+ * <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>mnn</i></td>
+ *     <td headers="matches">The character with octal value <tt>0</tt><i>mnn</i>
+ *         (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>m</i>&nbsp;<tt>&lt;=</tt>&nbsp;3,
+ *         0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
+ * <tr><td valign="top" headers="construct characters"><tt>\x</tt><i>hh</i></td>
+ *     <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hh</i></td></tr>
+ * <tr><td valign="top" headers="construct characters"><tt>&#92;u</tt><i>hhhh</i></td>
+ *     <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hhhh</i></td></tr>
+ * <tr><td valign="top" headers="matches"><tt>\t</tt></td>
+ *     <td headers="matches">The tab character (<tt>'&#92;u0009'</tt>)</td></tr>
+ * <tr><td valign="top" headers="construct characters"><tt>\n</tt></td>
+ *     <td headers="matches">The newline (line feed) character (<tt>'&#92;u000A'</tt>)</td></tr>
+ * <tr><td valign="top" headers="construct characters"><tt>\r</tt></td>
+ *     <td headers="matches">The carriage-return character (<tt>'&#92;u000D'</tt>)</td></tr>
+ * <tr><td valign="top" headers="construct characters"><tt>\f</tt></td>
+ *     <td headers="matches">The form-feed character (<tt>'&#92;u000C'</tt>)</td></tr>
+ * <tr><td valign="top" headers="construct characters"><tt>\a</tt></td>
+ *     <td headers="matches">The alert (bell) character (<tt>'&#92;u0007'</tt>)</td></tr>
+ * <tr><td valign="top" headers="construct characters"><tt>\e</tt></td>
+ *     <td headers="matches">The escape character (<tt>'&#92;u001B'</tt>)</td></tr>
+ * <tr><td valign="top" headers="construct characters"><tt>\c</tt><i>x</i></td>
+ *     <td headers="matches">The control character corresponding to <i>x</i></td></tr>
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2" id="classes">Character classes</th></tr>
+ *
+ * <tr><td valign="top" headers="construct classes"><tt>[abc]</tt></td>
+ *     <td headers="matches"><tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (simple class)</td></tr>
+ * <tr><td valign="top" headers="construct classes"><tt>[^abc]</tt></td>
+ *     <td headers="matches">Any character except <tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (negation)</td></tr>
+ * <tr><td valign="top" headers="construct classes"><tt>[a-zA-Z]</tt></td>
+ *     <td headers="matches"><tt>a</tt> through <tt>z</tt>
+ *         or <tt>A</tt> through <tt>Z</tt>, inclusive (range)</td></tr>
+ * <tr><td valign="top" headers="construct classes"><tt>[a-d[m-p]]</tt></td>
+ *     <td headers="matches"><tt>a</tt> through <tt>d</tt>,
+ *      or <tt>m</tt> through <tt>p</tt>: <tt>[a-dm-p]</tt> (union)</td></tr>
+ * <tr><td valign="top" headers="construct classes"><tt>[a-z&&[def]]</tt></td>
+ *     <td headers="matches"><tt>d</tt>, <tt>e</tt>, or <tt>f</tt> (intersection)</tr>
+ * <tr><td valign="top" headers="construct classes"><tt>[a-z&&[^bc]]</tt></td>
+ *     <td headers="matches"><tt>a</tt> through <tt>z</tt>,
+ *         except for <tt>b</tt> and <tt>c</tt>: <tt>[ad-z]</tt> (subtraction)</td></tr>
+ * <tr><td valign="top" headers="construct classes"><tt>[a-z&&[^m-p]]</tt></td>
+ *     <td headers="matches"><tt>a</tt> through <tt>z</tt>,
+ *          and not <tt>m</tt> through <tt>p</tt>: <tt>[a-lq-z]</tt>(subtraction)</td></tr>
+ * <tr><th>&nbsp;</th></tr>
+ *
+ * <tr align="left"><th colspan="2" id="predef">Predefined character classes</th></tr>
+ *
+ * <tr><td valign="top" headers="construct predef"><tt>.</tt></td>
+ *     <td headers="matches">Any character (may or may not match <a href="#lt">line terminators</a>)</td></tr>
+ * <tr><td valign="top" headers="construct predef"><tt>\d</tt></td>
+ *     <td headers="matches">A digit: <tt>[0-9]</tt></td></tr>
+ * <tr><td valign="top" headers="construct predef"><tt>\D</tt></td>
+ *     <td headers="matches">A non-digit: <tt>[^0-9]</tt></td></tr>
+ * <tr><td valign="top" headers="construct predef"><tt>\s</tt></td>
+ *     <td headers="matches">A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
+ * <tr><td valign="top" headers="construct predef"><tt>\S</tt></td>
+ *     <td headers="matches">A non-whitespace character: <tt>[^\s]</tt></td></tr>
+ * <tr><td valign="top" headers="construct predef"><tt>\w</tt></td>
+ *     <td headers="matches">A word character: <tt>[a-zA-Z_0-9]</tt></td></tr>
+ * <tr><td valign="top" headers="construct predef"><tt>\W</tt></td>
+ *     <td headers="matches">A non-word character: <tt>[^\w]</tt></td></tr>
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2" id="posix">POSIX character classes</b> (US-ASCII only)<b></th></tr>
+ *
+ * <tr><td valign="top" headers="construct posix"><tt>\p{Lower}</tt></td>
+ *     <td headers="matches">A lower-case alphabetic character: <tt>[a-z]</tt></td></tr>
+ * <tr><td valign="top" headers="construct posix"><tt>\p{Upper}</tt></td>
+ *     <td headers="matches">An upper-case alphabetic character:<tt>[A-Z]</tt></td></tr>
+ * <tr><td valign="top" headers="construct posix"><tt>\p{ASCII}</tt></td>
+ *     <td headers="matches">All ASCII:<tt>[\x00-\x7F]</tt></td></tr>
+ * <tr><td valign="top" headers="construct posix"><tt>\p{Alpha}</tt></td>
+ *     <td headers="matches">An alphabetic character:<tt>[\p{Lower}\p{Upper}]</tt></td></tr>
+ * <tr><td valign="top" headers="construct posix"><tt>\p{Digit}</tt></td>
+ *     <td headers="matches">A decimal digit: <tt>[0-9]</tt></td></tr>
+ * <tr><td valign="top" headers="construct posix"><tt>\p{Alnum}</tt></td>
+ *     <td headers="matches">An alphanumeric character:<tt>[\p{Alpha}\p{Digit}]</tt></td></tr>
+ * <tr><td valign="top" headers="construct posix"><tt>\p{Punct}</tt></td>
+ *     <td headers="matches">Punctuation: One of <tt>!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~</tt></td></tr>
+ *     <!-- <tt>[\!"#\$%&'\(\)\*\+,\-\./:;\<=\>\?@\[\\\]\^_`\{\|\}~]</tt>
+ *          <tt>[\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]</tt> -->
+ * <tr><td valign="top" headers="construct posix"><tt>\p{Graph}</tt></td>
+ *     <td headers="matches">A visible character: <tt>[\p{Alnum}\p{Punct}]</tt></td></tr>
+ * <tr><td valign="top" headers="construct posix"><tt>\p{Print}</tt></td>
+ *     <td headers="matches">A printable character: <tt>[\p{Graph}\x20]</tt></td></tr>
+ * <tr><td valign="top" headers="construct posix"><tt>\p{Blank}</tt></td>
+ *     <td headers="matches">A space or a tab: <tt>[ \t]</tt></td></tr>
+ * <tr><td valign="top" headers="construct posix"><tt>\p{Cntrl}</tt></td>
+ *     <td headers="matches">A control character: <tt>[\x00-\x1F\x7F]</tt></td></tr>
+ * <tr><td valign="top" headers="construct posix"><tt>\p{XDigit}</tt></td>
+ *     <td headers="matches">A hexadecimal digit: <tt>[0-9a-fA-F]</tt></td></tr>
+ * <tr><td valign="top" headers="construct posix"><tt>\p{Space}</tt></td>
+ *     <td headers="matches">A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2">java.lang.Character classes (simple <a href="#jcc">java character type</a>)</th></tr>
+ *
+ * <tr><td valign="top"><tt>\p{javaLowerCase}</tt></td>
+ *     <td>Equivalent to java.lang.Character.isLowerCase()</td></tr>
+ * <tr><td valign="top"><tt>\p{javaUpperCase}</tt></td>
+ *     <td>Equivalent to java.lang.Character.isUpperCase()</td></tr>
+ * <tr><td valign="top"><tt>\p{javaWhitespace}</tt></td>
+ *     <td>Equivalent to java.lang.Character.isWhitespace()</td></tr>
+ * <tr><td valign="top"><tt>\p{javaMirrored}</tt></td>
+ *     <td>Equivalent to java.lang.Character.isMirrored()</td></tr>
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2" id="unicode">Classes for Unicode blocks and categories</th></tr>
+ *
+ * <tr><td valign="top" headers="construct unicode"><tt>\p{InGreek}</tt></td>
+ *     <td headers="matches">A character in the Greek&nbsp;block (simple <a href="#ubc">block</a>)</td></tr>
+ * <tr><td valign="top" headers="construct unicode"><tt>\p{Lu}</tt></td>
+ *     <td headers="matches">An uppercase letter (simple <a href="#ubc">category</a>)</td></tr>
+ * <tr><td valign="top" headers="construct unicode"><tt>\p{Sc}</tt></td>
+ *     <td headers="matches">A currency symbol</td></tr>
+ * <tr><td valign="top" headers="construct unicode"><tt>\P{InGreek}</tt></td>
+ *     <td headers="matches">Any character except one in the Greek block (negation)</td></tr>
+ * <tr><td valign="top" headers="construct unicode"><tt>[\p{L}&&[^\p{Lu}]]&nbsp;</tt></td>
+ *     <td headers="matches">Any letter except an uppercase letter (subtraction)</td></tr>
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2" id="bounds">Boundary matchers</th></tr>
+ *
+ * <tr><td valign="top" headers="construct bounds"><tt>^</tt></td>
+ *     <td headers="matches">The beginning of a line</td></tr>
+ * <tr><td valign="top" headers="construct bounds"><tt>$</tt></td>
+ *     <td headers="matches">The end of a line</td></tr>
+ * <tr><td valign="top" headers="construct bounds"><tt>\b</tt></td>
+ *     <td headers="matches">A word boundary</td></tr>
+ * <tr><td valign="top" headers="construct bounds"><tt>\B</tt></td>
+ *     <td headers="matches">A non-word boundary</td></tr>
+ * <tr><td valign="top" headers="construct bounds"><tt>\A</tt></td>
+ *     <td headers="matches">The beginning of the input</td></tr>
+ * <tr><td valign="top" headers="construct bounds"><tt>\G</tt></td>
+ *     <td headers="matches">The end of the previous match</td></tr>
+ * <tr><td valign="top" headers="construct bounds"><tt>\Z</tt></td>
+ *     <td headers="matches">The end of the input but for the final
+ *         <a href="#lt">terminator</a>, if&nbsp;any</td></tr>
+ * <tr><td valign="top" headers="construct bounds"><tt>\z</tt></td>
+ *     <td headers="matches">The end of the input</td></tr>
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2" id="greedy">Greedy quantifiers</th></tr>
+ *
+ * <tr><td valign="top" headers="construct greedy"><i>X</i><tt>?</tt></td>
+ *     <td headers="matches"><i>X</i>, once or not at all</td></tr>
+ * <tr><td valign="top" headers="construct greedy"><i>X</i><tt>*</tt></td>
+ *     <td headers="matches"><i>X</i>, zero or more times</td></tr>
+ * <tr><td valign="top" headers="construct greedy"><i>X</i><tt>+</tt></td>
+ *     <td headers="matches"><i>X</i>, one or more times</td></tr>
+ * <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>}</tt></td>
+ *     <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
+ * <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,}</tt></td>
+ *     <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
+ * <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}</tt></td>
+ *     <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2" id="reluc">Reluctant quantifiers</th></tr>
+ *
+ * <tr><td valign="top" headers="construct reluc"><i>X</i><tt>??</tt></td>
+ *     <td headers="matches"><i>X</i>, once or not at all</td></tr>
+ * <tr><td valign="top" headers="construct reluc"><i>X</i><tt>*?</tt></td>
+ *     <td headers="matches"><i>X</i>, zero or more times</td></tr>
+ * <tr><td valign="top" headers="construct reluc"><i>X</i><tt>+?</tt></td>
+ *     <td headers="matches"><i>X</i>, one or more times</td></tr>
+ * <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>}?</tt></td>
+ *     <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
+ * <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,}?</tt></td>
+ *     <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
+ * <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}?</tt></td>
+ *     <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2" id="poss">Possessive quantifiers</th></tr>
+ *
+ * <tr><td valign="top" headers="construct poss"><i>X</i><tt>?+</tt></td>
+ *     <td headers="matches"><i>X</i>, once or not at all</td></tr>
+ * <tr><td valign="top" headers="construct poss"><i>X</i><tt>*+</tt></td>
+ *     <td headers="matches"><i>X</i>, zero or more times</td></tr>
+ * <tr><td valign="top" headers="construct poss"><i>X</i><tt>++</tt></td>
+ *     <td headers="matches"><i>X</i>, one or more times</td></tr>
+ * <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>}+</tt></td>
+ *     <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
+ * <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,}+</tt></td>
+ *     <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
+ * <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}+</tt></td>
+ *     <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2" id="logical">Logical operators</th></tr>
+ *
+ * <tr><td valign="top" headers="construct logical"><i>XY</i></td>
+ *     <td headers="matches"><i>X</i> followed by <i>Y</i></td></tr>
+ * <tr><td valign="top" headers="construct logical"><i>X</i><tt>|</tt><i>Y</i></td>
+ *     <td headers="matches">Either <i>X</i> or <i>Y</i></td></tr>
+ * <tr><td valign="top" headers="construct logical"><tt>(</tt><i>X</i><tt>)</tt></td>
+ *     <td headers="matches">X, as a <a href="#cg">capturing group</a></td></tr>
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2" id="backref">Back references</th></tr>
+ *
+ * <tr><td valign="bottom" headers="construct backref"><tt>\</tt><i>n</i></td>
+ *     <td valign="bottom" headers="matches">Whatever the <i>n</i><sup>th</sup>
+ *     <a href="#cg">capturing group</a> matched</td></tr>
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2" id="quot">Quotation</th></tr>
+ *
+ * <tr><td valign="top" headers="construct quot"><tt>\</tt></td>
+ *     <td headers="matches">Nothing, but quotes the following character</td></tr>
+ * <tr><td valign="top" headers="construct quot"><tt>\Q</tt></td>
+ *     <td headers="matches">Nothing, but quotes all characters until <tt>\E</tt></td></tr>
+ * <tr><td valign="top" headers="construct quot"><tt>\E</tt></td>
+ *     <td headers="matches">Nothing, but ends quoting started by <tt>\Q</tt></td></tr>
+ *     <!-- Metachars: !$()*+.<>?[\]^{|} -->
+ *
+ * <tr><th>&nbsp;</th></tr>
+ * <tr align="left"><th colspan="2" id="special">Special constructs (non-capturing)</th></tr>
+ *
+ * <tr><td valign="top" headers="construct special"><tt>(?:</tt><i>X</i><tt>)</tt></td>
+ *     <td headers="matches"><i>X</i>, as a non-capturing group</td></tr>
+ * <tr><td valign="top" headers="construct special"><tt>(?idmsux-idmsux)&nbsp;</tt></td>
+ *     <td headers="matches">Nothing, but turns match flags <a href="#CASE_INSENSITIVE">i</a>
+ * <a href="#UNIX_LINES">d</a> <a href="#MULTILINE">m</a> <a href="#DOTALL">s</a>
+ * <a href="#UNICODE_CASE">u</a> <a href="#COMMENTS">x</a> on - off</td></tr>
+ * <tr><td valign="top" headers="construct special"><tt>(?idmsux-idmsux:</tt><i>X</i><tt>)</tt>&nbsp;&nbsp;</td>
+ *     <td headers="matches"><i>X</i>, as a <a href="#cg">non-capturing group</a> with the
+ *         given flags <a href="#CASE_INSENSITIVE">i</a> <a href="#UNIX_LINES">d</a>
+ * <a href="#MULTILINE">m</a> <a href="#DOTALL">s</a> <a href="#UNICODE_CASE">u</a >
+ * <a href="#COMMENTS">x</a> on - off</td></tr>
+ * <tr><td valign="top" headers="construct special"><tt>(?=</tt><i>X</i><tt>)</tt></td>
+ *     <td headers="matches"><i>X</i>, via zero-width positive lookahead</td></tr>
+ * <tr><td valign="top" headers="construct special"><tt>(?!</tt><i>X</i><tt>)</tt></td>
+ *     <td headers="matches"><i>X</i>, via zero-width negative lookahead</td></tr>
+ * <tr><td valign="top" headers="construct special"><tt>(?&lt;=</tt><i>X</i><tt>)</tt></td>
+ *     <td headers="matches"><i>X</i>, via zero-width positive lookbehind</td></tr>
+ * <tr><td valign="top" headers="construct special"><tt>(?&lt;!</tt><i>X</i><tt>)</tt></td>
+ *     <td headers="matches"><i>X</i>, via zero-width negative lookbehind</td></tr>
+ * <tr><td valign="top" headers="construct special"><tt>(?&gt;</tt><i>X</i><tt>)</tt></td>
+ *     <td headers="matches"><i>X</i>, as an independent, non-capturing group</td></tr>
+ *
+ * </table>
+ *
+ * <hr>
+ *
+ *
+ * <a name="bs">
+ * <h4> Backslashes, escapes, and quoting </h4>
+ *
+ * <p> The backslash character (<tt>'\'</tt>) serves to introduce escaped
+ * constructs, as defined in the table above, as well as to quote characters
+ * that otherwise would be interpreted as unescaped constructs.  Thus the
+ * expression <tt>\\</tt> matches a single backslash and <tt>\{</tt> matches a
+ * left brace.
+ *
+ * <p> It is an error to use a backslash prior to any alphabetic character that
+ * does not denote an escaped construct; these are reserved for future
+ * extensions to the regular-expression language.  A backslash may be used
+ * prior to a non-alphabetic character regardless of whether that character is
+ * part of an unescaped construct.
+ *
+ * <p> Backslashes within string literals in Java source code are interpreted
+ * as required by the <a
+ * href="http://java.sun.com/docs/books/jls">Java Language
+ * Specification</a> as either <a
+ * href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#100850">Unicode
+ * escapes</a> or other <a
+ * href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089">character
+ * escapes</a>.  It is therefore necessary to double backslashes in string
+ * literals that represent regular expressions to protect them from
+ * interpretation by the Java bytecode compiler.  The string literal
+ * <tt>"&#92;b"</tt>, for example, matches a single backspace character when
+ * interpreted as a regular expression, while <tt>"&#92;&#92;b"</tt> matches a
+ * word boundary.  The string literal <tt>"&#92;(hello&#92;)"</tt> is illegal
+ * and leads to a compile-time error; in order to match the string
+ * <tt>(hello)</tt> the string literal <tt>"&#92;&#92;(hello&#92;&#92;)"</tt>
+ * must be used.
+ *
+ * <a name="cc">
+ * <h4> Character Classes </h4>
+ *
+ *    <p> Character classes may appear within other character classes, and
+ *    may be composed by the union operator (implicit) and the intersection
+ *    operator (<tt>&amp;&amp;</tt>).
+ *    The union operator denotes a class that contains every character that is
+ *    in at least one of its operand classes.  The intersection operator
+ *    denotes a class that contains every character that is in both of its
+ *    operand classes.
+ *
+ *    <p> The precedence of character-class operators is as follows, from
+ *    highest to lowest:
+ *
+ *    <blockquote><table border="0" cellpadding="1" cellspacing="0"
+ *                 summary="Precedence of character class operators.">
+ *      <tr><th>1&nbsp;&nbsp;&nbsp;&nbsp;</th>
+ *        <td>Literal escape&nbsp;&nbsp;&nbsp;&nbsp;</td>
+ *        <td><tt>\x</tt></td></tr>
+ *     <tr><th>2&nbsp;&nbsp;&nbsp;&nbsp;</th>
+ *        <td>Grouping</td>
+ *        <td><tt>[...]</tt></td></tr>
+ *     <tr><th>3&nbsp;&nbsp;&nbsp;&nbsp;</th>
+ *        <td>Range</td>
+ *        <td><tt>a-z</tt></td></tr>
+ *      <tr><th>4&nbsp;&nbsp;&nbsp;&nbsp;</th>
+ *        <td>Union</td>
+ *        <td><tt>[a-e][i-u]</tt></td></tr>
+ *      <tr><th>5&nbsp;&nbsp;&nbsp;&nbsp;</th>
+ *        <td>Intersection</td>
+ *        <td><tt>[a-z&&[aeiou]]</tt></td></tr>
+ *    </table></blockquote>
+ *
+ *    <p> Note that a different set of metacharacters are in effect inside
+ *    a character class than outside a character class. For instance, the
+ *    regular expression <tt>.</tt> loses its special meaning inside a
+ *    character class, while the expression <tt>-</tt> becomes a range
+ *    forming metacharacter.
+ *
+ * <a name="lt">
+ * <h4> Line terminators </h4>
+ *
+ * <p> A <i>line terminator</i> is a one- or two-character sequence that marks
+ * the end of a line of the input character sequence.  The following are
+ * recognized as line terminators:
+ *
+ * <ul>
+ *
+ *   <li> A newline (line feed) character&nbsp;(<tt>'\n'</tt>),
+ *
+ *   <li> A carriage-return character followed immediately by a newline
+ *   character&nbsp;(<tt>"\r\n"</tt>),
+ *
+ *   <li> A standalone carriage-return character&nbsp;(<tt>'\r'</tt>),
+ *
+ *   <li> A next-line character&nbsp;(<tt>'&#92;u0085'</tt>),
+ *
+ *   <li> A line-separator character&nbsp;(<tt>'&#92;u2028'</tt>), or
+ *
+ *   <li> A paragraph-separator character&nbsp;(<tt>'&#92;u2029</tt>).
+ *
+ * </ul>
+ * <p>If {@link #UNIX_LINES} mode is activated, then the only line terminators
+ * recognized are newline characters.
+ *
+ * <p> The regular expression <tt>.</tt> matches any character except a line
+ * terminator unless the {@link #DOTALL} flag is specified.
+ *
+ * <p> By default, the regular expressions <tt>^</tt> and <tt>$</tt> ignore
+ * line terminators and only match at the beginning and the end, respectively,
+ * of the entire input sequence. If {@link #MULTILINE} mode is activated then
+ * <tt>^</tt> matches at the beginning of input and after any line terminator
+ * except at the end of input. When in {@link #MULTILINE} mode <tt>$</tt>
+ * matches just before a line terminator or the end of the input sequence.
+ *
+ * <a name="cg">
+ * <h4> Groups and capturing </h4>
+ *
+ * <p> Capturing groups are numbered by counting their opening parentheses from
+ * left to right.  In the expression <tt>((A)(B(C)))</tt>, for example, there
+ * are four such groups: </p>
+ *
+ * <blockquote><table cellpadding=1 cellspacing=0 summary="Capturing group numberings">
+ * <tr><th>1&nbsp;&nbsp;&nbsp;&nbsp;</th>
+ *     <td><tt>((A)(B(C)))</tt></td></tr>
+ * <tr><th>2&nbsp;&nbsp;&nbsp;&nbsp;</th>
+ *     <td><tt>(A)</tt></td></tr>
+ * <tr><th>3&nbsp;&nbsp;&nbsp;&nbsp;</th>
+ *     <td><tt>(B(C))</tt></td></tr>
+ * <tr><th>4&nbsp;&nbsp;&nbsp;&nbsp;</th>
+ *     <td><tt>(C)</tt></td></tr>
+ * </table></blockquote>
+ *
+ * <p> Group zero always stands for the entire expression.
+ *
+ * <p> Capturing groups are so named because, during a match, each subsequence
+ * of the input sequence that matches such a group is saved.  The captured
+ * subsequence may be used later in the expression, via a back reference, and
+ * may also be retrieved from the matcher once the match operation is complete.
+ *
+ * <p> The captured input associated with a group is always the subsequence
+ * that the group most recently matched.  If a group is evaluated a second time
+ * because of quantification then its previously-captured value, if any, will
+ * be retained if the second evaluation fails.  Matching the string
+ * <tt>"aba"</tt> against the expression <tt>(a(b)?)+</tt>, for example, leaves
+ * group two set to <tt>"b"</tt>.  All captured input is discarded at the
+ * beginning of each match.
+ *
+ * <p> Groups beginning with <tt>(?</tt> are pure, <i>non-capturing</i> groups
+ * that do not capture text and do not count towards the group total.
+ *
+ *
+ * <h4> Unicode support </h4>
+ *
+ * <p> This class is in conformance with Level 1 of <a
+ * href="http://www.unicode.org/reports/tr18/"><i>Unicode Technical
+ * Standard #18: Unicode Regular Expression Guidelines</i></a>, plus RL2.1
+ * Canonical Equivalents.
+ *
+ * <p> Unicode escape sequences such as <tt>&#92;u2014</tt> in Java source code
+ * are processed as described in <a
+ * href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#100850">\u00A73.3</a>
+ * of the Java Language Specification.  Such escape sequences are also
+ * implemented directly by the regular-expression parser so that Unicode
+ * escapes can be used in expressions that are read from files or from the
+ * keyboard.  Thus the strings <tt>"&#92;u2014"</tt> and <tt>"\\u2014"</tt>,
+ * while not equal, compile into the same pattern, which matches the character
+ * with hexadecimal value <tt>0x2014</tt>.
+ *
+ * <a name="ubc"> <p>Unicode blocks and categories are written with the
+ * <tt>\p</tt> and <tt>\P</tt> constructs as in
+ * Perl. <tt>\p{</tt><i>prop</i><tt>}</tt> matches if the input has the
+ * property <i>prop</i>, while <tt>\P{</tt><i>prop</i><tt>}</tt> does not match if
+ * the input has that property.  Blocks are specified with the prefix
+ * <tt>In</tt>, as in <tt>InMongolian</tt>.  Categories may be specified with
+ * the optional prefix <tt>Is</tt>: Both <tt>\p{L}</tt> and <tt>\p{IsL}</tt>
+ * denote the category of Unicode letters.  Blocks and categories can be used
+ * both inside and outside of a character class.
+ *
+ * <p> The supported categories are those of
+ * <a href="http://www.unicode.org/unicode/standard/standard.html">
+ * <i>The Unicode Standard</i></a> in the version specified by the
+ * {@link java.lang.Character Character} class. The category names are those
+ * defined in the Standard, both normative and informative.
+ * The block names supported by <code>Pattern</code> are the valid block names
+ * accepted and defined by
+ * {@link java.lang.Character.UnicodeBlock#forName(String) UnicodeBlock.forName}.
+ *
+ * <a name="jcc"> <p>Categories that behave like the java.lang.Character
+ * boolean is<i>methodname</i> methods (except for the deprecated ones) are
+ * available through the same <tt>\p{</tt><i>prop</i><tt>}</tt> syntax where
+ * the specified property has the name <tt>java<i>methodname</i></tt>.
+ *
+ * <h4> Comparison to Perl 5 </h4>
+ *
+ * <p>The <code>Pattern</code> engine performs traditional NFA-based matching
+ * with ordered alternation as occurs in Perl 5.
+ *
+ * <p> Perl constructs not supported by this class: </p>
+ *
+ * <ul>
+ *
+ *    <li><p> The conditional constructs <tt>(?{</tt><i>X</i><tt>})</tt> and
+ *    <tt>(?(</tt><i>condition</i><tt>)</tt><i>X</i><tt>|</tt><i>Y</i><tt>)</tt>,
+ *    </p></li>
+ *
+ *    <li><p> The embedded code constructs <tt>(?{</tt><i>code</i><tt>})</tt>
+ *    and <tt>(??{</tt><i>code</i><tt>})</tt>,</p></li>
+ *
+ *    <li><p> The embedded comment syntax <tt>(?#comment)</tt>, and </p></li>
+ *
+ *    <li><p> The preprocessing operations <tt>\l</tt> <tt>&#92;u</tt>,
+ *    <tt>\L</tt>, and <tt>\U</tt>.  </p></li>
+ *
+ * </ul>
+ *
+ * <p> Constructs supported by this class but not by Perl: </p>
+ *
+ * <ul>
+ *
+ *    <li><p> Possessive quantifiers, which greedily match as much as they can
+ *    and do not back off, even when doing so would allow the overall match to
+ *    succeed.  </p></li>
+ *
+ *    <li><p> Character-class union and intersection as described
+ *    <a href="#cc">above</a>.</p></li>
+ *
+ * </ul>
+ *
+ * <p> Notable differences from Perl: </p>
+ *
+ * <ul>
+ *
+ *    <li><p> In Perl, <tt>\1</tt> through <tt>\9</tt> are always interpreted
+ *    as back references; a backslash-escaped number greater than <tt>9</tt> is
+ *    treated as a back reference if at least that many subexpressions exist,
+ *    otherwise it is interpreted, if possible, as an octal escape.  In this
+ *    class octal escapes must always begin with a zero. In this class,
+ *    <tt>\1</tt> through <tt>\9</tt> are always interpreted as back
+ *    references, and a larger number is accepted as a back reference if at
+ *    least that many subexpressions exist at that point in the regular
+ *    expression, otherwise the parser will drop digits until the number is
+ *    smaller or equal to the existing number of groups or it is one digit.
+ *    </p></li>
+ *
+ *    <li><p> Perl uses the <tt>g</tt> flag to request a match that resumes
+ *    where the last match left off.  This functionality is provided implicitly
+ *    by the {@link Matcher} class: Repeated invocations of the {@link
+ *    Matcher#find find} method will resume where the last match left off,
+ *    unless the matcher is reset.  </p></li>
+ *
+ *    <li><p> In Perl, embedded flags at the top level of an expression affect
+ *    the whole expression.  In this class, embedded flags always take effect
+ *    at the point at which they appear, whether they are at the top level or
+ *    within a group; in the latter case, flags are restored at the end of the
+ *    group just as in Perl.  </p></li>
+ *
+ *    <li><p> Perl is forgiving about malformed matching constructs, as in the
+ *    expression <tt>*a</tt>, as well as dangling brackets, as in the
+ *    expression <tt>abc]</tt>, and treats them as literals.  This
+ *    class also accepts dangling brackets but is strict about dangling
+ *    metacharacters like +, ? and *, and will throw a
+ *    {@link PatternSyntaxException} if it encounters them. </p></li>
+ *
+ * </ul>
+ *
+ *
+ * <p> For a more precise description of the behavior of regular expression
+ * constructs, please see <a href="http://www.oreilly.com/catalog/regex3/">
+ * <i>Mastering Regular Expressions, 3nd Edition</i>, Jeffrey E. F. Friedl,
+ * O'Reilly and Associates, 2006.</a>
+ * </p>
+ *
+ * @see java.lang.String#split(String, int)
+ * @see java.lang.String#split(String)
+ *
+ * @author      Mike McCloskey
+ * @author      Mark Reinhold
+ * @author      JSR-51 Expert Group
+ * @since       1.4
+ * @spec        JSR-51
+ */
+
+public final class Pattern
+    implements java.io.Serializable
+{
+
+    /**
+     * Regular expression modifier values.  Instead of being passed as
+     * arguments, they can also be passed as inline modifiers.
+     * For example, the following statements have the same effect.
+     * <pre>
+     * RegExp r1 = RegExp.compile("abc", Pattern.I|Pattern.M);
+     * RegExp r2 = RegExp.compile("(?im)abc", 0);
+     * </pre>
+     *
+     * The flags are duplicated so that the familiar Perl match flag
+     * names are available.
+     */
+
+    /**
+     * Enables Unix lines mode.
+     *
+     * <p> In this mode, only the <tt>'\n'</tt> line terminator is recognized
+     * in the behavior of <tt>.</tt>, <tt>^</tt>, and <tt>$</tt>.
+     *
+     * <p> Unix lines mode can also be enabled via the embedded flag
+     * expression&nbsp;<tt>(?d)</tt>.
+     */
+    public static final int UNIX_LINES = 0x01;
+
+    /**
+     * Enables case-insensitive matching.
+     *
+     * <p> By default, case-insensitive matching assumes that only characters
+     * in the US-ASCII charset are being matched.  Unicode-aware
+     * case-insensitive matching can be enabled by specifying the {@link
+     * #UNICODE_CASE} flag in conjunction with this flag.
+     *
+     * <p> Case-insensitive matching can also be enabled via the embedded flag
+     * expression&nbsp;<tt>(?i)</tt>.
+     *
+     * <p> Specifying this flag may impose a slight performance penalty.  </p>
+     */
+    public static final int CASE_INSENSITIVE = 0x02;
+
+    /**
+     * Permits whitespace and comments in pattern.
+     *
+     * <p> In this mode, whitespace is ignored, and embedded comments starting
+     * with <tt>#</tt> are ignored until the end of a line.
+     *
+     * <p> Comments mode can also be enabled via the embedded flag
+     * expression&nbsp;<tt>(?x)</tt>.
+     */
+    public static final int COMMENTS = 0x04;
+
+    /**
+     * Enables multiline mode.
+     *
+     * <p> In multiline mode the expressions <tt>^</tt> and <tt>$</tt> match
+     * just after or just before, respectively, a line terminator or the end of
+     * the input sequence.  By default these expressions only match at the
+     * beginning and the end of the entire input sequence.
+     *
+     * <p> Multiline mode can also be enabled via the embedded flag
+     * expression&nbsp;<tt>(?m)</tt>.  </p>
+     */
+    public static final int MULTILINE = 0x08;
+
+    /**
+     * Enables literal parsing of the pattern.
+     *
+     * <p> When this flag is specified then the input string that specifies
+     * the pattern is treated as a sequence of literal characters.
+     * Metacharacters or escape sequences in the input sequence will be
+     * given no special meaning.
+     *
+     * <p>The flags CASE_INSENSITIVE and UNICODE_CASE retain their impact on
+     * matching when used in conjunction with this flag. The other flags
+     * become superfluous.
+     *
+     * <p> There is no embedded flag character for enabling literal parsing.
+     * @since 1.5
+     */
+    public static final int LITERAL = 0x10;
+
+    /**
+     * Enables dotall mode.
+     *
+     * <p> In dotall mode, the expression <tt>.</tt> matches any character,
+     * including a line terminator.  By default this expression does not match
+     * line terminators.
+     *
+     * <p> Dotall mode can also be enabled via the embedded flag
+     * expression&nbsp;<tt>(?s)</tt>.  (The <tt>s</tt> is a mnemonic for
+     * "single-line" mode, which is what this is called in Perl.)  </p>
+     */
+    public static final int DOTALL = 0x20;
+
+    /**
+     * Enables Unicode-aware case folding.
+     *
+     * <p> When this flag is specified then case-insensitive matching, when
+     * enabled by the {@link #CASE_INSENSITIVE} flag, is done in a manner
+     * consistent with the Unicode Standard.  By default, case-insensitive
+     * matching assumes that only characters in the US-ASCII charset are being
+     * matched.
+     *
+     * <p> Unicode-aware case folding can also be enabled via the embedded flag
+     * expression&nbsp;<tt>(?u)</tt>.
+     *
+     * <p> Specifying this flag may impose a performance penalty.  </p>
+     */
+    public static final int UNICODE_CASE = 0x40;
+
+    /**
+     * Enables canonical equivalence.
+     *
+     * <p> When this flag is specified then two characters will be considered
+     * to match if, and only if, their full canonical decompositions match.
+     * The expression <tt>"a&#92;u030A"</tt>, for example, will match the
+     * string <tt>"&#92;u00E5"</tt> when this flag is specified.  By default,
+     * matching does not take canonical equivalence into account.
+     *
+     * <p> There is no embedded flag character for enabling canonical
+     * equivalence.
+     *
+     * <p> Specifying this flag may impose a performance penalty.  </p>
+     */
+    public static final int CANON_EQ = 0x80;
+
+    /* Pattern has only two serialized components: The pattern string
+     * and the flags, which are all that is needed to recompile the pattern
+     * when it is deserialized.
+     */
+
+    /** use serialVersionUID from Merlin b59 for interoperability */
+    private static final long serialVersionUID = 5073258162644648461L;
+
+    /**
+     * The original regular-expression pattern string.
+     *
+     * @serial
+     */
+    private String pattern;
+
+    /**
+     * The original pattern flags.
+     *
+     * @serial
+     */
+    private int flags;
+
+    /**
+     * Boolean indicating this Pattern is compiled; this is necessary in order
+     * to lazily compile deserialized Patterns.
+     */
+    private transient volatile boolean compiled = false;
+
+    /**
+     * The normalized pattern string.
+     */
+    private transient String normalizedPattern;
+
+    /**
+     * The starting point of state machine for the find operation.  This allows
+     * a match to start anywhere in the input.
+     */
+    transient Node root;
+
+    /**
+     * The root of object tree for a match operation.  The pattern is matched
+     * at the beginning.  This may include a find that uses BnM or a First
+     * node.
+     */
+    transient Node matchRoot;
+
+    /**
+     * Temporary storage used by parsing pattern slice.
+     */
+    transient int[] buffer;
+
+    /**
+     * Temporary storage used while parsing group references.
+     */
+    transient GroupHead[] groupNodes;
+
+    /**
+     * Temporary null terminated code point array used by pattern compiling.
+     */
+    private transient int[] temp;
+
+    /**
+     * The number of capturing groups in this Pattern. Used by matchers to
+     * allocate storage needed to perform a match.
+     */
+    transient int capturingGroupCount;
+
+    /**
+     * The local variable count used by parsing tree. Used by matchers to
+     * allocate storage needed to perform a match.
+     */
+    transient int localCount;
+
+    /**
+     * Index into the pattern string that keeps track of how much has been
+     * parsed.
+     */
+    private transient int cursor;
+
+    /**
+     * Holds the length of the pattern string.
+     */
+    private transient int patternLength;
+
+    /**
+     * Compiles the given regular expression into a pattern.  </p>
+     *
+     * @param  regex
+     *         The expression to be compiled
+     *
+     * @throws  PatternSyntaxException
+     *          If the expression's syntax is invalid
+     */
+    public static Pattern compile(String regex) {
+        return new Pattern(regex, 0);
+    }
+
+    /**
+     * Compiles the given regular expression into a pattern with the given
+     * flags.  </p>
+     *
+     * @param  regex
+     *         The expression to be compiled
+     *
+     * @param  flags
+     *         Match flags, a bit mask that may include
+     *         {@link #CASE_INSENSITIVE}, {@link #MULTILINE}, {@link #DOTALL},
+     *         {@link #UNICODE_CASE}, {@link #CANON_EQ}, {@link #UNIX_LINES},
+     *         {@link #LITERAL} and {@link #COMMENTS}
+     *
+     * @throws  IllegalArgumentException
+     *          If bit values other than those corresponding to the defined
+     *          match flags are set in <tt>flags</tt>
+     *
+     * @throws  PatternSyntaxException
+     *          If the expression's syntax is invalid
+     */
+    public static Pattern compile(String regex, int flags) {
+        return new Pattern(regex, flags);
+    }
+
+    /**
+     * Returns the regular expression from which this pattern was compiled.
+     * </p>
+     *
+     * @return  The source of this pattern
+     */
+    public String pattern() {
+        return pattern;
+    }
+
+    /**
+     * <p>Returns the string representation of this pattern. This
+     * is the regular expression from which this pattern was
+     * compiled.</p>
+     *
+     * @return  The string representation of this pattern
+     * @since 1.5
+     */
+    public String toString() {
+        return pattern;
+    }
+
+    /**
+     * Creates a matcher that will match the given input against this pattern.
+     * </p>
+     *
+     * @param  input
+     *         The character sequence to be matched
+     *
+     * @return  A new matcher for this pattern
+     */
+    public Matcher matcher(CharSequence input) {
+        if (!compiled) {
+            synchronized(this) {
+                if (!compiled)
+                    compile();
+            }
+        }
+        Matcher m = new Matcher(this, input);
+        return m;
+    }
+
+    /**
+     * Returns this pattern's match flags.  </p>
+     *
+     * @return  The match flags specified when this pattern was compiled
+     */
+    public int flags() {
+        return flags;
+    }
+
+    /**
+     * Compiles the given regular expression and attempts to match the given
+     * input against it.
+     *
+     * <p> An invocation of this convenience method of the form
+     *
+     * <blockquote><pre>
+     * Pattern.matches(regex, input);</pre></blockquote>
+     *
+     * behaves in exactly the same way as the expression
+     *
+     * <blockquote><pre>
+     * Pattern.compile(regex).matcher(input).matches()</pre></blockquote>
+     *
+     * <p> If a pattern is to be used multiple times, compiling it once and reusing
+     * it will be more efficient than invoking this method each time.  </p>
+     *
+     * @param  regex
+     *         The expression to be compiled
+     *
+     * @param  input
+     *         The character sequence to be matched
+     *
+     * @throws  PatternSyntaxException
+     *          If the expression's syntax is invalid
+     */
+    public static boolean matches(String regex, CharSequence input) {
+        Pattern p = Pattern.compile(regex);
+        Matcher m = p.matcher(input);
+        return m.matches();
+    }
+
+    /**
+     * Splits the given input sequence around matches of this pattern.
+     *
+     * <p> The array returned by this method contains each substring of the
+     * input sequence that is terminated by another subsequence that matches
+     * this pattern or is terminated by the end of the input sequence.  The
+     * substrings in the array are in the order in which they occur in the
+     * input.  If this pattern does not match any subsequence of the input then
+     * the resulting array has just one element, namely the input sequence in
+     * string form.
+     *
+     * <p> The <tt>limit</tt> parameter controls the number of times the
+     * pattern is applied and therefore affects the length of the resulting
+     * array.  If the limit <i>n</i> is greater than zero then the pattern
+     * will be applied at most <i>n</i>&nbsp;-&nbsp;1 times, the array's
+     * length will be no greater than <i>n</i>, and the array's last entry
+     * will contain all input beyond the last matched delimiter.  If <i>n</i>
+     * is non-positive then the pattern will be applied as many times as
+     * possible and the array can have any length.  If <i>n</i> is zero then
+     * the pattern will be applied as many times as possible, the array can
+     * have any length, and trailing empty strings will be discarded.
+     *
+     * <p> The input <tt>"boo:and:foo"</tt>, for example, yields the following
+     * results with these parameters:
+     *
+     * <blockquote><table cellpadding=1 cellspacing=0
+     *              summary="Split examples showing regex, limit, and result">
+     * <tr><th><P align="left"><i>Regex&nbsp;&nbsp;&nbsp;&nbsp;</i></th>
+     *     <th><P align="left"><i>Limit&nbsp;&nbsp;&nbsp;&nbsp;</i></th>
+     *     <th><P align="left"><i>Result&nbsp;&nbsp;&nbsp;&nbsp;</i></th></tr>
+     * <tr><td align=center>:</td>
+     *     <td align=center>2</td>
+     *     <td><tt>{ "boo", "and:foo" }</tt></td></tr>
+     * <tr><td align=center>:</td>
+     *     <td align=center>5</td>
+     *     <td><tt>{ "boo", "and", "foo" }</tt></td></tr>
+     * <tr><td align=center>:</td>
+     *     <td align=center>-2</td>
+     *     <td><tt>{ "boo", "and", "foo" }</tt></td></tr>
+     * <tr><td align=center>o</td>
+     *     <td align=center>5</td>
+     *     <td><tt>{ "b", "", ":and:f", "", "" }</tt></td></tr>
+     * <tr><td align=center>o</td>
+     *     <td align=center>-2</td>
+     *     <td><tt>{ "b", "", ":and:f", "", "" }</tt></td></tr>
+     * <tr><td align=center>o</td>
+     *     <td align=center>0</td>
+     *     <td><tt>{ "b", "", ":and:f" }</tt></td></tr>
+     * </table></blockquote>
+     *
+     *
+     * @param  input
+     *         The character sequence to be split
+     *
+     * @param  limit
+     *         The result threshold, as described above
+     *
+     * @return  The array of strings computed by splitting the input
+     *          around matches of this pattern
+     */
+    public String[] split(CharSequence input, int limit) {
+        int index = 0;
+        boolean matchLimited = limit > 0;
+        ArrayList<String> matchList = new ArrayList<String>();
+        Matcher m = matcher(input);
+
+        // Add segments before each match found
+        while(m.find()) {
+            if (!matchLimited || matchList.size() < limit - 1) {
+                String match = input.subSequence(index, m.start()).toString();
+                matchList.add(match);
+                index = m.end();
+            } else if (matchList.size() == limit - 1) { // last one
+                String match = input.subSequence(index,
+                                                 input.length()).toString();
+                matchList.add(match);
+                index = m.end();
+            }
+        }
+
+        // If no match was found, return this
+        if (index == 0)
+            return new String[] {input.toString()};
+
+        // Add remaining segment
+        if (!matchLimited || matchList.size() < limit)
+            matchList.add(input.subSequence(index, input.length()).toString());
+
+        // Construct result
+        int resultSize = matchList.size();
+        if (limit == 0)
+            while (resultSize > 0 && matchList.get(resultSize-1).equals(""))
+                resultSize--;
+        String[] result = new String[resultSize];
+        return matchList.subList(0, resultSize).toArray(result);
+    }
+
+    /**
+     * Splits the given input sequence around matches of this pattern.
+     *
+     * <p> This method works as if by invoking the two-argument {@link
+     * #split(java.lang.CharSequence, int) split} method with the given input
+     * sequence and a limit argument of zero.  Trailing empty strings are
+     * therefore not included in the resulting array. </p>
+     *
+     * <p> The input <tt>"boo:and:foo"</tt>, for example, yields the following
+     * results with these expressions:
+     *
+     * <blockquote><table cellpadding=1 cellspacing=0
+     *              summary="Split examples showing regex and result">
+     * <tr><th><P align="left"><i>Regex&nbsp;&nbsp;&nbsp;&nbsp;</i></th>
+     *     <th><P align="left"><i>Result</i></th></tr>
+     * <tr><td align=center>:</td>
+     *     <td><tt>{ "boo", "and", "foo" }</tt></td></tr>
+     * <tr><td align=center>o</td>
+     *     <td><tt>{ "b", "", ":and:f" }</tt></td></tr>
+     * </table></blockquote>
+     *
+     *
+     * @param  input
+     *         The character sequence to be split
+     *
+     * @return  The array of strings computed by splitting the input
+     *          around matches of this pattern
+     */
+    public String[] split(CharSequence input) {
+        return split(input, 0);
+    }
+
+    /**
+     * Returns a literal pattern <code>String</code> for the specified
+     * <code>String</code>.
+     *
+     * <p>This method produces a <code>String</code> that can be used to
+     * create a <code>Pattern</code> that would match the string
+     * <code>s</code> as if it were a literal pattern.</p> Metacharacters
+     * or escape sequences in the input sequence will be given no special
+     * meaning.
+     *
+     * @param  s The string to be literalized
+     * @return  A literal string replacement
+     * @since 1.5
+     */
+    public static String quote(String s) {
+        int slashEIndex = s.indexOf("\\E");
+        if (slashEIndex == -1)
+            return "\\Q" + s + "\\E";
+
+        StringBuilder sb = new StringBuilder(s.length() * 2);
+        sb.append("\\Q");
+        slashEIndex = 0;
+        int current = 0;
+        while ((slashEIndex = s.indexOf("\\E", current)) != -1) {
+            sb.append(s.substring(current, slashEIndex));
+            current = slashEIndex + 2;
+            sb.append("\\E\\\\E\\Q");
+        }
+        sb.append(s.substring(current, s.length()));
+        sb.append("\\E");
+        return sb.toString();
+    }
+
+    /**
+     * Recompile the Pattern instance from a stream.  The original pattern
+     * string is read in and the object tree is recompiled from it.
+     */
+    private void readObject(java.io.ObjectInputStream s)
+        throws java.io.IOException, ClassNotFoundException {
+
+        // Read in all fields
+        s.defaultReadObject();
+
+        // Initialize counts
+        capturingGroupCount = 1;
+        localCount = 0;
+
+        // if length > 0, the Pattern is lazily compiled
+        compiled = false;
+        if (pattern.length() == 0) {
+            root = new Start(lastAccept);
+            matchRoot = lastAccept;
+            compiled = true;
+        }
+    }
+
+    /**
+     * This private constructor is used to create all Patterns. The pattern
+     * string and match flags are all that is needed to completely describe
+     * a Pattern. An empty pattern string results in an object tree with
+     * only a Start node and a LastNode node.
+     */
+    private Pattern(String p, int f) {
+        pattern = p;
+        flags = f;
+
+        // Reset group index count
+        capturingGroupCount = 1;
+        localCount = 0;
+
+        if (pattern.length() > 0) {
+            compile();
+        } else {
+            root = new Start(lastAccept);
+            matchRoot = lastAccept;
+        }
+    }
+
+    /**
+     * The pattern is converted to normalizedD form and then a pure group
+     * is constructed to match canonical equivalences of the characters.
+     */
+    private void normalize() {
+        boolean inCharClass = false;
+        int lastCodePoint = -1;
+
+        // Convert pattern into normalizedD form
+        normalizedPattern = Normalizer.normalize(pattern, Normalizer.Form.NFD);
+        patternLength = normalizedPattern.length();
+
+        // Modify pattern to match canonical equivalences
+        StringBuilder newPattern = new StringBuilder(patternLength);
+        for(int i=0; i<patternLength; ) {
+            int c = normalizedPattern.codePointAt(i);
+            StringBuilder sequenceBuffer;
+            if ((Character.getType(c) == Character.NON_SPACING_MARK)
+                && (lastCodePoint != -1)) {
+                sequenceBuffer = new StringBuilder();
+                sequenceBuffer.appendCodePoint(lastCodePoint);
+                sequenceBuffer.appendCodePoint(c);
+                while(Character.getType(c) == Character.NON_SPACING_MARK) {
+                    i += Character.charCount(c);
+                    if (i >= patternLength)
+                        break;
+                    c = normalizedPattern.codePointAt(i);
+                    sequenceBuffer.appendCodePoint(c);
+                }
+                String ea = produceEquivalentAlternation(
+                                               sequenceBuffer.toString());
+                newPattern.setLength(newPattern.length()-Character.charCount(lastCodePoint));
+                newPattern.append("(?:").append(ea).append(")");
+            } else if (c == '[' && lastCodePoint != '\\') {
+                i = normalizeCharClass(newPattern, i);
+            } else {
+                newPattern.appendCodePoint(c);
+            }
+            lastCodePoint = c;
+            i += Character.charCount(c);
+        }
+        normalizedPattern = newPattern.toString();
+    }
+
+    /**
+     * Complete the character class being parsed and add a set
+     * of alternations to it that will match the canonical equivalences
+     * of the characters within the class.
+     */
+    private int normalizeCharClass(StringBuilder newPattern, int i) {
+        StringBuilder charClass = new StringBuilder();
+        StringBuilder eq = null;
+        int lastCodePoint = -1;
+        String result;
+
+        i++;
+        charClass.append("[");
+        while(true) {
+            int c = normalizedPattern.codePointAt(i);
+            StringBuilder sequenceBuffer;
+
+            if (c == ']' && lastCodePoint != '\\') {
+                charClass.append((char)c);
+                break;
+            } else if (Character.getType(c) == Character.NON_SPACING_MARK) {
+                sequenceBuffer = new StringBuilder();
+                sequenceBuffer.appendCodePoint(lastCodePoint);
+                while(Character.getType(c) == Character.NON_SPACING_MARK) {
+                    sequenceBuffer.appendCodePoint(c);
+                    i += Character.charCount(c);
+                    if (i >= normalizedPattern.length())
+                        break;
+                    c = normalizedPattern.codePointAt(i);
+                }
+                String ea = produceEquivalentAlternation(
+                                                  sequenceBuffer.toString());
+
+                charClass.setLength(charClass.length()-Character.charCount(lastCodePoint));
+                if (eq == null)
+                    eq = new StringBuilder();
+                eq.append('|');
+                eq.append(ea);
+            } else {
+                charClass.appendCodePoint(c);
+                i++;
+            }
+            if (i == normalizedPattern.length())
+                throw error("Unclosed character class");
+            lastCodePoint = c;
+        }
+
+        if (eq != null) {
+            result = "(?:"+charClass.toString()+eq.toString()+")";
+        } else {
+            result = charClass.toString();
+        }
+
+        newPattern.append(result);
+        return i;
+    }
+
+    /**
+     * Given a specific sequence composed of a regular character and
+     * combining marks that follow it, produce the alternation that will
+     * match all canonical equivalences of that sequence.
+     */
+    private String produceEquivalentAlternation(String source) {
+        int len = countChars(source, 0, 1);
+        if (source.length() == len)
+            // source has one character.
+            return source;
+
+        String base = source.substring(0,len);
+        String combiningMarks = source.substring(len);
+
+        String[] perms = producePermutations(combiningMarks);
+        StringBuilder result = new StringBuilder(source);
+
+        // Add combined permutations
+        for(int x=0; x<perms.length; x++) {
+            String next = base + perms[x];
+            if (x>0)
+                result.append("|"+next);
+            next = composeOneStep(next);
+            if (next != null)
+                result.append("|"+produceEquivalentAlternation(next));
+        }
+        return result.toString();
+    }
+
+    /**
+     * Returns an array of strings that have all the possible
+     * permutations of the characters in the input string.
+     * This is used to get a list of all possible orderings
+     * of a set of combining marks. Note that some of the permutations
+     * are invalid because of combining class collisions, and these
+     * possibilities must be removed because they are not canonically
+     * equivalent.
+     */
+    private String[] producePermutations(String input) {
+        if (input.length() == countChars(input, 0, 1))
+            return new String[] {input};
+
+        if (input.length() == countChars(input, 0, 2)) {
+            int c0 = Character.codePointAt(input, 0);
+            int c1 = Character.codePointAt(input, Character.charCount(c0));
+            if (getClass(c1) == getClass(c0)) {
+                return new String[] {input};
+            }
+            String[] result = new String[2];
+            result[0] = input;
+            StringBuilder sb = new StringBuilder(2);
+            sb.appendCodePoint(c1);
+            sb.appendCodePoint(c0);
+            result[1] = sb.toString();
+            return result;
+        }
+
+        int length = 1;
+        int nCodePoints = countCodePoints(input);
+        for(int x=1; x<nCodePoints; x++)
+            length = length * (x+1);
+
+        String[] temp = new String[length];
+
+        int combClass[] = new int[nCodePoints];
+        for(int x=0, i=0; x<nCodePoints; x++) {
+            int c = Character.codePointAt(input, i);
+            combClass[x] = getClass(c);
+            i +=  Character.charCount(c);
+        }
+
+        // For each char, take it out and add the permutations
+        // of the remaining chars
+        int index = 0;
+        int len;
+        // offset maintains the index in code units.
+loop:   for(int x=0, offset=0; x<nCodePoints; x++, offset+=len) {
+            len = countChars(input, offset, 1);
+            boolean skip = false;
+            for(int y=x-1; y>=0; y--) {
+                if (combClass[y] == combClass[x]) {
+                    continue loop;
+                }
+            }
+            StringBuilder sb = new StringBuilder(input);
+            String otherChars = sb.delete(offset, offset+len).toString();
+            String[] subResult = producePermutations(otherChars);
+
+            String prefix = input.substring(offset, offset+len);
+            for(int y=0; y<subResult.length; y++)
+                temp[index++] =  prefix + subResult[y];
+        }
+        String[] result = new String[index];
+        for (int x=0; x<index; x++)
+            result[x] = temp[x];
+        return result;
+    }
+
+    private int getClass(int c) {
+        return sun.text.Normalizer.getCombiningClass(c);
+    }
+
+    /**
+     * Attempts to compose input by combining the first character
+     * with the first combining mark following it. Returns a String
+     * that is the composition of the leading character with its first
+     * combining mark followed by the remaining combining marks. Returns
+     * null if the first two characters cannot be further composed.
+     */
+    private String composeOneStep(String input) {
+        int len = countChars(input, 0, 2);
+        String firstTwoCharacters = input.substring(0, len);
+        String result = Normalizer.normalize(firstTwoCharacters, Normalizer.Form.NFC);
+
+        if (result.equals(firstTwoCharacters))
+            return null;
+        else {
+            String remainder = input.substring(len);
+            return result + remainder;
+        }
+    }
+
+    /**
+     * Preprocess any \Q...\E sequences in `temp', meta-quoting them.
+     * See the description of `quotemeta' in perlfunc(1).
+     */
+    private void RemoveQEQuoting() {
+        final int pLen = patternLength;
+        int i = 0;
+        while (i < pLen-1) {
+            if (temp[i] != '\\')
+                i += 1;
+            else if (temp[i + 1] != 'Q')
+                i += 2;
+            else
+                break;
+        }
+        if (i >= pLen - 1)    // No \Q sequence found
+            return;
+        int j = i;
+        i += 2;
+        int[] newtemp = new int[j + 2*(pLen-i) + 2];
+        System.arraycopy(temp, 0, newtemp, 0, j);
+
+        boolean inQuote = true;
+        while (i < pLen) {
+            int c = temp[i++];
+            if (! ASCII.isAscii(c) || ASCII.isAlnum(c)) {
+                newtemp[j++] = c;
+            } else if (c != '\\') {
+                if (inQuote) newtemp[j++] = '\\';
+                newtemp[j++] = c;
+            } else if (inQuote) {
+                if (temp[i] == 'E') {
+                    i++;
+                    inQuote = false;
+                } else {
+                    newtemp[j++] = '\\';
+                    newtemp[j++] = '\\';
+                }
+            } else {
+                if (temp[i] == 'Q') {
+                    i++;
+                    inQuote = true;
+                } else {
+                    newtemp[j++] = c;
+                    if (i != pLen)
+                        newtemp[j++] = temp[i++];
+                }
+            }
+        }
+
+        patternLength = j;
+        temp = Arrays.copyOf(newtemp, j + 2); // double zero termination
+    }
+
+    /**
+     * Copies regular expression to an int array and invokes the parsing
+     * of the expression which will create the object tree.
+     */
+    private void compile() {
+        // Handle canonical equivalences
+        if (has(CANON_EQ) && !has(LITERAL)) {
+            normalize();
+        } else {
+            normalizedPattern = pattern;
+        }
+        patternLength = normalizedPattern.length();
+
+        // Copy pattern to int array for convenience
+        // Use double zero to terminate pattern
+        temp = new int[patternLength + 2];
+
+        boolean hasSupplementary = false;
+        int c, count = 0;
+        // Convert all chars into code points
+        for (int x = 0; x < patternLength; x += Character.charCount(c)) {
+            c = normalizedPattern.codePointAt(x);
+            if (isSupplementary(c)) {
+                hasSupplementary = true;
+            }
+            temp[count++] = c;
+        }
+
+        patternLength = count;   // patternLength now in code points
+
+        if (! has(LITERAL))
+            RemoveQEQuoting();
+
+        // Allocate all temporary objects here.
+        buffer = new int[32];
+        groupNodes = new GroupHead[10];
+
+        if (has(LITERAL)) {
+            // Literal pattern handling
+            matchRoot = newSlice(temp, patternLength, hasSupplementary);
+            matchRoot.next = lastAccept;
+        } else {
+            // Start recursive descent parsing
+            matchRoot = expr(lastAccept);
+            // Check extra pattern characters
+            if (patternLength != cursor) {
+                if (peek() == ')') {
+                    throw error("Unmatched closing ')'");
+                } else {
+                    throw error("Unexpected internal error");
+                }
+            }
+        }
+
+        // Peephole optimization
+        if (matchRoot instanceof Slice) {
+            root = BnM.optimize(matchRoot);
+            if (root == matchRoot) {
+                root = hasSupplementary ? new StartS(matchRoot) : new Start(matchRoot);
+            }
+        } else if (matchRoot instanceof Begin || matchRoot instanceof First) {
+            root = matchRoot;
+        } else {
+            root = hasSupplementary ? new StartS(matchRoot) : new Start(matchRoot);
+        }
+
+        // Release temporary storage
+        temp = null;
+        buffer = null;
+        groupNodes = null;
+        patternLength = 0;
+        compiled = true;
+    }
+
+    /**
+     * Used to print out a subtree of the Pattern to help with debugging.
+     */
+    private static void printObjectTree(Node node) {
+        while(node != null) {
+            if (node instanceof Prolog) {
+                System.out.println(node);
+                printObjectTree(((Prolog)node).loop);
+                System.out.println("**** end contents prolog loop");
+            } else if (node instanceof Loop) {
+                System.out.println(node);
+                printObjectTree(((Loop)node).body);
+                System.out.println("**** end contents Loop body");
+            } else if (node instanceof Curly) {
+                System.out.println(node);
+                printObjectTree(((Curly)node).atom);
+                System.out.println("**** end contents Curly body");
+            } else if (node instanceof GroupCurly) {
+                System.out.println(node);
+                printObjectTree(((GroupCurly)node).atom);
+                System.out.println("**** end contents GroupCurly body");
+            } else if (node instanceof GroupTail) {
+                System.out.println(node);
+                System.out.println("Tail next is "+node.next);
+                return;
+            } else {
+                System.out.println(node);
+            }
+            node = node.next;
+            if (node != null)
+                System.out.println("->next:");
+            if (node == Pattern.accept) {
+                System.out.println("Accept Node");
+                node = null;
+            }
+       }
+    }
+
+    /**
+     * Used to accumulate information about a subtree of the object graph
+     * so that optimizations can be applied to the subtree.
+     */
+    static final class TreeInfo {
+        int minLength;
+        int maxLength;
+        boolean maxValid;
+        boolean deterministic;
+
+        TreeInfo() {
+            reset();
+        }
+        void reset() {
+            minLength = 0;
+            maxLength = 0;
+            maxValid = true;
+            deterministic = true;
+        }
+    }
+
+    /*
+     * The following private methods are mainly used to improve the
+     * readability of the code. In order to let the Java compiler easily
+     * inline them, we should not put many assertions or error checks in them.
+     */
+
+    /**
+     * Indicates whether a particular flag is set or not.
+     */
+    private boolean has(int f) {
+        return (flags & f) != 0;
+    }
+
+    /**
+     * Match next character, signal error if failed.
+     */
+    private void accept(int ch, String s) {
+        int testChar = temp[cursor++];
+        if (has(COMMENTS))
+            testChar = parsePastWhitespace(testChar);
+        if (ch != testChar) {
+            throw error(s);
+        }
+    }
+
+    /**
+     * Mark the end of pattern with a specific character.
+     */
+    private void mark(int c) {
+        temp[patternLength] = c;
+    }
+
+    /**
+     * Peek the next character, and do not advance the cursor.
+     */
+    private int peek() {
+        int ch = temp[cursor];
+        if (has(COMMENTS))
+            ch = peekPastWhitespace(ch);
+        return ch;
+    }
+
+    /**
+     * Read the next character, and advance the cursor by one.
+     */
+    private int read() {
+        int ch = temp[cursor++];
+        if (has(COMMENTS))
+            ch = parsePastWhitespace(ch);
+        return ch;
+    }
+
+    /**
+     * Read the next character, and advance the cursor by one,
+     * ignoring the COMMENTS setting
+     */
+    private int readEscaped() {
+        int ch = temp[cursor++];
+        return ch;
+    }
+
+    /**
+     * Advance the cursor by one, and peek the next character.
+     */
+    private int next() {
+        int ch = temp[++cursor];
+        if (has(COMMENTS))
+            ch = peekPastWhitespace(ch);
+        return ch;
+    }
+
+    /**
+     * Advance the cursor by one, and peek the next character,
+     * ignoring the COMMENTS setting
+     */
+    private int nextEscaped() {
+        int ch = temp[++cursor];
+        return ch;
+    }
+
+    /**
+     * If in xmode peek past whitespace and comments.
+     */
+    private int peekPastWhitespace(int ch) {
+        while (ASCII.isSpace(ch) || ch == '#') {
+            while (ASCII.isSpace(ch))
+                ch = temp[++cursor];
+            if (ch == '#') {
+                ch = peekPastLine();
+            }
+        }
+        return ch;
+    }
+
+    /**
+     * If in xmode parse past whitespace and comments.
+     */
+    private int parsePastWhitespace(int ch) {
+        while (ASCII.isSpace(ch) || ch == '#') {
+            while (ASCII.isSpace(ch))
+                ch = temp[cursor++];
+            if (ch == '#')
+                ch = parsePastLine();
+        }
+        return ch;
+    }
+
+    /**
+     * xmode parse past comment to end of line.
+     */
+    private int parsePastLine() {
+        int ch = temp[cursor++];
+        while (ch != 0 && !isLineSeparator(ch))
+            ch = temp[cursor++];
+        return ch;
+    }
+
+    /**
+     * xmode peek past comment to end of line.
+     */
+    private int peekPastLine() {
+        int ch = temp[++cursor];
+        while (ch != 0 && !isLineSeparator(ch))
+            ch = temp[++cursor];
+        return ch;
+    }
+
+    /**
+     * Determines if character is a line separator in the current mode
+     */
+    private boolean isLineSeparator(int ch) {
+        if (has(UNIX_LINES)) {
+            return ch == '\n';
+        } else {
+            return (ch == '\n' ||
+                    ch == '\r' ||
+                    (ch|1) == '\u2029' ||
+                    ch == '\u0085');
+        }
+    }
+
+    /**
+     * Read the character after the next one, and advance the cursor by two.
+     */
+    private int skip() {
+        int i = cursor;
+        int ch = temp[i+1];
+        cursor = i + 2;
+        return ch;
+    }
+
+    /**
+     * Unread one next character, and retreat cursor by one.
+     */
+    private void unread() {
+        cursor--;
+    }
+
+    /**
+     * Internal method used for handling all syntax errors. The pattern is
+     * displayed with a pointer to aid in locating the syntax error.
+     */
+    private PatternSyntaxException error(String s) {
+        return new PatternSyntaxException(s, normalizedPattern,  cursor - 1);
+    }
+
+    /**
+     * Determines if there is any supplementary character or unpaired
+     * surrogate in the specified range.
+     */
+    private boolean findSupplementary(int start, int end) {
+        for (int i = start; i < end; i++) {
+            if (isSupplementary(temp[i]))
+                return true;
+        }
+        return false;
+    }
+
+    /**
+     * Determines if the specified code point is a supplementary
+     * character or unpaired surrogate.
+     */
+    private static final boolean isSupplementary(int ch) {
+        return ch >= Character.MIN_SUPPLEMENTARY_CODE_POINT || isSurrogate(ch);
+    }
+
+    /**
+     *  The following methods handle the main parsing. They are sorted
+     *  according to their precedence order, the lowest one first.
+     */
+
+    /**
+     * The expression is parsed with branch nodes added for alternations.
+     * This may be called recursively to parse sub expressions that may
+     * contain alternations.
+     */
+    private Node expr(Node end) {
+        Node prev = null;
+        Node firstTail = null;
+        Node branchConn = null;
+
+        for (;;) {
+            Node node = sequence(end);
+            Node nodeTail = root;      //double return
+            if (prev == null) {
+                prev = node;
+                firstTail = nodeTail;
+            } else {
+                // Branch
+                if (branchConn == null) {
+                    branchConn = new BranchConn();
+                    branchConn.next = end;
+                }
+                if (node == end) {
+                    // if the node returned from sequence() is "end"
+                    // we have an empty expr, set a null atom into
+                    // the branch to indicate to go "next" directly.
+                    node = null;
+                } else {
+                    // the "tail.next" of each atom goes to branchConn
+                    nodeTail.next = branchConn;
+                }
+                if (prev instanceof Branch) {
+                    ((Branch)prev).add(node);
+                } else {
+                    if (prev == end) {
+                        prev = null;
+                    } else {
+                        // replace the "end" with "branchConn" at its tail.next
+                        // when put the "prev" into the branch as the first atom.
+                        firstTail.next = branchConn;
+                    }
+                    prev = new Branch(prev, node, branchConn);
+                }
+            }
+            if (peek() != '|') {
+                return prev;
+            }
+            next();
+        }
+    }
+
+    /**
+     * Parsing of sequences between alternations.
+     */
+    private Node sequence(Node end) {
+        Node head = null;
+        Node tail = null;
+        Node node = null;
+    LOOP:
+        for (;;) {
+            int ch = peek();
+            switch (ch) {
+            case '(':
+                // Because group handles its own closure,
+                // we need to treat it differently
+                node = group0();
+                // Check for comment or flag group
+                if (node == null)
+                    continue;
+                if (head == null)
+                    head = node;
+                else
+                    tail.next = node;
+                // Double return: Tail was returned in root
+                tail = root;
+                continue;
+            case '[':
+                node = clazz(true);
+                break;
+            case '\\':
+                ch = nextEscaped();
+                if (ch == 'p' || ch == 'P') {
+                    boolean oneLetter = true;
+                    boolean comp = (ch == 'P');
+                    ch = next(); // Consume { if present
+                    if (ch != '{') {
+                        unread();
+                    } else {
+                        oneLetter = false;
+                    }
+                    node = family(oneLetter).maybeComplement(comp);
+                } else {
+                    unread();
+                    node = atom();
+                }
+                break;
+            case '^':
+                next();
+                if (has(MULTILINE)) {
+                    if (has(UNIX_LINES))
+                        node = new UnixCaret();
+                    else
+                        node = new Caret();
+                } else {
+                    node = new Begin();
+                }
+                break;
+            case '$':
+                next();
+                if (has(UNIX_LINES))
+                    node = new UnixDollar(has(MULTILINE));
+                else
+                    node = new Dollar(has(MULTILINE));
+                break;
+            case '.':
+                next();
+                if (has(DOTALL)) {
+                    node = new All();
+                } else {
+                    if (has(UNIX_LINES))
+                        node = new UnixDot();
+                    else {
+                        node = new Dot();
+                    }
+                }
+                break;
+            case '|':
+            case ')':
+                break LOOP;
+            case ']': // Now interpreting dangling ] and } as literals
+            case '}':
+                node = atom();
+                break;
+            case '?':
+            case '*':
+            case '+':
+                next();
+                throw error("Dangling meta character '" + ((char)ch) + "'");
+            case 0:
+                if (cursor >= patternLength) {
+                    break LOOP;
+                }
+                // Fall through
+            default:
+                node = atom();
+                break;
+            }
+
+            node = closure(node);
+
+            if (head == null) {
+                head = tail = node;
+            } else {
+                tail.next = node;
+                tail = node;
+            }
+        }
+        if (head == null) {
+            return end;
+        }
+        tail.next = end;
+        root = tail;      //double return
+        return head;
+    }
+
+    /**
+     * Parse and add a new Single or Slice.
+     */
+    private Node atom() {
+        int first = 0;
+        int prev = -1;
+        boolean hasSupplementary = false;
+        int ch = peek();
+        for (;;) {
+            switch (ch) {
+            case '*':
+            case '+':
+            case '?':
+            case '{':
+                if (first > 1) {
+                    cursor = prev;    // Unwind one character
+                    first--;
+                }
+                break;
+            case '$':
+            case '.':
+            case '^':
+            case '(':
+            case '[':
+            case '|':
+            case ')':
+                break;
+            case '\\':
+                ch = nextEscaped();
+                if (ch == 'p' || ch == 'P') { // Property
+                    if (first > 0) { // Slice is waiting; handle it first
+                        unread();
+                        break;
+                    } else { // No slice; just return the family node
+                        boolean comp = (ch == 'P');
+                        boolean oneLetter = true;
+                        ch = next(); // Consume { if present
+                        if (ch != '{')
+                            unread();
+                        else
+                            oneLetter = false;
+                        return family(oneLetter).maybeComplement(comp);
+                    }
+                }
+                unread();
+                prev = cursor;
+                ch = escape(false, first == 0);
+                if (ch >= 0) {
+                    append(ch, first);
+                    first++;
+                    if (isSupplementary(ch)) {
+                        hasSupplementary = true;
+                    }
+                    ch = peek();
+                    continue;
+                } else if (first == 0) {
+                    return root;
+                }
+                // Unwind meta escape sequence
+                cursor = prev;
+                break;
+            case 0:
+                if (cursor >= patternLength) {
+                    break;
+                }
+                // Fall through
+            default:
+                prev = cursor;
+                append(ch, first);
+                first++;
+                if (isSupplementary(ch)) {
+                    hasSupplementary = true;
+                }
+                ch = next();
+                continue;
+            }
+            break;
+        }
+        if (first == 1) {
+            return newSingle(buffer[0]);
+        } else {
+            return newSlice(buffer, first, hasSupplementary);
+        }
+    }
+
+    private void append(int ch, int len) {
+        if (len >= buffer.length) {
+            int[] tmp = new int[len+len];
+            System.arraycopy(buffer, 0, tmp, 0, len);
+            buffer = tmp;
+        }
+        buffer[len] = ch;
+    }
+
+    /**
+     * Parses a backref greedily, taking as many numbers as it
+     * can. The first digit is always treated as a backref, but
+     * multi digit numbers are only treated as a backref if at
+     * least that many backrefs exist at this point in the regex.
+     */
+    private Node ref(int refNum) {
+        boolean done = false;
+        while(!done) {
+            int ch = peek();
+            switch(ch) {
+            case '0':
+            case '1':
+            case '2':
+            case '3':
+            case '4':
+            case '5':
+            case '6':
+            case '7':
+            case '8':
+            case '9':
+                int newRefNum = (refNum * 10) + (ch - '0');
+                // Add another number if it doesn't make a group
+                // that doesn't exist
+                if (capturingGroupCount - 1 < newRefNum) {
+                    done = true;
+                    break;
+                }
+                refNum = newRefNum;
+                read();
+                break;
+            default:
+                done = true;
+                break;
+            }
+        }
+        if (has(CASE_INSENSITIVE))
+            return new CIBackRef(refNum, has(UNICODE_CASE));
+        else
+            return new BackRef(refNum);
+    }
+
+    /**
+     * Parses an escape sequence to determine the actual value that needs
+     * to be matched.
+     * If -1 is returned and create was true a new object was added to the tree
+     * to handle the escape sequence.
+     * If the returned value is greater than zero, it is the value that
+     * matches the escape sequence.
+     */
+    private int escape(boolean inclass, boolean create) {
+        int ch = skip();
+        switch (ch) {
+        case '0':
+            return o();
+        case '1':
+        case '2':
+        case '3':
+        case '4':
+        case '5':
+        case '6':
+        case '7':
+        case '8':
+        case '9':
+            if (inclass) break;
+            if (create) {
+                root = ref((ch - '0'));
+            }
+            return -1;
+        case 'A':
+            if (inclass) break;
+            if (create) root = new Begin();
+            return -1;
+        case 'B':
+            if (inclass) break;
+            if (create) root = new Bound(Bound.NONE);
+            return -1;
+        case 'C':
+            break;
+        case 'D':
+            if (create) root = new Ctype(ASCII.DIGIT).complement();
+            return -1;
+        case 'E':
+        case 'F':
+            break;
+        case 'G':
+            if (inclass) break;
+            if (create) root = new LastMatch();
+            return -1;
+        case 'H':
+        case 'I':
+        case 'J':
+        case 'K':
+        case 'L':
+        case 'M':
+        case 'N':
+        case 'O':
+        case 'P':
+        case 'Q':
+        case 'R':
+            break;
+        case 'S':
+            if (create) root = new Ctype(ASCII.SPACE).complement();
+            return -1;
+        case 'T':
+        case 'U':
+        case 'V':
+            break;
+        case 'W':
+            if (create) root = new Ctype(ASCII.WORD).complement();
+            return -1;
+        case 'X':
+        case 'Y':
+            break;
+        case 'Z':
+            if (inclass) break;
+            if (create) {
+                if (has(UNIX_LINES))
+                    root = new UnixDollar(false);
+                else
+                    root = new Dollar(false);
+            }
+            return -1;
+        case 'a':
+            return '\007';
+        case 'b':
+            if (inclass) break;
+            if (create) root = new Bound(Bound.BOTH);
+            return -1;
+        case 'c':
+            return c();
+        case 'd':
+            if (create) root = new Ctype(ASCII.DIGIT);
+            return -1;
+        case 'e':
+            return '\033';
+        case 'f':
+            return '\f';
+        case 'g':
+        case 'h':
+        case 'i':
+        case 'j':
+        case 'k':
+        case 'l':
+        case 'm':
+            break;
+        case 'n':
+            return '\n';
+        case 'o':
+        case 'p':
+        case 'q':
+            break;
+        case 'r':
+            return '\r';
+        case 's':
+            if (create) root = new Ctype(ASCII.SPACE);
+            return -1;
+        case 't':
+            return '\t';
+        case 'u':
+            return u();
+        case 'v':
+            return '\013';
+        case 'w':
+            if (create) root = new Ctype(ASCII.WORD);
+            return -1;
+        case 'x':
+            return x();
+        case 'y':
+            break;
+        case 'z':
+            if (inclass) break;
+            if (create) root = new End();
+            return -1;
+        default:
+            return ch;
+        }
+        throw error("Illegal/unsupported escape sequence");
+    }
+
+    /**
+     * Parse a character class, and return the node that matches it.
+     *
+     * Consumes a ] on the way out if consume is true. Usually consume
+     * is true except for the case of [abc&&def] where def is a separate
+     * right hand node with "understood" brackets.
+     */
+    private CharProperty clazz(boolean consume) {
+        CharProperty prev = null;
+        CharProperty node = null;
+        BitClass bits = new BitClass();
+        boolean include = true;
+        boolean firstInClass = true;
+        int ch = next();
+        for (;;) {
+            switch (ch) {
+                case '^':
+                    // Negates if first char in a class, otherwise literal
+                    if (firstInClass) {
+                        if (temp[cursor-1] != '[')
+                            break;
+                        ch = next();
+                        include = !include;
+                        continue;
+                    } else {
+                        // ^ not first in class, treat as literal
+                        break;
+                    }
+                case '[':
+                    firstInClass = false;
+                    node = clazz(true);
+                    if (prev == null)
+                        prev = node;
+                    else
+                        prev = union(prev, node);
+                    ch = peek();
+                    continue;
+                case '&':
+                    firstInClass = false;
+                    ch = next();
+                    if (ch == '&') {
+                        ch = next();
+                        CharProperty rightNode = null;
+                        while (ch != ']' && ch != '&') {
+                            if (ch == '[') {
+                                if (rightNode == null)
+                                    rightNode = clazz(true);
+                                else
+                                    rightNode = union(rightNode, clazz(true));
+                            } else { // abc&&def
+                                unread();
+                                rightNode = clazz(false);
+                            }
+                            ch = peek();
+                        }
+                        if (rightNode != null)
+                            node = rightNode;
+                        if (prev == null) {
+                            if (rightNode == null)
+                                throw error("Bad class syntax");
+                            else
+                                prev = rightNode;
+                        } else {
+                            prev = intersection(prev, node);
+                        }
+                    } else {
+                        // treat as a literal &
+                        unread();
+                        break;
+                    }
+                    continue;
+                case 0:
+                    firstInClass = false;
+                    if (cursor >= patternLength)
+                        throw error("Unclosed character class");
+                    break;
+                case ']':
+                    firstInClass = false;
+                    if (prev != null) {
+                        if (consume)
+                            next();
+                        return prev;
+                    }
+                    break;
+                default:
+                    firstInClass = false;
+                    break;
+            }
+            node = range(bits);
+            if (include) {
+                if (prev == null) {
+                    prev = node;
+                } else {
+                    if (prev != node)
+                        prev = union(prev, node);
+                }
+            } else {
+                if (prev == null) {
+                    prev = node.complement();
+                } else {
+                    if (prev != node)
+                        prev = setDifference(prev, node);
+                }
+            }
+            ch = peek();
+        }
+    }
+
+    private CharProperty bitsOrSingle(BitClass bits, int ch) {
+        /* Bits can only handle codepoints in [u+0000-u+00ff] range.
+           Use "single" node instead of bits when dealing with unicode
+           case folding for codepoints listed below.
+           (1)Uppercase out of range: u+00ff, u+00b5
+              toUpperCase(u+00ff) -> u+0178
+              toUpperCase(u+00b5) -> u+039c
+           (2)LatinSmallLetterLongS u+17f
+              toUpperCase(u+017f) -> u+0053
+           (3)LatinSmallLetterDotlessI u+131
+              toUpperCase(u+0131) -> u+0049
+           (4)LatinCapitalLetterIWithDotAbove u+0130
+              toLowerCase(u+0130) -> u+0069
+           (5)KelvinSign u+212a
+              toLowerCase(u+212a) ==> u+006B
+           (6)AngstromSign u+212b
+              toLowerCase(u+212b) ==> u+00e5
+        */
+        int d;
+        if (ch < 256 &&
+            !(has(CASE_INSENSITIVE) && has(UNICODE_CASE) &&
+              (ch == 0xff || ch == 0xb5 ||
+               ch == 0x49 || ch == 0x69 ||  //I and i
+               ch == 0x53 || ch == 0x73 ||  //S and s
+               ch == 0x4b || ch == 0x6b ||  //K and k
+               ch == 0xc5 || ch == 0xe5)))  //A+ring
+            return bits.add(ch, flags());
+        return newSingle(ch);
+    }
+
+    /**
+     * Parse a single character or a character range in a character class
+     * and return its representative node.
+     */
+    private CharProperty range(BitClass bits) {
+        int ch = peek();
+        if (ch == '\\') {
+            ch = nextEscaped();
+            if (ch == 'p' || ch == 'P') { // A property
+                boolean comp = (ch == 'P');
+                boolean oneLetter = true;
+                // Consume { if present
+                ch = next();
+                if (ch != '{')
+                    unread();
+                else
+                    oneLetter = false;
+                return family(oneLetter).maybeComplement(comp);
+            } else { // ordinary escape
+                unread();
+                ch = escape(true, true);
+                if (ch == -1)
+                    return (CharProperty) root;
+            }
+        } else {
+            ch = single();
+        }
+        if (ch >= 0) {
+            if (peek() == '-') {
+                int endRange = temp[cursor+1];
+                if (endRange == '[') {
+                    return bitsOrSingle(bits, ch);
+                }
+                if (endRange != ']') {
+                    next();
+                    int m = single();
+                    if (m < ch)
+                        throw error("Illegal character range");
+                    if (has(CASE_INSENSITIVE))
+                        return caseInsensitiveRangeFor(ch, m);
+                    else
+                        return rangeFor(ch, m);
+                }
+            }
+            return bitsOrSingle(bits, ch);
+        }
+        throw error("Unexpected character '"+((char)ch)+"'");
+    }
+
+    private int single() {
+        int ch = peek();
+        switch (ch) {
+        case '\\':
+            return escape(true, false);
+        default:
+            next();
+            return ch;
+        }
+    }
+
+    /**
+     * Parses a Unicode character family and returns its representative node.
+     */
+    private CharProperty family(boolean singleLetter) {
+        next();
+        String name;
+
+        if (singleLetter) {
+            int c = temp[cursor];
+            if (!Character.isSupplementaryCodePoint(c)) {
+                name = String.valueOf((char)c);
+            } else {
+                name = new String(temp, cursor, 1);
+            }
+            read();
+        } else {
+            int i = cursor;
+            mark('}');
+            while(read() != '}') {
+            }
+            mark('\000');
+            int j = cursor;
+            if (j > patternLength)
+                throw error("Unclosed character family");
+            if (i + 1 >= j)
+                throw error("Empty character family");
+            name = new String(temp, i, j-i-1);
+        }
+
+        if (name.startsWith("In")) {
+            return unicodeBlockPropertyFor(name.substring(2));
+        } else {
+            if (name.startsWith("Is"))
+                name = name.substring(2);
+            return charPropertyNodeFor(name);
+        }
+    }
+
+    /**
+     * Returns a CharProperty matching all characters in a UnicodeBlock.
+     */
+    private CharProperty unicodeBlockPropertyFor(String name) {
+        final Character.UnicodeBlock block;
+        try {
+            block = Character.UnicodeBlock.forName(name);
+        } catch (IllegalArgumentException iae) {
+            throw error("Unknown character block name {" + name + "}");
+        }
+        return new CharProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return block == Character.UnicodeBlock.of(ch);}};
+    }
+
+    /**
+     * Returns a CharProperty matching all characters in a named property.
+     */
+    private CharProperty charPropertyNodeFor(String name) {
+        CharProperty p = CharPropertyNames.charPropertyFor(name);
+        if (p == null)
+            throw error("Unknown character property name {" + name + "}");
+        return p;
+    }
+
+    /**
+     * Parses a group and returns the head node of a set of nodes that process
+     * the group. Sometimes a double return system is used where the tail is
+     * returned in root.
+     */
+    private Node group0() {
+        boolean capturingGroup = false;
+        Node head = null;
+        Node tail = null;
+        int save = flags;
+        root = null;
+        int ch = next();
+        if (ch == '?') {
+            ch = skip();
+            switch (ch) {
+            case ':':   //  (?:xxx) pure group
+                head = createGroup(true);
+                tail = root;
+                head.next = expr(tail);
+                break;
+            case '=':   // (?=xxx) and (?!xxx) lookahead
+            case '!':
+                head = createGroup(true);
+                tail = root;
+                head.next = expr(tail);
+                if (ch == '=') {
+                    head = tail = new Pos(head);
+                } else {
+                    head = tail = new Neg(head);
+                }
+                break;
+            case '>':   // (?>xxx)  independent group
+                head = createGroup(true);
+                tail = root;
+                head.next = expr(tail);
+                head = tail = new Ques(head, INDEPENDENT);
+                break;
+            case '<':   // (?<xxx)  look behind
+                ch = read();
+                int start = cursor;
+                head = createGroup(true);
+                tail = root;
+                head.next = expr(tail);
+                tail.next = lookbehindEnd;
+                TreeInfo info = new TreeInfo();
+                head.study(info);
+                if (info.maxValid == false) {
+                    throw error("Look-behind group does not have "
+                                + "an obvious maximum length");
+                }
+                boolean hasSupplementary = findSupplementary(start, patternLength);
+                if (ch == '=') {
+                    head = tail = (hasSupplementary ?
+                                   new BehindS(head, info.maxLength,
+                                               info.minLength) :
+                                   new Behind(head, info.maxLength,
+                                              info.minLength));
+                } else if (ch == '!') {
+                    head = tail = (hasSupplementary ?
+                                   new NotBehindS(head, info.maxLength,
+                                                  info.minLength) :
+                                   new NotBehind(head, info.maxLength,
+                                                 info.minLength));
+                } else {
+                    throw error("Unknown look-behind group");
+                }
+                break;
+            case '$':
+            case '@':
+                throw error("Unknown group type");
+            default:    // (?xxx:) inlined match flags
+                unread();
+                addFlag();
+                ch = read();
+                if (ch == ')') {
+                    return null;    // Inline modifier only
+                }
+                if (ch != ':') {
+                    throw error("Unknown inline modifier");
+                }
+                head = createGroup(true);
+                tail = root;
+                head.next = expr(tail);
+                break;
+            }
+        } else { // (xxx) a regular group
+            capturingGroup = true;
+            head = createGroup(false);
+            tail = root;
+            head.next = expr(tail);
+        }
+
+        accept(')', "Unclosed group");
+        flags = save;
+
+        // Check for quantifiers
+        Node node = closure(head);
+        if (node == head) { // No closure
+            root = tail;
+            return node;    // Dual return
+        }
+        if (head == tail) { // Zero length assertion
+            root = node;
+            return node;    // Dual return
+        }
+
+        if (node instanceof Ques) {
+            Ques ques = (Ques) node;
+            if (ques.type == POSSESSIVE) {
+                root = node;
+                return node;
+            }
+            tail.next = new BranchConn();
+            tail = tail.next;
+            if (ques.type == GREEDY) {
+                head = new Branch(head, null, tail);
+            } else { // Reluctant quantifier
+                head = new Branch(null, head, tail);
+            }
+            root = tail;
+            return head;
+        } else if (node instanceof Curly) {
+            Curly curly = (Curly) node;
+            if (curly.type == POSSESSIVE) {
+                root = node;
+                return node;
+            }
+            // Discover if the group is deterministic
+            TreeInfo info = new TreeInfo();
+            if (head.study(info)) { // Deterministic
+                GroupTail temp = (GroupTail) tail;
+                head = root = new GroupCurly(head.next, curly.cmin,
+                                   curly.cmax, curly.type,
+                                   ((GroupTail)tail).localIndex,
+                                   ((GroupTail)tail).groupIndex,
+                                             capturingGroup);
+                return head;
+            } else { // Non-deterministic
+                int temp = ((GroupHead) head).localIndex;
+                Loop loop;
+                if (curly.type == GREEDY)
+                    loop = new Loop(this.localCount, temp);
+                else  // Reluctant Curly
+                    loop = new LazyLoop(this.localCount, temp);
+                Prolog prolog = new Prolog(loop);
+                this.localCount += 1;
+                loop.cmin = curly.cmin;
+                loop.cmax = curly.cmax;
+                loop.body = head;
+                tail.next = loop;
+                root = loop;
+                return prolog; // Dual return
+            }
+        }
+        throw error("Internal logic error");
+    }
+
+    /**
+     * Create group head and tail nodes using double return. If the group is
+     * created with anonymous true then it is a pure group and should not
+     * affect group counting.
+     */
+    private Node createGroup(boolean anonymous) {
+        int localIndex = localCount++;
+        int groupIndex = 0;
+        if (!anonymous)
+            groupIndex = capturingGroupCount++;
+        GroupHead head = new GroupHead(localIndex);
+        root = new GroupTail(localIndex, groupIndex);
+        if (!anonymous && groupIndex < 10)
+            groupNodes[groupIndex] = head;
+        return head;
+    }
+
+    /**
+     * Parses inlined match flags and set them appropriately.
+     */
+    private void addFlag() {
+        int ch = peek();
+        for (;;) {
+            switch (ch) {
+            case 'i':
+                flags |= CASE_INSENSITIVE;
+                break;
+            case 'm':
+                flags |= MULTILINE;
+                break;
+            case 's':
+                flags |= DOTALL;
+                break;
+            case 'd':
+                flags |= UNIX_LINES;
+                break;
+            case 'u':
+                flags |= UNICODE_CASE;
+                break;
+            case 'c':
+                flags |= CANON_EQ;
+                break;
+            case 'x':
+                flags |= COMMENTS;
+                break;
+            case '-': // subFlag then fall through
+                ch = next();
+                subFlag();
+            default:
+                return;
+            }
+            ch = next();
+        }
+    }
+
+    /**
+     * Parses the second part of inlined match flags and turns off
+     * flags appropriately.
+     */
+    private void subFlag() {
+        int ch = peek();
+        for (;;) {
+            switch (ch) {
+            case 'i':
+                flags &= ~CASE_INSENSITIVE;
+                break;
+            case 'm':
+                flags &= ~MULTILINE;
+                break;
+            case 's':
+                flags &= ~DOTALL;
+                break;
+            case 'd':
+                flags &= ~UNIX_LINES;
+                break;
+            case 'u':
+                flags &= ~UNICODE_CASE;
+                break;
+            case 'c':
+                flags &= ~CANON_EQ;
+                break;
+            case 'x':
+                flags &= ~COMMENTS;
+                break;
+            default:
+                return;
+            }
+            ch = next();
+        }
+    }
+
+    static final int MAX_REPS   = 0x7FFFFFFF;
+
+    static final int GREEDY     = 0;
+
+    static final int LAZY       = 1;
+
+    static final int POSSESSIVE = 2;
+
+    static final int INDEPENDENT = 3;
+
+    /**
+     * Processes repetition. If the next character peeked is a quantifier
+     * then new nodes must be appended to handle the repetition.
+     * Prev could be a single or a group, so it could be a chain of nodes.
+     */
+    private Node closure(Node prev) {
+        Node atom;
+        int ch = peek();
+        switch (ch) {
+        case '?':
+            ch = next();
+            if (ch == '?') {
+                next();
+                return new Ques(prev, LAZY);
+            } else if (ch == '+') {
+                next();
+                return new Ques(prev, POSSESSIVE);
+            }
+            return new Ques(prev, GREEDY);
+        case '*':
+            ch = next();
+            if (ch == '?') {
+                next();
+                return new Curly(prev, 0, MAX_REPS, LAZY);
+            } else if (ch == '+') {
+                next();
+                return new Curly(prev, 0, MAX_REPS, POSSESSIVE);
+            }
+            return new Curly(prev, 0, MAX_REPS, GREEDY);
+        case '+':
+            ch = next();
+            if (ch == '?') {
+                next();
+                return new Curly(prev, 1, MAX_REPS, LAZY);
+            } else if (ch == '+') {
+                next();
+                return new Curly(prev, 1, MAX_REPS, POSSESSIVE);
+            }
+            return new Curly(prev, 1, MAX_REPS, GREEDY);
+        case '{':
+            ch = temp[cursor+1];
+            if (ASCII.isDigit(ch)) {
+                skip();
+                int cmin = 0;
+                do {
+                    cmin = cmin * 10 + (ch - '0');
+                } while (ASCII.isDigit(ch = read()));
+                int cmax = cmin;
+                if (ch == ',') {
+                    ch = read();
+                    cmax = MAX_REPS;
+                    if (ch != '}') {
+                        cmax = 0;
+                        while (ASCII.isDigit(ch)) {
+                            cmax = cmax * 10 + (ch - '0');
+                            ch = read();
+                        }
+                    }
+                }
+                if (ch != '}')
+                    throw error("Unclosed counted closure");
+                if (((cmin) | (cmax) | (cmax - cmin)) < 0)
+                    throw error("Illegal repetition range");
+                Curly curly;
+                ch = peek();
+                if (ch == '?') {
+                    next();
+                    curly = new Curly(prev, cmin, cmax, LAZY);
+                } else if (ch == '+') {
+                    next();
+                    curly = new Curly(prev, cmin, cmax, POSSESSIVE);
+                } else {
+                    curly = new Curly(prev, cmin, cmax, GREEDY);
+                }
+                return curly;
+            } else {
+                throw error("Illegal repetition");
+            }
+        default:
+            return prev;
+        }
+    }
+
+    /**
+     *  Utility method for parsing control escape sequences.
+     */
+    private int c() {
+        if (cursor < patternLength) {
+            return read() ^ 64;
+        }
+        throw error("Illegal control escape sequence");
+    }
+
+    /**
+     *  Utility method for parsing octal escape sequences.
+     */
+    private int o() {
+        int n = read();
+        if (((n-'0')|('7'-n)) >= 0) {
+            int m = read();
+            if (((m-'0')|('7'-m)) >= 0) {
+                int o = read();
+                if ((((o-'0')|('7'-o)) >= 0) && (((n-'0')|('3'-n)) >= 0)) {
+                    return (n - '0') * 64 + (m - '0') * 8 + (o - '0');
+                }
+                unread();
+                return (n - '0') * 8 + (m - '0');
+            }
+            unread();
+            return (n - '0');
+        }
+        throw error("Illegal octal escape sequence");
+    }
+
+    /**
+     *  Utility method for parsing hexadecimal escape sequences.
+     */
+    private int x() {
+        int n = read();
+        if (ASCII.isHexDigit(n)) {
+            int m = read();
+            if (ASCII.isHexDigit(m)) {
+                return ASCII.toDigit(n) * 16 + ASCII.toDigit(m);
+            }
+        }
+        throw error("Illegal hexadecimal escape sequence");
+    }
+
+    /**
+     *  Utility method for parsing unicode escape sequences.
+     */
+    private int cursor() {
+        return cursor;
+    }
+
+    private void setcursor(int pos) {
+        cursor = pos;
+    }
+
+    private int uxxxx() {
+        int n = 0;
+        for (int i = 0; i < 4; i++) {
+            int ch = read();
+            if (!ASCII.isHexDigit(ch)) {
+                throw error("Illegal Unicode escape sequence");
+            }
+            n = n * 16 + ASCII.toDigit(ch);
+        }
+        return n;
+    }
+
+    private int u() {
+        int n = uxxxx();
+        if (Character.isHighSurrogate((char)n)) {
+            int cur = cursor();
+            if (read() == '\\' && read() == 'u') {
+                int n2 = uxxxx();
+                if (Character.isLowSurrogate((char)n2))
+                    return Character.toCodePoint((char)n, (char)n2);
+            }
+            setcursor(cur);
+        }
+        return n;
+    }
+
+    //
+    // Utility methods for code point support
+    //
+
+    /**
+     * Tests a surrogate value.
+     */
+    private static final boolean isSurrogate(int c) {
+        return c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE;
+    }
+
+    private static final int countChars(CharSequence seq, int index,
+                                        int lengthInCodePoints) {
+        // optimization
+        if (lengthInCodePoints == 1 && !Character.isHighSurrogate(seq.charAt(index))) {
+            assert (index >= 0 && index < seq.length());
+            return 1;
+        }
+        int length = seq.length();
+        int x = index;
+        if (lengthInCodePoints >= 0) {
+            assert (index >= 0 && index < length);
+            for (int i = 0; x < length && i < lengthInCodePoints; i++) {
+                if (Character.isHighSurrogate(seq.charAt(x++))) {
+                    if (x < length && Character.isLowSurrogate(seq.charAt(x))) {
+                        x++;
+                    }
+                }
+            }
+            return x - index;
+        }
+
+        assert (index >= 0 && index <= length);
+        if (index == 0) {
+            return 0;
+        }
+        int len = -lengthInCodePoints;
+        for (int i = 0; x > 0 && i < len; i++) {
+            if (Character.isLowSurrogate(seq.charAt(--x))) {
+                if (x > 0 && Character.isHighSurrogate(seq.charAt(x-1))) {
+                    x--;
+                }
+            }
+        }
+        return index - x;
+    }
+
+    private static final int countCodePoints(CharSequence seq) {
+        int length = seq.length();
+        int n = 0;
+        for (int i = 0; i < length; ) {
+            n++;
+            if (Character.isHighSurrogate(seq.charAt(i++))) {
+                if (i < length && Character.isLowSurrogate(seq.charAt(i))) {
+                    i++;
+                }
+            }
+        }
+        return n;
+    }
+
+    /**
+     *  Creates a bit vector for matching Latin-1 values. A normal BitClass
+     *  never matches values above Latin-1, and a complemented BitClass always
+     *  matches values above Latin-1.
+     */
+    private static final class BitClass extends BmpCharProperty {
+        final boolean[] bits;
+        BitClass() { bits = new boolean[256]; }
+        private BitClass(boolean[] bits) { this.bits = bits; }
+        BitClass add(int c, int flags) {
+            assert c >= 0 && c <= 255;
+            if ((flags & CASE_INSENSITIVE) != 0) {
+                if (ASCII.isAscii(c)) {
+                    bits[ASCII.toUpper(c)] = true;
+                    bits[ASCII.toLower(c)] = true;
+                } else if ((flags & UNICODE_CASE) != 0) {
+                    bits[Character.toLowerCase(c)] = true;
+                    bits[Character.toUpperCase(c)] = true;
+                }
+            }
+            bits[c] = true;
+            return this;
+        }
+        boolean isSatisfiedBy(int ch) {
+            return ch < 256 && bits[ch];
+        }
+    }
+
+    /**
+     *  Returns a suitably optimized, single character matcher.
+     */
+    private CharProperty newSingle(final int ch) {
+        if (has(CASE_INSENSITIVE)) {
+            int lower, upper;
+            if (has(UNICODE_CASE)) {
+                upper = Character.toUpperCase(ch);
+                lower = Character.toLowerCase(upper);
+                if (upper != lower)
+                    return new SingleU(lower);
+            } else if (ASCII.isAscii(ch)) {
+                lower = ASCII.toLower(ch);
+                upper = ASCII.toUpper(ch);
+                if (lower != upper)
+                    return new SingleI(lower, upper);
+            }
+        }
+        if (isSupplementary(ch))
+            return new SingleS(ch);    // Match a given Unicode character
+        return new Single(ch);         // Match a given BMP character
+    }
+
+    /**
+     *  Utility method for creating a string slice matcher.
+     */
+    private Node newSlice(int[] buf, int count, boolean hasSupplementary) {
+        int[] tmp = new int[count];
+        if (has(CASE_INSENSITIVE)) {
+            if (has(UNICODE_CASE)) {
+                for (int i = 0; i < count; i++) {
+                    tmp[i] = Character.toLowerCase(
+                                 Character.toUpperCase(buf[i]));
+                }
+                return hasSupplementary? new SliceUS(tmp) : new SliceU(tmp);
+            }
+            for (int i = 0; i < count; i++) {
+                tmp[i] = ASCII.toLower(buf[i]);
+            }
+            return hasSupplementary? new SliceIS(tmp) : new SliceI(tmp);
+        }
+        for (int i = 0; i < count; i++) {
+            tmp[i] = buf[i];
+        }
+        return hasSupplementary ? new SliceS(tmp) : new Slice(tmp);
+    }
+
+    /**
+     * The following classes are the building components of the object
+     * tree that represents a compiled regular expression. The object tree
+     * is made of individual elements that handle constructs in the Pattern.
+     * Each type of object knows how to match its equivalent construct with
+     * the match() method.
+     */
+
+    /**
+     * Base class for all node classes. Subclasses should override the match()
+     * method as appropriate. This class is an accepting node, so its match()
+     * always returns true.
+     */
+    static class Node extends Object {
+        Node next;
+        Node() {
+            next = Pattern.accept;
+        }
+        /**
+         * This method implements the classic accept node.
+         */
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            matcher.last = i;
+            matcher.groups[0] = matcher.first;
+            matcher.groups[1] = matcher.last;
+            return true;
+        }
+        /**
+         * This method is good for all zero length assertions.
+         */
+        boolean study(TreeInfo info) {
+            if (next != null) {
+                return next.study(info);
+            } else {
+                return info.deterministic;
+            }
+        }
+    }
+
+    static class LastNode extends Node {
+        /**
+         * This method implements the classic accept node with
+         * the addition of a check to see if the match occurred
+         * using all of the input.
+         */
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            if (matcher.acceptMode == Matcher.ENDANCHOR && i != matcher.to)
+                return false;
+            matcher.last = i;
+            matcher.groups[0] = matcher.first;
+            matcher.groups[1] = matcher.last;
+            return true;
+        }
+    }
+
+    /**
+     * Used for REs that can start anywhere within the input string.
+     * This basically tries to match repeatedly at each spot in the
+     * input string, moving forward after each try. An anchored search
+     * or a BnM will bypass this node completely.
+     */
+    static class Start extends Node {
+        int minLength;
+        Start(Node node) {
+            this.next = node;
+            TreeInfo info = new TreeInfo();
+            next.study(info);
+            minLength = info.minLength;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            if (i > matcher.to - minLength) {
+                matcher.hitEnd = true;
+                return false;
+            }
+            boolean ret = false;
+            int guard = matcher.to - minLength;
+            for (; i <= guard; i++) {
+                if (ret = next.match(matcher, i, seq))
+                    break;
+                if (i == guard)
+                    matcher.hitEnd = true;
+            }
+            if (ret) {
+                matcher.first = i;
+                matcher.groups[0] = matcher.first;
+                matcher.groups[1] = matcher.last;
+            }
+            return ret;
+        }
+        boolean study(TreeInfo info) {
+            next.study(info);
+            info.maxValid = false;
+            info.deterministic = false;
+            return false;
+        }
+    }
+
+    /*
+     * StartS supports supplementary characters, including unpaired surrogates.
+     */
+    static final class StartS extends Start {
+        StartS(Node node) {
+            super(node);
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            if (i > matcher.to - minLength) {
+                matcher.hitEnd = true;
+                return false;
+            }
+            boolean ret = false;
+            int guard = matcher.to - minLength;
+            while (i <= guard) {
+                if ((ret = next.match(matcher, i, seq)) || i == guard)
+                    break;
+                // Optimization to move to the next character. This is
+                // faster than countChars(seq, i, 1).
+                if (Character.isHighSurrogate(seq.charAt(i++))) {
+                    if (i < seq.length() && Character.isLowSurrogate(seq.charAt(i))) {
+                        i++;
+                    }
+                }
+                if (i == guard)
+                    matcher.hitEnd = true;
+            }
+            if (ret) {
+                matcher.first = i;
+                matcher.groups[0] = matcher.first;
+                matcher.groups[1] = matcher.last;
+            }
+            return ret;
+        }
+    }
+
+    /**
+     * Node to anchor at the beginning of input. This object implements the
+     * match for a \A sequence, and the caret anchor will use this if not in
+     * multiline mode.
+     */
+    static final class Begin extends Node {
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int fromIndex = (matcher.anchoringBounds) ?
+                matcher.from : 0;
+            if (i == fromIndex && next.match(matcher, i, seq)) {
+                matcher.first = i;
+                matcher.groups[0] = i;
+                matcher.groups[1] = matcher.last;
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    /**
+     * Node to anchor at the end of input. This is the absolute end, so this
+     * should not match at the last newline before the end as $ will.
+     */
+    static final class End extends Node {
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int endIndex = (matcher.anchoringBounds) ?
+                matcher.to : matcher.getTextLength();
+            if (i == endIndex) {
+                matcher.hitEnd = true;
+                return next.match(matcher, i, seq);
+            }
+            return false;
+        }
+    }
+
+    /**
+     * Node to anchor at the beginning of a line. This is essentially the
+     * object to match for the multiline ^.
+     */
+    static final class Caret extends Node {
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int startIndex = matcher.from;
+            int endIndex = matcher.to;
+            if (!matcher.anchoringBounds) {
+                startIndex = 0;
+                endIndex = matcher.getTextLength();
+            }
+            // Perl does not match ^ at end of input even after newline
+            if (i == endIndex) {
+                matcher.hitEnd = true;
+                return false;
+            }
+            if (i > startIndex) {
+                char ch = seq.charAt(i-1);
+                if (ch != '\n' && ch != '\r'
+                    && (ch|1) != '\u2029'
+                    && ch != '\u0085' ) {
+                    return false;
+                }
+                // Should treat /r/n as one newline
+                if (ch == '\r' && seq.charAt(i) == '\n')
+                    return false;
+            }
+            return next.match(matcher, i, seq);
+        }
+    }
+
+    /**
+     * Node to anchor at the beginning of a line when in unixdot mode.
+     */
+    static final class UnixCaret extends Node {
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int startIndex = matcher.from;
+            int endIndex = matcher.to;
+            if (!matcher.anchoringBounds) {
+                startIndex = 0;
+                endIndex = matcher.getTextLength();
+            }
+            // Perl does not match ^ at end of input even after newline
+            if (i == endIndex) {
+                matcher.hitEnd = true;
+                return false;
+            }
+            if (i > startIndex) {
+                char ch = seq.charAt(i-1);
+                if (ch != '\n') {
+                    return false;
+                }
+            }
+            return next.match(matcher, i, seq);
+        }
+    }
+
+    /**
+     * Node to match the location where the last match ended.
+     * This is used for the \G construct.
+     */
+    static final class LastMatch extends Node {
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            if (i != matcher.oldLast)
+                return false;
+            return next.match(matcher, i, seq);
+        }
+    }
+
+    /**
+     * Node to anchor at the end of a line or the end of input based on the
+     * multiline mode.
+     *
+     * When not in multiline mode, the $ can only match at the very end
+     * of the input, unless the input ends in a line terminator in which
+     * it matches right before the last line terminator.
+     *
+     * Note that \r\n is considered an atomic line terminator.
+     *
+     * Like ^ the $ operator matches at a position, it does not match the
+     * line terminators themselves.
+     */
+    static final class Dollar extends Node {
+        boolean multiline;
+        Dollar(boolean mul) {
+            multiline = mul;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int endIndex = (matcher.anchoringBounds) ?
+                matcher.to : matcher.getTextLength();
+            if (!multiline) {
+                if (i < endIndex - 2)
+                    return false;
+                if (i == endIndex - 2) {
+                    char ch = seq.charAt(i);
+                    if (ch != '\r')
+                        return false;
+                    ch = seq.charAt(i + 1);
+                    if (ch != '\n')
+                        return false;
+                }
+            }
+            // Matches before any line terminator; also matches at the
+            // end of input
+            // Before line terminator:
+            // If multiline, we match here no matter what
+            // If not multiline, fall through so that the end
+            // is marked as hit; this must be a /r/n or a /n
+            // at the very end so the end was hit; more input
+            // could make this not match here
+            if (i < endIndex) {
+                char ch = seq.charAt(i);
+                 if (ch == '\n') {
+                     // No match between \r\n
+                     if (i > 0 && seq.charAt(i-1) == '\r')
+                         return false;
+                     if (multiline)
+                         return next.match(matcher, i, seq);
+                 } else if (ch == '\r' || ch == '\u0085' ||
+                            (ch|1) == '\u2029') {
+                     if (multiline)
+                         return next.match(matcher, i, seq);
+                 } else { // No line terminator, no match
+                     return false;
+                 }
+            }
+            // Matched at current end so hit end
+            matcher.hitEnd = true;
+            // If a $ matches because of end of input, then more input
+            // could cause it to fail!
+            matcher.requireEnd = true;
+            return next.match(matcher, i, seq);
+        }
+        boolean study(TreeInfo info) {
+            next.study(info);
+            return info.deterministic;
+        }
+    }
+
+    /**
+     * Node to anchor at the end of a line or the end of input based on the
+     * multiline mode when in unix lines mode.
+     */
+    static final class UnixDollar extends Node {
+        boolean multiline;
+        UnixDollar(boolean mul) {
+            multiline = mul;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int endIndex = (matcher.anchoringBounds) ?
+                matcher.to : matcher.getTextLength();
+            if (i < endIndex) {
+                char ch = seq.charAt(i);
+                if (ch == '\n') {
+                    // If not multiline, then only possible to
+                    // match at very end or one before end
+                    if (multiline == false && i != endIndex - 1)
+                        return false;
+                    // If multiline return next.match without setting
+                    // matcher.hitEnd
+                    if (multiline)
+                        return next.match(matcher, i, seq);
+                } else {
+                    return false;
+                }
+            }
+            // Matching because at the end or 1 before the end;
+            // more input could change this so set hitEnd
+            matcher.hitEnd = true;
+            // If a $ matches because of end of input, then more input
+            // could cause it to fail!
+            matcher.requireEnd = true;
+            return next.match(matcher, i, seq);
+        }
+        boolean study(TreeInfo info) {
+            next.study(info);
+            return info.deterministic;
+        }
+    }
+
+    /**
+     * Abstract node class to match one character satisfying some
+     * boolean property.
+     */
+    private static abstract class CharProperty extends Node {
+        abstract boolean isSatisfiedBy(int ch);
+        CharProperty complement() {
+            return new CharProperty() {
+                    boolean isSatisfiedBy(int ch) {
+                        return ! CharProperty.this.isSatisfiedBy(ch);}};
+        }
+        CharProperty maybeComplement(boolean complement) {
+            return complement ? complement() : this;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            if (i < matcher.to) {
+                int ch = Character.codePointAt(seq, i);
+                return isSatisfiedBy(ch)
+                    && next.match(matcher, i+Character.charCount(ch), seq);
+            } else {
+                matcher.hitEnd = true;
+                return false;
+            }
+        }
+        boolean study(TreeInfo info) {
+            info.minLength++;
+            info.maxLength++;
+            return next.study(info);
+        }
+    }
+
+    /**
+     * Optimized version of CharProperty that works only for
+     * properties never satisfied by Supplementary characters.
+     */
+    private static abstract class BmpCharProperty extends CharProperty {
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            if (i < matcher.to) {
+                return isSatisfiedBy(seq.charAt(i))
+                    && next.match(matcher, i+1, seq);
+            } else {
+                matcher.hitEnd = true;
+                return false;
+            }
+        }
+    }
+
+    /**
+     * Node class that matches a Supplementary Unicode character
+     */
+    static final class SingleS extends CharProperty {
+        final int c;
+        SingleS(int c) { this.c = c; }
+        boolean isSatisfiedBy(int ch) {
+            return ch == c;
+        }
+    }
+
+    /**
+     * Optimization -- matches a given BMP character
+     */
+    static final class Single extends BmpCharProperty {
+        final int c;
+        Single(int c) { this.c = c; }
+        boolean isSatisfiedBy(int ch) {
+            return ch == c;
+        }
+    }
+
+    /**
+     * Case insensitive matches a given BMP character
+     */
+    static final class SingleI extends BmpCharProperty {
+        final int lower;
+        final int upper;
+        SingleI(int lower, int upper) {
+            this.lower = lower;
+            this.upper = upper;
+        }
+        boolean isSatisfiedBy(int ch) {
+            return ch == lower || ch == upper;
+        }
+    }
+
+    /**
+     * Unicode case insensitive matches a given Unicode character
+     */
+    static final class SingleU extends CharProperty {
+        final int lower;
+        SingleU(int lower) {
+            this.lower = lower;
+        }
+        boolean isSatisfiedBy(int ch) {
+            return lower == ch ||
+                lower == Character.toLowerCase(Character.toUpperCase(ch));
+        }
+    }
+
+    /**
+     * Node class that matches a Unicode category.
+     */
+    static final class Category extends CharProperty {
+        final int typeMask;
+        Category(int typeMask) { this.typeMask = typeMask; }
+        boolean isSatisfiedBy(int ch) {
+            return (typeMask & (1 << Character.getType(ch))) != 0;
+        }
+    }
+
+    /**
+     * Node class that matches a POSIX type.
+     */
+    static final class Ctype extends BmpCharProperty {
+        final int ctype;
+        Ctype(int ctype) { this.ctype = ctype; }
+        boolean isSatisfiedBy(int ch) {
+            return ch < 128 && ASCII.isType(ch, ctype);
+        }
+    }
+
+    /**
+     * Base class for all Slice nodes
+     */
+    static class SliceNode extends Node {
+        int[] buffer;
+        SliceNode(int[] buf) {
+            buffer = buf;
+        }
+        boolean study(TreeInfo info) {
+            info.minLength += buffer.length;
+            info.maxLength += buffer.length;
+            return next.study(info);
+        }
+    }
+
+    /**
+     * Node class for a case sensitive/BMP-only sequence of literal
+     * characters.
+     */
+    static final class Slice extends SliceNode {
+        Slice(int[] buf) {
+            super(buf);
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int[] buf = buffer;
+            int len = buf.length;
+            for (int j=0; j<len; j++) {
+                if ((i+j) >= matcher.to) {
+                    matcher.hitEnd = true;
+                    return false;
+                }
+                if (buf[j] != seq.charAt(i+j))
+                    return false;
+            }
+            return next.match(matcher, i+len, seq);
+        }
+    }
+
+    /**
+     * Node class for a case_insensitive/BMP-only sequence of literal
+     * characters.
+     */
+    static class SliceI extends SliceNode {
+        SliceI(int[] buf) {
+            super(buf);
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int[] buf = buffer;
+            int len = buf.length;
+            for (int j=0; j<len; j++) {
+                if ((i+j) >= matcher.to) {
+                    matcher.hitEnd = true;
+                    return false;
+                }
+                int c = seq.charAt(i+j);
+                if (buf[j] != c &&
+                    buf[j] != ASCII.toLower(c))
+                    return false;
+            }
+            return next.match(matcher, i+len, seq);
+        }
+    }
+
+    /**
+     * Node class for a unicode_case_insensitive/BMP-only sequence of
+     * literal characters. Uses unicode case folding.
+     */
+    static final class SliceU extends SliceNode {
+        SliceU(int[] buf) {
+            super(buf);
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int[] buf = buffer;
+            int len = buf.length;
+            for (int j=0; j<len; j++) {
+                if ((i+j) >= matcher.to) {
+                    matcher.hitEnd = true;
+                    return false;
+                }
+                int c = seq.charAt(i+j);
+                if (buf[j] != c &&
+                    buf[j] != Character.toLowerCase(Character.toUpperCase(c)))
+                    return false;
+            }
+            return next.match(matcher, i+len, seq);
+        }
+    }
+
+    /**
+     * Node class for a case sensitive sequence of literal characters
+     * including supplementary characters.
+     */
+    static final class SliceS extends SliceNode {
+        SliceS(int[] buf) {
+            super(buf);
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int[] buf = buffer;
+            int x = i;
+            for (int j = 0; j < buf.length; j++) {
+                if (x >= matcher.to) {
+                    matcher.hitEnd = true;
+                    return false;
+                }
+                int c = Character.codePointAt(seq, x);
+                if (buf[j] != c)
+                    return false;
+                x += Character.charCount(c);
+                if (x > matcher.to) {
+                    matcher.hitEnd = true;
+                    return false;
+                }
+            }
+            return next.match(matcher, x, seq);
+        }
+    }
+
+    /**
+     * Node class for a case insensitive sequence of literal characters
+     * including supplementary characters.
+     */
+    static class SliceIS extends SliceNode {
+        SliceIS(int[] buf) {
+            super(buf);
+        }
+        int toLower(int c) {
+            return ASCII.toLower(c);
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int[] buf = buffer;
+            int x = i;
+            for (int j = 0; j < buf.length; j++) {
+                if (x >= matcher.to) {
+                    matcher.hitEnd = true;
+                    return false;
+                }
+                int c = Character.codePointAt(seq, x);
+                if (buf[j] != c && buf[j] != toLower(c))
+                    return false;
+                x += Character.charCount(c);
+                if (x > matcher.to) {
+                    matcher.hitEnd = true;
+                    return false;
+                }
+            }
+            return next.match(matcher, x, seq);
+        }
+    }
+
+    /**
+     * Node class for a case insensitive sequence of literal characters.
+     * Uses unicode case folding.
+     */
+    static final class SliceUS extends SliceIS {
+        SliceUS(int[] buf) {
+            super(buf);
+        }
+        int toLower(int c) {
+            return Character.toLowerCase(Character.toUpperCase(c));
+        }
+    }
+
+    private static boolean inRange(int lower, int ch, int upper) {
+        return lower <= ch && ch <= upper;
+    }
+
+    /**
+     * Returns node for matching characters within an explicit value range.
+     */
+    private static CharProperty rangeFor(final int lower,
+                                         final int upper) {
+        return new CharProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return inRange(lower, ch, upper);}};
+    }
+
+    /**
+     * Returns node for matching characters within an explicit value
+     * range in a case insensitive manner.
+     */
+    private CharProperty caseInsensitiveRangeFor(final int lower,
+                                                 final int upper) {
+        if (has(UNICODE_CASE))
+            return new CharProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    if (inRange(lower, ch, upper))
+                        return true;
+                    int up = Character.toUpperCase(ch);
+                    return inRange(lower, up, upper) ||
+                           inRange(lower, Character.toLowerCase(up), upper);}};
+        return new CharProperty() {
+            boolean isSatisfiedBy(int ch) {
+                return inRange(lower, ch, upper) ||
+                    ASCII.isAscii(ch) &&
+                        (inRange(lower, ASCII.toUpper(ch), upper) ||
+                         inRange(lower, ASCII.toLower(ch), upper));
+            }};
+    }
+
+    /**
+     * Implements the Unicode category ALL and the dot metacharacter when
+     * in dotall mode.
+     */
+    static final class All extends CharProperty {
+        boolean isSatisfiedBy(int ch) {
+            return true;
+        }
+    }
+
+    /**
+     * Node class for the dot metacharacter when dotall is not enabled.
+     */
+    static final class Dot extends CharProperty {
+        boolean isSatisfiedBy(int ch) {
+            return (ch != '\n' && ch != '\r'
+                    && (ch|1) != '\u2029'
+                    && ch != '\u0085');
+        }
+    }
+
+    /**
+     * Node class for the dot metacharacter when dotall is not enabled
+     * but UNIX_LINES is enabled.
+     */
+    static final class UnixDot extends CharProperty {
+        boolean isSatisfiedBy(int ch) {
+            return ch != '\n';
+        }
+    }
+
+    /**
+     * The 0 or 1 quantifier. This one class implements all three types.
+     */
+    static final class Ques extends Node {
+        Node atom;
+        int type;
+        Ques(Node node, int type) {
+            this.atom = node;
+            this.type = type;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            switch (type) {
+            case GREEDY:
+                return (atom.match(matcher, i, seq) && next.match(matcher, matcher.last, seq))
+                    || next.match(matcher, i, seq);
+            case LAZY:
+                return next.match(matcher, i, seq)
+                    || (atom.match(matcher, i, seq) && next.match(matcher, matcher.last, seq));
+            case POSSESSIVE:
+                if (atom.match(matcher, i, seq)) i = matcher.last;
+                return next.match(matcher, i, seq);
+            default:
+                return atom.match(matcher, i, seq) && next.match(matcher, matcher.last, seq);
+            }
+        }
+        boolean study(TreeInfo info) {
+            if (type != INDEPENDENT) {
+                int minL = info.minLength;
+                atom.study(info);
+                info.minLength = minL;
+                info.deterministic = false;
+                return next.study(info);
+            } else {
+                atom.study(info);
+                return next.study(info);
+            }
+        }
+    }
+
+    /**
+     * Handles the curly-brace style repetition with a specified minimum and
+     * maximum occurrences. The * quantifier is handled as a special case.
+     * This class handles the three types.
+     */
+    static final class Curly extends Node {
+        Node atom;
+        int type;
+        int cmin;
+        int cmax;
+
+        Curly(Node node, int cmin, int cmax, int type) {
+            this.atom = node;
+            this.type = type;
+            this.cmin = cmin;
+            this.cmax = cmax;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int j;
+            for (j = 0; j < cmin; j++) {
+                if (atom.match(matcher, i, seq)) {
+                    i = matcher.last;
+                    continue;
+                }
+                return false;
+            }
+            if (type == GREEDY)
+                return match0(matcher, i, j, seq);
+            else if (type == LAZY)
+                return match1(matcher, i, j, seq);
+            else
+                return match2(matcher, i, j, seq);
+        }
+        // Greedy match.
+        // i is the index to start matching at
+        // j is the number of atoms that have matched
+        boolean match0(Matcher matcher, int i, int j, CharSequence seq) {
+            if (j >= cmax) {
+                // We have matched the maximum... continue with the rest of
+                // the regular expression
+                return next.match(matcher, i, seq);
+            }
+            int backLimit = j;
+            while (atom.match(matcher, i, seq)) {
+                // k is the length of this match
+                int k = matcher.last - i;
+                if (k == 0) // Zero length match
+                    break;
+                // Move up index and number matched
+                i = matcher.last;
+                j++;
+                // We are greedy so match as many as we can
+                while (j < cmax) {
+                    if (!atom.match(matcher, i, seq))
+                        break;
+                    if (i + k != matcher.last) {
+                        if (match0(matcher, matcher.last, j+1, seq))
+                            return true;
+                        break;
+                    }
+                    i += k;
+                    j++;
+                }
+                // Handle backing off if match fails
+                while (j >= backLimit) {
+                   if (next.match(matcher, i, seq))
+                        return true;
+                    i -= k;
+                    j--;
+                }
+                return false;
+            }
+            return next.match(matcher, i, seq);
+        }
+        // Reluctant match. At this point, the minimum has been satisfied.
+        // i is the index to start matching at
+        // j is the number of atoms that have matched
+        boolean match1(Matcher matcher, int i, int j, CharSequence seq) {
+            for (;;) {
+                // Try finishing match without consuming any more
+                if (next.match(matcher, i, seq))
+                    return true;
+                // At the maximum, no match found
+                if (j >= cmax)
+                    return false;
+                // Okay, must try one more atom
+                if (!atom.match(matcher, i, seq))
+                    return false;
+                // If we haven't moved forward then must break out
+                if (i == matcher.last)
+                    return false;
+                // Move up index and number matched
+                i = matcher.last;
+                j++;
+            }
+        }
+        boolean match2(Matcher matcher, int i, int j, CharSequence seq) {
+            for (; j < cmax; j++) {
+                if (!atom.match(matcher, i, seq))
+                    break;
+                if (i == matcher.last)
+                    break;
+                i = matcher.last;
+            }
+            return next.match(matcher, i, seq);
+        }
+        boolean study(TreeInfo info) {
+            // Save original info
+            int minL = info.minLength;
+            int maxL = info.maxLength;
+            boolean maxV = info.maxValid;
+            boolean detm = info.deterministic;
+            info.reset();
+
+            atom.study(info);
+
+            int temp = info.minLength * cmin + minL;
+            if (temp < minL) {
+                temp = 0xFFFFFFF; // arbitrary large number
+            }
+            info.minLength = temp;
+
+            if (maxV & info.maxValid) {
+                temp = info.maxLength * cmax + maxL;
+                info.maxLength = temp;
+                if (temp < maxL) {
+                    info.maxValid = false;
+                }
+            } else {
+                info.maxValid = false;
+            }
+
+            if (info.deterministic && cmin == cmax)
+                info.deterministic = detm;
+            else
+                info.deterministic = false;
+
+            return next.study(info);
+        }
+    }
+
+    /**
+     * Handles the curly-brace style repetition with a specified minimum and
+     * maximum occurrences in deterministic cases. This is an iterative
+     * optimization over the Prolog and Loop system which would handle this
+     * in a recursive way. The * quantifier is handled as a special case.
+     * If capture is true then this class saves group settings and ensures
+     * that groups are unset when backing off of a group match.
+     */
+    static final class GroupCurly extends Node {
+        Node atom;
+        int type;
+        int cmin;
+        int cmax;
+        int localIndex;
+        int groupIndex;
+        boolean capture;
+
+        GroupCurly(Node node, int cmin, int cmax, int type, int local,
+                   int group, boolean capture) {
+            this.atom = node;
+            this.type = type;
+            this.cmin = cmin;
+            this.cmax = cmax;
+            this.localIndex = local;
+            this.groupIndex = group;
+            this.capture = capture;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int[] groups = matcher.groups;
+            int[] locals = matcher.locals;
+            int save0 = locals[localIndex];
+            int save1 = 0;
+            int save2 = 0;
+
+            if (capture) {
+                save1 = groups[groupIndex];
+                save2 = groups[groupIndex+1];
+            }
+
+            // Notify GroupTail there is no need to setup group info
+            // because it will be set here
+            locals[localIndex] = -1;
+
+            boolean ret = true;
+            for (int j = 0; j < cmin; j++) {
+                if (atom.match(matcher, i, seq)) {
+                    if (capture) {
+                        groups[groupIndex] = i;
+                        groups[groupIndex+1] = matcher.last;
+                    }
+                    i = matcher.last;
+                } else {
+                    ret = false;
+                    break;
+                }
+            }
+            if (ret) {
+                if (type == GREEDY) {
+                    ret = match0(matcher, i, cmin, seq);
+                } else if (type == LAZY) {
+                    ret = match1(matcher, i, cmin, seq);
+                } else {
+                    ret = match2(matcher, i, cmin, seq);
+                }
+            }
+            if (!ret) {
+                locals[localIndex] = save0;
+                if (capture) {
+                    groups[groupIndex] = save1;
+                    groups[groupIndex+1] = save2;
+                }
+            }
+            return ret;
+        }
+        // Aggressive group match
+        boolean match0(Matcher matcher, int i, int j, CharSequence seq) {
+            int[] groups = matcher.groups;
+            int save0 = 0;
+            int save1 = 0;
+            if (capture) {
+                save0 = groups[groupIndex];
+                save1 = groups[groupIndex+1];
+            }
+            for (;;) {
+                if (j >= cmax)
+                    break;
+                if (!atom.match(matcher, i, seq))
+                    break;
+                int k = matcher.last - i;
+                if (k <= 0) {
+                    if (capture) {
+                        groups[groupIndex] = i;
+                        groups[groupIndex+1] = i + k;
+                    }
+                    i = i + k;
+                    break;
+                }
+                for (;;) {
+                    if (capture) {
+                        groups[groupIndex] = i;
+                        groups[groupIndex+1] = i + k;
+                    }
+                    i = i + k;
+                    if (++j >= cmax)
+                        break;
+                    if (!atom.match(matcher, i, seq))
+                        break;
+                    if (i + k != matcher.last) {
+                        if (match0(matcher, i, j, seq))
+                            return true;
+                        break;
+                    }
+                }
+                while (j > cmin) {
+                    if (next.match(matcher, i, seq)) {
+                        if (capture) {
+                            groups[groupIndex+1] = i;
+                            groups[groupIndex] = i - k;
+                        }
+                        i = i - k;
+                        return true;
+                    }
+                    // backing off
+                    if (capture) {
+                        groups[groupIndex+1] = i;
+                        groups[groupIndex] = i - k;
+                    }
+                    i = i - k;
+                    j--;
+                }
+                break;
+            }
+            if (capture) {
+                groups[groupIndex] = save0;
+                groups[groupIndex+1] = save1;
+            }
+            return next.match(matcher, i, seq);
+        }
+        // Reluctant matching
+        boolean match1(Matcher matcher, int i, int j, CharSequence seq) {
+            for (;;) {
+                if (next.match(matcher, i, seq))
+                    return true;
+                if (j >= cmax)
+                    return false;
+                if (!atom.match(matcher, i, seq))
+                    return false;
+                if (i == matcher.last)
+                    return false;
+                if (capture) {
+                    matcher.groups[groupIndex] = i;
+                    matcher.groups[groupIndex+1] = matcher.last;
+                }
+                i = matcher.last;
+                j++;
+            }
+        }
+        // Possessive matching
+        boolean match2(Matcher matcher, int i, int j, CharSequence seq) {
+            for (; j < cmax; j++) {
+                if (!atom.match(matcher, i, seq)) {
+                    break;
+                }
+                if (capture) {
+                    matcher.groups[groupIndex] = i;
+                    matcher.groups[groupIndex+1] = matcher.last;
+                }
+                if (i == matcher.last) {
+                    break;
+                }
+                i = matcher.last;
+            }
+            return next.match(matcher, i, seq);
+        }
+        boolean study(TreeInfo info) {
+            // Save original info
+            int minL = info.minLength;
+            int maxL = info.maxLength;
+            boolean maxV = info.maxValid;
+            boolean detm = info.deterministic;
+            info.reset();
+
+            atom.study(info);
+
+            int temp = info.minLength * cmin + minL;
+            if (temp < minL) {
+                temp = 0xFFFFFFF; // Arbitrary large number
+            }
+            info.minLength = temp;
+
+            if (maxV & info.maxValid) {
+                temp = info.maxLength * cmax + maxL;
+                info.maxLength = temp;
+                if (temp < maxL) {
+                    info.maxValid = false;
+                }
+            } else {
+                info.maxValid = false;
+            }
+
+            if (info.deterministic && cmin == cmax) {
+                info.deterministic = detm;
+            } else {
+                info.deterministic = false;
+            }
+
+            return next.study(info);
+        }
+    }
+
+    /**
+     * A Guard node at the end of each atom node in a Branch. It
+     * serves the purpose of chaining the "match" operation to
+     * "next" but not the "study", so we can collect the TreeInfo
+     * of each atom node without including the TreeInfo of the
+     * "next".
+     */
+    static final class BranchConn extends Node {
+        BranchConn() {};
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            return next.match(matcher, i, seq);
+        }
+        boolean study(TreeInfo info) {
+            return info.deterministic;
+        }
+    }
+
+    /**
+     * Handles the branching of alternations. Note this is also used for
+     * the ? quantifier to branch between the case where it matches once
+     * and where it does not occur.
+     */
+    static final class Branch extends Node {
+        Node[] atoms = new Node[2];
+        int size = 2;
+        Node conn;
+        Branch(Node first, Node second, Node branchConn) {
+            conn = branchConn;
+            atoms[0] = first;
+            atoms[1] = second;
+        }
+
+        void add(Node node) {
+            if (size >= atoms.length) {
+                Node[] tmp = new Node[atoms.length*2];
+                System.arraycopy(atoms, 0, tmp, 0, atoms.length);
+                atoms = tmp;
+            }
+            atoms[size++] = node;
+        }
+
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            for (int n = 0; n < size; n++) {
+                if (atoms[n] == null) {
+                    if (conn.next.match(matcher, i, seq))
+                        return true;
+                } else if (atoms[n].match(matcher, i, seq)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        boolean study(TreeInfo info) {
+            int minL = info.minLength;
+            int maxL = info.maxLength;
+            boolean maxV = info.maxValid;
+
+            int minL2 = Integer.MAX_VALUE; //arbitrary large enough num
+            int maxL2 = -1;
+            for (int n = 0; n < size; n++) {
+                info.reset();
+                if (atoms[n] != null)
+                    atoms[n].study(info);
+                minL2 = Math.min(minL2, info.minLength);
+                maxL2 = Math.max(maxL2, info.maxLength);
+                maxV = (maxV & info.maxValid);
+            }
+
+            minL += minL2;
+            maxL += maxL2;
+
+            info.reset();
+            conn.next.study(info);
+
+            info.minLength += minL;
+            info.maxLength += maxL;
+            info.maxValid &= maxV;
+            info.deterministic = false;
+            return false;
+        }
+    }
+
+    /**
+     * The GroupHead saves the location where the group begins in the locals
+     * and restores them when the match is done.
+     *
+     * The matchRef is used when a reference to this group is accessed later
+     * in the expression. The locals will have a negative value in them to
+     * indicate that we do not want to unset the group if the reference
+     * doesn't match.
+     */
+    static final class GroupHead extends Node {
+        int localIndex;
+        GroupHead(int localCount) {
+            localIndex = localCount;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int save = matcher.locals[localIndex];
+            matcher.locals[localIndex] = i;
+            boolean ret = next.match(matcher, i, seq);
+            matcher.locals[localIndex] = save;
+            return ret;
+        }
+        boolean matchRef(Matcher matcher, int i, CharSequence seq) {
+            int save = matcher.locals[localIndex];
+            matcher.locals[localIndex] = ~i; // HACK
+            boolean ret = next.match(matcher, i, seq);
+            matcher.locals[localIndex] = save;
+            return ret;
+        }
+    }
+
+    /**
+     * Recursive reference to a group in the regular expression. It calls
+     * matchRef because if the reference fails to match we would not unset
+     * the group.
+     */
+    static final class GroupRef extends Node {
+        GroupHead head;
+        GroupRef(GroupHead head) {
+            this.head = head;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            return head.matchRef(matcher, i, seq)
+                && next.match(matcher, matcher.last, seq);
+        }
+        boolean study(TreeInfo info) {
+            info.maxValid = false;
+            info.deterministic = false;
+            return next.study(info);
+        }
+    }
+
+    /**
+     * The GroupTail handles the setting of group beginning and ending
+     * locations when groups are successfully matched. It must also be able to
+     * unset groups that have to be backed off of.
+     *
+     * The GroupTail node is also used when a previous group is referenced,
+     * and in that case no group information needs to be set.
+     */
+    static final class GroupTail extends Node {
+        int localIndex;
+        int groupIndex;
+        GroupTail(int localCount, int groupCount) {
+            localIndex = localCount;
+            groupIndex = groupCount + groupCount;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int tmp = matcher.locals[localIndex];
+            if (tmp >= 0) { // This is the normal group case.
+                // Save the group so we can unset it if it
+                // backs off of a match.
+                int groupStart = matcher.groups[groupIndex];
+                int groupEnd = matcher.groups[groupIndex+1];
+
+                matcher.groups[groupIndex] = tmp;
+                matcher.groups[groupIndex+1] = i;
+                if (next.match(matcher, i, seq)) {
+                    return true;
+                }
+                matcher.groups[groupIndex] = groupStart;
+                matcher.groups[groupIndex+1] = groupEnd;
+                return false;
+            } else {
+                // This is a group reference case. We don't need to save any
+                // group info because it isn't really a group.
+                matcher.last = i;
+                return true;
+            }
+        }
+    }
+
+    /**
+     * This sets up a loop to handle a recursive quantifier structure.
+     */
+    static final class Prolog extends Node {
+        Loop loop;
+        Prolog(Loop loop) {
+            this.loop = loop;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            return loop.matchInit(matcher, i, seq);
+        }
+        boolean study(TreeInfo info) {
+            return loop.study(info);
+        }
+    }
+
+    /**
+     * Handles the repetition count for a greedy Curly. The matchInit
+     * is called from the Prolog to save the index of where the group
+     * beginning is stored. A zero length group check occurs in the
+     * normal match but is skipped in the matchInit.
+     */
+    static class Loop extends Node {
+        Node body;
+        int countIndex; // local count index in matcher locals
+        int beginIndex; // group beginning index
+        int cmin, cmax;
+        Loop(int countIndex, int beginIndex) {
+            this.countIndex = countIndex;
+            this.beginIndex = beginIndex;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            // Avoid infinite loop in zero-length case.
+            if (i > matcher.locals[beginIndex]) {
+                int count = matcher.locals[countIndex];
+
+                // This block is for before we reach the minimum
+                // iterations required for the loop to match
+                if (count < cmin) {
+                    matcher.locals[countIndex] = count + 1;
+                    boolean b = body.match(matcher, i, seq);
+                    // If match failed we must backtrack, so
+                    // the loop count should NOT be incremented
+                    if (!b)
+                        matcher.locals[countIndex] = count;
+                    // Return success or failure since we are under
+                    // minimum
+                    return b;
+                }
+                // This block is for after we have the minimum
+                // iterations required for the loop to match
+                if (count < cmax) {
+                    matcher.locals[countIndex] = count + 1;
+                    boolean b = body.match(matcher, i, seq);
+                    // If match failed we must backtrack, so
+                    // the loop count should NOT be incremented
+                    if (!b)
+                        matcher.locals[countIndex] = count;
+                    else
+                        return true;
+                }
+            }
+            return next.match(matcher, i, seq);
+        }
+        boolean matchInit(Matcher matcher, int i, CharSequence seq) {
+            int save = matcher.locals[countIndex];
+            boolean ret = false;
+            if (0 < cmin) {
+                matcher.locals[countIndex] = 1;
+                ret = body.match(matcher, i, seq);
+            } else if (0 < cmax) {
+                matcher.locals[countIndex] = 1;
+                ret = body.match(matcher, i, seq);
+                if (ret == false)
+                    ret = next.match(matcher, i, seq);
+            } else {
+                ret = next.match(matcher, i, seq);
+            }
+            matcher.locals[countIndex] = save;
+            return ret;
+        }
+        boolean study(TreeInfo info) {
+            info.maxValid = false;
+            info.deterministic = false;
+            return false;
+        }
+    }
+
+    /**
+     * Handles the repetition count for a reluctant Curly. The matchInit
+     * is called from the Prolog to save the index of where the group
+     * beginning is stored. A zero length group check occurs in the
+     * normal match but is skipped in the matchInit.
+     */
+    static final class LazyLoop extends Loop {
+        LazyLoop(int countIndex, int beginIndex) {
+            super(countIndex, beginIndex);
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            // Check for zero length group
+            if (i > matcher.locals[beginIndex]) {
+                int count = matcher.locals[countIndex];
+                if (count < cmin) {
+                    matcher.locals[countIndex] = count + 1;
+                    boolean result = body.match(matcher, i, seq);
+                    // If match failed we must backtrack, so
+                    // the loop count should NOT be incremented
+                    if (!result)
+                        matcher.locals[countIndex] = count;
+                    return result;
+                }
+                if (next.match(matcher, i, seq))
+                    return true;
+                if (count < cmax) {
+                    matcher.locals[countIndex] = count + 1;
+                    boolean result = body.match(matcher, i, seq);
+                    // If match failed we must backtrack, so
+                    // the loop count should NOT be incremented
+                    if (!result)
+                        matcher.locals[countIndex] = count;
+                    return result;
+                }
+                return false;
+            }
+            return next.match(matcher, i, seq);
+        }
+        boolean matchInit(Matcher matcher, int i, CharSequence seq) {
+            int save = matcher.locals[countIndex];
+            boolean ret = false;
+            if (0 < cmin) {
+                matcher.locals[countIndex] = 1;
+                ret = body.match(matcher, i, seq);
+            } else if (next.match(matcher, i, seq)) {
+                ret = true;
+            } else if (0 < cmax) {
+                matcher.locals[countIndex] = 1;
+                ret = body.match(matcher, i, seq);
+            }
+            matcher.locals[countIndex] = save;
+            return ret;
+        }
+        boolean study(TreeInfo info) {
+            info.maxValid = false;
+            info.deterministic = false;
+            return false;
+        }
+    }
+
+    /**
+     * Refers to a group in the regular expression. Attempts to match
+     * whatever the group referred to last matched.
+     */
+    static class BackRef extends Node {
+        int groupIndex;
+        BackRef(int groupCount) {
+            super();
+            groupIndex = groupCount + groupCount;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int j = matcher.groups[groupIndex];
+            int k = matcher.groups[groupIndex+1];
+
+            int groupSize = k - j;
+
+            // If the referenced group didn't match, neither can this
+            if (j < 0)
+                return false;
+
+            // If there isn't enough input left no match
+            if (i + groupSize > matcher.to) {
+                matcher.hitEnd = true;
+                return false;
+            }
+
+            // Check each new char to make sure it matches what the group
+            // referenced matched last time around
+            for (int index=0; index<groupSize; index++)
+                if (seq.charAt(i+index) != seq.charAt(j+index))
+                    return false;
+
+            return next.match(matcher, i+groupSize, seq);
+        }
+        boolean study(TreeInfo info) {
+            info.maxValid = false;
+            return next.study(info);
+        }
+    }
+
+    static class CIBackRef extends Node {
+        int groupIndex;
+        boolean doUnicodeCase;
+        CIBackRef(int groupCount, boolean doUnicodeCase) {
+            super();
+            groupIndex = groupCount + groupCount;
+            this.doUnicodeCase = doUnicodeCase;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int j = matcher.groups[groupIndex];
+            int k = matcher.groups[groupIndex+1];
+
+            int groupSize = k - j;
+
+            // If the referenced group didn't match, neither can this
+            if (j < 0)
+                return false;
+
+            // If there isn't enough input left no match
+            if (i + groupSize > matcher.to) {
+                matcher.hitEnd = true;
+                return false;
+            }
+
+            // Check each new char to make sure it matches what the group
+            // referenced matched last time around
+            int x = i;
+            for (int index=0; index<groupSize; index++) {
+                int c1 = Character.codePointAt(seq, x);
+                int c2 = Character.codePointAt(seq, j);
+                if (c1 != c2) {
+                    if (doUnicodeCase) {
+                        int cc1 = Character.toUpperCase(c1);
+                        int cc2 = Character.toUpperCase(c2);
+                        if (cc1 != cc2 &&
+                            Character.toLowerCase(cc1) !=
+                            Character.toLowerCase(cc2))
+                            return false;
+                    } else {
+                        if (ASCII.toLower(c1) != ASCII.toLower(c2))
+                            return false;
+                    }
+                }
+                x += Character.charCount(c1);
+                j += Character.charCount(c2);
+            }
+
+            return next.match(matcher, i+groupSize, seq);
+        }
+        boolean study(TreeInfo info) {
+            info.maxValid = false;
+            return next.study(info);
+        }
+    }
+
+    /**
+     * Searches until the next instance of its atom. This is useful for
+     * finding the atom efficiently without passing an instance of it
+     * (greedy problem) and without a lot of wasted search time (reluctant
+     * problem).
+     */
+    static final class First extends Node {
+        Node atom;
+        First(Node node) {
+            this.atom = BnM.optimize(node);
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            if (atom instanceof BnM) {
+                return atom.match(matcher, i, seq)
+                    && next.match(matcher, matcher.last, seq);
+            }
+            for (;;) {
+                if (i > matcher.to) {
+                    matcher.hitEnd = true;
+                    return false;
+                }
+                if (atom.match(matcher, i, seq)) {
+                    return next.match(matcher, matcher.last, seq);
+                }
+                i += countChars(seq, i, 1);
+                matcher.first++;
+            }
+        }
+        boolean study(TreeInfo info) {
+            atom.study(info);
+            info.maxValid = false;
+            info.deterministic = false;
+            return next.study(info);
+        }
+    }
+
+    static final class Conditional extends Node {
+        Node cond, yes, not;
+        Conditional(Node cond, Node yes, Node not) {
+            this.cond = cond;
+            this.yes = yes;
+            this.not = not;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            if (cond.match(matcher, i, seq)) {
+                return yes.match(matcher, i, seq);
+            } else {
+                return not.match(matcher, i, seq);
+            }
+        }
+        boolean study(TreeInfo info) {
+            int minL = info.minLength;
+            int maxL = info.maxLength;
+            boolean maxV = info.maxValid;
+            info.reset();
+            yes.study(info);
+
+            int minL2 = info.minLength;
+            int maxL2 = info.maxLength;
+            boolean maxV2 = info.maxValid;
+            info.reset();
+            not.study(info);
+
+            info.minLength = minL + Math.min(minL2, info.minLength);
+            info.maxLength = maxL + Math.max(maxL2, info.maxLength);
+            info.maxValid = (maxV & maxV2 & info.maxValid);
+            info.deterministic = false;
+            return next.study(info);
+        }
+    }
+
+    /**
+     * Zero width positive lookahead.
+     */
+    static final class Pos extends Node {
+        Node cond;
+        Pos(Node cond) {
+            this.cond = cond;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int savedTo = matcher.to;
+            boolean conditionMatched = false;
+
+            // Relax transparent region boundaries for lookahead
+            if (matcher.transparentBounds)
+                matcher.to = matcher.getTextLength();
+            try {
+                conditionMatched = cond.match(matcher, i, seq);
+            } finally {
+                // Reinstate region boundaries
+                matcher.to = savedTo;
+            }
+            return conditionMatched && next.match(matcher, i, seq);
+        }
+    }
+
+    /**
+     * Zero width negative lookahead.
+     */
+    static final class Neg extends Node {
+        Node cond;
+        Neg(Node cond) {
+            this.cond = cond;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int savedTo = matcher.to;
+            boolean conditionMatched = false;
+
+            // Relax transparent region boundaries for lookahead
+            if (matcher.transparentBounds)
+                matcher.to = matcher.getTextLength();
+            try {
+                if (i < matcher.to) {
+                    conditionMatched = !cond.match(matcher, i, seq);
+                } else {
+                    // If a negative lookahead succeeds then more input
+                    // could cause it to fail!
+                    matcher.requireEnd = true;
+                    conditionMatched = !cond.match(matcher, i, seq);
+                }
+            } finally {
+                // Reinstate region boundaries
+                matcher.to = savedTo;
+            }
+            return conditionMatched && next.match(matcher, i, seq);
+        }
+    }
+
+    /**
+     * For use with lookbehinds; matches the position where the lookbehind
+     * was encountered.
+     */
+    static Node lookbehindEnd = new Node() {
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            return i == matcher.lookbehindTo;
+        }
+    };
+
+    /**
+     * Zero width positive lookbehind.
+     */
+    static class Behind extends Node {
+        Node cond;
+        int rmax, rmin;
+        Behind(Node cond, int rmax, int rmin) {
+            this.cond = cond;
+            this.rmax = rmax;
+            this.rmin = rmin;
+        }
+
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int savedFrom = matcher.from;
+            boolean conditionMatched = false;
+            int startIndex = (!matcher.transparentBounds) ?
+                             matcher.from : 0;
+            int from = Math.max(i - rmax, startIndex);
+            // Set end boundary
+            int savedLBT = matcher.lookbehindTo;
+            matcher.lookbehindTo = i;
+            // Relax transparent region boundaries for lookbehind
+            if (matcher.transparentBounds)
+                matcher.from = 0;
+            for (int j = i - rmin; !conditionMatched && j >= from; j--) {
+                conditionMatched = cond.match(matcher, j, seq);
+            }
+            matcher.from = savedFrom;
+            matcher.lookbehindTo = savedLBT;
+            return conditionMatched && next.match(matcher, i, seq);
+        }
+    }
+
+    /**
+     * Zero width positive lookbehind, including supplementary
+     * characters or unpaired surrogates.
+     */
+    static final class BehindS extends Behind {
+        BehindS(Node cond, int rmax, int rmin) {
+            super(cond, rmax, rmin);
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int rmaxChars = countChars(seq, i, -rmax);
+            int rminChars = countChars(seq, i, -rmin);
+            int savedFrom = matcher.from;
+            int startIndex = (!matcher.transparentBounds) ?
+                             matcher.from : 0;
+            boolean conditionMatched = false;
+            int from = Math.max(i - rmaxChars, startIndex);
+            // Set end boundary
+            int savedLBT = matcher.lookbehindTo;
+            matcher.lookbehindTo = i;
+            // Relax transparent region boundaries for lookbehind
+            if (matcher.transparentBounds)
+                matcher.from = 0;
+
+            for (int j = i - rminChars;
+                 !conditionMatched && j >= from;
+                 j -= j>from ? countChars(seq, j, -1) : 1) {
+                conditionMatched = cond.match(matcher, j, seq);
+            }
+            matcher.from = savedFrom;
+            matcher.lookbehindTo = savedLBT;
+            return conditionMatched && next.match(matcher, i, seq);
+        }
+    }
+
+    /**
+     * Zero width negative lookbehind.
+     */
+    static class NotBehind extends Node {
+        Node cond;
+        int rmax, rmin;
+        NotBehind(Node cond, int rmax, int rmin) {
+            this.cond = cond;
+            this.rmax = rmax;
+            this.rmin = rmin;
+        }
+
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int savedLBT = matcher.lookbehindTo;
+            int savedFrom = matcher.from;
+            boolean conditionMatched = false;
+            int startIndex = (!matcher.transparentBounds) ?
+                             matcher.from : 0;
+            int from = Math.max(i - rmax, startIndex);
+            matcher.lookbehindTo = i;
+            // Relax transparent region boundaries for lookbehind
+            if (matcher.transparentBounds)
+                matcher.from = 0;
+            for (int j = i - rmin; !conditionMatched && j >= from; j--) {
+                conditionMatched = cond.match(matcher, j, seq);
+            }
+            // Reinstate region boundaries
+            matcher.from = savedFrom;
+            matcher.lookbehindTo = savedLBT;
+            return !conditionMatched && next.match(matcher, i, seq);
+        }
+    }
+
+    /**
+     * Zero width negative lookbehind, including supplementary
+     * characters or unpaired surrogates.
+     */
+    static final class NotBehindS extends NotBehind {
+        NotBehindS(Node cond, int rmax, int rmin) {
+            super(cond, rmax, rmin);
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int rmaxChars = countChars(seq, i, -rmax);
+            int rminChars = countChars(seq, i, -rmin);
+            int savedFrom = matcher.from;
+            int savedLBT = matcher.lookbehindTo;
+            boolean conditionMatched = false;
+            int startIndex = (!matcher.transparentBounds) ?
+                             matcher.from : 0;
+            int from = Math.max(i - rmaxChars, startIndex);
+            matcher.lookbehindTo = i;
+            // Relax transparent region boundaries for lookbehind
+            if (matcher.transparentBounds)
+                matcher.from = 0;
+            for (int j = i - rminChars;
+                 !conditionMatched && j >= from;
+                 j -= j>from ? countChars(seq, j, -1) : 1) {
+                conditionMatched = cond.match(matcher, j, seq);
+            }
+            //Reinstate region boundaries
+            matcher.from = savedFrom;
+            matcher.lookbehindTo = savedLBT;
+            return !conditionMatched && next.match(matcher, i, seq);
+        }
+    }
+
+    /**
+     * Returns the set union of two CharProperty nodes.
+     */
+    private static CharProperty union(final CharProperty lhs,
+                                      final CharProperty rhs) {
+        return new CharProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return lhs.isSatisfiedBy(ch) || rhs.isSatisfiedBy(ch);}};
+    }
+
+    /**
+     * Returns the set intersection of two CharProperty nodes.
+     */
+    private static CharProperty intersection(final CharProperty lhs,
+                                             final CharProperty rhs) {
+        return new CharProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return lhs.isSatisfiedBy(ch) && rhs.isSatisfiedBy(ch);}};
+    }
+
+    /**
+     * Returns the set difference of two CharProperty nodes.
+     */
+    private static CharProperty setDifference(final CharProperty lhs,
+                                              final CharProperty rhs) {
+        return new CharProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return ! rhs.isSatisfiedBy(ch) && lhs.isSatisfiedBy(ch);}};
+    }
+
+    /**
+     * Handles word boundaries. Includes a field to allow this one class to
+     * deal with the different types of word boundaries we can match. The word
+     * characters include underscores, letters, and digits. Non spacing marks
+     * can are also part of a word if they have a base character, otherwise
+     * they are ignored for purposes of finding word boundaries.
+     */
+    static final class Bound extends Node {
+        static int LEFT = 0x1;
+        static int RIGHT= 0x2;
+        static int BOTH = 0x3;
+        static int NONE = 0x4;
+        int type;
+        Bound(int n) {
+            type = n;
+        }
+        int check(Matcher matcher, int i, CharSequence seq) {
+            int ch;
+            boolean left = false;
+            int startIndex = matcher.from;
+            int endIndex = matcher.to;
+            if (matcher.transparentBounds) {
+                startIndex = 0;
+                endIndex = matcher.getTextLength();
+            }
+            if (i > startIndex) {
+                ch = Character.codePointBefore(seq, i);
+                left = (ch == '_' || Character.isLetterOrDigit(ch) ||
+                    ((Character.getType(ch) == Character.NON_SPACING_MARK)
+                     && hasBaseCharacter(matcher, i-1, seq)));
+            }
+            boolean right = false;
+            if (i < endIndex) {
+                ch = Character.codePointAt(seq, i);
+                right = (ch == '_' || Character.isLetterOrDigit(ch) ||
+                    ((Character.getType(ch) == Character.NON_SPACING_MARK)
+                     && hasBaseCharacter(matcher, i, seq)));
+            } else {
+                // Tried to access char past the end
+                matcher.hitEnd = true;
+                // The addition of another char could wreck a boundary
+                matcher.requireEnd = true;
+            }
+            return ((left ^ right) ? (right ? LEFT : RIGHT) : NONE);
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            return (check(matcher, i, seq) & type) > 0
+                && next.match(matcher, i, seq);
+        }
+    }
+
+    /**
+     * Non spacing marks only count as word characters in bounds calculations
+     * if they have a base character.
+     */
+    private static boolean hasBaseCharacter(Matcher matcher, int i,
+                                            CharSequence seq)
+    {
+        int start = (!matcher.transparentBounds) ?
+            matcher.from : 0;
+        for (int x=i; x >= start; x--) {
+            int ch = Character.codePointAt(seq, x);
+            if (Character.isLetterOrDigit(ch))
+                return true;
+            if (Character.getType(ch) == Character.NON_SPACING_MARK)
+                continue;
+            return false;
+        }
+        return false;
+    }
+
+    /**
+     * Attempts to match a slice in the input using the Boyer-Moore string
+     * matching algorithm. The algorithm is based on the idea that the
+     * pattern can be shifted farther ahead in the search text if it is
+     * matched right to left.
+     * <p>
+     * The pattern is compared to the input one character at a time, from
+     * the rightmost character in the pattern to the left. If the characters
+     * all match the pattern has been found. If a character does not match,
+     * the pattern is shifted right a distance that is the maximum of two
+     * functions, the bad character shift and the good suffix shift. This
+     * shift moves the attempted match position through the input more
+     * quickly than a naive one position at a time check.
+     * <p>
+     * The bad character shift is based on the character from the text that
+     * did not match. If the character does not appear in the pattern, the
+     * pattern can be shifted completely beyond the bad character. If the
+     * character does occur in the pattern, the pattern can be shifted to
+     * line the pattern up with the next occurrence of that character.
+     * <p>
+     * The good suffix shift is based on the idea that some subset on the right
+     * side of the pattern has matched. When a bad character is found, the
+     * pattern can be shifted right by the pattern length if the subset does
+     * not occur again in pattern, or by the amount of distance to the
+     * next occurrence of the subset in the pattern.
+     *
+     * Boyer-Moore search methods adapted from code by Amy Yu.
+     */
+    static class BnM extends Node {
+        int[] buffer;
+        int[] lastOcc;
+        int[] optoSft;
+
+        /**
+         * Pre calculates arrays needed to generate the bad character
+         * shift and the good suffix shift. Only the last seven bits
+         * are used to see if chars match; This keeps the tables small
+         * and covers the heavily used ASCII range, but occasionally
+         * results in an aliased match for the bad character shift.
+         */
+        static Node optimize(Node node) {
+            if (!(node instanceof Slice)) {
+                return node;
+            }
+
+            int[] src = ((Slice) node).buffer;
+            int patternLength = src.length;
+            // The BM algorithm requires a bit of overhead;
+            // If the pattern is short don't use it, since
+            // a shift larger than the pattern length cannot
+            // be used anyway.
+            if (patternLength < 4) {
+                return node;
+            }
+            int i, j, k;
+            int[] lastOcc = new int[128];
+            int[] optoSft = new int[patternLength];
+            // Precalculate part of the bad character shift
+            // It is a table for where in the pattern each
+            // lower 7-bit value occurs
+            for (i = 0; i < patternLength; i++) {
+                lastOcc[src[i]&0x7F] = i + 1;
+            }
+            // Precalculate the good suffix shift
+            // i is the shift amount being considered
+NEXT:       for (i = patternLength; i > 0; i--) {
+                // j is the beginning index of suffix being considered
+                for (j = patternLength - 1; j >= i; j--) {
+                    // Testing for good suffix
+                    if (src[j] == src[j-i]) {
+                        // src[j..len] is a good suffix
+                        optoSft[j-1] = i;
+                    } else {
+                        // No match. The array has already been
+                        // filled up with correct values before.
+                        continue NEXT;
+                    }
+                }
+                // This fills up the remaining of optoSft
+                // any suffix can not have larger shift amount
+                // then its sub-suffix. Why???
+                while (j > 0) {
+                    optoSft[--j] = i;
+                }
+            }
+            // Set the guard value because of unicode compression
+            optoSft[patternLength-1] = 1;
+            if (node instanceof SliceS)
+                return new BnMS(src, lastOcc, optoSft, node.next);
+            return new BnM(src, lastOcc, optoSft, node.next);
+        }
+        BnM(int[] src, int[] lastOcc, int[] optoSft, Node next) {
+            this.buffer = src;
+            this.lastOcc = lastOcc;
+            this.optoSft = optoSft;
+            this.next = next;
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int[] src = buffer;
+            int patternLength = src.length;
+            int last = matcher.to - patternLength;
+
+            // Loop over all possible match positions in text
+NEXT:       while (i <= last) {
+                // Loop over pattern from right to left
+                for (int j = patternLength - 1; j >= 0; j--) {
+                    int ch = seq.charAt(i+j);
+                    if (ch != src[j]) {
+                        // Shift search to the right by the maximum of the
+                        // bad character shift and the good suffix shift
+                        i += Math.max(j + 1 - lastOcc[ch&0x7F], optoSft[j]);
+                        continue NEXT;
+                    }
+                }
+                // Entire pattern matched starting at i
+                matcher.first = i;
+                boolean ret = next.match(matcher, i + patternLength, seq);
+                if (ret) {
+                    matcher.first = i;
+                    matcher.groups[0] = matcher.first;
+                    matcher.groups[1] = matcher.last;
+                    return true;
+                }
+                i++;
+            }
+            // BnM is only used as the leading node in the unanchored case,
+            // and it replaced its Start() which always searches to the end
+            // if it doesn't find what it's looking for, so hitEnd is true.
+            matcher.hitEnd = true;
+            return false;
+        }
+        boolean study(TreeInfo info) {
+            info.minLength += buffer.length;
+            info.maxValid = false;
+            return next.study(info);
+        }
+    }
+
+    /**
+     * Supplementary support version of BnM(). Unpaired surrogates are
+     * also handled by this class.
+     */
+    static final class BnMS extends BnM {
+        int lengthInChars;
+
+        BnMS(int[] src, int[] lastOcc, int[] optoSft, Node next) {
+            super(src, lastOcc, optoSft, next);
+            for (int x = 0; x < buffer.length; x++) {
+                lengthInChars += Character.charCount(buffer[x]);
+            }
+        }
+        boolean match(Matcher matcher, int i, CharSequence seq) {
+            int[] src = buffer;
+            int patternLength = src.length;
+            int last = matcher.to - lengthInChars;
+
+            // Loop over all possible match positions in text
+NEXT:       while (i <= last) {
+                // Loop over pattern from right to left
+                int ch;
+                for (int j = countChars(seq, i, patternLength), x = patternLength - 1;
+                     j > 0; j -= Character.charCount(ch), x--) {
+                    ch = Character.codePointBefore(seq, i+j);
+                    if (ch != src[x]) {
+                        // Shift search to the right by the maximum of the
+                        // bad character shift and the good suffix shift
+                        int n = Math.max(x + 1 - lastOcc[ch&0x7F], optoSft[x]);
+                        i += countChars(seq, i, n);
+                        continue NEXT;
+                    }
+                }
+                // Entire pattern matched starting at i
+                matcher.first = i;
+                boolean ret = next.match(matcher, i + lengthInChars, seq);
+                if (ret) {
+                    matcher.first = i;
+                    matcher.groups[0] = matcher.first;
+                    matcher.groups[1] = matcher.last;
+                    return true;
+                }
+                i += countChars(seq, i, 1);
+            }
+            matcher.hitEnd = true;
+            return false;
+        }
+    }
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+    /**
+     *  This must be the very first initializer.
+     */
+    static Node accept = new Node();
+
+    static Node lastAccept = new LastNode();
+
+    private static class CharPropertyNames {
+
+        static CharProperty charPropertyFor(String name) {
+            CharPropertyFactory m = map.get(name);
+            return m == null ? null : m.make();
+        }
+
+        private static abstract class CharPropertyFactory {
+            abstract CharProperty make();
+        }
+
+        private static void defCategory(String name,
+                                        final int typeMask) {
+            map.put(name, new CharPropertyFactory() {
+                    CharProperty make() { return new Category(typeMask);}});
+        }
+
+        private static void defRange(String name,
+                                     final int lower, final int upper) {
+            map.put(name, new CharPropertyFactory() {
+                    CharProperty make() { return rangeFor(lower, upper);}});
+        }
+
+        private static void defCtype(String name,
+                                     final int ctype) {
+            map.put(name, new CharPropertyFactory() {
+                    CharProperty make() { return new Ctype(ctype);}});
+        }
+
+        private static abstract class CloneableProperty
+            extends CharProperty implements Cloneable
+        {
+            public CloneableProperty clone() {
+                try {
+                    return (CloneableProperty) super.clone();
+                } catch (CloneNotSupportedException e) {
+                    throw new AssertionError(e);
+                }
+            }
+        }
+
+        private static void defClone(String name,
+                                     final CloneableProperty p) {
+            map.put(name, new CharPropertyFactory() {
+                    CharProperty make() { return p.clone();}});
+        }
+
+        private static final HashMap<String, CharPropertyFactory> map
+            = new HashMap<String, CharPropertyFactory>();
+
+        static {
+            // Unicode character property aliases, defined in
+            // http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt
+            defCategory("Cn", 1<<Character.UNASSIGNED);
+            defCategory("Lu", 1<<Character.UPPERCASE_LETTER);
+            defCategory("Ll", 1<<Character.LOWERCASE_LETTER);
+            defCategory("Lt", 1<<Character.TITLECASE_LETTER);
+            defCategory("Lm", 1<<Character.MODIFIER_LETTER);
+            defCategory("Lo", 1<<Character.OTHER_LETTER);
+            defCategory("Mn", 1<<Character.NON_SPACING_MARK);
+            defCategory("Me", 1<<Character.ENCLOSING_MARK);
+            defCategory("Mc", 1<<Character.COMBINING_SPACING_MARK);
+            defCategory("Nd", 1<<Character.DECIMAL_DIGIT_NUMBER);
+            defCategory("Nl", 1<<Character.LETTER_NUMBER);
+            defCategory("No", 1<<Character.OTHER_NUMBER);
+            defCategory("Zs", 1<<Character.SPACE_SEPARATOR);
+            defCategory("Zl", 1<<Character.LINE_SEPARATOR);
+            defCategory("Zp", 1<<Character.PARAGRAPH_SEPARATOR);
+            defCategory("Cc", 1<<Character.CONTROL);
+            defCategory("Cf", 1<<Character.FORMAT);
+            defCategory("Co", 1<<Character.PRIVATE_USE);
+            defCategory("Cs", 1<<Character.SURROGATE);
+            defCategory("Pd", 1<<Character.DASH_PUNCTUATION);
+            defCategory("Ps", 1<<Character.START_PUNCTUATION);
+            defCategory("Pe", 1<<Character.END_PUNCTUATION);
+            defCategory("Pc", 1<<Character.CONNECTOR_PUNCTUATION);
+            defCategory("Po", 1<<Character.OTHER_PUNCTUATION);
+            defCategory("Sm", 1<<Character.MATH_SYMBOL);
+            defCategory("Sc", 1<<Character.CURRENCY_SYMBOL);
+            defCategory("Sk", 1<<Character.MODIFIER_SYMBOL);
+            defCategory("So", 1<<Character.OTHER_SYMBOL);
+            defCategory("Pi", 1<<Character.INITIAL_QUOTE_PUNCTUATION);
+            defCategory("Pf", 1<<Character.FINAL_QUOTE_PUNCTUATION);
+            defCategory("L", ((1<<Character.UPPERCASE_LETTER) |
+                              (1<<Character.LOWERCASE_LETTER) |
+                              (1<<Character.TITLECASE_LETTER) |
+                              (1<<Character.MODIFIER_LETTER)  |
+                              (1<<Character.OTHER_LETTER)));
+            defCategory("M", ((1<<Character.NON_SPACING_MARK) |
+                              (1<<Character.ENCLOSING_MARK)   |
+                              (1<<Character.COMBINING_SPACING_MARK)));
+            defCategory("N", ((1<<Character.DECIMAL_DIGIT_NUMBER) |
+                              (1<<Character.LETTER_NUMBER)        |
+                              (1<<Character.OTHER_NUMBER)));
+            defCategory("Z", ((1<<Character.SPACE_SEPARATOR) |
+                              (1<<Character.LINE_SEPARATOR)  |
+                              (1<<Character.PARAGRAPH_SEPARATOR)));
+            defCategory("C", ((1<<Character.CONTROL)     |
+                              (1<<Character.FORMAT)      |
+                              (1<<Character.PRIVATE_USE) |
+                              (1<<Character.SURROGATE))); // Other
+            defCategory("P", ((1<<Character.DASH_PUNCTUATION)      |
+                              (1<<Character.START_PUNCTUATION)     |
+                              (1<<Character.END_PUNCTUATION)       |
+                              (1<<Character.CONNECTOR_PUNCTUATION) |
+                              (1<<Character.OTHER_PUNCTUATION)     |
+                              (1<<Character.INITIAL_QUOTE_PUNCTUATION) |
+                              (1<<Character.FINAL_QUOTE_PUNCTUATION)));
+            defCategory("S", ((1<<Character.MATH_SYMBOL)     |
+                              (1<<Character.CURRENCY_SYMBOL) |
+                              (1<<Character.MODIFIER_SYMBOL) |
+                              (1<<Character.OTHER_SYMBOL)));
+            defCategory("LC", ((1<<Character.UPPERCASE_LETTER) |
+                               (1<<Character.LOWERCASE_LETTER) |
+                               (1<<Character.TITLECASE_LETTER)));
+            defCategory("LD", ((1<<Character.UPPERCASE_LETTER) |
+                               (1<<Character.LOWERCASE_LETTER) |
+                               (1<<Character.TITLECASE_LETTER) |
+                               (1<<Character.MODIFIER_LETTER)  |
+                               (1<<Character.OTHER_LETTER)     |
+                               (1<<Character.DECIMAL_DIGIT_NUMBER)));
+            defRange("L1", 0x00, 0xFF); // Latin-1
+            map.put("all", new CharPropertyFactory() {
+                    CharProperty make() { return new All(); }});
+
+            // Posix regular expression character classes, defined in
+            // http://www.unix.org/onlinepubs/009695399/basedefs/xbd_chap09.html
+            defRange("ASCII", 0x00, 0x7F);   // ASCII
+            defCtype("Alnum", ASCII.ALNUM);  // Alphanumeric characters
+            defCtype("Alpha", ASCII.ALPHA);  // Alphabetic characters
+            defCtype("Blank", ASCII.BLANK);  // Space and tab characters
+            defCtype("Cntrl", ASCII.CNTRL);  // Control characters
+            defRange("Digit", '0', '9');     // Numeric characters
+            defCtype("Graph", ASCII.GRAPH);  // printable and visible
+            defRange("Lower", 'a', 'z');     // Lower-case alphabetic
+            defRange("Print", 0x20, 0x7E);   // Printable characters
+            defCtype("Punct", ASCII.PUNCT);  // Punctuation characters
+            defCtype("Space", ASCII.SPACE);  // Space characters
+            defRange("Upper", 'A', 'Z');     // Upper-case alphabetic
+            defCtype("XDigit",ASCII.XDIGIT); // hexadecimal digits
+
+            // Java character properties, defined by methods in Character.java
+            defClone("javaLowerCase", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isLowerCase(ch);}});
+            defClone("javaUpperCase", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isUpperCase(ch);}});
+            defClone("javaTitleCase", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isTitleCase(ch);}});
+            defClone("javaDigit", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isDigit(ch);}});
+            defClone("javaDefined", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isDefined(ch);}});
+            defClone("javaLetter", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isLetter(ch);}});
+            defClone("javaLetterOrDigit", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isLetterOrDigit(ch);}});
+            defClone("javaJavaIdentifierStart", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isJavaIdentifierStart(ch);}});
+            defClone("javaJavaIdentifierPart", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isJavaIdentifierPart(ch);}});
+            defClone("javaUnicodeIdentifierStart", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isUnicodeIdentifierStart(ch);}});
+            defClone("javaUnicodeIdentifierPart", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isUnicodeIdentifierPart(ch);}});
+            defClone("javaIdentifierIgnorable", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isIdentifierIgnorable(ch);}});
+            defClone("javaSpaceChar", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isSpaceChar(ch);}});
+            defClone("javaWhitespace", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isWhitespace(ch);}});
+            defClone("javaISOControl", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isISOControl(ch);}});
+            defClone("javaMirrored", new CloneableProperty() {
+                boolean isSatisfiedBy(int ch) {
+                    return Character.isMirrored(ch);}});
+        }
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/PatternSyntaxException.java phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/PatternSyntaxException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/PatternSyntaxException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/builtinsage/regex/PatternSyntaxException.java	2010-02-05 14:24:15.000000000 -0500
@@ -0,0 +1,123 @@
+/*
+ * Copyright 1999-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.util.regex;
+
+import sun.security.action.GetPropertyAction;
+
+
+/**
+ * Unchecked exception thrown to indicate a syntax error in a
+ * regular-expression pattern.
+ *
+ * @author  unascribed
+ * @since 1.4
+ * @spec JSR-51
+ */
+
+public class PatternSyntaxException
+    extends IllegalArgumentException
+{
+
+    private final String desc;
+    private final String pattern;
+    private final int index;
+
+    /**
+     * Constructs a new instance of this class.
+     *
+     * @param  desc
+     *         A description of the error
+     *
+     * @param  regex
+     *         The erroneous pattern
+     *
+     * @param  index
+     *         The approximate index in the pattern of the error,
+     *         or <tt>-1</tt> if the index is not known
+     */
+    public PatternSyntaxException(String desc, String regex, int index) {
+        this.desc = desc;
+        this.pattern = regex;
+        this.index = index;
+    }
+
+    /**
+     * Retrieves the error index.
+     *
+     * @return  The approximate index in the pattern of the error,
+     *         or <tt>-1</tt> if the index is not known
+     */
+    public int getIndex() {
+        return index;
+    }
+
+    /**
+     * Retrieves the description of the error.
+     *
+     * @return  The description of the error
+     */
+    public String getDescription() {
+        return desc;
+    }
+
+    /**
+     * Retrieves the erroneous regular-expression pattern.
+     *
+     * @return  The erroneous pattern
+     */
+    public String getPattern() {
+        return pattern;
+    }
+
+    private static final String nl =
+        java.security.AccessController
+            .doPrivileged(new GetPropertyAction("line.separator"));
+
+    /**
+     * Returns a multi-line string containing the description of the syntax
+     * error and its index, the erroneous regular-expression pattern, and a
+     * visual indication of the error index within the pattern.
+     *
+     * @return  The full detail message
+     */
+    public String getMessage() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(desc);
+        if (index >= 0) {
+            sb.append(" near index ");
+            sb.append(index);
+        }
+        sb.append(nl);
+        sb.append(pattern);
+        if (index >= 0) {
+            sb.append(nl);
+            for (int i = 0; i < index; i++) sb.append(' ');
+            sb.append('^');
+        }
+        return sb.toString();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/GNUmakefile phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/GNUmakefile
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/linux-mips-testsigmafloat/GNUmakefile	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/build/linux-mips-testsigmafloat/GNUmakefile	2010-02-05 15:27:32.000000000 -0500
@@ -0,0 +1,74 @@
+#
+# Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
+# 
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License version
+# 2 only, as published by the Free Software Foundation. 
+# 
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License version 2 for more details (a copy is
+# included at /legal/license.txt). 
+# 
+# You should have received a copy of the GNU General Public License
+# version 2 along with this work; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+# 02110-1301 USA 
+# 
+# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+# Clara, CA 95054 or visit www.sun.com if you need additional
+# information or have any questions. 
+#
+# @(#)GNUmakefile	1.6 06/10/10
+#
+
+#
+# GNUmakefile for linux-arm-strongarm target using GCC 3.x and VFP
+#
+
+#
+# platform specific architecture flags
+#
+# NOTE: -msoft-float is enabled in linux-arm/defs.mk automatically if
+# CVM_FORCE_HARD_FLOAT is not true, which is the default.
+#
+CVM_FORCE_HARD_FLOAT	= true
+ASM_ARCH_FLAGS		= -EL -mips32r2
+CC_ARCH_FLAGS		= -EL -mips32r2
+CC_ARCH_FLAGS_FDLIB	=
+CC_ARCH_FLAGS_LOOP 	=
+LINK_ARCH_FLAGS		= -EL
+LINK_ARCH_LIBS		= -lm
+
+# assume the JIT is enabled for this device unless told otherwise
+CVM_JIT ?= true
+CVM_JIT_USE_FP_HARDWARE ?= true
+#CVM_JIT_PROFILE ?= true
+#CVM_TRACE_JIT ?= true
+#CVM_DEBUG ?= true
+
+CVM_JCC_INPUT +=  builtinsage/KeyEvent.class
+CVM_JCC_INPUT +=  builtinsage/regex/ASCII.class
+CVM_JCC_INPUT +=  builtinsage/regex/MatchResult.class
+CVM_JCC_INPUT +=  builtinsage/regex/Matcher.class
+CVM_JCC_INPUT +=  builtinsage/regex/Pattern.class
+CVM_JCC_INPUT +=  builtinsage/regex/PatternSyntaxException.class
+
+#CVM_SRCDIRS += builtinsage
+#CVM_BUILDDIRS += builtinsage
+#CLASSLIB_CLASSES = java.awt.event.KeyEvent
+
+CCFLAGS_SPEED_OPTIONS ?= -Os
+CCFLAGS_SPACE_OPTIONS ?= -Os
+
+USE_VERBOSE_MAKE = true
+
+# Need to figure out how to make it not produce StringBuilder...
+JAVAC_SOURCE_TARGET_OPTIONS = -source 1.4 -target 1.5
+
+# Only enable USE_GCC2 if GCC 3.x or later is *not* being used
+# USE_GCC2 ?= false
+
+include ../share/top.mk
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/share/defs_cdc.mk phoneme_advanced-mr2-dev-b122/cdc/build/share/defs_cdc.mk
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/share/defs_cdc.mk	2009-07-06 18:35:02.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/build/share/defs_cdc.mk	2009-07-06 19:35:51.000000000 -0400
@@ -496,6 +496,101 @@
     com.sun.cdc.config.PropertyProviderAdapter \
     com.sun.cdc.config.DynamicProperties \
     com.sun.cdc.config.PackageManager \
+	java.nio.Bits \
+	java.nio.Buffer \
+	java.nio.ByteOrder \
+	java.nio.MappedByteBuffer \
+	\
+	java.nio.channels.ByteChannel \
+	java.nio.channels.Channel \
+	java.nio.channels.Channels \
+	java.nio.channels.FileChannel \
+	java.nio.channels.FileLock \
+	java.nio.channels.GatheringByteChannel \
+	java.nio.channels.InterruptibleChannel \
+	java.nio.channels.ReadableByteChannel \
+	java.nio.channels.ScatteringByteChannel \
+	java.nio.channels.SelectableChannel \
+	java.nio.channels.Selector \
+	java.nio.channels.SelectionKey \
+	java.nio.channels.ServerSocketChannel \
+	java.nio.channels.SocketChannel \
+	java.nio.channels.WritableByteChannel \
+	\
+	java.nio.channels.spi.AbstractInterruptibleChannel \
+	java.nio.channels.spi.AbstractSelectableChannel \
+	java.nio.channels.spi.AbstractSelectionKey \
+	java.nio.channels.spi.AbstractSelector \
+	java.nio.channels.spi.SelectorProvider \
+	\
+	sun.nio.ByteBuffered \
+	\
+        sun.nio.ch.AbstractPollArrayWrapper \
+	sun.nio.ch.AllocatedNativeObject \
+	sun.nio.ch.ChannelInputStream \
+        sun.nio.ch.DefaultSelectorProvider \
+	sun.nio.ch.DirectBuffer \
+	sun.nio.ch.FileChannelImpl \
+	sun.nio.ch.FileDispatcher \
+	sun.nio.ch.FileKey \
+	sun.nio.ch.Interruptible \
+	sun.nio.ch.IOUtil \
+	sun.nio.ch.IOStatus \
+	sun.nio.ch.IOVecWrapper \
+	sun.nio.ch.NativeDispatcher \
+	sun.nio.ch.NativeObject \
+	sun.nio.ch.NativeThread \
+	sun.nio.ch.NativeThreadSet \
+	sun.nio.ch.Net \
+	sun.nio.ch.OptionAdaptor \
+	sun.nio.ch.PollArrayWrapper \
+	sun.nio.ch.Reflect \
+	sun.nio.ch.SelectionKeyImpl \
+	sun.nio.ch.SelectorImpl \
+	sun.nio.ch.SelectorProviderImpl \
+	sun.nio.ch.SelChImpl \
+	sun.nio.ch.ServerSocketAdaptor \
+	sun.nio.ch.ServerSocketChannelImpl \
+	sun.nio.ch.SocketAdaptor \
+	sun.nio.ch.SocketChannelImpl \
+	sun.nio.ch.SocketDispatcher \
+	sun.nio.ch.SocketOpts \
+	sun.nio.ch.SocketOptsImpl \
+	sun.nio.ch.Util \
+	\
+	sun.misc.Cleaner \
+	java.nio.ByteBuffer \
+	\
+	java.nio.HeapByteBuffer \
+	java.nio.HeapByteBufferR \
+	\
+	java.nio.DirectByteBuffer \
+	java.nio.DirectByteBufferR \
+	\
+	java.nio.BufferOverflowException \
+	java.nio.BufferUnderflowException \
+	java.nio.InvalidMarkException \
+	java.nio.ReadOnlyBufferException \
+	\
+	java.nio.channels.AlreadyConnectedException \
+	java.nio.channels.AsynchronousCloseException \
+	java.nio.channels.ClosedByInterruptException \
+	java.nio.channels.ClosedChannelException \
+	java.nio.channels.ClosedSelectorException \
+	java.nio.channels.ConnectionPendingException \
+	java.nio.channels.FileLockInterruptionException \
+	java.nio.channels.IllegalBlockingModeException \
+	java.nio.channels.IllegalSelectorException \
+	java.nio.channels.NoConnectionPendingException \
+	java.nio.channels.NonReadableChannelException \
+	java.nio.channels.NonWritableChannelException \
+	java.nio.channels.NotYetBoundException \
+	java.nio.channels.NotYetConnectedException \
+	java.nio.channels.OverlappingFileLockException \
+	java.nio.channels.UnresolvedAddressException \
+	java.nio.channels.UnsupportedAddressTypeException \
+	\
+	sun.nio.ch.AlreadyBoundException
 
 ifeq ($(CVM_REFLECT), true)
 CVM_BUILDTIME_CLASSES += \
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/share/defs.mk phoneme_advanced-mr2-dev-b122/cdc/build/share/defs.mk
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/share/defs.mk	2009-07-06 18:35:02.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/build/share/defs.mk	2010-02-05 14:15:14.000000000 -0500
@@ -1392,6 +1392,9 @@
 	$(CVM_SHAREROOT)/native/java/util/zip \
 	$(CVM_SHAREROOT)/native/java/util/zip/zlib-1.1.3 \
 	$(CVM_SHAREROOT)/native/sun/misc \
+	$(CVM_SHAREROOT)/native/java/nio \
+	$(CVM_SHAREROOT)/native/sun/nio \
+	$(CVM_SHAREROOT)/native/sun/nio/ch \
 
 ifeq ($(CVM_LVM), true)
 CVM_SRCDIRS += \
@@ -1481,6 +1484,7 @@
 	$(CVM_SHAREROOT)/native/java/util/zip \
 	$(CVM_SHAREROOT)/native/java/util/zip/zlib-1.1.3 \
 	$(CVM_DERIVEDROOT)/jni \
+	$(CVM_SHAREROOT)/native/sun/nio/ch \
 
 ifneq ($(KBENCH_JAR),)
 CVM_TEST_JARFILES += $(KBENCH_JAR)
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/build/share/defs_op.mk phoneme_advanced-mr2-dev-b122/cdc/build/share/defs_op.mk
--- phoneme_advanced-mr2-dev-b122-ori/cdc/build/share/defs_op.mk	2009-07-06 18:35:02.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/build/share/defs_op.mk	2009-07-27 19:49:49.000000000 -0400
@@ -119,13 +119,13 @@
 endif
 ABSTRACTIONS_MAKE_FILE = $($(JSROP_ABSTR_DIR))/build/$(SUBSYSTEM_MAKE_FILE)
 ifeq ($(wildcard $(ABSTRACTIONS_MAKE_FILE)),)
-$(error $(JSROP_ABSTR_DIR) must point to a directory containing JSROP abstractions sources)
+$(error $(JSROP_ABSTR_DIR) $(COMPONENTS_DIR) must point to a directory containing JSROP abstractions sources)
 endif
 include $(ABSTRACTIONS_MAKE_FILE)
 
 JSROP_JARS=$(ABSTRACTIONS_JAR) $(JSROP_BUILD_JARS)
 # abstractions required javacall types
-CVM_INCLUDE_JAVACALL=true
+#CVM_INCLUDE_JAVACALL=true
 endif
 
 # Include JSR 75
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/DatagramDispatcher.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/DatagramDispatcher.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/DatagramDispatcher.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/DatagramDispatcher.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2001-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+import java.net.*;
+
+/**
+ * Allows different platforms to call different native methods
+ * for read and write operations.
+ */
+
+class DatagramDispatcher extends NativeDispatcher
+{
+    static {
+        Util.load();
+    }
+
+    int read(FileDescriptor fd, long address, int len) throws IOException {
+        return read0(fd, address, len);
+    }
+
+    long readv(FileDescriptor fd, long address, int len) throws IOException {
+        return readv0(fd, address, len);
+    }
+
+    int write(FileDescriptor fd, long address, int len) throws IOException {
+        return write0(fd, address, len);
+    }
+
+    long writev(FileDescriptor fd, long address, int len) throws IOException {
+        return writev0(fd, address, len);
+    }
+
+    void close(FileDescriptor fd) throws IOException {
+        FileDispatcher.close0(fd);
+    }
+
+    void preClose(FileDescriptor fd) throws IOException {
+        FileDispatcher.preClose0(fd);
+    }
+
+    static native int read0(FileDescriptor fd, long address, int len)
+        throws IOException;
+
+    static native long readv0(FileDescriptor fd, long address, int len)
+        throws IOException;
+
+    static native int write0(FileDescriptor fd, long address, int len)
+        throws IOException;
+
+    static native long writev0(FileDescriptor fd, long address, int len)
+        throws IOException;
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/DefaultSelectorProvider.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/DefaultSelectorProvider.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/DefaultSelectorProvider.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/DefaultSelectorProvider.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2001-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.nio.channels.spi.SelectorProvider;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import sun.security.action.GetPropertyAction;
+
+/**
+ * Creates this platform's default SelectorProvider
+ */
+
+public class DefaultSelectorProvider {
+
+    /**
+     * Prevent instantiation.
+     */
+    private DefaultSelectorProvider() { }
+
+    /**
+     * Returns the default SelectorProvider.
+     */
+    public static SelectorProvider create() {
+        String osname = AccessController.doPrivileged(
+            new GetPropertyAction("os.name"));
+        if ("SunOS".equals(osname)) {
+            return new sun.nio.ch.DevPollSelectorProvider();
+        }
+
+        // use EPollSelectorProvider for Linux kernels >= 2.6
+        if ("Linux".equals(osname)) {
+            String osversion = AccessController.doPrivileged(
+                new GetPropertyAction("os.version"));
+            String[] vers = osversion.split("\\.", 0);
+            if (vers.length >= 2) {
+                try {
+                    int major = Integer.parseInt(vers[0]);
+                    int minor = Integer.parseInt(vers[1]);
+                    if (major > 2 || (major == 2 && minor >= 6)) {
+                        return new sun.nio.ch.EPollSelectorProvider();
+                    }
+                } catch (NumberFormatException x) {
+                    // format not recognized
+                }
+            }
+        }
+
+        return new sun.nio.ch.PollSelectorProvider();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/DevPollArrayWrapper.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/DevPollArrayWrapper.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/DevPollArrayWrapper.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/DevPollArrayWrapper.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,284 @@
+/*
+ * Copyright 2001-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import sun.misc.*;
+import java.io.IOException;
+import java.util.LinkedList;
+
+
+/**
+ * Manipulates a native array of pollfd structs on Solaris:
+ *
+ * typedef struct pollfd {
+ *    int fd;
+ *    short events;
+ *    short revents;
+ * } pollfd_t;
+ *
+ * @author Mike McCloskey
+ * @since 1.4
+ */
+
+class DevPollArrayWrapper {
+
+    // Event masks
+    static final short POLLIN       = 0x0001;
+    static final short POLLPRI      = 0x0002;
+    static final short POLLOUT      = 0x0004;
+    static final short POLLRDNORM   = 0x0040;
+    static final short POLLWRNORM   = POLLOUT;
+    static final short POLLRDBAND   = 0x0080;
+    static final short POLLWRBAND   = 0x0100;
+    static final short POLLNORM     = POLLRDNORM;
+    static final short POLLERR      = 0x0008;
+    static final short POLLHUP      = 0x0010;
+    static final short POLLNVAL     = 0x0020;
+    static final short POLLREMOVE   = 0x0800;
+    static final short POLLCONN     = POLLOUT;
+
+    // Miscellaneous constants
+    static final short SIZE_POLLFD   = 8;
+    static final short FD_OFFSET     = 0;
+    static final short EVENT_OFFSET  = 4;
+    static final short REVENT_OFFSET = 6;
+
+    // Maximum number of open file descriptors
+    static final int   OPEN_MAX      = fdLimit();
+
+    // Number of pollfd structures to create.
+    // DP_POLL ioctl allows up to OPEN_MAX-1
+    static final int   NUM_POLLFDS   = Math.min(OPEN_MAX-1, 8192);
+
+    // Base address of the native pollArray
+    private long pollArrayAddress;
+
+    // Maximum number of POLL_FD structs to update at once
+    private int MAX_UPDATE_SIZE = 10000;
+
+    DevPollArrayWrapper() {
+        int allocationSize = NUM_POLLFDS * SIZE_POLLFD;
+        pollArray = new AllocatedNativeObject(allocationSize, true);
+        pollArrayAddress = pollArray.address();
+        wfd = init();
+
+        for (int i=0; i<NUM_POLLFDS; i++) {
+            putDescriptor(i, 0);
+            putEventOps(i, 0);
+            putReventOps(i, 0);
+        }
+    }
+
+    // Machinery for remembering fd registration changes
+    // A hashmap could be used but the number of changes pending
+    // is expected to be small
+    private static class Updator {
+        int fd;
+        int mask;
+        Updator(int fd, int mask) {
+            this.fd = fd;
+            this.mask = mask;
+        }
+    }
+    private LinkedList<Updator> updateList = new LinkedList<Updator>();
+
+    // The pollfd array for results from devpoll driver
+    private AllocatedNativeObject pollArray;
+
+    // The fd of the devpoll driver
+    int wfd;
+
+    // The fd of the interrupt line going out
+    int outgoingInterruptFD;
+
+    // The fd of the interrupt line coming in
+    int incomingInterruptFD;
+
+    // The index of the interrupt FD
+    int interruptedIndex;
+
+    // Number of updated pollfd entries
+    int updated;
+
+    void initInterrupt(int fd0, int fd1) {
+        outgoingInterruptFD = fd1;
+        incomingInterruptFD = fd0;
+        register(wfd, fd0, POLLIN);
+    }
+
+    void putEventOps(int i, int event) {
+        int offset = SIZE_POLLFD * i + EVENT_OFFSET;
+        pollArray.putShort(offset, (short)event);
+    }
+
+    void putReventOps(int i, int revent) {
+        int offset = SIZE_POLLFD * i + REVENT_OFFSET;
+        pollArray.putShort(offset, (short)revent);
+    }
+
+    void putDescriptor(int i, int fd) {
+        int offset = SIZE_POLLFD * i + FD_OFFSET;
+        pollArray.putInt(offset, fd);
+    }
+
+    int getEventOps(int i) {
+        int offset = SIZE_POLLFD * i + EVENT_OFFSET;
+        return pollArray.getShort(offset);
+    }
+
+    int getReventOps(int i) {
+        int offset = SIZE_POLLFD * i + REVENT_OFFSET;
+        return pollArray.getShort(offset);
+    }
+
+    int getDescriptor(int i) {
+        int offset = SIZE_POLLFD * i + FD_OFFSET;
+        return pollArray.getInt(offset);
+    }
+
+    void setInterest(int fd, int mask) {
+        synchronized (updateList) {
+            updateList.add(new Updator(fd, mask));
+        }
+    }
+
+    void release(int fd) {
+        synchronized (updateList) {
+            updateList.add(new Updator(fd, POLLREMOVE));
+        }
+    }
+
+    void closeDevPollFD() throws IOException {
+        FileDispatcher.closeIntFD(wfd);
+        pollArray.free();
+    }
+
+    int poll(long timeout) {
+        updateRegistrations();
+        updated = poll0(pollArrayAddress, NUM_POLLFDS, timeout, wfd);
+        for (int i=0; i<updated; i++) {
+            if (getDescriptor(i) == incomingInterruptFD) {
+                interruptedIndex = i;
+                interrupted = true;
+                break;
+            }
+        }
+        return updated;
+    }
+
+    void updateRegistrations() {
+        // take snapshot of the updateList size to see if there are
+        // any registrations to update
+        int updateSize;
+        synchronized (updateList) {
+            updateSize = updateList.size();
+        }
+        if (updateSize > 0) {
+            // Construct a pollfd array with updated masks; we may overallocate
+            // by some amount because if the events are already POLLREMOVE
+            // then the second pollfd of that pair will not be needed. The
+            // number of entries is limited to a reasonable number to avoid
+            // allocating a lot of memory.
+            int maxUpdates = Math.min(updateSize * 2, MAX_UPDATE_SIZE);
+            int allocationSize =  maxUpdates * SIZE_POLLFD;
+            AllocatedNativeObject updatePollArray =
+                new AllocatedNativeObject(allocationSize, true);
+
+            try {
+                synchronized (updateList) {
+                    while (updateList.size() > 0) {
+                        // We have to insert a dummy node in between each
+                        // real update to use POLLREMOVE on the fd first because
+                        // otherwise the changes are simply OR'd together
+                        int index = 0;
+                        Updator u = null;
+                        while ((u = updateList.poll()) != null) {
+                            // First add pollfd struct to clear out this fd
+                            putPollFD(updatePollArray, index, u.fd, POLLREMOVE);
+                            index++;
+                            // Now add pollfd to update this fd, if necessary
+                            if (u.mask != POLLREMOVE) {
+                                putPollFD(updatePollArray, index, u.fd,
+                                          (short)u.mask);
+                                index++;
+                            }
+
+                            // Check against the max allocation size; these are
+                            // all we will process. Valid index ranges from 0 to
+                            // (maxUpdates - 1) and we can use up to 2 per loop
+                            if (index > maxUpdates - 2)
+                                break;
+                        }
+                        // Register the changes with /dev/poll
+                        registerMultiple(wfd, updatePollArray.address(), index);
+                     }
+                }
+            } finally {
+                // Free the native array
+                updatePollArray.free();
+                // BUG: If an exception was thrown then the selector now believes
+                // that the last set of changes was updated but it probably
+                // was not. This should not be a likely occurrence.
+            }
+        }
+    }
+
+    private void putPollFD(AllocatedNativeObject array, int index, int fd,
+                           short event)
+    {
+        int structIndex = SIZE_POLLFD * index;
+        array.putInt(structIndex + FD_OFFSET, fd);
+        array.putShort(structIndex + EVENT_OFFSET, event);
+        array.putShort(structIndex + REVENT_OFFSET, (short)0);
+    }
+
+    boolean interrupted = false;
+
+    public void interrupt() {
+        interrupt(outgoingInterruptFD);
+    }
+
+    public int interruptedIndex() {
+        return interruptedIndex;
+    }
+
+    boolean interrupted() {
+        return interrupted;
+    }
+
+    void clearInterrupted() {
+        interrupted = false;
+    }
+
+    private native int init();
+    private native void register(int wfd, int fd, int mask);
+    private native void registerMultiple(int wfd, long address, int len);
+    private native int poll0(long pollAddress, int numfds, long timeout,
+                             int wfd);
+    private static native void interrupt(int fd);
+    private static native int fdLimit();
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/DevPollSelectorImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/DevPollSelectorImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/DevPollSelectorImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/DevPollSelectorImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,211 @@
+/*
+ * Copyright 2001-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.util.*;
+import sun.misc.*;
+
+
+/**
+ * An implementation of Selector for Solaris.
+ */
+class DevPollSelectorImpl
+    extends SelectorImpl
+{
+
+    // File descriptors used for interrupt
+    protected int fd0;
+    protected int fd1;
+
+    // The poll object
+    DevPollArrayWrapper pollWrapper;
+
+    // The number of valid channels in this Selector's poll array
+    private int totalChannels;
+
+    // Maps from file descriptors to keys
+    private Map<Integer,SelectionKeyImpl> fdToKey;
+
+    // True if this Selector has been closed
+    private boolean closed = false;
+
+    // Lock for interrupt triggering and clearing
+    private Object interruptLock = new Object();
+    private boolean interruptTriggered = false;
+
+    /**
+     * Package private constructor called by factory method in
+     * the abstract superclass Selector.
+     */
+    DevPollSelectorImpl(SelectorProvider sp) {
+        super(sp);
+        int[] fdes = new int[2];
+        IOUtil.initPipe(fdes, false);
+        fd0 = fdes[0];
+        fd1 = fdes[1];
+        pollWrapper = new DevPollArrayWrapper();
+        pollWrapper.initInterrupt(fd0, fd1);
+        fdToKey = new HashMap<Integer,SelectionKeyImpl>();
+        totalChannels = 1;
+    }
+
+    protected int doSelect(long timeout)
+        throws IOException
+    {
+        if (closed)
+            throw new ClosedSelectorException();
+        processDeregisterQueue();
+        try {
+            begin();
+            pollWrapper.poll(timeout);
+        } finally {
+            end();
+        }
+        processDeregisterQueue();
+        int numKeysUpdated = updateSelectedKeys();
+        if (pollWrapper.interrupted()) {
+            // Clear the wakeup pipe
+            pollWrapper.putReventOps(pollWrapper.interruptedIndex(), 0);
+            synchronized (interruptLock) {
+                pollWrapper.clearInterrupted();
+                IOUtil.drain(fd0);
+                interruptTriggered = false;
+            }
+        }
+        return numKeysUpdated;
+    }
+
+    /**
+     * Update the keys whose fd's have been selected by the devpoll
+     * driver. Add the ready keys to the ready queue.
+     */
+    private int updateSelectedKeys() {
+        int entries = pollWrapper.updated;
+        int numKeysUpdated = 0;
+        for (int i=0; i<entries; i++) {
+            int nextFD = pollWrapper.getDescriptor(i);
+            SelectionKeyImpl ski = fdToKey.get(Integer.valueOf(nextFD));
+            // ski is null in the case of an interrupt
+            if (ski != null) {
+                int rOps = pollWrapper.getReventOps(i);
+                if (selectedKeys.contains(ski)) {
+                    if (ski.channel.translateAndSetReadyOps(rOps, ski)) {
+                        numKeysUpdated++;
+                    }
+                } else {
+                    ski.channel.translateAndSetReadyOps(rOps, ski);
+                    if ((ski.nioReadyOps() & ski.nioInterestOps()) != 0) {
+                        selectedKeys.add(ski);
+                        numKeysUpdated++;
+                    }
+                }
+            }
+        }
+        return numKeysUpdated;
+    }
+
+    protected void implClose() throws IOException {
+        if (!closed) {
+            closed = true;
+
+            // prevent further wakeup
+            synchronized (interruptLock) {
+                interruptTriggered = true;
+            }
+
+            FileDispatcher.closeIntFD(fd0);
+            FileDispatcher.closeIntFD(fd1);
+            if (pollWrapper != null) {
+
+                pollWrapper.release(fd0);
+                pollWrapper.closeDevPollFD();
+                pollWrapper = null;
+                selectedKeys = null;
+
+                // Deregister channels
+                Iterator i = keys.iterator();
+                while (i.hasNext()) {
+                    SelectionKeyImpl ski = (SelectionKeyImpl)i.next();
+                    deregister(ski);
+                    SelectableChannel selch = ski.channel();
+                    if (!selch.isOpen() && !selch.isRegistered())
+                        ((SelChImpl)selch).kill();
+                    i.remove();
+                }
+                totalChannels = 0;
+
+            }
+            fd0 = -1;
+            fd1 = -1;
+        }
+    }
+
+    protected void implRegister(SelectionKeyImpl ski) {
+        int fd = IOUtil.fdVal(ski.channel.getFD());
+        fdToKey.put(Integer.valueOf(fd), ski);
+        totalChannels++;
+        keys.add(ski);
+    }
+
+    protected void implDereg(SelectionKeyImpl ski) throws IOException {
+        int i = ski.getIndex();
+        assert (i >= 0);
+        int fd = ski.channel.getFDVal();
+        fdToKey.remove(Integer.valueOf(fd));
+        pollWrapper.release(fd);
+        totalChannels--;
+        ski.setIndex(-1);
+        keys.remove(ski);
+        selectedKeys.remove(ski);
+        deregister((AbstractSelectionKey)ski);
+        SelectableChannel selch = ski.channel();
+        if (!selch.isOpen() && !selch.isRegistered())
+            ((SelChImpl)selch).kill();
+    }
+
+    void putEventOps(SelectionKeyImpl sk, int ops) {
+        int fd = IOUtil.fdVal(sk.channel.getFD());
+        pollWrapper.setInterest(fd, ops);
+    }
+
+    public Selector wakeup() {
+        synchronized (interruptLock) {
+            if (!interruptTriggered) {
+                pollWrapper.interrupt();
+                interruptTriggered = true;
+            }
+        }
+        return this;
+    }
+
+    static {
+        Util.load();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/EPollArrayWrapper.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/EPollArrayWrapper.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/EPollArrayWrapper.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/EPollArrayWrapper.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,286 @@
+/*
+ * Copyright 2005-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.HashSet;
+
+/**
+ * Manipulates a native array of epoll_event structs on Linux:
+ *
+ * typedef union epoll_data {
+ *     void *ptr;
+ *     int fd;
+ *     __uint32_t u32;
+ *     __uint64_t u64;
+ *  } epoll_data_t;
+ *
+ * struct epoll_event {
+ *     __uint32_t events;
+ *     epoll_data_t data;
+ * };
+ *
+ * The system call to wait for I/O events is epoll_wait(2). It populates an
+ * array of epoll_event structures that are passed to the call. The data
+ * member of the epoll_event structure contains the same data as was set
+ * when the file descriptor was registered to epoll via epoll_ctl(2). In
+ * this implementation we set data.fd to be the file descriptor that we
+ * register. That way, we have the file descriptor available when we
+ * process the events.
+ *
+ * All file descriptors registered with epoll have the POLLHUP and POLLERR
+ * events enabled even when registered with an event set of 0. To ensure
+ * that epoll_wait doesn't poll an idle file descriptor when the underlying
+ * connection is closed or reset then its registration is deleted from
+ * epoll (it will be re-added again if the event set is changed)
+ */
+
+class EPollArrayWrapper {
+    // EPOLL_EVENTS
+    static final int EPOLLIN      = 0x001;
+
+    // opcodes
+    static final int EPOLL_CTL_ADD      = 1;
+    static final int EPOLL_CTL_DEL      = 2;
+    static final int EPOLL_CTL_MOD      = 3;
+
+    // Miscellaneous constants
+    static final short SIZE_EPOLLEVENT  = 12;
+    static final short EVENT_OFFSET     = 0;
+    static final short DATA_OFFSET      = 4;
+    static final short FD_OFFSET        = 4;
+    static final int   NUM_EPOLLEVENTS  = Math.min(fdLimit(), 8192);
+
+    // Base address of the native pollArray
+    private final long pollArrayAddress;
+
+    // Set of "idle" file descriptors
+    private final HashSet<Integer> idleSet;
+
+    EPollArrayWrapper() {
+        // creates the epoll file descriptor
+        epfd = epollCreate();
+
+        // the epoll_event array passed to epoll_wait
+        int allocationSize = NUM_EPOLLEVENTS * SIZE_EPOLLEVENT;
+        pollArray = new AllocatedNativeObject(allocationSize, true);
+        pollArrayAddress = pollArray.address();
+
+        for (int i=0; i<NUM_EPOLLEVENTS; i++) {
+            putEventOps(i, 0);
+            putData(i, 0L);
+        }
+
+        // create idle set
+        idleSet = new HashSet<Integer>();
+    }
+
+    // Used to update file description registrations
+    private static class Updator {
+        int opcode;
+        int fd;
+        int events;
+        Updator(int opcode, int fd, int events) {
+            this.opcode = opcode;
+            this.fd = fd;
+            this.events = events;
+        }
+    }
+
+    private LinkedList<Updator> updateList = new LinkedList<Updator>();
+
+    // The epoll_event array for results from epoll_wait
+    private AllocatedNativeObject pollArray;
+
+    // The fd of the epoll driver
+    final int epfd;
+
+    // The fd of the interrupt line going out
+    int outgoingInterruptFD;
+
+    // The fd of the interrupt line coming in
+    int incomingInterruptFD;
+
+    // The index of the interrupt FD
+    int interruptedIndex;
+
+    // Number of updated pollfd entries
+    int updated;
+
+    void initInterrupt(int fd0, int fd1) {
+        outgoingInterruptFD = fd1;
+        incomingInterruptFD = fd0;
+        epollCtl(epfd, EPOLL_CTL_ADD, fd0, EPOLLIN);
+    }
+
+    void putEventOps(int i, int event) {
+        int offset = SIZE_EPOLLEVENT * i + EVENT_OFFSET;
+        pollArray.putInt(offset, event);
+    }
+
+    void putData(int i, long value) {
+        int offset = SIZE_EPOLLEVENT * i + DATA_OFFSET;
+        pollArray.putLong(offset, value);
+    }
+
+    void putDescriptor(int i, int fd) {
+        int offset = SIZE_EPOLLEVENT * i + FD_OFFSET;
+        pollArray.putInt(offset, fd);
+    }
+
+    int getEventOps(int i) {
+        int offset = SIZE_EPOLLEVENT * i + EVENT_OFFSET;
+        return pollArray.getInt(offset);
+    }
+
+    int getDescriptor(int i) {
+        int offset = SIZE_EPOLLEVENT * i + FD_OFFSET;
+        return pollArray.getInt(offset);
+    }
+
+    /**
+     * Update the events for a given file descriptor.
+     */
+    void setInterest(int fd, int mask) {
+        synchronized (updateList) {
+
+            // if the interest events are 0 then add to idle set, and delete
+            // from epoll if registered (or pending)
+            if (mask == 0) {
+                if (idleSet.add(fd)) {
+                    updateList.add(new Updator(EPOLL_CTL_DEL, fd, 0));
+                }
+                return;
+            }
+
+            // if file descriptor is idle then add to epoll
+            if (!idleSet.isEmpty() && idleSet.remove(fd)) {
+                updateList.add(new Updator(EPOLL_CTL_ADD, fd, mask));
+                return;
+            }
+
+            // if the previous pending operation is to add this file descriptor
+            // to epoll then update its event set
+            if (updateList.size() > 0) {
+                Updator last = updateList.getLast();
+                if (last.fd == fd && last.opcode == EPOLL_CTL_ADD) {
+                    last.events = mask;
+                    return;
+                }
+            }
+
+            // update existing registration
+            updateList.add(new Updator(EPOLL_CTL_MOD, fd, mask));
+        }
+    }
+
+    /**
+     * Add a new file descriptor to epoll
+     */
+    void add(int fd) {
+        synchronized (updateList) {
+            updateList.add(new Updator(EPOLL_CTL_ADD, fd, 0));
+        }
+    }
+
+    /**
+     * Remove a file descriptor from epoll
+     */
+    void release(int fd) {
+        synchronized (updateList) {
+            // if file descriptor is idle then remove from idle set, otherwise
+            // delete from epoll
+            if (!idleSet.remove(fd)) {
+                updateList.add(new Updator(EPOLL_CTL_DEL, fd, 0));
+            }
+        }
+    }
+
+    /**
+     * Close epoll file descriptor and free poll array
+     */
+    void closeEPollFD() throws IOException {
+        FileDispatcher.closeIntFD(epfd);
+        pollArray.free();
+    }
+
+    int poll(long timeout) throws IOException {
+        updateRegistrations();
+        updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);
+        for (int i=0; i<updated; i++) {
+            if (getDescriptor(i) == incomingInterruptFD) {
+                interruptedIndex = i;
+                interrupted = true;
+                break;
+            }
+        }
+        return updated;
+    }
+
+    /**
+     * Update the pending registrations.
+     */
+    void updateRegistrations() {
+        synchronized (updateList) {
+            Updator u = null;
+            while ((u = updateList.poll()) != null) {
+                epollCtl(epfd, u.opcode, u.fd, u.events);
+            }
+        }
+    }
+
+    // interrupt support
+    boolean interrupted = false;
+
+    public void interrupt() {
+        interrupt(outgoingInterruptFD);
+    }
+
+    public int interruptedIndex() {
+        return interruptedIndex;
+    }
+
+    boolean interrupted() {
+        return interrupted;
+    }
+
+    void clearInterrupted() {
+        interrupted = false;
+    }
+
+    static {
+        init();
+    }
+
+    private native int epollCreate();
+    private native void epollCtl(int epfd, int opcode, int fd, int events);
+    private native int epollWait(long pollAddress, int numfds, long timeout,
+                                 int epfd) throws IOException;
+    private static native int fdLimit();
+    private static native void interrupt(int fd);
+    private static native void init();
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/EPollSelectorImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/EPollSelectorImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/EPollSelectorImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/EPollSelectorImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,204 @@
+/*
+ * Copyright 2005-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.util.*;
+import sun.misc.*;
+
+
+/**
+ * An implementation of Selector for Linux 2.6+ kernels that uses
+ * the epoll event notification facility.
+ */
+class EPollSelectorImpl
+    extends SelectorImpl
+{
+
+    // File descriptors used for interrupt
+    protected int fd0;
+    protected int fd1;
+
+    // The poll object
+    EPollArrayWrapper pollWrapper;
+
+    // Maps from file descriptors to keys
+    private Map<Integer,SelectionKeyImpl> fdToKey;
+
+    // True if this Selector has been closed
+    private boolean closed = false;
+
+    // Lock for interrupt triggering and clearing
+    private Object interruptLock = new Object();
+    private boolean interruptTriggered = false;
+
+    /**
+     * Package private constructor called by factory method in
+     * the abstract superclass Selector.
+     */
+    EPollSelectorImpl(SelectorProvider sp) {
+        super(sp);
+        int[] fdes = new int[2];
+        IOUtil.initPipe(fdes, false);
+        fd0 = fdes[0];
+        fd1 = fdes[1];
+        pollWrapper = new EPollArrayWrapper();
+        pollWrapper.initInterrupt(fd0, fd1);
+        fdToKey = new HashMap<Integer,SelectionKeyImpl>();
+    }
+
+    protected int doSelect(long timeout)
+        throws IOException
+    {
+        if (closed)
+            throw new ClosedSelectorException();
+        processDeregisterQueue();
+        try {
+            begin();
+            pollWrapper.poll(timeout);
+        } finally {
+            end();
+        }
+        processDeregisterQueue();
+        int numKeysUpdated = updateSelectedKeys();
+        if (pollWrapper.interrupted()) {
+            // Clear the wakeup pipe
+            pollWrapper.putEventOps(pollWrapper.interruptedIndex(), 0);
+            synchronized (interruptLock) {
+                pollWrapper.clearInterrupted();
+                IOUtil.drain(fd0);
+                interruptTriggered = false;
+            }
+        }
+        return numKeysUpdated;
+    }
+
+    /**
+     * Update the keys whose fd's have been selected by the epoll.
+     * Add the ready keys to the ready queue.
+     */
+    private int updateSelectedKeys() {
+        int entries = pollWrapper.updated;
+        int numKeysUpdated = 0;
+        for (int i=0; i<entries; i++) {
+            int nextFD = pollWrapper.getDescriptor(i);
+            SelectionKeyImpl ski = fdToKey.get(Integer.valueOf(nextFD));
+            // ski is null in the case of an interrupt
+            if (ski != null) {
+                int rOps = pollWrapper.getEventOps(i);
+                if (selectedKeys.contains(ski)) {
+                    if (ski.channel.translateAndSetReadyOps(rOps, ski)) {
+                        numKeysUpdated++;
+                    }
+                } else {
+                    ski.channel.translateAndSetReadyOps(rOps, ski);
+                    if ((ski.nioReadyOps() & ski.nioInterestOps()) != 0) {
+                        selectedKeys.add(ski);
+                        numKeysUpdated++;
+                    }
+                }
+            }
+        }
+        return numKeysUpdated;
+    }
+
+    protected void implClose() throws IOException {
+        if (!closed) {
+            closed = true;
+
+            // prevent further wakeup
+            synchronized (interruptLock) {
+                interruptTriggered = true;
+            }
+
+            FileDispatcher.closeIntFD(fd0);
+            FileDispatcher.closeIntFD(fd1);
+            if (pollWrapper != null) {
+
+                pollWrapper.release(fd0);
+                pollWrapper.closeEPollFD();
+                pollWrapper = null;
+                selectedKeys = null;
+
+                // Deregister channels
+                Iterator i = keys.iterator();
+                while (i.hasNext()) {
+                    SelectionKeyImpl ski = (SelectionKeyImpl)i.next();
+                    deregister(ski);
+                    SelectableChannel selch = ski.channel();
+                    if (!selch.isOpen() && !selch.isRegistered())
+                        ((SelChImpl)selch).kill();
+                    i.remove();
+                }
+            }
+            fd0 = -1;
+            fd1 = -1;
+        }
+    }
+
+    protected void implRegister(SelectionKeyImpl ski) {
+        int fd = IOUtil.fdVal(ski.channel.getFD());
+        fdToKey.put(Integer.valueOf(fd), ski);
+        pollWrapper.add(fd);
+        keys.add(ski);
+    }
+
+    protected void implDereg(SelectionKeyImpl ski) throws IOException {
+        assert (ski.getIndex() >= 0);
+        int fd = ski.channel.getFDVal();
+        fdToKey.remove(Integer.valueOf(fd));
+        pollWrapper.release(fd);
+        ski.setIndex(-1);
+        keys.remove(ski);
+        selectedKeys.remove(ski);
+        deregister((AbstractSelectionKey)ski);
+        SelectableChannel selch = ski.channel();
+        if (!selch.isOpen() && !selch.isRegistered())
+            ((SelChImpl)selch).kill();
+    }
+
+    void putEventOps(SelectionKeyImpl sk, int ops) {
+        int fd = IOUtil.fdVal(sk.channel.getFD());
+        pollWrapper.setInterest(fd, ops);
+    }
+
+    public Selector wakeup() {
+        synchronized (interruptLock) {
+            if (!interruptTriggered) {
+                pollWrapper.interrupt();
+                interruptTriggered = true;
+            }
+        }
+        return this;
+    }
+
+    static {
+        Util.load();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/EPollSelectorProvider.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/EPollSelectorProvider.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/EPollSelectorProvider.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/EPollSelectorProvider.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+public class EPollSelectorProvider
+    extends SelectorProviderImpl
+{
+    public AbstractSelector openSelector() throws IOException {
+        return new EPollSelectorImpl(this);
+    }
+
+    public Channel inheritedChannel() throws IOException {
+        return InheritedChannel.getChannel();
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/FileDispatcher.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/FileDispatcher.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/FileDispatcher.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/FileDispatcher.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+
+/**
+ * Allows different platforms to call different native methods
+ * for read and write operations.
+ */
+
+class FileDispatcher extends NativeDispatcher
+{
+
+    static {
+        Util.load();
+        init();
+    }
+
+    int read(FileDescriptor fd, long address, int len) throws IOException {
+        return read0(fd, address, len);
+    }
+
+    int pread(FileDescriptor fd, long address, int len,
+                             long position, Object lock) throws IOException {
+        return pread0(fd, address, len, position);
+    }
+
+    long readv(FileDescriptor fd, long address, int len) throws IOException {
+        return readv0(fd, address, len);
+    }
+
+    int write(FileDescriptor fd, long address, int len) throws IOException {
+        return write0(fd, address, len);
+    }
+
+    int pwrite(FileDescriptor fd, long address, int len,
+                             long position, Object lock) throws IOException
+    {
+        return pwrite0(fd, address, len, position);
+    }
+
+    long writev(FileDescriptor fd, long address, int len)
+        throws IOException
+    {
+        return writev0(fd, address, len);
+    }
+
+    void close(FileDescriptor fd) throws IOException {
+        close0(fd);
+    }
+
+    void preClose(FileDescriptor fd) throws IOException {
+        preClose0(fd);
+    }
+
+    // -- Native methods --
+
+    static native int read0(FileDescriptor fd, long address, int len)
+        throws IOException;
+
+    static native int pread0(FileDescriptor fd, long address, int len,
+                             long position) throws IOException;
+
+    static native long readv0(FileDescriptor fd, long address, int len)
+        throws IOException;
+
+    static native int write0(FileDescriptor fd, long address, int len)
+        throws IOException;
+
+    static native int pwrite0(FileDescriptor fd, long address, int len,
+                             long position) throws IOException;
+
+    static native long writev0(FileDescriptor fd, long address, int len)
+        throws IOException;
+
+    static native void close0(FileDescriptor fd) throws IOException;
+
+    static native void preClose0(FileDescriptor fd) throws IOException;
+
+    static native void closeIntFD(int fd) throws IOException;
+
+    static native void init();
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/FileKey.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/FileKey.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/FileKey.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/FileKey.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+
+/*
+ * Represents a key to a specific file on Solaris or Linux
+ */
+public class FileKey {
+
+    private long st_dev;    // ID of device
+    private long st_ino;    // Inode number
+
+    private FileKey() { }
+
+    public static FileKey create(FileDescriptor fd) {
+        FileKey fk = new FileKey();
+        try {
+            fk.init(fd);
+        } catch (IOException ioe) {
+            throw new Error(ioe);
+        }
+        return fk;
+    }
+
+    public int hashCode() {
+        return (int)(st_dev ^ (st_dev >>> 32)) +
+               (int)(st_ino ^ (st_ino >>> 32));
+    }
+
+    public boolean equals(Object obj) {
+        if (obj == this)
+            return true;
+        if (!(obj instanceof FileKey))
+            return false;
+        FileKey other = (FileKey)obj;
+        if ((this.st_dev != other.st_dev) ||
+            (this.st_ino != other.st_ino)) {
+            return false;
+        }
+        return true;
+    }
+
+    private native void init(FileDescriptor fd) throws IOException;
+    private static native void initIDs();
+
+    static {
+        initIDs();
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/InheritedChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/InheritedChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/InheritedChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/InheritedChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,240 @@
+/*
+ * Copyright 2003-2004 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.lang.reflect.Constructor;
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.channels.Channel;
+import java.nio.channels.SocketChannel;
+import java.nio.channels.ServerSocketChannel;
+import java.nio.channels.DatagramChannel;
+import java.nio.channels.spi.SelectorProvider;
+
+class InheritedChannel {
+
+    // the "types" of socket returned by soType0
+    private static final int UNKNOWN            = -1;
+    private static final int SOCK_STREAM        = 1;
+    private static final int SOCK_DGRAM         = 2;
+
+    // oflag values when opening a file
+    private static final int O_RDONLY           = 0;
+    private static final int O_WRONLY           = 1;
+    private static final int O_RDWR             = 2;
+
+    /*
+     * In order to "detach" the standard streams we dup them to /dev/null.
+     * In order to reduce the possibility of an error at close time we
+     * open /dev/null early - that way we know we won't run out of file
+     * descriptors at close time. This makes the close operation a
+     * simple dup2 operation for each of the standard streams.
+     */
+    private static int devnull = -1;
+
+    private static void detachIOStreams() {
+        try {
+            dup2(devnull, 0);
+            dup2(devnull, 1);
+            dup2(devnull, 2);
+        } catch (IOException ioe) {
+            // this shouldn't happen
+            throw new InternalError();
+        }
+    }
+
+    /*
+     * Override the implCloseSelectableChannel for each channel type - this
+     * allows us to "detach" the standard streams after closing and ensures
+     * that the underlying socket really closes.
+     */
+    public static class InheritedSocketChannelImpl extends SocketChannelImpl {
+
+        InheritedSocketChannelImpl(SelectorProvider sp,
+                                   FileDescriptor fd,
+                                   InetSocketAddress remote)
+            throws IOException
+        {
+            super(sp, fd, remote);
+        }
+
+        protected void implCloseSelectableChannel() throws IOException {
+            super.implCloseSelectableChannel();
+            detachIOStreams();
+        }
+    }
+
+    public static class InheritedServerSocketChannelImpl extends
+        ServerSocketChannelImpl {
+
+        InheritedServerSocketChannelImpl(SelectorProvider sp,
+                                         FileDescriptor fd)
+            throws IOException
+        {
+            super(sp, fd);
+        }
+
+        protected void implCloseSelectableChannel() throws IOException {
+            super.implCloseSelectableChannel();
+            detachIOStreams();
+        }
+
+    }
+
+    public static class InheritedDatagramChannelImpl extends
+        DatagramChannelImpl {
+
+        InheritedDatagramChannelImpl(SelectorProvider sp,
+                                     FileDescriptor fd)
+            throws IOException
+        {
+            super(sp, fd);
+        }
+
+        protected void implCloseSelectableChannel() throws IOException {
+            super.implCloseSelectableChannel();
+            detachIOStreams();
+        }
+    }
+
+    /*
+     * If there's a SecurityManager then check for the appropriate
+     * RuntimePermission.
+     */
+    private static void checkAccess(Channel c) {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            sm.checkPermission(
+                new RuntimePermission("inheritedChannel")
+            );
+        }
+    }
+
+
+    /*
+     * If standard inherited channel is connected to a socket then return a Channel
+     * of the appropriate type based standard input.
+     */
+    private static Channel createChannel() throws IOException {
+
+        // dup the file descriptor - we do this so that for two reasons :-
+        // 1. Avoids any timing issues with FileDescriptor.in being closed
+        //    or redirected while we create the channel.
+        // 2. Allows streams based on file descriptor 0 to co-exist with
+        //    the channel (closing one doesn't impact the other)
+
+        int fdVal = dup(0);
+
+        // Examine the file descriptor - if it's not a socket then we don't
+        // create a channel so we release the file descriptor.
+
+        int st;
+        st = soType0(fdVal);
+        if (st != SOCK_STREAM && st != SOCK_DGRAM) {
+            close0(fdVal);
+            return null;
+        }
+
+
+        // Next we create a FileDescriptor for the dup'ed file descriptor
+        // Have to use reflection and also make assumption on how FD
+        // is implemented.
+
+        Class paramTypes[] = { int.class };
+        Constructor ctr = Reflect.lookupConstructor("java.io.FileDescriptor",
+                                                    paramTypes);
+        Object args[] = { new Integer(fdVal) };
+        FileDescriptor fd = (FileDescriptor)Reflect.invoke(ctr, args);
+
+
+        // Now create the channel. If the socket is a streams socket then
+        // we see if tthere is a peer (ie: connected). If so, then we
+        // create a SocketChannel, otherwise a ServerSocketChannel.
+        // If the socket is a datagram socket then create a DatagramChannel
+
+        SelectorProvider provider = SelectorProvider.provider();
+        assert provider instanceof sun.nio.ch.SelectorProviderImpl;
+
+        Channel c;
+        if (st == SOCK_STREAM) {
+            InetAddress ia = peerAddress0(fdVal);
+            if (ia == null) {
+               c = new InheritedServerSocketChannelImpl(provider, fd);
+            } else {
+               int port = peerPort0(fdVal);
+               assert port > 0;
+               InetSocketAddress isa = new InetSocketAddress(ia, port);
+               c = new InheritedSocketChannelImpl(provider, fd, isa);
+            }
+        } else {
+            c = new InheritedDatagramChannelImpl(provider, fd);
+        }
+        return c;
+    }
+
+    private static boolean haveChannel = false;
+    private static Channel channel = null;
+
+    /*
+     * Returns a Channel representing the inherited channel if the
+     * inherited channel is a stream connected to a network socket.
+     */
+    public static synchronized Channel getChannel() throws IOException {
+        if (devnull < 0) {
+            devnull = open0("/dev/null", O_RDWR);
+        }
+
+        // If we don't have the channel try to create it
+        if (!haveChannel) {
+            channel = createChannel();
+            haveChannel = true;
+        }
+
+        // if there is a channel then do the security check before
+        // returning it.
+        if (channel != null) {
+            checkAccess(channel);
+        }
+        return channel;
+    }
+
+
+    // -- Native methods --
+
+    private static native int dup(int fd) throws IOException;
+    private static native void dup2(int fd, int fd2) throws IOException;
+    private static native int open0(String path, int oflag) throws IOException;
+    private static native void close0(int fd) throws IOException;
+    private static native int soType0(int fd);
+    private static native InetAddress peerAddress0(int fd);
+    private static native int peerPort0(int fd);
+
+    static {
+        Util.load();
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/NativeThread.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/NativeThread.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/NativeThread.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/NativeThread.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2002-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+
+// Signalling operations on native threads
+//
+// On some operating systems (e.g., Linux), closing a channel while another
+// thread is blocked in an I/O operation upon that channel does not cause that
+// thread to be released.  This class provides access to the native threads
+// upon which Java threads are built, and defines a simple signal mechanism
+// that can be used to release a native thread from a blocking I/O operation.
+// On systems that do not require this type of signalling, the current() method
+// always returns -1 and the signal(long) method has no effect.
+
+
+class NativeThread {
+
+    // Returns an opaque token representing the native thread underlying the
+    // invoking Java thread.  On systems that do not require signalling, this
+    // method always returns -1.
+    //
+    static native long current();
+
+    // Signals the given native thread so as to release it from a blocking I/O
+    // operation.  On systems that do not require signalling, this method has
+    // no effect.
+    //
+    static native void signal(long nt);
+
+    static native void init();
+
+    static {
+        Util.load();
+        init();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/PipeImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/PipeImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/PipeImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/PipeImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2000-2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+
+class PipeImpl
+    extends Pipe
+{
+
+    // Source and sink channels
+    private final SourceChannel source;
+    private final SinkChannel sink;
+
+    PipeImpl(SelectorProvider sp) {
+        int[] fdes = new int[2];
+        IOUtil.initPipe(fdes, true);
+        FileDescriptor sourcefd = new FileDescriptor();
+        IOUtil.setfdVal(sourcefd, fdes[0]);
+        source = new SourceChannelImpl(sp, sourcefd);
+        FileDescriptor sinkfd = new FileDescriptor();
+        IOUtil.setfdVal(sinkfd, fdes[1]);
+        sink = new SinkChannelImpl(sp, sinkfd);
+    }
+
+    public SourceChannel source() {
+        return source;
+    }
+
+    public SinkChannel sink() {
+        return sink;
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/PollArrayWrapper.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/PollArrayWrapper.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/PollArrayWrapper.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/PollArrayWrapper.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2001-2004 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import sun.misc.*;
+
+
+/**
+ * Manipulates a native array of pollfd structs on Solaris:
+ *
+ * typedef struct pollfd {
+ *    int fd;
+ *    short events;
+ *    short revents;
+ * } pollfd_t;
+ *
+ * @author Mike McCloskey
+ * @since 1.4
+ */
+
+class PollArrayWrapper extends AbstractPollArrayWrapper {
+
+    static final short POLLCONN = POLLOUT;
+
+    // File descriptor to write for interrupt
+    int interruptFD;
+
+    PollArrayWrapper(int newSize) {
+        newSize = (newSize + 1) * SIZE_POLLFD;
+        pollArray = new AllocatedNativeObject(newSize, false);
+        pollArrayAddress = pollArray.address();
+        totalChannels = 1;
+    }
+
+    void initInterrupt(int fd0, int fd1) {
+        interruptFD = fd1;
+        putDescriptor(0, fd0);
+        putEventOps(0, POLLIN);
+        putReventOps(0, 0);
+    }
+
+    void release(int i) {
+        return;
+    }
+
+    void free() {
+        pollArray.free();
+    }
+
+    /**
+     * Prepare another pollfd struct for use.
+     */
+    void addEntry(SelChImpl sc) {
+        putDescriptor(totalChannels, IOUtil.fdVal(sc.getFD()));
+        putEventOps(totalChannels, 0);
+        putReventOps(totalChannels, 0);
+        totalChannels++;
+    }
+
+    /**
+     * Writes the pollfd entry from the source wrapper at the source index
+     * over the entry in the target wrapper at the target index. The source
+     * array remains unchanged unless the source array and the target are
+     * the same array.
+     */
+    static void replaceEntry(PollArrayWrapper source, int sindex,
+                      PollArrayWrapper target, int tindex) {
+        target.putDescriptor(tindex, source.getDescriptor(sindex));
+        target.putEventOps(tindex, source.getEventOps(sindex));
+        target.putReventOps(tindex, source.getReventOps(sindex));
+    }
+
+    /**
+     * Grows the pollfd array to a size that will accommodate newSize
+     * pollfd entries. This method does no checking of the newSize
+     * to determine if it is in fact bigger than the old size: it
+     * always reallocates an array of the new size.
+     */
+    void grow(int newSize) {
+        // create new array
+        PollArrayWrapper temp = new PollArrayWrapper(newSize);
+
+        // Copy over existing entries
+        for (int i=0; i<totalChannels; i++)
+            replaceEntry(this, i, temp, i);
+
+        // Swap new array into pollArray field
+        pollArray.free();
+        pollArray = temp.pollArray;
+        pollArrayAddress = pollArray.address();
+    }
+
+    int poll(int numfds, int offset, long timeout) {
+        return poll0(pollArrayAddress + (offset * SIZE_POLLFD),
+                     numfds, timeout);
+    }
+
+    public void interrupt() {
+        interrupt(interruptFD);
+    }
+
+    private native int poll0(long pollAddress, int numfds, long timeout);
+
+    private static native void interrupt(int fd);
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/PollSelectorImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/PollSelectorImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/PollSelectorImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/PollSelectorImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2001-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.util.*;
+import sun.misc.*;
+
+
+/**
+ * An implementation of Selector for Solaris.
+ */
+
+class PollSelectorImpl
+    extends AbstractPollSelectorImpl
+{
+
+    // File descriptors used for interrupt
+    private int fd0;
+    private int fd1;
+
+    // Lock for interrupt triggering and clearing
+    private Object interruptLock = new Object();
+    private boolean interruptTriggered = false;
+
+    /**
+     * Package private constructor called by factory method in
+     * the abstract superclass Selector.
+     */
+    PollSelectorImpl(SelectorProvider sp) {
+        super(sp, 1, 1);
+        int[] fdes = new int[2];
+        IOUtil.initPipe(fdes, false);
+        fd0 = fdes[0];
+        fd1 = fdes[1];
+        pollWrapper = new PollArrayWrapper(INIT_CAP);
+        pollWrapper.initInterrupt(fd0, fd1);
+        channelArray = new SelectionKeyImpl[INIT_CAP];
+    }
+
+    protected int doSelect(long timeout)
+        throws IOException
+    {
+        if (channelArray == null)
+            throw new ClosedSelectorException();
+        processDeregisterQueue();
+        try {
+            begin();
+            pollWrapper.poll(totalChannels, 0, timeout);
+        } finally {
+            end();
+        }
+        processDeregisterQueue();
+        int numKeysUpdated = updateSelectedKeys();
+        if (pollWrapper.getReventOps(0) != 0) {
+            // Clear the wakeup pipe
+            pollWrapper.putReventOps(0, 0);
+            synchronized (interruptLock) {
+                IOUtil.drain(fd0);
+                interruptTriggered = false;
+            }
+        }
+        return numKeysUpdated;
+    }
+
+    protected void implCloseInterrupt() throws IOException {
+        // prevent further wakeup
+        synchronized (interruptLock) {
+            interruptTriggered = true;
+        }
+        FileDispatcher.closeIntFD(fd0);
+        FileDispatcher.closeIntFD(fd1);
+        fd0 = -1;
+        fd1 = -1;
+        pollWrapper.release(0);
+    }
+
+    public Selector wakeup() {
+        synchronized (interruptLock) {
+            if (!interruptTriggered) {
+                pollWrapper.interrupt();
+                interruptTriggered = true;
+            }
+        }
+        return this;
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/SinkChannelImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/SinkChannelImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/SinkChannelImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/SinkChannelImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2000-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+import java.nio.ByteBuffer;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+
+class SinkChannelImpl
+    extends Pipe.SinkChannel
+    implements SelChImpl
+{
+
+    // Used to make native read and write calls
+    private static NativeDispatcher nd;
+
+    // The file descriptor associated with this channel
+    FileDescriptor fd;
+
+    // fd value needed for dev/poll. This value will remain valid
+    // even after the value in the file descriptor object has been set to -1
+    int fdVal;
+
+    // ID of native thread doing write, for signalling
+    private volatile long thread = 0;
+
+    // Lock held by current reading thread
+    private final Object lock = new Object();
+
+    // Lock held by any thread that modifies the state fields declared below
+    // DO NOT invoke a blocking I/O operation while holding this lock!
+    private final Object stateLock = new Object();
+
+    // -- The following fields are protected by stateLock
+
+    // Channel state
+    private static final int ST_UNINITIALIZED = -1;
+    private static final int ST_INUSE = 0;
+    private static final int ST_KILLED = 1;
+    private volatile int state = ST_UNINITIALIZED;
+
+    // -- End of fields protected by stateLock
+
+
+    public FileDescriptor getFD() {
+        return fd;
+    }
+
+    public int getFDVal() {
+        return fdVal;
+    }
+
+    SinkChannelImpl(SelectorProvider sp, FileDescriptor fd) {
+        super(sp);
+        this.fd = fd;
+        this.fdVal = IOUtil.fdVal(fd);
+        this.state = ST_INUSE;
+    }
+
+    protected void implCloseSelectableChannel() throws IOException {
+        synchronized (stateLock) {
+            nd.preClose(fd);
+            long th = thread;
+            if (th != 0)
+                NativeThread.signal(th);
+            if (!isRegistered())
+                kill();
+        }
+    }
+
+    public void kill() throws IOException {
+        synchronized (stateLock) {
+            if (state == ST_KILLED)
+                return;
+            if (state == ST_UNINITIALIZED) {
+                state = ST_KILLED;
+                return;
+            }
+            assert !isOpen() && !isRegistered();
+            nd.close(fd);
+            state = ST_KILLED;
+        }
+    }
+
+    protected void implConfigureBlocking(boolean block) throws IOException {
+        IOUtil.configureBlocking(fd, block);
+    }
+
+    public boolean translateReadyOps(int ops, int initialOps,
+                                     SelectionKeyImpl sk) {
+        int intOps = sk.nioInterestOps();// Do this just once, it synchronizes
+        int oldOps = sk.nioReadyOps();
+        int newOps = initialOps;
+
+        if ((ops & PollArrayWrapper.POLLNVAL) != 0)
+            throw new Error("POLLNVAL detected");
+
+        if ((ops & (PollArrayWrapper.POLLERR
+                    | PollArrayWrapper.POLLHUP)) != 0) {
+            newOps = intOps;
+            sk.nioReadyOps(newOps);
+            return (newOps & ~oldOps) != 0;
+        }
+
+        if (((ops & PollArrayWrapper.POLLOUT) != 0) &&
+            ((intOps & SelectionKey.OP_WRITE) != 0))
+            newOps |= SelectionKey.OP_WRITE;
+
+        sk.nioReadyOps(newOps);
+        return (newOps & ~oldOps) != 0;
+    }
+
+    public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl sk) {
+        return translateReadyOps(ops, sk.nioReadyOps(), sk);
+    }
+
+    public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl sk) {
+        return translateReadyOps(ops, 0, sk);
+    }
+
+    public void translateAndSetInterestOps(int ops, SelectionKeyImpl sk) {
+        if (ops == SelectionKey.OP_WRITE)
+            ops = PollArrayWrapper.POLLOUT;
+        sk.selector.putEventOps(sk, ops);
+    }
+
+    private void ensureOpen() throws IOException {
+        if (!isOpen())
+            throw new ClosedChannelException();
+    }
+
+    public int write(ByteBuffer src) throws IOException {
+        ensureOpen();
+        synchronized (lock) {
+            int n = 0;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                thread = NativeThread.current();
+                do {
+                    n = IOUtil.write(fd, src, -1, nd, lock);
+                } while ((n == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(n);
+            } finally {
+                thread = 0;
+                end((n > 0) || (n == IOStatus.UNAVAILABLE));
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    public long write(ByteBuffer[] srcs) throws IOException {
+        if (srcs == null)
+            throw new NullPointerException();
+        ensureOpen();
+        synchronized (lock) {
+            long n = 0;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                thread = NativeThread.current();
+                do {
+                    n = IOUtil.write(fd, srcs, nd);
+                } while ((n == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(n);
+            } finally {
+                thread = 0;
+                end((n > 0) || (n == IOStatus.UNAVAILABLE));
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    public long write(ByteBuffer[] srcs, int offset, int length)
+        throws IOException
+    {
+        if ((offset < 0) || (length < 0) || (offset > srcs.length - length))
+           throw new IndexOutOfBoundsException();
+        return write(Util.subsequence(srcs, offset, length));
+    }
+
+    static {
+        Util.load();
+        nd = new FileDispatcher();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/SocketDispatcher.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/SocketDispatcher.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/SocketDispatcher.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/SocketDispatcher.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2000-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+
+/**
+ * Allows different platforms to call different native methods
+ * for read and write operations.
+ */
+
+class SocketDispatcher extends NativeDispatcher
+{
+
+    int read(FileDescriptor fd, long address, int len) throws IOException {
+        return FileDispatcher.read0(fd, address, len);
+    }
+
+    long readv(FileDescriptor fd, long address, int len) throws IOException {
+        return FileDispatcher.readv0(fd, address, len);
+    }
+
+    int write(FileDescriptor fd, long address, int len) throws IOException {
+        return FileDispatcher.write0(fd, address, len);
+    }
+
+    long writev(FileDescriptor fd, long address, int len) throws IOException {
+        return FileDispatcher.writev0(fd, address, len);
+    }
+
+    void close(FileDescriptor fd) throws IOException {
+        FileDispatcher.close0(fd);
+    }
+
+    void preClose(FileDescriptor fd) throws IOException {
+        FileDispatcher.preClose0(fd);
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/SourceChannelImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/SourceChannelImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/ch/SourceChannelImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/ch/SourceChannelImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2000-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+import java.nio.ByteBuffer;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+
+class SourceChannelImpl
+    extends Pipe.SourceChannel
+    implements SelChImpl
+{
+
+    // Used to make native read and write calls
+    private static NativeDispatcher nd;
+
+    // The file descriptor associated with this channel
+    FileDescriptor fd;
+
+    // fd value needed for dev/poll. This value will remain valid
+    // even after the value in the file descriptor object has been set to -1
+    int fdVal;
+
+    // ID of native thread doing read, for signalling
+    private volatile long thread = 0;
+
+    // Lock held by current reading thread
+    private final Object lock = new Object();
+
+    // Lock held by any thread that modifies the state fields declared below
+    // DO NOT invoke a blocking I/O operation while holding this lock!
+    private final Object stateLock = new Object();
+
+    // -- The following fields are protected by stateLock
+
+    // Channel state
+    private static final int ST_UNINITIALIZED = -1;
+    private static final int ST_INUSE = 0;
+    private static final int ST_KILLED = 1;
+    private volatile int state = ST_UNINITIALIZED;
+
+    // -- End of fields protected by stateLock
+
+
+    public FileDescriptor getFD() {
+        return fd;
+    }
+
+    public int getFDVal() {
+        return fdVal;
+    }
+
+    SourceChannelImpl(SelectorProvider sp, FileDescriptor fd) {
+        super(sp);
+        this.fd = fd;
+        this.fdVal = IOUtil.fdVal(fd);
+        this.state = ST_INUSE;
+    }
+
+    protected void implCloseSelectableChannel() throws IOException {
+        synchronized (stateLock) {
+            nd.preClose(fd);
+            long th = thread;
+            if (th != 0)
+                NativeThread.signal(th);
+            if (!isRegistered())
+                kill();
+        }
+    }
+
+    public void kill() throws IOException {
+        synchronized (stateLock) {
+            if (state == ST_KILLED)
+                return;
+            if (state == ST_UNINITIALIZED) {
+                state = ST_KILLED;
+                return;
+            }
+            assert !isOpen() && !isRegistered();
+            nd.close(fd);
+            state = ST_KILLED;
+        }
+    }
+
+    protected void implConfigureBlocking(boolean block) throws IOException {
+        IOUtil.configureBlocking(fd, block);
+    }
+
+    public boolean translateReadyOps(int ops, int initialOps,
+                                     SelectionKeyImpl sk) {
+        int intOps = sk.nioInterestOps(); // Do this just once, it synchronizes
+        int oldOps = sk.nioReadyOps();
+        int newOps = initialOps;
+
+        if ((ops & PollArrayWrapper.POLLNVAL) != 0)
+            throw new Error("POLLNVAL detected");
+
+        if ((ops & (PollArrayWrapper.POLLERR
+                    | PollArrayWrapper.POLLHUP)) != 0) {
+            newOps = intOps;
+            sk.nioReadyOps(newOps);
+            return (newOps & ~oldOps) != 0;
+        }
+
+        if (((ops & PollArrayWrapper.POLLIN) != 0) &&
+            ((intOps & SelectionKey.OP_READ) != 0))
+            newOps |= SelectionKey.OP_READ;
+
+        sk.nioReadyOps(newOps);
+        return (newOps & ~oldOps) != 0;
+    }
+
+    public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl sk) {
+        return translateReadyOps(ops, sk.nioReadyOps(), sk);
+    }
+
+    public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl sk) {
+        return translateReadyOps(ops, 0, sk);
+    }
+
+    public void translateAndSetInterestOps(int ops, SelectionKeyImpl sk) {
+        if (ops == SelectionKey.OP_READ)
+            ops = PollArrayWrapper.POLLIN;
+        sk.selector.putEventOps(sk, ops);
+    }
+
+    private void ensureOpen() throws IOException {
+        if (!isOpen())
+            throw new ClosedChannelException();
+    }
+
+    public int read(ByteBuffer dst) throws IOException {
+        ensureOpen();
+        synchronized (lock) {
+            int n = 0;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                thread = NativeThread.current();
+                do {
+                    n = IOUtil.read(fd, dst, -1, nd, lock);
+                } while ((n == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(n);
+            } finally {
+                thread = 0;
+                end((n > 0) || (n == IOStatus.UNAVAILABLE));
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    public long read(ByteBuffer[] dsts, int offset, int length)
+        throws IOException
+    {
+        if ((offset < 0) || (length < 0) || (offset > dsts.length - length))
+           throw new IndexOutOfBoundsException();
+        return read(Util.subsequence(dsts, offset, length));
+    }
+
+    public long read(ByteBuffer[] dsts) throws IOException {
+        if (dsts == null)
+            throw new NullPointerException();
+        ensureOpen();
+        synchronized (lock) {
+            long n = 0;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                thread = NativeThread.current();
+                do {
+                    n = IOUtil.read(fd, dsts, nd);
+                } while ((n == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(n);
+            } finally {
+                thread = 0;
+                end((n > 0) || (n == IOStatus.UNAVAILABLE));
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    static {
+        Util.load();
+        nd = new FileDispatcher();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/cs/ext/COMPOUND_TEXT_Decoder.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/cs/ext/COMPOUND_TEXT_Decoder.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/cs/ext/COMPOUND_TEXT_Decoder.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/cs/ext/COMPOUND_TEXT_Decoder.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,714 @@
+/*
+ * Copyright 2001-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.cs.ext;
+import java.io.ByteArrayOutputStream;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.*;
+
+/**
+ * An algorithmic conversion from COMPOUND_TEXT to Unicode.
+ */
+
+public class COMPOUND_TEXT_Decoder extends CharsetDecoder {
+
+    private static final int NORMAL_BYTES             =  0;
+    private static final int NONSTANDARD_BYTES        =  1;
+    private static final int VERSION_SEQUENCE_V       =  2;
+    private static final int VERSION_SEQUENCE_TERM    =  3;
+    private static final int ESCAPE_SEQUENCE          =  4;
+    private static final int CHARSET_NGIIF            =  5;
+    private static final int CHARSET_NLIIF            =  6;
+    private static final int CHARSET_NLIF             =  7;
+    private static final int CHARSET_NRIIF            =  8;
+    private static final int CHARSET_NRIF             =  9;
+    private static final int CHARSET_NONSTANDARD_FOML = 10;
+    private static final int CHARSET_NONSTANDARD_OML  = 11;
+    private static final int CHARSET_NONSTANDARD_ML   = 12;
+    private static final int CHARSET_NONSTANDARD_L    = 13;
+    private static final int CHARSET_NONSTANDARD      = 14;
+    private static final int CHARSET_LIIF             = 15;
+    private static final int CHARSET_LIF              = 16;
+    private static final int CHARSET_RIIF             = 17;
+    private static final int CHARSET_RIF              = 18;
+    private static final int CONTROL_SEQUENCE_PIF     = 19;
+    private static final int CONTROL_SEQUENCE_IF      = 20;
+    private static final int EXTENSION_ML             = 21;
+    private static final int EXTENSION_L              = 22;
+    private static final int EXTENSION                = 23;
+    private static final int ESCAPE_SEQUENCE_OTHER    = 24;
+
+    private static final String ERR_LATIN1 = "ISO8859_1 unsupported";
+    private static final String ERR_ILLSTATE = "Illegal state";
+    private static final String ERR_ESCBYTE =
+        "Illegal byte in 0x1B escape sequence";
+    private static final String ERR_ENCODINGBYTE =
+        "Illegal byte in non-standard character set name";
+    private static final String ERR_CTRLBYTE =
+        "Illegal byte in 0x9B control sequence";
+    private static final String ERR_CTRLPI =
+        "P following I in 0x9B control sequence";
+    private static final String ERR_VERSTART =
+        "Versioning escape sequence can only appear at start of byte stream";
+    private static final String ERR_VERMANDATORY =
+        "Cannot parse mandatory extensions";
+    private static final String ERR_ENCODING = "Unknown encoding: ";
+    private static final String ERR_FLUSH =
+        "Escape sequence, control sequence, or ML extension not terminated";
+
+    private int state = NORMAL_BYTES ;
+    private int ext_count, ext_offset;
+    private boolean versionSequenceAllowed = true;
+    private byte[] byteBuf = new byte[1];
+    private ByteBuffer inBB = ByteBuffer.allocate(16);
+    private ByteArrayOutputStream queue = new ByteArrayOutputStream(),
+        encodingQueue = new ByteArrayOutputStream();
+
+    private CharsetDecoder glDecoder, grDecoder, nonStandardDecoder,
+        lastDecoder;
+    private boolean glHigh = false, grHigh = true;
+
+
+    public COMPOUND_TEXT_Decoder(Charset cs) {
+        super(cs, 1.0f, 1.0f);
+        try {
+            // Initial state in ISO 2022 designates Latin-1 charset.
+            glDecoder = Charset.forName("ASCII").newDecoder();
+            grDecoder = Charset.forName("ISO8859_1").newDecoder();
+        } catch (IllegalArgumentException e) {
+            error(ERR_LATIN1);
+        }
+        initDecoder(glDecoder);
+        initDecoder(grDecoder);
+    }
+
+    protected CoderResult decodeLoop(ByteBuffer src, CharBuffer des) {
+        CoderResult cr = CoderResult.UNDERFLOW;
+        byte[] input = src.array();
+        int inOff = src.arrayOffset() + src.position();
+        int inEnd = src.arrayOffset() + src.limit();
+
+        try {
+            while (inOff < inEnd && cr.isUnderflow()) {
+                // Byte parsing is done with shorts instead of bytes because
+                // Java bytes are signed, while COMPOUND_TEXT bytes are not. If
+                // we used the Java byte type, the > and < tests during parsing
+                // would not work correctly.
+                cr = handleByte((short)(input[inOff] & 0xFF), des);
+                inOff++;
+            }
+            return cr;
+        } finally {
+            src.position(inOff - src.arrayOffset());
+        }
+    }
+
+    private CoderResult handleByte(short newByte, CharBuffer cb) {
+        CoderResult cr = CoderResult.UNDERFLOW;
+        switch (state) {
+        case NORMAL_BYTES:
+            cr= normalBytes(newByte, cb);
+            break;
+        case NONSTANDARD_BYTES:
+            cr = nonStandardBytes(newByte, cb);
+            break;
+        case VERSION_SEQUENCE_V:
+        case VERSION_SEQUENCE_TERM:
+            cr = versionSequence(newByte);
+            break;
+        case ESCAPE_SEQUENCE:
+            cr = escapeSequence(newByte);
+            break;
+        case CHARSET_NGIIF:
+            cr = charset94N(newByte);
+            break;
+        case CHARSET_NLIIF:
+        case CHARSET_NLIF:
+            cr = charset94NL(newByte, cb);
+            break;
+        case CHARSET_NRIIF:
+        case CHARSET_NRIF:
+            cr = charset94NR(newByte, cb);
+            break;
+        case CHARSET_NONSTANDARD_FOML:
+        case CHARSET_NONSTANDARD_OML:
+        case CHARSET_NONSTANDARD_ML:
+        case CHARSET_NONSTANDARD_L:
+        case CHARSET_NONSTANDARD:
+            cr = charsetNonStandard(newByte, cb);
+            break;
+        case CHARSET_LIIF:
+        case CHARSET_LIF:
+            cr = charset9496L(newByte, cb);
+            break;
+        case CHARSET_RIIF:
+        case CHARSET_RIF:
+            cr = charset9496R(newByte, cb);
+            break;
+        case CONTROL_SEQUENCE_PIF:
+        case CONTROL_SEQUENCE_IF:
+            cr = controlSequence(newByte);
+            break;
+        case EXTENSION_ML:
+        case EXTENSION_L:
+        case EXTENSION:
+            cr = extension(newByte);
+            break;
+        case ESCAPE_SEQUENCE_OTHER:
+            cr = escapeSequenceOther(newByte);
+            break;
+        default:
+            error(ERR_ILLSTATE);
+        }
+        return cr;
+    }
+
+    private CoderResult normalBytes(short newByte, CharBuffer cb) {
+        CoderResult cr = CoderResult.UNDERFLOW;
+        if ((newByte >= 0x00 && newByte <= 0x1F) || // C0
+            (newByte >= 0x80 && newByte <= 0x9F)) { // C1
+            char newChar;
+
+            switch (newByte) {
+            case 0x1B:
+                state = ESCAPE_SEQUENCE;
+                queue.write(newByte);
+                return cr;
+            case 0x9B:
+                state = CONTROL_SEQUENCE_PIF;
+                versionSequenceAllowed = false;
+                queue.write(newByte);
+                return cr;
+            case 0x09:
+                versionSequenceAllowed = false;
+                newChar = '\t';
+                break;
+            case 0x0A:
+                versionSequenceAllowed = false;
+                newChar = '\n';
+                break;
+            default:
+                versionSequenceAllowed = false;
+                return cr;
+            }
+            if (!cb.hasRemaining())
+                return CoderResult.OVERFLOW;
+            else
+                cb.put(newChar);
+        } else {
+            CharsetDecoder decoder;
+            boolean high;
+            versionSequenceAllowed = false;
+
+            if (newByte >= 0x20 && newByte <= 0x7F) {
+                decoder = glDecoder;
+                high = glHigh;
+            } else /* if (newByte >= 0xA0 && newByte <= 0xFF) */ {
+                decoder = grDecoder;
+                high = grHigh;
+            }
+            if (lastDecoder != null && decoder != lastDecoder) {
+                cr = flushDecoder(lastDecoder, cb);
+            }
+            lastDecoder = decoder;
+
+            if (decoder != null) {
+                byte b = (byte)newByte;
+                if (high) {
+                    b |= 0x80;
+                } else {
+                    b &= 0x7F;
+                }
+                inBB.put(b);
+                inBB.flip();
+                cr = decoder.decode(inBB, cb, false);
+                if (!inBB.hasRemaining() || cr.isMalformed()) {
+                    inBB.clear();
+                } else {
+                  int pos = inBB.limit();
+                  inBB.clear();
+                  inBB.position(pos);
+                }
+            } else if (cb.remaining() < replacement().length()) {
+                cb.put(replacement());
+            } else {
+                return CoderResult.OVERFLOW;
+            }
+        }
+        return cr;
+    }
+
+    private CoderResult nonStandardBytes(short newByte, CharBuffer cb)
+    {
+        CoderResult cr = CoderResult.UNDERFLOW;
+        if (nonStandardDecoder != null) {
+            //byteBuf[0] = (byte)newByte;
+            inBB.put((byte)newByte);
+            inBB.flip();
+            cr = nonStandardDecoder.decode(inBB, cb, false);
+            if (!inBB.hasRemaining()) {
+                inBB.clear();
+            } else {
+                int pos = inBB.limit();
+                inBB.clear();
+                inBB.position(pos);
+            }
+        } else if (cb.remaining() < replacement().length()) {
+            cb.put(replacement());
+        } else {
+            return CoderResult.OVERFLOW;
+        }
+
+        ext_offset++;
+        if (ext_offset >= ext_count) {
+            ext_offset = ext_count = 0;
+            state = NORMAL_BYTES;
+            cr = flushDecoder(nonStandardDecoder, cb);
+            nonStandardDecoder = null;
+        }
+        return cr;
+    }
+
+    private CoderResult escapeSequence(short newByte) {
+        switch (newByte) {
+        case 0x23:
+            state = VERSION_SEQUENCE_V;
+            break;
+        case 0x24:
+            state = CHARSET_NGIIF;
+            versionSequenceAllowed = false;
+            break;
+        case 0x25:
+            state = CHARSET_NONSTANDARD_FOML;
+            versionSequenceAllowed = false;
+            break;
+        case 0x28:
+            state = CHARSET_LIIF;
+            versionSequenceAllowed = false;
+            break;
+        case 0x29:
+        case 0x2D:
+            state = CHARSET_RIIF;
+            versionSequenceAllowed = false;
+            break;
+        default:
+            // escapeSequenceOther will write to queue if appropriate
+            return escapeSequenceOther(newByte);
+        }
+
+        queue.write(newByte);
+        return CoderResult.UNDERFLOW;
+    }
+
+    /**
+     * Test for unknown, but valid, escape sequences.
+     */
+    private CoderResult escapeSequenceOther(short newByte) {
+        if (newByte >= 0x20 && newByte <= 0x2F) {
+            // {I}
+            state = ESCAPE_SEQUENCE_OTHER;
+            versionSequenceAllowed = false;
+            queue.write(newByte);
+        } else if (newByte >= 0x30 && newByte <= 0x7E) {
+            // F -- end of sequence
+            state = NORMAL_BYTES;
+            versionSequenceAllowed = false;
+            queue.reset();
+        } else {
+            return malformedInput(ERR_ESCBYTE);
+        }
+        return CoderResult.UNDERFLOW;
+    }
+
+    /**
+     * Parses directionality, as well as unknown, but valid, control sequences.
+     */
+    private CoderResult controlSequence(short newByte) {
+        if (newByte >= 0x30 && newByte <= 0x3F) {
+            // {P}
+            if (state == CONTROL_SEQUENCE_IF) {
+                // P no longer allowed
+                return malformedInput(ERR_CTRLPI);
+            }
+            queue.write(newByte);
+        } else if (newByte >= 0x20 && newByte <= 0x2F) {
+            // {I}
+            state = CONTROL_SEQUENCE_IF;
+            queue.write(newByte);
+        } else if (newByte >= 0x40 && newByte <= 0x7E) {
+            // F -- end of sequence
+            state = NORMAL_BYTES;
+            queue.reset();
+        } else {
+            return malformedInput(ERR_CTRLBYTE);
+        }
+        return CoderResult.UNDERFLOW;
+    }
+
+    private CoderResult versionSequence(short newByte) {
+        if (state == VERSION_SEQUENCE_V) {
+            if (newByte >= 0x20 && newByte <= 0x2F) {
+                state = VERSION_SEQUENCE_TERM;
+                queue.write(newByte);
+            } else {
+                return escapeSequenceOther(newByte);
+            }
+        } else /* if (state == VERSION_SEQUENCE_TERM) */ {
+            switch (newByte) {
+            case 0x30:
+                if (!versionSequenceAllowed) {
+                    return malformedInput(ERR_VERSTART);
+                }
+
+                // OK to ignore extensions
+                versionSequenceAllowed = false;
+                state = NORMAL_BYTES;
+                queue.reset();
+                break;
+            case 0x31:
+                return malformedInput((versionSequenceAllowed)
+                               ? ERR_VERMANDATORY : ERR_VERSTART);
+            default:
+                return escapeSequenceOther(newByte);
+            }
+        }
+        return CoderResult.UNDERFLOW;
+    }
+
+    private CoderResult charset94N(short newByte) {
+        switch (newByte) {
+        case 0x28:
+            state = CHARSET_NLIIF;
+            break;
+        case 0x29:
+            state = CHARSET_NRIIF;
+            break;
+        default:
+            // escapeSequenceOther will write byte if appropriate
+            return escapeSequenceOther(newByte);
+        }
+
+        queue.write(newByte);
+        return CoderResult.UNDERFLOW;
+    }
+
+    private CoderResult charset94NL(short newByte, CharBuffer cb) {
+        if (newByte >= 0x21 &&
+            newByte <= (state == CHARSET_NLIIF ? 0x23 : 0x2F)) {
+            // {I}
+            state = CHARSET_NLIF;
+            queue.write(newByte);
+        } else if (newByte >= 0x40 && newByte <= 0x7E) {
+            // F
+            return switchDecoder(newByte, cb);
+        } else {
+            return escapeSequenceOther(newByte);
+        }
+        return CoderResult.UNDERFLOW;
+    }
+
+    private CoderResult charset94NR(short newByte, CharBuffer cb)
+    {
+        if (newByte >= 0x21 &&
+            newByte <= (state == CHARSET_NRIIF ? 0x23 : 0x2F)) {
+            // {I}
+            state = CHARSET_NRIF;
+            queue.write(newByte);
+        } else if (newByte >= 0x40 && newByte <= 0x7E) {
+            // F
+            return switchDecoder(newByte, cb);
+        } else {
+            return escapeSequenceOther(newByte);
+        }
+        return CoderResult.UNDERFLOW;
+    }
+
+    private CoderResult charset9496L(short newByte, CharBuffer cb) {
+        if (newByte >= 0x21 &&
+            newByte <= (state == CHARSET_LIIF ? 0x23 : 0x2F)) {
+            // {I}
+            state = CHARSET_LIF;
+            queue.write(newByte);
+            return CoderResult.UNDERFLOW;
+        } else if (newByte >= 0x40 && newByte <= 0x7E) {
+            // F
+            return switchDecoder(newByte, cb);
+        } else {
+            return escapeSequenceOther(newByte);
+        }
+    }
+
+    private CoderResult charset9496R(short newByte, CharBuffer cb) {
+        if (newByte >= 0x21 &&
+            newByte <= (state == CHARSET_RIIF ? 0x23 : 0x2F)) {
+            // {I}
+            state = CHARSET_RIF;
+            queue.write(newByte);
+            return CoderResult.UNDERFLOW;
+        } else if (newByte >= 0x40 && newByte <= 0x7E) {
+            // F
+            return switchDecoder(newByte, cb);
+        } else {
+            return escapeSequenceOther(newByte);
+        }
+    }
+
+    private CoderResult charsetNonStandard(short newByte, CharBuffer cb) {
+        switch (state) {
+        case CHARSET_NONSTANDARD_FOML:
+            if (newByte == 0x2F) {
+                state = CHARSET_NONSTANDARD_OML;
+                queue.write(newByte);
+            } else {
+                return escapeSequenceOther(newByte);
+            }
+            break;
+        case CHARSET_NONSTANDARD_OML:
+            if (newByte >= 0x30 && newByte <= 0x34) {
+                state = CHARSET_NONSTANDARD_ML;
+                queue.write(newByte);
+            } else if (newByte >= 0x35 && newByte <= 0x3F) {
+                state = EXTENSION_ML;
+                queue.write(newByte);
+            } else {
+                return escapeSequenceOther(newByte);
+            }
+            break;
+        case CHARSET_NONSTANDARD_ML:
+            ext_count = (newByte & 0x7F) * 0x80;
+            state = CHARSET_NONSTANDARD_L;
+            break;
+        case CHARSET_NONSTANDARD_L:
+            ext_count = ext_count + (newByte & 0x7F);
+            state = (ext_count > 0) ? CHARSET_NONSTANDARD : NORMAL_BYTES;
+            break;
+        case CHARSET_NONSTANDARD:
+            if (newByte == 0x3F || newByte == 0x2A) {
+                queue.reset(); // In this case, only current byte is bad.
+                return malformedInput(ERR_ENCODINGBYTE);
+            }
+            ext_offset++;
+            if (ext_offset >= ext_count) {
+                ext_offset = ext_count = 0;
+                state = NORMAL_BYTES;
+                queue.reset();
+                encodingQueue.reset();
+            } else if (newByte == 0x02) {
+                // encoding name terminator
+                return switchDecoder((short)0, cb);
+            } else {
+                encodingQueue.write(newByte);
+            }
+            break;
+        default:
+            error(ERR_ILLSTATE);
+        }
+        return CoderResult.UNDERFLOW;
+    }
+
+    private CoderResult extension(short newByte) {
+        switch (state) {
+        case EXTENSION_ML:
+            ext_count = (newByte & 0x7F) * 0x80;
+            state = EXTENSION_L;
+            break;
+        case EXTENSION_L:
+            ext_count = ext_count + (newByte & 0x7F);
+            state = (ext_count > 0) ? EXTENSION : NORMAL_BYTES;
+            break;
+        case EXTENSION:
+            // Consume 'count' bytes. Don't bother putting them on the queue.
+            // There may be too many and we can't do anything with them anyway.
+            ext_offset++;
+            if (ext_offset >= ext_count) {
+                ext_offset = ext_count = 0;
+                state = NORMAL_BYTES;
+                queue.reset();
+            }
+            break;
+        default:
+            error(ERR_ILLSTATE);
+        }
+        return CoderResult.UNDERFLOW;
+    }
+
+    /**
+     * Preconditions:
+     *   1. 'queue' contains ControlSequence.escSequence
+     *   2. 'encodingQueue' contains ControlSequence.encoding
+     */
+    private CoderResult switchDecoder(short lastByte, CharBuffer cb) {
+        CoderResult cr = CoderResult.UNDERFLOW;
+        CharsetDecoder decoder = null;
+        boolean high = false;
+        byte[] escSequence;
+        byte[] encoding = null;
+
+        if (lastByte != 0) {
+            queue.write(lastByte);
+        }
+
+        escSequence = queue.toByteArray();
+        queue.reset();
+
+        if (state == CHARSET_NONSTANDARD) {
+            encoding = encodingQueue.toByteArray();
+            encodingQueue.reset();
+            decoder = CompoundTextSupport.
+                getNonStandardDecoder(escSequence, encoding);
+        } else {
+            decoder = CompoundTextSupport.getStandardDecoder(escSequence);
+            high = CompoundTextSupport.getHighBit(escSequence);
+        }
+        if (decoder != null) {
+            initDecoder(decoder);
+        } else if (unmappableCharacterAction() == CodingErrorAction.REPORT) {
+            int badInputLength = 1;
+            if (encoding != null) {
+                badInputLength = encoding.length;
+            } else if (escSequence.length > 0) {
+                badInputLength = escSequence.length;
+            }
+            return CoderResult.unmappableForLength(badInputLength);
+        }
+
+        if (state == CHARSET_NLIIF || state == CHARSET_NLIF ||
+            state == CHARSET_LIIF || state == CHARSET_LIF)
+        {
+            if (lastDecoder == glDecoder) {
+                cr = flushDecoder(glDecoder, cb);
+            }
+            glDecoder = lastDecoder = decoder;
+            glHigh = high;
+            state = NORMAL_BYTES;
+        } else if (state == CHARSET_NRIIF || state == CHARSET_NRIF ||
+                   state == CHARSET_RIIF || state == CHARSET_RIF) {
+            if (lastDecoder == grDecoder) {
+                cr = flushDecoder(grDecoder, cb);
+            }
+            grDecoder = lastDecoder = decoder;
+            grHigh = high;
+            state = NORMAL_BYTES;
+        } else if (state == CHARSET_NONSTANDARD) {
+            if (lastDecoder != null) {
+                cr = flushDecoder(lastDecoder, cb);
+                lastDecoder = null;
+            }
+            nonStandardDecoder = decoder;
+            state = NONSTANDARD_BYTES;
+        } else {
+            error(ERR_ILLSTATE);
+        }
+        return cr;
+    }
+
+    private ByteBuffer fbb= ByteBuffer.allocate(0);
+    private CoderResult flushDecoder(CharsetDecoder dec, CharBuffer cb) {
+        dec.decode(fbb, cb, true);
+        CoderResult cr = dec.flush(cb);
+        dec.reset();  //reuse
+        return cr;
+    }
+
+    private CoderResult malformedInput(String msg) {
+        int badInputLength = queue.size() + 1 /* current byte */ ;
+        queue.reset();
+        //TBD: nowhere to put the msg in CoderResult
+        return CoderResult.malformedForLength(badInputLength);
+    }
+
+    private void error(String msg) {
+        // For now, throw InternalError. Convert to 'assert' keyword later.
+        throw new InternalError(msg);
+    }
+
+    protected CoderResult implFlush(CharBuffer out) {
+        CoderResult cr = CoderResult.UNDERFLOW;
+        if (lastDecoder != null)
+          cr = flushDecoder(lastDecoder, out);
+        if (state != NORMAL_BYTES)
+            //TBD message ERR_FLUSH;
+            cr = CoderResult.malformedForLength(0);
+        reset();
+        return cr;
+    }
+
+    /**
+     * Resets the decoder.
+     * Call this method to reset the decoder to its initial state
+     */
+    protected void implReset() {
+        state = NORMAL_BYTES;
+        ext_count = ext_offset = 0;
+        versionSequenceAllowed = true;
+        queue.reset();
+        encodingQueue.reset();
+        nonStandardDecoder = lastDecoder = null;
+        glHigh = false;
+        grHigh = true;
+        try {
+            // Initial state in ISO 2022 designates Latin-1 charset.
+            glDecoder = Charset.forName("ASCII").newDecoder();
+            grDecoder = Charset.forName("ISO8859_1").newDecoder();
+        } catch (IllegalArgumentException e) {
+            error(ERR_LATIN1);
+        }
+        initDecoder(glDecoder);
+        initDecoder(grDecoder);
+    }
+
+    protected void implOnMalformedInput(CodingErrorAction newAction) {
+        if (glDecoder != null)
+            glDecoder.onMalformedInput(newAction);
+        if (grDecoder != null)
+            grDecoder.onMalformedInput(newAction);
+        if (nonStandardDecoder != null)
+            nonStandardDecoder.onMalformedInput(newAction);
+    }
+
+    protected void implOnUnmappableCharacter(CodingErrorAction newAction) {
+        if (glDecoder != null)
+            glDecoder.onUnmappableCharacter(newAction);
+        if (grDecoder != null)
+            grDecoder.onUnmappableCharacter(newAction);
+        if (nonStandardDecoder != null)
+            nonStandardDecoder.onUnmappableCharacter(newAction);
+    }
+
+    protected void implReplaceWith(String newReplacement) {
+        if (glDecoder != null)
+            glDecoder.replaceWith(newReplacement);
+        if (grDecoder != null)
+            grDecoder.replaceWith(newReplacement);
+        if (nonStandardDecoder != null)
+            nonStandardDecoder.replaceWith(newReplacement);
+    }
+
+    private void initDecoder(CharsetDecoder dec) {
+        dec.onUnmappableCharacter(CodingErrorAction.REPLACE)
+            .replaceWith(replacement());
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/cs/ext/COMPOUND_TEXT_Encoder.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/cs/ext/COMPOUND_TEXT_Encoder.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/cs/ext/COMPOUND_TEXT_Encoder.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/cs/ext/COMPOUND_TEXT_Encoder.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,352 @@
+/*
+ * Copyright 2001-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package sun.nio.cs.ext;
+
+import java.io.ByteArrayOutputStream;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.*;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+public class COMPOUND_TEXT_Encoder extends CharsetEncoder {
+
+    /**
+     * NOTE: The following four static variables should be used *only* for
+     * testing whether a encoder can encode a specific character. They
+     * cannot be used for actual encoding because they are shared across all
+     * COMPOUND_TEXT encoders and may be stateful.
+     */
+    private static final Map encodingToEncoderMap =
+        Collections.synchronizedMap(new HashMap(21, 1.0f));
+    private static final CharsetEncoder latin1Encoder;
+    private static final CharsetEncoder defaultEncoder;
+    private static final boolean defaultEncodingSupported;
+
+    static {
+        CharsetEncoder encoder = Charset.defaultCharset().newEncoder();
+        String encoding = encoder.charset().name();
+        if ("ISO8859_1".equals(encoding)) {
+            latin1Encoder = encoder;
+            defaultEncoder = encoder;
+            defaultEncodingSupported = true;
+        } else {
+            try {
+                latin1Encoder =
+                    Charset.forName("ISO8859_1").newEncoder();
+            } catch (IllegalArgumentException e) {
+                throw new ExceptionInInitializerError
+                    ("ISO8859_1 unsupported");
+            }
+            defaultEncoder = encoder;
+            defaultEncodingSupported = CompoundTextSupport.getEncodings().
+                contains(defaultEncoder.charset().name());
+        }
+    }
+
+    private CharsetEncoder encoder;
+    private char[] charBuf = new char[1];
+    private CharBuffer charbuf = CharBuffer.wrap(charBuf);
+    private ByteArrayOutputStream nonStandardCharsetBuffer;
+    private byte[] byteBuf;
+    private ByteBuffer bytebuf;
+    private int numNonStandardChars, nonStandardEncodingLen;
+
+    public COMPOUND_TEXT_Encoder(Charset cs) {
+        super(cs,
+              (float)(CompoundTextSupport.MAX_CONTROL_SEQUENCE_LEN + 2),
+              (float)(CompoundTextSupport.MAX_CONTROL_SEQUENCE_LEN + 2));
+        try {
+            encoder = Charset.forName("ISO8859_1").newEncoder();
+        } catch (IllegalArgumentException cannotHappen) {}
+        initEncoder(encoder);
+    }
+
+    protected CoderResult encodeLoop(CharBuffer src, ByteBuffer des) {
+        CoderResult cr = CoderResult.UNDERFLOW;
+        char[] input = src.array();
+        int inOff = src.arrayOffset() + src.position();
+        int inEnd = src.arrayOffset() + src.limit();
+
+        try {
+            while (inOff < inEnd && cr.isUnderflow()) {
+                charBuf[0] = input[inOff];
+                if (charBuf[0] <= '\u0008' ||
+                    (charBuf[0] >= '\u000B' && charBuf[0] <= '\u001F') ||
+                    (charBuf[0] >= '\u0080' && charBuf[0] <= '\u009F')) {
+                    // The compound text specification only permits the octets
+                    // 0x09, 0x0A, 0x1B, and 0x9B in C0 and C1. Of these, 1B and
+                    // 9B must also be removed because they initiate control
+                    // sequences.
+                    charBuf[0] = '?';
+                }
+
+                CharsetEncoder enc = getEncoder(charBuf[0]);
+                //System.out.println("char=" + charBuf[0] + ", enc=" + enc);
+                if (enc == null) {
+                    if (unmappableCharacterAction()
+                        == CodingErrorAction.REPORT) {
+                        charBuf[0] = '?';
+                        enc = latin1Encoder;
+                    } else {
+                        return CoderResult.unmappableForLength(1);
+                    }
+                }
+                if (enc != encoder) {
+                    if (nonStandardCharsetBuffer != null) {
+                        cr = flushNonStandardCharsetBuffer(des);
+                    } else {
+                        //cr= encoder.flush(des);
+                        flushEncoder(encoder, des);
+                    }
+                    if (!cr.isUnderflow())
+                        return cr;
+                    byte[] escSequence = CompoundTextSupport.
+                        getEscapeSequence(enc.charset().name());
+                    if (escSequence == null) {
+                        throw new InternalError("Unknown encoding: " +
+                                                enc.charset().name());
+                    } else if (escSequence[1] == (byte)0x25 &&
+                               escSequence[2] == (byte)0x2F) {
+                        initNonStandardCharsetBuffer(enc, escSequence);
+                    } else if (des.remaining() >= escSequence.length) {
+                        des.put(escSequence, 0, escSequence.length);
+                    } else {
+                        return CoderResult.OVERFLOW;
+                    }
+                    encoder = enc;
+                    continue;
+                }
+                charbuf.rewind();
+                if (nonStandardCharsetBuffer == null) {
+                    cr = encoder.encode(charbuf, des, false);
+                } else {
+                    bytebuf.clear();
+                    cr = encoder.encode(charbuf, bytebuf, false);
+                    bytebuf.flip();
+                    nonStandardCharsetBuffer.write(byteBuf,
+                                                   0, bytebuf.limit());
+                    numNonStandardChars++;
+                }
+                inOff++;
+            }
+            return cr;
+        } finally {
+            src.position(inOff - src.arrayOffset());
+        }
+    }
+
+    protected CoderResult implFlush(ByteBuffer out) {
+        CoderResult cr = (nonStandardCharsetBuffer != null)
+            ? flushNonStandardCharsetBuffer(out)
+            //: encoder.flush(out);
+            : flushEncoder(encoder, out);
+        reset();
+        return cr;
+    }
+
+    private void initNonStandardCharsetBuffer(CharsetEncoder c,
+                                              byte[] escSequence)
+    {
+        nonStandardCharsetBuffer = new ByteArrayOutputStream();
+        byteBuf = new byte[(int)c.maxBytesPerChar()];
+        bytebuf = ByteBuffer.wrap(byteBuf);
+        nonStandardCharsetBuffer.write(escSequence, 0, escSequence.length);
+        nonStandardCharsetBuffer.write(0); // M placeholder
+        nonStandardCharsetBuffer.write(0); // L placeholder
+        byte[] encoding = CompoundTextSupport.
+            getEncoding(c.charset().name());
+        if (encoding == null) {
+            throw new InternalError
+                ("Unknown encoding: " + encoder.charset().name());
+        }
+        nonStandardCharsetBuffer.write(encoding, 0, encoding.length);
+        nonStandardCharsetBuffer.write(0x02); // divider
+        nonStandardEncodingLen = encoding.length + 1;
+    }
+
+    private CoderResult flushNonStandardCharsetBuffer(ByteBuffer out) {
+        if (numNonStandardChars > 0) {
+            byte[] flushBuf = new byte[(int)encoder.maxBytesPerChar() *
+                                       numNonStandardChars];
+            ByteBuffer bb = ByteBuffer.wrap(flushBuf);
+            flushEncoder(encoder, bb);
+            bb.flip();
+            nonStandardCharsetBuffer.write(flushBuf, 0, bb.limit());
+            numNonStandardChars = 0;
+        }
+
+        int numBytes = nonStandardCharsetBuffer.size();
+        int nonStandardBytesOff = 6 + nonStandardEncodingLen;
+
+        if (out.remaining() < (numBytes - nonStandardBytesOff) +
+            nonStandardBytesOff * (((numBytes - nonStandardBytesOff) /
+                                    ((1 << 14) - 1)) + 1))
+        {
+            return CoderResult.OVERFLOW;
+        }
+
+        byte[] nonStandardBytes =
+            nonStandardCharsetBuffer.toByteArray();
+
+        // The non-standard charset header only supports 2^14-1 bytes of data.
+        // If we have more than that, we have to repeat the header.
+        do {
+            out.put((byte)0x1B);
+            out.put((byte)0x25);
+            out.put((byte)0x2F);
+            out.put((byte)nonStandardBytes[3]);
+
+            int toWrite = Math.min(numBytes - nonStandardBytesOff,
+                                   (1 << 14) - 1 - nonStandardEncodingLen);
+
+            out.put((byte)
+                (((toWrite + nonStandardEncodingLen) / 0x80) | 0x80)); // M
+            out.put((byte)
+                (((toWrite + nonStandardEncodingLen) % 0x80) | 0x80)); // L
+            out.put(nonStandardBytes, 6, nonStandardEncodingLen);
+            out.put(nonStandardBytes, nonStandardBytesOff, toWrite);
+            nonStandardBytesOff += toWrite;
+        } while (nonStandardBytesOff < numBytes);
+
+        nonStandardCharsetBuffer = null;
+        byteBuf = null;
+        nonStandardEncodingLen = 0;
+        return CoderResult.UNDERFLOW;
+    }
+
+    /**
+     * Resets the encoder.
+     * Call this method to reset the encoder to its initial state
+     */
+    protected void implReset() {
+        numNonStandardChars = nonStandardEncodingLen = 0;
+        nonStandardCharsetBuffer = null;
+        byteBuf = null;
+        try {
+            encoder = Charset.forName("ISO8859_1").newEncoder();
+        } catch (IllegalArgumentException cannotHappen) {
+        }
+        initEncoder(encoder);
+    }
+
+    /**
+     * Return whether a character is mappable or not
+     * @return true if a character is mappable
+     */
+    public boolean canEncode(char ch) {
+        return getEncoder(ch) != null;
+    }
+
+    protected void implOnMalformedInput(CodingErrorAction newAction) {
+        encoder.onUnmappableCharacter(newAction);
+    }
+
+    protected void implOnUnmappableCharacter(CodingErrorAction newAction) {
+        encoder.onUnmappableCharacter(newAction);
+    }
+
+    protected void implReplaceWith(byte[] newReplacement) {
+        if (encoder != null)
+            encoder.replaceWith(newReplacement);
+    }
+
+    /**
+     * Try to figure out which CharsetEncoder to use for conversion
+     * of the specified Unicode character. The target character encoding
+     * of the returned encoder is approved to be used with Compound Text.
+     *
+     * @param ch Unicode character
+     * @return CharsetEncoder to convert the given character
+     */
+    private CharsetEncoder getEncoder(char ch) {
+        // 1. Try the current encoder.
+        if (encoder.canEncode(ch)) {
+            return encoder;
+        }
+
+        // 2. Try the default encoder.
+        if (defaultEncodingSupported && defaultEncoder.canEncode(ch)) {
+            CharsetEncoder retval = null;
+            try {
+                retval = defaultEncoder.charset().newEncoder();
+            } catch (UnsupportedOperationException cannotHappen) {
+            }
+            initEncoder(retval);
+            return retval;
+        }
+
+        // 3. Try ISO8859-1.
+        if (latin1Encoder.canEncode(ch)) {
+            CharsetEncoder retval = null;
+            try {
+                retval = latin1Encoder.charset().newEncoder();
+            } catch (UnsupportedOperationException cannotHappen) {}
+            initEncoder(retval);
+            return retval;
+        }
+
+        // 4. Brute force search of all supported encodings.
+        for (Iterator iter = CompoundTextSupport.getEncodings().iterator();
+             iter.hasNext();)
+        {
+            String encoding = (String)iter.next();
+            CharsetEncoder enc =
+                (CharsetEncoder)encodingToEncoderMap.get(encoding);
+            if (enc == null) {
+                enc = CompoundTextSupport.getEncoder(encoding);
+                if (enc == null) {
+                    throw new InternalError("Unsupported encoding: " +
+                                            encoding);
+                }
+                encodingToEncoderMap.put(encoding, enc);
+            }
+            if (enc.canEncode(ch)) {
+                CharsetEncoder retval = CompoundTextSupport.getEncoder(encoding);
+                initEncoder(retval);
+                return retval;
+            }
+        }
+
+        return null;
+    }
+
+    private void initEncoder(CharsetEncoder enc) {
+        try {
+            enc.onUnmappableCharacter(CodingErrorAction.REPLACE)
+                .replaceWith(replacement());
+        } catch (IllegalArgumentException x) {}
+    }
+
+    private CharBuffer fcb= CharBuffer.allocate(0);
+    private CoderResult flushEncoder(CharsetEncoder enc, ByteBuffer bb) {
+        enc.encode(fcb, bb, true);
+        return enc.flush(bb);
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/cs/ext/COMPOUND_TEXT.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/cs/ext/COMPOUND_TEXT.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/cs/ext/COMPOUND_TEXT.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/cs/ext/COMPOUND_TEXT.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2005-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.cs.ext;
+
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetEncoder;
+import java.nio.charset.CharsetDecoder;
+
+public class COMPOUND_TEXT extends Charset {
+    public COMPOUND_TEXT () {
+        super("x-COMPOUND_TEXT",
+              ExtendedCharsets.aliasesFor("x-COMPOUND_TEXT"));
+    }
+
+    public CharsetEncoder newEncoder() {
+        return new COMPOUND_TEXT_Encoder(this);
+    }
+
+    public CharsetDecoder newDecoder() {
+        return new COMPOUND_TEXT_Decoder(this);
+    }
+
+    public boolean contains(Charset cs) {
+        return cs instanceof COMPOUND_TEXT;
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/cs/ext/CompoundTextSupport.java phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/cs/ext/CompoundTextSupport.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/classes/sun/nio/cs/ext/CompoundTextSupport.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/classes/sun/nio/cs/ext/CompoundTextSupport.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,548 @@
+/*
+ * Copyright 2001-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.cs.ext;
+
+import java.util.Collections;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.nio.charset.*;
+
+final class CompoundTextSupport {
+
+    private static final class ControlSequence {
+
+        final int hash;
+        final byte[] escSequence;
+        final byte[] encoding;
+
+        ControlSequence(byte[] escSequence) {
+            this(escSequence, null);
+        }
+        ControlSequence(byte[] escSequence, byte[] encoding) {
+            if (escSequence == null) {
+                throw new NullPointerException();
+            }
+
+            this.escSequence = escSequence;
+            this.encoding = encoding;
+
+            int hash = 0;
+            int length = escSequence.length;
+
+            for (int i = 0; i < escSequence.length; i++) {
+                hash += (((int)escSequence[i]) & 0xff) << (i % 4);
+            }
+            if (encoding != null) {
+                for (int i = 0; i < encoding.length; i++) {
+                    hash += (((int)encoding[i]) & 0xff) << (i % 4);
+                }
+                length += 2 /* M L */ + encoding.length + 1 /* 0x02 */;
+            }
+
+            this.hash = hash;
+
+            if (MAX_CONTROL_SEQUENCE_LEN < length) {
+                MAX_CONTROL_SEQUENCE_LEN = length;
+            }
+        }
+
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (!(obj instanceof ControlSequence)) {
+                return false;
+            }
+            ControlSequence rhs = (ControlSequence)obj;
+            if (escSequence != rhs.escSequence) {
+                if (escSequence.length != rhs.escSequence.length) {
+                    return false;
+                }
+                for (int i = 0; i < escSequence.length; i++) {
+                    if (escSequence[i] != rhs.escSequence[i]) {
+                        return false;
+                    }
+                }
+            }
+            if (encoding != rhs.encoding) {
+                if (encoding == null || rhs.encoding == null ||
+                    encoding.length != rhs.encoding.length)
+                {
+                    return false;
+                }
+                for (int i = 0; i < encoding.length; i++) {
+                    if (encoding[i] != rhs.encoding[i]) {
+                        return false;
+                    }
+                }
+            }
+            return true;
+        }
+
+        public int hashCode() {
+            return hash;
+        }
+
+        ControlSequence concatenate(ControlSequence rhs) {
+            if (encoding != null) {
+                throw new IllegalArgumentException
+                    ("cannot concatenate to a non-standard charset escape " +
+                     "sequence");
+            }
+
+            int len = escSequence.length + rhs.escSequence.length;
+            byte[] newEscSequence = new byte[len];
+            System.arraycopy(escSequence, 0, newEscSequence, 0,
+                             escSequence.length);
+            System.arraycopy(rhs.escSequence, 0, newEscSequence,
+                             escSequence.length, rhs.escSequence.length);
+            return new ControlSequence(newEscSequence, rhs.encoding);
+        }
+    }
+
+    static int MAX_CONTROL_SEQUENCE_LEN;
+
+    /**
+     * Maps a GL or GR escape sequence to an encoding.
+     */
+    private static final Map sequenceToEncodingMap;
+
+    /**
+     * Indicates whether a particular encoding wants the high bit turned on
+     * or off.
+     */
+    private static final Map highBitsMap;
+
+    /**
+     * Maps an encoding to an escape sequence. Rather than manage two
+     * converters in CharToByteCOMPOUND_TEXT, we output escape sequences which
+     * modify both GL and GR if necessary. This makes the output slightly less
+     * efficient, but our code much simpler.
+     */
+    private static final Map encodingToSequenceMap;
+
+    /**
+     * The keys of 'encodingToSequenceMap', sorted in preferential order.
+     */
+    private static final List encodings;
+
+    static {
+        HashMap tSequenceToEncodingMap = new HashMap(33, 1.0f);
+        HashMap tHighBitsMap = new HashMap(31, 1.0f);
+        HashMap tEncodingToSequenceMap = new HashMap(21, 1.0f);
+        ArrayList tEncodings = new ArrayList(21);
+
+        if (!(isEncodingSupported("US-ASCII") &&
+              isEncodingSupported("ISO-8859-1")))
+        {
+            throw new ExceptionInInitializerError
+                ("US-ASCII and ISO-8859-1 unsupported");
+        }
+
+        ControlSequence leftAscii = // high bit off, leave off
+            new ControlSequence(new byte[] { 0x1B, 0x28, 0x42 });
+        tSequenceToEncodingMap.put(leftAscii, "US-ASCII");
+        tHighBitsMap.put(leftAscii, Boolean.FALSE);
+
+        {
+            ControlSequence rightAscii = // high bit on, turn off
+                new ControlSequence(new byte[] { 0x1B, 0x29, 0x42 });
+            tSequenceToEncodingMap.put(rightAscii, "US-ASCII");
+            tHighBitsMap.put(rightAscii, Boolean.FALSE);
+        }
+
+        {
+            ControlSequence rightHalf = // high bit on, leave on
+                new ControlSequence(new byte[] { 0x1B, 0x2D, 0x41 });
+            tSequenceToEncodingMap.put(rightHalf, "ISO-8859-1");
+            tHighBitsMap.put(rightHalf, Boolean.TRUE);
+
+            ControlSequence fullSet = leftAscii.concatenate(rightHalf);
+            tEncodingToSequenceMap.put("ISO-8859-1", fullSet);
+            tEncodings.add("ISO-8859-1");
+        }
+        if (isEncodingSupported("ISO-8859-2")) {
+            ControlSequence rightHalf = // high bit on, leave on
+                new ControlSequence(new byte[] { 0x1B, 0x2D, 0x42 });
+            tSequenceToEncodingMap.put(rightHalf, "ISO-8859-2");
+            tHighBitsMap.put(rightHalf, Boolean.TRUE);
+
+            ControlSequence fullSet = leftAscii.concatenate(rightHalf);
+            tEncodingToSequenceMap.put("ISO-8859-2", fullSet);
+            tEncodings.add("ISO-8859-2");
+        }
+        if (isEncodingSupported("ISO-8859-3")) {
+            ControlSequence rightHalf = // high bit on, leave on
+                new ControlSequence(new byte[] { 0x1B, 0x2D, 0x43 });
+            tSequenceToEncodingMap.put(rightHalf, "ISO-8859-3");
+            tHighBitsMap.put(rightHalf, Boolean.TRUE);
+
+            ControlSequence fullSet = leftAscii.concatenate(rightHalf);
+            tEncodingToSequenceMap.put("ISO-8859-3", fullSet);
+            tEncodings.add("ISO-8859-3");
+        }
+        if (isEncodingSupported("ISO-8859-4")) {
+            ControlSequence rightHalf = // high bit on, leave on
+                new ControlSequence(new byte[] { 0x1B, 0x2D, 0x44 });
+            tSequenceToEncodingMap.put(rightHalf, "ISO-8859-4");
+            tHighBitsMap.put(rightHalf, Boolean.TRUE);
+
+            ControlSequence fullSet = leftAscii.concatenate(rightHalf);
+            tEncodingToSequenceMap.put("ISO-8859-4", fullSet);
+            tEncodings.add("ISO-8859-4");
+        }
+        if (isEncodingSupported("ISO-8859-5")) {
+            ControlSequence rightHalf = // high bit on, leave on
+                new ControlSequence(new byte[] { 0x1B, 0x2D, 0x4C });
+            tSequenceToEncodingMap.put(rightHalf, "ISO-8859-5");
+            tHighBitsMap.put(rightHalf, Boolean.TRUE);
+
+            ControlSequence fullSet = leftAscii.concatenate(rightHalf);
+            tEncodingToSequenceMap.put("ISO-8859-5", fullSet);
+            tEncodings.add("ISO-8859-5");
+        }
+        if (isEncodingSupported("ISO-8859-6")) {
+            ControlSequence rightHalf = // high bit on, leave on
+                new ControlSequence(new byte[] { 0x1B, 0x2D, 0x47 });
+            tSequenceToEncodingMap.put(rightHalf, "ISO-8859-6");
+            tHighBitsMap.put(rightHalf, Boolean.TRUE);
+
+            ControlSequence fullSet = leftAscii.concatenate(rightHalf);
+            tEncodingToSequenceMap.put("ISO-8859-6", fullSet);
+            tEncodings.add("ISO-8859-6");
+        }
+        if (isEncodingSupported("ISO-8859-7")) {
+            ControlSequence rightHalf = // high bit on, leave on
+                new ControlSequence(new byte[] { 0x1B, 0x2D, 0x46 });
+            tSequenceToEncodingMap.put(rightHalf, "ISO-8859-7");
+            tHighBitsMap.put(rightHalf, Boolean.TRUE);
+
+            ControlSequence fullSet = leftAscii.concatenate(rightHalf);
+            tEncodingToSequenceMap.put("ISO-8859-7", fullSet);
+            tEncodings.add("ISO-8859-7");
+        }
+        if (isEncodingSupported("ISO-8859-8")) {
+            ControlSequence rightHalf = // high bit on, leave on
+                new ControlSequence(new byte[] { 0x1B, 0x2D, 0x48 });
+            tSequenceToEncodingMap.put(rightHalf, "ISO-8859-8");
+            tHighBitsMap.put(rightHalf, Boolean.TRUE);
+
+            ControlSequence fullSet = leftAscii.concatenate(rightHalf);
+            tEncodingToSequenceMap.put("ISO-8859-8", fullSet);
+            tEncodings.add("ISO-8859-8");
+        }
+        if (isEncodingSupported("ISO-8859-9")) {
+            ControlSequence rightHalf = // high bit on, leave on
+                new ControlSequence(new byte[] { 0x1B, 0x2D, 0x4D });
+            tSequenceToEncodingMap.put(rightHalf, "ISO-8859-9");
+            tHighBitsMap.put(rightHalf, Boolean.TRUE);
+
+            ControlSequence fullSet = leftAscii.concatenate(rightHalf);
+            tEncodingToSequenceMap.put("ISO-8859-9", fullSet);
+            tEncodings.add("ISO-8859-9");
+        }
+        if (isEncodingSupported("JIS_X0201")) {
+            ControlSequence glLeft = // high bit off, leave off
+                new ControlSequence(new byte[] { 0x1B, 0x28, 0x4A });
+            ControlSequence glRight = // high bit off, turn on
+                new ControlSequence(new byte[] { 0x1B, 0x28, 0x49 });
+            ControlSequence grLeft = // high bit on, turn off
+                new ControlSequence(new byte[] { 0x1B, 0x29, 0x4A });
+            ControlSequence grRight = // high bit on, leave on
+                new ControlSequence(new byte[] { 0x1B, 0x29, 0x49 });
+            tSequenceToEncodingMap.put(glLeft, "JIS_X0201");
+            tSequenceToEncodingMap.put(glRight, "JIS_X0201");
+            tSequenceToEncodingMap.put(grLeft, "JIS_X0201");
+            tSequenceToEncodingMap.put(grRight, "JIS_X0201");
+            tHighBitsMap.put(glLeft, Boolean.FALSE);
+            tHighBitsMap.put(glRight, Boolean.TRUE);
+            tHighBitsMap.put(grLeft, Boolean.FALSE);
+            tHighBitsMap.put(grRight, Boolean.TRUE);
+
+            ControlSequence fullSet = glLeft.concatenate(grRight);
+            tEncodingToSequenceMap.put("JIS_X0201", fullSet);
+            tEncodings.add("JIS_X0201");
+        }
+        if (isEncodingSupported("X11GB2312")) {
+            ControlSequence leftHalf =  // high bit off, leave off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x28, 0x41 });
+            ControlSequence rightHalf = // high bit on, turn off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x29, 0x41 });
+            tSequenceToEncodingMap.put(leftHalf, "X11GB2312");
+            tSequenceToEncodingMap.put(rightHalf, "X11GB2312");
+            tHighBitsMap.put(leftHalf, Boolean.FALSE);
+            tHighBitsMap.put(rightHalf, Boolean.FALSE);
+
+            tEncodingToSequenceMap.put("X11GB2312", leftHalf);
+            tEncodings.add("X11GB2312");
+        }
+        if (isEncodingSupported("x-JIS0208")) {
+            ControlSequence leftHalf = // high bit off, leave off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x28, 0x42 });
+            ControlSequence rightHalf = // high bit on, turn off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x29, 0x42 });
+            tSequenceToEncodingMap.put(leftHalf, "x-JIS0208");
+            tSequenceToEncodingMap.put(rightHalf, "x-JIS0208");
+            tHighBitsMap.put(leftHalf, Boolean.FALSE);
+            tHighBitsMap.put(rightHalf, Boolean.FALSE);
+
+            tEncodingToSequenceMap.put("x-JIS0208", leftHalf);
+            tEncodings.add("x-JIS0208");
+        }
+        if (isEncodingSupported("X11KSC5601")) {
+            ControlSequence leftHalf = // high bit off, leave off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x28, 0x43 });
+            ControlSequence rightHalf = // high bit on, turn off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x29, 0x43 });
+            tSequenceToEncodingMap.put(leftHalf, "X11KSC5601");
+            tSequenceToEncodingMap.put(rightHalf, "X11KSC5601");
+            tHighBitsMap.put(leftHalf, Boolean.FALSE);
+            tHighBitsMap.put(rightHalf, Boolean.FALSE);
+
+            tEncodingToSequenceMap.put("X11KSC5601", leftHalf);
+            tEncodings.add("X11KSC5601");
+        }
+
+        // Encodings not listed in Compound Text Encoding spec
+
+        // Esc seq: -b
+        if (isEncodingSupported("ISO-8859-15")) {
+            ControlSequence rightHalf = // high bit on, leave on
+                new ControlSequence(new byte[] { 0x1B, 0x2D, 0x62 });
+            tSequenceToEncodingMap.put(rightHalf, "ISO-8859-15");
+            tHighBitsMap.put(rightHalf, Boolean.TRUE);
+
+            ControlSequence fullSet = leftAscii.concatenate(rightHalf);
+            tEncodingToSequenceMap.put("ISO-8859-15", fullSet);
+            tEncodings.add("ISO-8859-15");
+        }
+        // Esc seq: -T
+        if (isEncodingSupported("TIS-620")) {
+            ControlSequence rightHalf = // high bit on, leave on
+                new ControlSequence(new byte[] { 0x1B, 0x2D, 0x54 });
+            tSequenceToEncodingMap.put(rightHalf, "TIS-620");
+            tHighBitsMap.put(rightHalf, Boolean.TRUE);
+
+            ControlSequence fullSet = leftAscii.concatenate(rightHalf);
+            tEncodingToSequenceMap.put("TIS-620", fullSet);
+            tEncodings.add("TIS-620");
+        }
+        if (isEncodingSupported("JIS_X0212-1990")) {
+            ControlSequence leftHalf = // high bit off, leave off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x28, 0x44 });
+            ControlSequence rightHalf = // high bit on, turn off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x29, 0x44 });
+            tSequenceToEncodingMap.put(leftHalf, "JIS_X0212-1990");
+            tSequenceToEncodingMap.put(rightHalf, "JIS_X0212-1990");
+            tHighBitsMap.put(leftHalf, Boolean.FALSE);
+            tHighBitsMap.put(rightHalf, Boolean.FALSE);
+
+            tEncodingToSequenceMap.put("JIS_X0212-1990", leftHalf);
+            tEncodings.add("JIS_X0212-1990");
+        }
+        if (isEncodingSupported("X11CNS11643P1")) {
+            ControlSequence leftHalf = // high bit off, leave off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x28, 0x47 });
+            ControlSequence rightHalf = // high bit on, turn off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x29, 0x47 });
+            tSequenceToEncodingMap.put(leftHalf, "X11CNS11643P1");
+            tSequenceToEncodingMap.put(rightHalf, "X11CNS11643P1");
+            tHighBitsMap.put(leftHalf, Boolean.FALSE);
+            tHighBitsMap.put(rightHalf, Boolean.FALSE);
+
+            tEncodingToSequenceMap.put("X11CNS11643P1", leftHalf);
+            tEncodings.add("X11CNS11643P1");
+        }
+        if (isEncodingSupported("X11CNS11643P2")) {
+            ControlSequence leftHalf = // high bit off, leave off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x28, 0x48 });
+            ControlSequence rightHalf = // high bit on, turn off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x29, 0x48 });
+            tSequenceToEncodingMap.put(leftHalf, "X11CNS11643P2");
+            tSequenceToEncodingMap.put(rightHalf, "X11CNS11643P2");
+            tHighBitsMap.put(leftHalf, Boolean.FALSE);
+            tHighBitsMap.put(rightHalf, Boolean.FALSE);
+
+            tEncodingToSequenceMap.put("X11CNS11643P2", leftHalf);
+            tEncodings.add("X11CNS11643P2");
+        }
+        if (isEncodingSupported("X11CNS11643P3")) {
+            ControlSequence leftHalf = // high bit off, leave off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x28, 0x49 });
+            ControlSequence rightHalf = // high bit on, turn off
+                new ControlSequence(new byte[] { 0x1B, 0x24, 0x29, 0x49 });
+            tSequenceToEncodingMap.put(leftHalf, "X11CNS11643P3");
+            tSequenceToEncodingMap.put(rightHalf, "X11CNS11643P3");
+            tHighBitsMap.put(leftHalf, Boolean.FALSE);
+            tHighBitsMap.put(rightHalf, Boolean.FALSE);
+
+            tEncodingToSequenceMap.put("X11CNS11643P3", leftHalf);
+            tEncodings.add("X11CNS11643P3");
+        }
+        // Esc seq: %/2??SUN-KSC5601.1992-3
+        if (isEncodingSupported("x-Johab")) {
+            // 0x32 looks wrong. It's copied from the Sun X11 Compound Text
+            // support code. It implies that all Johab characters comprise two
+            // octets, which isn't true. Johab supports the ASCII/KS-Roman
+            // characters from 0x21-0x7E with single-byte representations.
+            ControlSequence johab = new ControlSequence(
+                new byte[] { 0x1b, 0x25, 0x2f, 0x32 },
+                new byte[] { 0x53, 0x55, 0x4e, 0x2d, 0x4b, 0x53, 0x43, 0x35,
+                             0x36, 0x30, 0x31, 0x2e, 0x31, 0x39, 0x39, 0x32,
+                             0x2d, 0x33 });
+            tSequenceToEncodingMap.put(johab, "x-Johab");
+            tEncodingToSequenceMap.put("x-Johab", johab);
+            tEncodings.add("x-Johab");
+        }
+        // Esc seq: %/2??SUN-BIG5-1
+        if (isEncodingSupported("Big5")) {
+            // 0x32 looks wrong. It's copied from the Sun X11 Compound Text
+            // support code. It implies that all Big5 characters comprise two
+            // octets, which isn't true. Big5 supports the ASCII/CNS-Roman
+            // characters from 0x21-0x7E with single-byte representations.
+            ControlSequence big5 = new ControlSequence(
+                new byte[] { 0x1b, 0x25, 0x2f, 0x32 },
+                new byte[] { 0x53, 0x55, 0x4e, 0x2d, 0x42, 0x49, 0x47, 0x35,
+                             0x2d, 0x31 });
+            tSequenceToEncodingMap.put(big5, "Big5");
+            tEncodingToSequenceMap.put("Big5", big5);
+            tEncodings.add("Big5");
+        }
+
+        sequenceToEncodingMap =
+            Collections.unmodifiableMap(tSequenceToEncodingMap);
+        highBitsMap = Collections.unmodifiableMap(tHighBitsMap);
+        encodingToSequenceMap =
+            Collections.unmodifiableMap(tEncodingToSequenceMap);
+        encodings = Collections.unmodifiableList(tEncodings);
+    }
+
+    private static boolean isEncodingSupported(String encoding) {
+        try {
+            if (Charset.isSupported(encoding))
+                return true;
+        } catch (IllegalArgumentException x) { }
+        return (getDecoder(encoding) != null &&
+                getEncoder(encoding) != null);
+    }
+
+
+    // For Decoder
+    static CharsetDecoder getStandardDecoder(byte[] escSequence) {
+        return getNonStandardDecoder(escSequence, null);
+    }
+    static boolean getHighBit(byte[] escSequence) {
+        Boolean bool = (Boolean)highBitsMap.get
+            (new ControlSequence(escSequence));
+        return (bool == Boolean.TRUE);
+    }
+    static CharsetDecoder getNonStandardDecoder(byte[] escSequence,
+                                                       byte[] encoding) {
+        return getDecoder((String)sequenceToEncodingMap.get
+            (new ControlSequence(escSequence, encoding)));
+    }
+    static CharsetDecoder getDecoder(String enc) {
+        if (enc == null) {
+            return null;
+        }
+        Charset cs = null;
+        try {
+            cs = Charset.forName(enc);
+        } catch (IllegalArgumentException e) {
+            Class cls;
+            try {
+                cls = Class.forName("sun.awt.motif." + enc);
+            } catch (ClassNotFoundException ee) {
+                return null;
+            }
+            try {
+                cs = (Charset)cls.newInstance();
+            } catch (InstantiationException ee) {
+                return null;
+            } catch (IllegalAccessException ee) {
+                return null;
+            }
+        }
+        try {
+            return cs.newDecoder();
+        } catch (UnsupportedOperationException e) {}
+        return null;
+    }
+
+
+    // For Encoder
+    static byte[] getEscapeSequence(String encoding) {
+        ControlSequence seq = (ControlSequence)
+            encodingToSequenceMap.get(encoding);
+        if (seq != null) {
+            return seq.escSequence;
+        }
+        return null;
+    }
+    static byte[] getEncoding(String encoding) {
+        ControlSequence seq = (ControlSequence)
+            encodingToSequenceMap.get(encoding);
+        if (seq != null) {
+            return seq.encoding;
+        }
+        return null;
+    }
+    static List getEncodings() {
+        return encodings;
+    }
+    static CharsetEncoder getEncoder(String enc) {
+        if (enc == null) {
+            return null;
+        }
+        Charset cs = null;
+        try {
+            cs = Charset.forName(enc);
+        } catch (IllegalArgumentException e) {
+            Class cls;
+            try {
+                cls = Class.forName("sun.awt.motif." + enc);
+            } catch (ClassNotFoundException ee) {
+                return null;
+            }
+            try {
+                cs = (Charset)cls.newInstance();
+            } catch (InstantiationException ee) {
+                return null;
+            } catch (IllegalAccessException ee) {
+                return null;
+            }
+        }
+        try {
+            return cs.newEncoder();
+        } catch (Throwable e) {}
+        return null;
+    }
+
+    // Not an instantiable class
+    private CompoundTextSupport() {}
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/javavm/include/threads_md.h phoneme_advanced-mr2-dev-b122/cdc/src/linux/javavm/include/threads_md.h
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/javavm/include/threads_md.h	2009-07-06 18:35:22.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/javavm/include/threads_md.h	2011-01-21 15:09:54.000000000 -0500
@@ -29,6 +29,8 @@
  * Machine-dependent thread definitions.
  */
 
+#define LINUX_THREAD_PRIORITY_HACK
+
 #ifndef _LINUX_THREADS_MD_H
 #define _LINUX_THREADS_MD_H
 
@@ -71,6 +73,10 @@
     /* IO or wait queue */
     CVMThreadID *next;
     CVMThreadID **prev_p;
+#ifdef LINUX_THREAD_PRIORITY_HACK
+    pid_t threadid;
+    CVMInt32 priority;
+#endif
 };
 
 #define POSIX_COOKIE(t)		((t)->pthreadCookie)
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/javavm/runtime/sync_md.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/javavm/runtime/sync_md.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/javavm/runtime/sync_md.c	2009-07-06 18:35:21.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/javavm/runtime/sync_md.c	2009-07-06 19:25:13.000000000 -0400
@@ -48,6 +48,40 @@
 #include "javavm/include/porting/jit/jit.h"
 #endif
 
+/* BEGIN for Debug Use only */
+#include "javavm/include/interpreter.h"
+
+/* Warning: This thread dumper is only for the use of debugging code.
+   There's a risk that it can potentially crash the VM if invoked at
+   the wrong time.  Hence, this is not to be incorporated into a
+   production build.  It is only for assisting in debugging efforts
+   when needed.
+*/
+static void threadDumpHandler(int sig)
+{
+    CVMExecEnv *ee = CVMgetEE();
+    CVMBool success;
+    int threadCount = 1;
+
+    success = CVMsysMutexTryLock(ee, &CVMglobals.threadLock);
+    if (!success) {
+       return;
+    }
+
+    CVMconsolePrintf("\nStart thread dump:\n");
+    CVMconsolePrintf("======================================\n");
+    CVM_WALK_ALL_THREADS(ee, threadEE, {
+       CVMconsolePrintf("Thread %d: ee 0x%x", threadCount, threadEE);
+       CVMdumpStack(&threadEE->interpreterStack,0,0,0);
+       CVMconsolePrintf("======================================\n");
+       threadCount++;
+    });
+    CVMconsolePrintf("End thread dump\n\n");
+
+    CVMsysMutexUnlock(ee, &CVMglobals.threadLock);
+}
+/* END for Debug Use only */
+
 /*
  * signal handler for CVMthreadSuspend() and CVMthreadResume() request.
  */
@@ -539,6 +573,10 @@
 #if defined(CVM_JVMPI) || defined(CVM_JVMTI)
             {SIGQUIT, sigquitHandler, SA_RESTART},
 #endif
+            /* BEGIN for Debug Use only */
+            {SIGQUIT, threadDumpHandler, SA_RESTART},
+            /* END for Debug Use only */
+
 	    {SIGUSR1, handleSuspendResume, SA_RESTART},
 	    {SIGBUS, crash, 0},
 	    {SIGILL, crash, 0},
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/javavm/runtime/sync_md.c.orig phoneme_advanced-mr2-dev-b122/cdc/src/linux/javavm/runtime/sync_md.c.orig
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/javavm/runtime/sync_md.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/javavm/runtime/sync_md.c.orig	2009-07-06 18:35:21.000000000 -0400
@@ -0,0 +1,563 @@
+/*
+ * @(#)sync_md.c	1.32 06/10/10
+ *
+ * Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.  
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+ *   
+ * This program is free software; you can redistribute it and/or  
+ * modify it under the terms of the GNU General Public License version  
+ * 2 only, as published by the Free Software Foundation.   
+ *   
+ * This program is distributed in the hope that it will be useful, but  
+ * WITHOUT ANY WARRANTY; without even the implied warranty of  
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+ * General Public License version 2 for more details (a copy is  
+ * included at /legal/license.txt).   
+ *   
+ * You should have received a copy of the GNU General Public License  
+ * version 2 along with this work; if not, write to the Free Software  
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+ * 02110-1301 USA   
+ *   
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+ * Clara, CA 95054 or visit www.sun.com if you need additional  
+ * information or have any questions. 
+ *
+ */
+
+#include "javavm/include/porting/sync.h"
+#include "javavm/include/porting/threads.h"
+#include "javavm/include/porting/float.h"	/* for setFPMode() */
+#include <pthread.h>
+#include <sys/time.h>
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+#include <assert.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#ifdef CVM_JVMPI
+#include "javavm/include/globals.h"
+#endif
+#ifdef CVM_JVMTI
+#include "javavm/include/globals.h"
+#include "javavm/include/jvmtiExport.h"
+#endif
+#ifdef CVM_JIT
+#include "javavm/include/porting/jit/jit.h"
+#endif
+
+/*
+ * signal handler for CVMthreadSuspend() and CVMthreadResume() request.
+ */
+/* NOTE: handleSuspendResume() is needed regardless of whether we enable
+   thread suspension or not.  This is because the IO system uses SIGUSR1 to
+   break a blocked thread out of its wait if the corresponding file descriptor
+   is closed.  All the signal handler has to do in those cases is return.
+   In the event that thread suspension is enabled, a SIGUSR1 from an IO
+   function will cause the handler to be called, but since the handler always
+   check the current suspension state self->isSuspended, receiving these
+   SIGUSR1s won't change the behavior of suspension code.  This is as we
+   expect it to be.
+*/
+static void handleSuspendResume(int sig)
+{
+#ifdef CVM_THREAD_SUSPENSION
+    CVMThreadID *self = CVMthreadSelf();
+    assert(POSIX_COOKIE(self) == pthread_self());
+
+    /* NOTE: Normally, the SIGUSR1 signal would be masked out while we're in
+       this handler thereby preventing this handler function from being called
+       recursively.  However, the sigsuspend() call below is designed to
+       suspend this thread while re-enabling SIGUSR1 so that we can wake up
+       if someone sends us that signal again (usually to resume the thread).
+       Hence, it is possible to enter this handler recursively when we're
+       waiting for sigsuspend() to return.  The isInSuspendHandler flag is
+       used to ensure that we don't do anything when the SIGUSR1 signal
+       triggers again.  We simply return.
+
+       When SIGUSR1 is received again, sigsuspend() will return to its caller,
+       thereby allowing the first invocation of this handler function to
+       continue running again.  Because there can be racing suspend and resume
+       requests, we need to always check the isSuspended flag before
+       returning.  If the isSuspended flag is set, then we need to call
+       sigsuspend() again to suspend the thread.  The suspend/resume semantics
+       is that the last most request will be honored.
+    */
+    if (self->isInSuspendHandler) {
+        /* The handler is already on the stack.  Just return and let the first
+           invocation of the handler deal with any changes to the suspension
+           state which may need to be done. */
+        return;
+    }
+    if (self->isMutexBlocked || self->isWaitBlocked) {
+        /* We're currently in the process of acquiring a mutex or is waiting
+           on a condvar.  There's nothing to do but return.  When we're done
+           acquiring the mutex or waiting on the condvar, the thread will
+           suspend itself automatically by raising this signal. */
+        return;
+    }
+    self->isInSuspendHandler = CVM_TRUE;
+    if (self->isSuspended) {
+	sigset_t sig_set;
+
+	pthread_sigmask(SIG_SETMASK, NULL, &sig_set);
+	sigdelset(&sig_set, SIGUSR1);
+
+        /* We'll keep suspending the thread as long as the its isSuspended
+           flag indicates that we're supposed to be suspended. */
+	do {
+	    /* wait for thread resume or set-owner request */
+            /* Mask out other signals but allow SIGUSR1 to trigger.
+               sigsuspend() will wait until we receive SIGUSR1 again. See NOTE
+               above for more details. */
+	    sigsuspend(&sig_set);
+	} while (self->isSuspended);
+    }
+    self->isInSuspendHandler = CVM_FALSE;
+#endif /* CVM_THREAD_SUSPENSION */
+}
+
+#ifdef CVM_THREAD_SUSPENSION
+/* Purpose: Suspend the self thread. */
+static void suspendSelf(void)
+{
+    sigset_t sig_set;
+    /* Create the signal set for SIGUSR1: */
+    sigemptyset(&sig_set);
+    sigaddset(&sig_set, SIGUSR1);
+
+    /* NOTE: Prevent SIGUSR1 from triggering the signal handler while we're
+       calling it.  We need to block SIGUSR1 while we're calling the signal
+       handler explicitly and cannot simply rely on the isInSuspendHandler
+       flag instead because there can be a race condition that can result in
+       resume failing.
+
+       If we don't block the signal before calling handleSuspendResume(), then
+       we could be in a suspended state (i.e. self->isSuspended is true) and
+       just get past the check for self->isSuspended in handleSuspendResume()
+       when a SIGUSR1 signal fires to resume the thread.  The signal causes
+       handleSuspendResume() to be called recursedly, but it does nothing
+       because self->isSuspended is now false.  The signal handler returns to
+       mainline code which is still executing in handleSuspendResume() which
+       proceeds to call sigsuspend() even though the thread should now be in
+       a resumed state.  This causes the thread to block even though it should
+       not be.
+
+       If we block the signal before calling handleSuspendResume(), then the
+       signal would not trigger the recursion into handleSuspendResume().
+       Instead, the signal will be pending until SIGUSR1 gets unblocked by
+       the call to sigsuspend() in handleSuspendResume().  At which point,
+       handleSuspendResume() will be recursed into, and does nothing as
+       expected because self->isSuspended is now false.  But upon returning
+       from the signal handler, in mainline code, we'll also return from the
+       call to sigsuspend() and the self->isSuspended flag will be checked
+       once more and found to be false causing handleSuspendResume() to
+       return.  Hence, the thread won't be blocking when it should have been
+       resumed as expected.
+    */
+    pthread_sigmask(SIG_BLOCK, &sig_set, NULL);
+    /* Call the signal handler to suspend self if necessary: */
+    handleSuspendResume(SIGUSR1);
+    /* Allow SIGUSR1 to trigger the signal handler again: */
+    pthread_sigmask(SIG_UNBLOCK, &sig_set, NULL);
+}
+
+/* Purpose: Locks the mutex.  This version is only needed to work around
+   issues that pthread library semantics that poses a problem for mutex
+   locking in the face of thread suspension.  Without thread suspension,
+   we can call the POSIX mutex lock directly. */
+void CVMmutexLock(CVMMutex *m)
+{
+    CVMThreadID * self = CVMthreadSelf();
+
+    /* The CVMThreadID may be NULL if the current thread hasn't been attached
+       to a Java thread yet.  If that is the case, we don't have to worry
+       about suspension, and just call through to the POSIX mutex lock.  This
+       is because we will need a non-NULL CVMThreadID in order to call the
+       suspension API. */
+    if (self != NULL) {
+        /* NOTE: We're about to attempt to acquire the mutex.  This can cause
+           this thread to block on that mutex.  This is OK, except that we
+           need to let the suspend handler know so that this thread doesn't
+           actually get suspended while it is in that state.  Usually, the
+           suspension requester thread would first acquire the mutex to make
+           sure that the target thread doesn't get suspended while holding
+           that mutex.  But if the target thread is blocked on the mutex and
+           gets suspended, when the owner of the mutex releases it, ownership
+           will inadvertantly be assigned to this thread even though it is
+           suspended (according to pthread library semantics).  So the
+           following code is put in place to ensure that the mutex is not
+           acquired while the thread is supposed to be suspended.
+        */
+        while(1) {
+            self->isMutexBlocked = CVM_TRUE;
+            POSIXmutexLock(&(m)->pmtx);
+            self->isMutexBlocked = CVM_FALSE;
+            if (self->isSuspended) {
+                /* Oops, this thread has been given ownership of the mutex
+                   while it's supposed to be suspended.  Release the mutex
+                   and suspend the thread.  We can acquire the mutex again
+                   later. */
+                POSIXmutexUnlock(&(m)->pmtx);
+                suspendSelf();
+            } else {
+                break;
+            }
+        }
+    } else {
+        POSIXmutexLock(&(m)->pmtx);
+    }
+}
+#endif /* CVM_THREAD_SUSPENSION */
+
+void
+CVMmutexSetOwner(CVMThreadID *self, CVMMutex *m, CVMThreadID *target)
+{
+    /* This is dependent on the pthreads library implementation.
+       A private API would be preferable */
+    m->pmtx = target->locked;
+    assert(!CVMmutexTryLock(m));
+}
+
+static void
+enqueue(CVMCondVar *c, CVMThreadID *t)
+{
+    *c->last_p = t;
+    t->prev_p = c->last_p;
+    c->last_p = &t->next;
+    t->next = NULL;
+}
+
+static CVMThreadID *
+dequeue(CVMCondVar *c)
+{
+    CVMThreadID *t = c->waiters;
+    if (t != NULL) {
+	c->waiters = t->next;
+
+	if (t->next != NULL) {
+	    t->next->prev_p = t->prev_p;
+	}
+
+	if (c->last_p == &t->next) {
+	    assert(t->prev_p == &c->waiters);
+	    c->last_p = &c->waiters;
+	}
+	t->next = NULL;
+	t->prev_p = NULL;
+    }
+    return t;
+}
+
+static void
+dequeue_me(CVMCondVar *c, CVMThreadID *t)
+{
+    *t->prev_p = t->next;
+
+    if (t->next != NULL) {
+	t->next->prev_p = t->prev_p;
+    }
+
+    if (c->last_p == &t->next) {
+	c->last_p = t->prev_p;
+    }
+
+    t->next = NULL;
+    t->prev_p = NULL;
+}
+
+CVMBool
+CVMcondvarWait(CVMCondVar* c, CVMMutex* m, CVMJavaLong millis)
+{
+    CVMBool waitForever;
+    CVMThreadID * self = CVMthreadSelf();
+    struct timespec timeout;
+
+    /* Determine the duration to wait: */
+    if (millis == 0LL) {
+	waitForever = CVM_TRUE;
+    } else {
+	struct timeval tv;
+	long secs;
+	long long tmp;
+        gettimeofday(&tv, NULL);
+
+	waitForever = CVM_FALSE;
+	tmp = millis / 1000LL;
+	secs = (long)tmp;
+	if (secs != tmp) {
+	    /* overflow */
+	    waitForever = CVM_TRUE;
+	} else {
+	    timeout.tv_sec = tv.tv_sec + secs;
+	    timeout.tv_nsec = tv.tv_usec * 1000;
+	    timeout.tv_nsec += (millis % 1000) * 1000000;
+            if (timeout.tv_nsec >= 1000000000) {
+                ++timeout.tv_sec;
+                timeout.tv_nsec -= 1000000000;
+            }
+            assert(timeout.tv_nsec < 1000000000);
+            if (timeout.tv_sec < tv.tv_sec) {
+                /* overflow */
+		waitForever = CVM_TRUE;
+            }
+	}
+    }
+
+    /* NOTE: The thing about Thread.interrupt() is that it is asynchronous
+       with respect to Object.wait().  Hence, there is a race between when
+       the interrupt request and when we actually enter into wait().  If
+       the interrupt comes too early (i.e. we're not waiting yet), then we'll
+       still end up waiting below.  There's nothing wrong with this. */
+    if (self->interrupted) {
+	self->interrupted = CVM_FALSE;
+	return CVM_FALSE;
+    }
+
+    /* NOTE: For notify() and notifyAll(), the following variables and the
+       enqueuing of this thread on the condvar's wait list are protected by
+       synchronization on the mutex m.  Thread.interrupt() will modify the
+       value field asynchronously, but that does not have any negative side
+       effects. */
+    self->notified = CVM_FALSE;
+    self->isWaitBlocked = CVM_TRUE;
+    self->value = 0;
+
+    /* add ourself to the wait queue that notify and notifyAll look at */
+    enqueue(c, self);
+
+    CVMmutexUnlock(m);
+
+    /* notifies can happen now */
+
+    /* emulate semaphore wait */
+    pthread_mutex_lock(&self->wait_mutex);
+
+    while (self->value == 0) {
+	if (waitForever) {
+	    pthread_cond_wait(&self->wait_cv, &self->wait_mutex);
+	} else {
+	    int status = pthread_cond_timedwait(&self->wait_cv,
+		&self->wait_mutex, &timeout);
+	    if (status == ETIMEDOUT) {
+		break;
+	    }
+	}
+    }
+
+    pthread_mutex_unlock(&self->wait_mutex);
+
+    self->isWaitBlocked = CVM_FALSE;
+#ifdef CVM_THREAD_SUSPENSION
+    /* If we're supposed to be suspended, then suspend self: */
+    while (self->isSuspended) {
+        suspendSelf();
+    }
+#endif /* CVM_THREAD_SUSPENSION */
+
+    /* reacquire condvar mutex */
+    CVMmutexLock(m);
+
+    /* no more notifications after this point */
+
+    {
+	/* find out why we were woken up */
+	if (self->notified) {
+	    /* normal notify or notifyAll */
+	    assert(self->value == 1);
+	    /* removed from wait queue */ 
+	    assert(self->next == NULL && self->prev_p == NULL);
+	} else {
+	    /*
+	     * We were woken up by linuxSyncInterruptWait() posting on
+	     * the semaphore, or the timed wait timed out.
+	     */
+	    assert(self->interrupted || !waitForever);
+	    dequeue_me(c, self);
+	    /* removed from wait queue */ 
+	    assert(self->next == NULL && self->prev_p == NULL);
+	}
+    }
+
+    /*
+     * Workaround for Linux kernel bug exposed by LinuxThreads.
+     */
+    setFPMode();
+
+    self->value = 0;
+
+    if (self->interrupted) {
+	self->interrupted = CVM_FALSE;
+	return CVM_FALSE;
+    }
+
+    return CVM_TRUE;
+
+}
+
+/* emulate a semaphore post */
+#define SEM_POST(t) \
+do {						\
+    pthread_mutex_lock(&(t)->wait_mutex);	\
+    (t)->value = 1;				\
+    pthread_cond_signal(&(t)->wait_cv);		\
+    pthread_mutex_unlock(&(t)->wait_mutex);	\
+} while (0)
+
+CVMBool
+CVMcondvarInit(CVMCondVar * c, CVMMutex * m)
+{
+    c->waiters = NULL;
+    c->last_p = &c->waiters;
+
+    return POSIXcondvarInit(&(c)->pcv, &(m)->pmtx);
+}
+
+void
+CVMcondvarDestroy(CVMCondVar * c)
+{
+    POSIXcondvarDestroy(&(c)->pcv);
+}
+
+void
+CVMcondvarNotify(CVMCondVar * c)
+{
+    CVMThreadID *t;
+    if ((t = dequeue(c)) != NULL) {
+	t->notified = CVM_TRUE;
+	SEM_POST(t);
+    }
+}
+
+void
+CVMcondvarNotifyAll(CVMCondVar * c)
+{
+    CVMThreadID *t;
+    while ((t = dequeue(c)) != NULL) {
+	t->notified = CVM_TRUE;
+	SEM_POST(t);
+    }
+}
+
+void
+linuxSyncInterruptWait(CVMThreadID *thread)
+{
+    if (thread->isWaitBlocked) {
+	/* thread->notified is not set */
+	/* thread will dequeue itself from wait queue */
+	SEM_POST(thread);
+    }
+}
+
+#ifdef CVM_THREAD_SUSPENSION
+void
+linuxSyncSuspend(CVMThreadID *t)
+{
+    /* The suspended flag can be modified asynchronously (last one to set its
+       value get to say what it is.  This is no different than racing suspend
+       and resume requests.  Last request (suspend or resume) determines if
+       the target thread is suspended or not.
+       NOTE: All the suspension magic is actually done by the target thread.
+             The requestor doesn't get to check nor manipulate the state of
+             the target thread.  It only gets to make a request to suspend or
+             resume the target thread.  This allows us to avoid having to do
+             some fancy synchronization between the requestor and the target
+             thread when manipulating the target thread's state.
+    */
+    t->isSuspended = CVM_TRUE;
+    /* Tell the target thread to service the suspension: */
+    pthread_kill(POSIX_COOKIE(t), SIGUSR1);
+}
+
+void
+linuxSyncResume(CVMThreadID *t)
+{
+    /* The suspended flag can be modified asynchronously (last one to set its
+       value get to say what it is.  This is no different than racing suspend
+       and resume requests.  Last request (suspend or resume) determines if
+       the target thread is suspended or not.
+       NOTE: All the suspension magic is actually done by the target thread.
+             The requestor doesn't get to check nor manipulate the state of
+             the target thread.  It only gets to make a request to suspend or
+             resume the target thread.  This allows us to avoid having to do
+             some fancy synchronization between the requestor and the target
+             thread when manipulating the target thread's state.
+    */
+    t->isSuspended = CVM_FALSE;
+    /* Tell the target thread to service the suspension: */
+    pthread_kill(POSIX_COOKIE(t), SIGUSR1);
+}
+#endif /* CVM_THREAD_SUSPENSION */
+
+
+/*
+ * Linux doesn't handle MT core dumps very well, so suspend here
+ * for the debugger.
+ */
+void crash(int sig)
+{
+    int pid = getpid();
+    
+    fprintf(stderr, "Process #%d received signal %d, suspending\n", pid, sig);
+    kill(pid, SIGSTOP);
+}
+
+#if defined(CVM_JVMPI) || defined(CVM_JVMTI)
+void sigquitHandler(int sig)
+{
+#ifdef CVM_JVMPI
+    CVMjvmpiSetDataDumpRequested();
+#endif
+#ifdef CVM_JVMTI
+    CVMjvmtiSetDataDumpRequested();
+#endif
+}
+#endif
+
+CVMBool
+linuxSyncInit(void)
+{
+    int result = 0;
+
+    /* NOTE: handleSuspendResume() is needed regardless of whether we enable
+       thread suspension or not.  See notes on handleSuspendResume() above for
+       details.
+    */
+    {
+	/* Signal initialization. The signals we recover from set
+	   the SA_RESTART flag. */
+	struct {
+	    int sig;
+	    void *handler;
+	    int flags;
+	} const signals[] = {
+#if !defined(CVM_JIT) && !defined(CVM_USE_MEM_MGR)
+	    {SIGSEGV, crash, 0},
+#endif
+#if defined(CVM_JVMPI) || defined(CVM_JVMTI)
+            {SIGQUIT, sigquitHandler, SA_RESTART},
+#endif
+	    {SIGUSR1, handleSuspendResume, SA_RESTART},
+	    {SIGBUS, crash, 0},
+	    {SIGILL, crash, 0},
+	    {SIGFPE, crash, 0}
+	};
+
+	int i;
+	int numsignals = sizeof signals / sizeof signals[0];
+
+	for (i = 0; i < numsignals; ++i) {
+	    struct sigaction sa;
+	    sa.sa_handler = (void (*)(int))signals[i].handler;
+	    sa.sa_flags = signals[i].flags;
+	    sigemptyset(&sa.sa_mask);
+	    if ((result = sigaction(signals[i].sig, &sa, NULL)) == -1)
+		break;
+	}
+	
+    }
+
+    return (result != -1);
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/javavm/runtime/time_md.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/javavm/runtime/time_md.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/javavm/runtime/time_md.c	2009-07-06 18:35:21.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/javavm/runtime/time_md.c	2009-07-09 18:22:25.000000000 -0400
@@ -339,7 +339,8 @@
 CVMInt64
 CVMtimeNanosecs(void)
 {
-#ifdef CLOCK_PROCESS_CPUTIME_ID
+// JFT, this is low res on mips sigma so comment it out for now
+/*#ifdef CLOCK_PROCESS_CPUTIME_ID
     if (_clock_gettime != NULL) {
         struct timespec tp;
         int status = _clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &tp);
@@ -348,11 +349,11 @@
         return (CVMInt64)(((CVMInt64)tp.tv_sec) * SEC_IN_NANOSECS +
                           (CVMInt64)tp.tv_nsec);
     } else
-#endif
+#endif*/
     {
         struct timeval t;
         gettimeofday(&t, 0);
-        return (CVMInt64)(((CVMInt64)t.tv_sec) * 1000000 + (CVMInt64)(t.tv_usec));
+        return (CVMInt64)(((CVMInt64)t.tv_sec) * 1000000000LL + (CVMInt64)(t.tv_usec)*1000LL);
     }
 }
 #endif
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/javavm/runtime/time_md.cy phoneme_advanced-mr2-dev-b122/cdc/src/linux/javavm/runtime/time_md.cy
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/javavm/runtime/time_md.cy	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/javavm/runtime/time_md.cy	2009-07-09 16:34:56.000000000 -0400
@@ -0,0 +1,366 @@
+/*
+ * @(#)time_md.c	1.8 06/10/10
+ *
+ * Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.  
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+ *   
+ * This program is free software; you can redistribute it and/or  
+ * modify it under the terms of the GNU General Public License version  
+ * 2 only, as published by the Free Software Foundation.   
+ *   
+ * This program is distributed in the hope that it will be useful, but  
+ * WITHOUT ANY WARRANTY; without even the implied warranty of  
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+ * General Public License version 2 for more details (a copy is  
+ * included at /legal/license.txt).   
+ *   
+ * You should have received a copy of the GNU General Public License  
+ * version 2 along with this work; if not, write to the Free Software  
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+ * 02110-1301 USA   
+ *   
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+ * Clara, CA 95054 or visit www.sun.com if you need additional  
+ * information or have any questions. 
+ *
+ */
+
+#include "javavm/include/porting/time.h"
+#include "javavm/include/porting/threads.h"
+#include "javavm/include/porting/ansi/stdlib.h"
+#include "portlibs/posix/threads.h"
+#include <stdio.h>
+#include <pthread.h>
+#include <errno.h>
+#include <dlfcn.h>
+#include <unistd.h>
+#include <string.h>
+#include "javavm/include/interpreter.h"
+#include "javavm/include/assert.h"
+
+#ifdef CVM_JVMTI
+#ifndef __UCLIBC__
+#include <gnu/libc-version.h>
+#endif
+#ifndef clockid_t
+typedef int clockid_t;
+#endif
+static int (*_clock_gettime)(clockid_t, struct timespec *);
+static int (*_clock_getres)(clockid_t, struct timespec *);
+static int (*_pthread_getcpuclockid)(pthread_t, clockid_t *);
+static CVMBool supportsFastThreadCpuTime = CVM_FALSE;
+static CVMBool isNPTL = CVM_FALSE;
+static int clockTicsPerSec = 100;
+#define SEC_IN_NANOSECS  CONST64(1000000000)
+
+void CVMtimeClockInit(void) {
+    /* we do dlopen's in this particular order due to bug in linux */
+    /* dynamical loader (see 6348968) leading to crash on exit */
+#ifdef CLOCK_PROCESS_CPUTIME_ID
+    void* handle = dlopen("librt.so.1", RTLD_LAZY);
+    if (handle == NULL) {
+	handle = dlopen("librt.so", RTLD_LAZY);
+    }
+
+    if (handle) {
+	int (*clock_getres_func)(clockid_t, struct timespec*) = 
+	    (int(*)(clockid_t, struct timespec*))dlsym(handle, "clock_getres");
+	int (*clock_gettime_func)(clockid_t, struct timespec*) = 
+	    (int(*)(clockid_t, struct timespec*))dlsym(handle, "clock_gettime");
+	if (clock_getres_func && clock_gettime_func) {
+	    /*
+	     * See if monotonic clock is supported by the kernel. Note that some
+	     * early implementations simply return kernel jiffies (updated every
+	     * 1/100 or 1/1000 second). It would be bad to use such a low res clock
+	     * for nano time (though the monotonic property is still nice to have).
+	     * It's fixed in newer kernels, however clock_getres() still returns
+	     * 1/HZ. We check if clock_getres() works, but will ignore its reported
+	     * resolution for now. Hopefully as people move to new kernels, this
+	     * won't be a problem.
+	     */
+	    struct timespec res;
+	    struct timespec tp;
+	    if (clock_getres_func (CLOCK_PROCESS_CPUTIME_ID, &res) == 0 &&
+		clock_gettime_func(CLOCK_PROCESS_CPUTIME_ID, &tp)  == 0) {
+		/* yes, monotonic clock is supported */
+		_clock_gettime = clock_gettime_func;
+		_clock_getres = clock_getres_func;
+	    } else {
+		/* close librt if there is no monotonic clock */
+		dlclose(handle);
+	    }
+	}
+    }
+    {
+#ifndef __UCLIBC__
+	char _gnu_libc_version[32];
+	char *glibc_version = _gnu_libc_version;
+	char *libpthread_version;
+	/*
+	 * Save glibc and pthread version strings. Note that _CS_GNU_LIBC_VERSION
+	 * and _CS_GNU_LIBPTHREAD_VERSION are supported in glibc >= 2.3.2. Use a 
+	 * generic name for earlier versions.
+	 * Define macros here so we can build HotSpot on old systems.
+	 */
+# ifndef _CS_GNU_LIBC_VERSION
+# define _CS_GNU_LIBC_VERSION 2
+# endif
+# ifndef _CS_GNU_LIBPTHREAD_VERSION
+# define _CS_GNU_LIBPTHREAD_VERSION 3
+# endif
+	
+	size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);
+	if (n > 0) {
+	    char *str = (char *)malloc(n);
+	    confstr(_CS_GNU_LIBC_VERSION, str, n);
+	    glibc_version = str;
+	} else {
+	    /* _CS_GNU_LIBC_VERSION is not supported, try gnu_get_libc_version()*/
+	    snprintf(_gnu_libc_version, sizeof(_gnu_libc_version), 
+		     "glibc %s %s", glibc_version, gnu_get_libc_release());
+	}
+	
+	n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
+	if (n > 0) {
+	    char *str = (char *)malloc(n);
+	    confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);
+	    /*	    
+	     * Vanilla RH-9 (glibc 2.3.2) has a bug that confstr() always tells
+	     * us "NPTL-0.29" even we are running with LinuxThreads. Check if
+	     * this is the case:
+	     */
+	    if (strcmp(glibc_version, "glibc 2.3.2") == 0 &&
+		strstr(str, "NPTL")) {
+		/*
+		 * LinuxThreads has a hard limit on max number of threads. So
+		 * sysconf(_SC_THREAD_THREADS_MAX) will return a positive
+		 * value. On the other hand, NPTL does not have such a limit,
+		 * sysconf() will return -1 and errno is not changed.
+		 * Check if it is really NPTL:
+		 */
+		if (sysconf(_SC_THREAD_THREADS_MAX) > 0) {
+		    free(str);
+		    str = "linuxthreads";
+		}
+	    }
+	    libpthread_version = str;
+	} else {
+	    /* glibc before 2.3.2 only has LinuxThreads. */
+	    libpthread_version = "linuxthreads";
+	}
+	
+	if (strstr(libpthread_version, "NPTL")) {
+	    isNPTL = CVM_TRUE;
+	}
+#endif /* __UCLIBC__ */
+    }
+#endif
+    clockTicsPerSec = sysconf(_SC_CLK_TCK);
+}
+
+void CVMtimeThreadCpuClockInit(CVMThreadID *threadID) {
+    clockid_t clockid;
+    struct timespec tp;
+    int (*pthread_getcpuclockid_func)(pthread_t, clockid_t *) = 
+	(int(*)(pthread_t, clockid_t *)) dlsym(RTLD_DEFAULT, "pthread_getcpuclockid");
+    /*
+     * Switch to using fast clocks for thread cpu time if
+     * the sys_clock_getres() returns 0 error code.
+     * Note, that some kernels may support the current thread
+     * clock (CLOCK_THREAD_CPUTIME_ID) but not the clocks
+     * returned by the pthread_getcpuclockid().
+     * If the fast Posix clocks are supported then the sys_clock_getres()
+     * must return at least tp.tv_sec == 0 which means a resolution
+     * better than 1 sec. This is extra check for reliability.
+     */
+
+    if(pthread_getcpuclockid_func &&
+       pthread_getcpuclockid_func(POSIX_COOKIE(threadID), &clockid) == 0 &&
+       _clock_getres != NULL &&
+       _clock_getres(clockid, &tp) == 0 && tp.tv_sec == 0) {
+	_pthread_getcpuclockid = pthread_getcpuclockid_func;
+	supportsFastThreadCpuTime = CVM_TRUE;
+    }
+}
+
+/*
+ * current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool) 
+ * are used by JVM M&M and JVMTI to get user+sys or user CPU time
+ * of a thread.
+ *
+ * current_thread_cpu_time() and thread_cpu_time(Thread*) returns
+ * the fast estimate available on the platform.
+ *
+ *
+ *  -1 on error.
+ */ 
+
+static CVMInt64
+threadCpuTimeX(CVMThreadID *thread, CVMBool user_sys_cpu_time) {
+    static CVMBool proc_pid_cpu_avail = CVM_TRUE;
+    static CVMBool proc_task_unchecked = CVM_TRUE;
+    static const char *proc_stat_path = "/proc/%d/stat";
+    pid_t  tid = POSIX_COOKIE(thread);
+    int i;
+    char *s;
+    char stat[2048];
+    int statlen;
+    char proc_name[64];
+    int count;
+    long sys_time, user_time;
+    char string[64];
+    int idummy;
+    long ldummy;
+    FILE *fp;
+
+    /* We first try accessing /proc/<pid>/cpu since this is faster to
+     * process.  If this file is not present (linux kernels 2.5 and above)
+     * then we open /proc/<pid>/stat.
+     */
+    if ( proc_pid_cpu_avail ) {
+	sprintf(proc_name, "/proc/%d/cpu", tid);
+	fp =  fopen(proc_name, "r");
+	if ( fp != NULL ) {
+	    count = fscanf( fp, "%s %lu %lu\n", string, &user_time, &sys_time);
+	    fclose(fp);
+	    if ( count != 3 ) return -1;
+
+	    if (user_sys_cpu_time) {
+		return ((CVMInt64)sys_time + (CVMInt64)user_time) * (SEC_IN_NANOSECS / clockTicsPerSec);
+	    } else {
+		return (CVMInt64)user_time * (SEC_IN_NANOSECS / clockTicsPerSec);
+	    }
+	}
+	else proc_pid_cpu_avail = CVM_FALSE;
+    }
+    /*
+     * The /proc/<tid>/stat aggregates per-process usage on
+     * new Linux kernels 2.6+ where NPTL is supported.
+     * The /proc/self/task/<tid>/stat still has the per-thread usage.
+     * See bug 6328462.
+     * There can be no directory /proc/self/task on kernels 2.4 with NPTL
+     * and possibly in some other cases, so we check its availability.
+     */
+    if (proc_task_unchecked && isNPTL) {
+	/* This is executed only once */
+	proc_task_unchecked = CVM_FALSE;
+	fp = fopen("/proc/self/task", "r");
+	if (fp != NULL) {
+	    proc_stat_path = "/proc/self/task/%d/stat";
+	    fclose(fp);
+	}
+    }
+
+    sprintf(proc_name, proc_stat_path, tid);
+    fp = fopen(proc_name, "r");
+    if ( fp == NULL ) return -1;
+    statlen = fread(stat, 1, 2047, fp);
+    stat[statlen] = '\0';
+    fclose(fp);
+    /*
+     * Skip pid and the command string. Note that we could be dealing with
+     * weird command names, e.g. user could decide to rename java launcher
+     * to "java 1.4.2 :)", then the stat file would look like
+     *                1234 (java 1.4.2 :)) R ... ...
+     * We don't really need to know the command string, just find the last
+     * occurrence of ")" and then start parsing from there. See bug 4726580.
+     */
+    s = strrchr(stat, ')');
+    i = 0;
+    if (s == NULL ) return -1;
+
+    /* Skip blank chars */
+    do s++; while (isspace(*s));
+
+    count = sscanf(s,"%c %d %d %d %d %d %lu %lu %lu %lu %lu %lu %lu", 
+		   (char *)&idummy, &idummy, &idummy, &idummy, &idummy,
+		   &idummy, &ldummy, &ldummy, &ldummy, &ldummy, &ldummy, 
+		   &user_time, &sys_time);
+    if ( count != 13 ) return -1;
+    if (user_sys_cpu_time) {
+	return ((jlong)sys_time + (jlong)user_time) * (SEC_IN_NANOSECS / clockTicsPerSec);
+    } else {
+	return (jlong)user_time * (SEC_IN_NANOSECS / clockTicsPerSec);
+    }
+}
+
+/*
+ * This is the fastest way to get thread cpu time on Linux.
+ * Returns cpu time (user+sys) for any thread, not only for current.
+ * POSIX compliant clocks are implemented in the kernels 2.6.16+.
+ * It might work on 2.6.10+ with a special kernel/glibc patch.
+ * For reference, please, see IEEE Std 1003.1-2004:
+ *   http://www.unix.org/single_unix_specification
+ */
+
+static CVMInt64
+fastThreadCpuTime(clockid_t clockid) {
+  struct timespec tp;
+  int rc = 0;
+  rc = _clock_gettime(clockid, &tp);
+  CVMassert(rc == 0);
+  return (tp.tv_sec * SEC_IN_NANOSECS) + tp.tv_nsec;
+}
+
+CVMInt64
+CVMtimeThreadCpuTime(CVMThreadID *thread) {
+    /* consistent with what current_thread_cpu_time() returns */
+    if (supportsFastThreadCpuTime) {
+	pthread_t tid = POSIX_COOKIE(thread);
+	clockid_t clockid;
+	int rc;
+	/* Get the thread clockid */
+	rc = _pthread_getcpuclockid(tid, &clockid);
+	CVMassert(rc == 0);
+	return fastThreadCpuTime(clockid);
+    } else {
+	return threadCpuTimeX(thread, CVM_TRUE /* user + sys */);
+    }
+}
+
+CVMBool CVMtimeIsThreadCpuTimeSupported(void) {
+    return CVM_TRUE;
+}
+
+CVMInt64
+CVMtimeCurrentThreadCpuTime(CVMThreadID *thread) {
+#ifdef CLOCK_PROCESS_CPUTIME_ID
+    if (supportsFastThreadCpuTime) {
+	return fastThreadCpuTime(CLOCK_THREAD_CPUTIME_ID);
+    } else
+#endif
+    {
+	/* return user + sys since the cost is the same */
+	return threadCpuTimeX(&(CVMgetEE()->threadInfo), CVM_TRUE /* user + sys */);
+    }
+}
+
+
+CVMInt64
+CVMtimeNanosecs(void)
+{
+#ifdef CLOCK_PROCESS_CPUTIME_ID
+    if (_clock_gettime != NULL) {
+        struct timespec tp;
+        int status = _clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &tp);
+        (void)status;
+        CVMassert(status == 0);
+        return (CVMInt64)(((CVMInt64)tp.tv_sec) * SEC_IN_NANOSECS +
+                          (CVMInt64)tp.tv_nsec);
+    } else
+#endif
+    {
+        struct timeval t;
+        gettimeofday(&t, 0);
+        return (CVMInt64)(((CVMInt64)t.tv_sec) * 1000000 + (CVMInt64)(t.tv_usec));
+    }
+}
+#endif
+
+CVMInt64
+CVMtimeMillis(void)
+{
+    struct timeval t;
+    gettimeofday(&t, 0);
+    return (CVMInt64)(((CVMInt64)t.tv_sec) * 1000 + (CVMInt64)(t.tv_usec/1000));
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/java/lang/UNIXProcess_md.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/java/lang/UNIXProcess_md.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/java/lang/UNIXProcess_md.c	2009-07-06 18:35:22.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/java/lang/UNIXProcess_md.c	2009-07-06 19:25:13.000000000 -0400
@@ -51,7 +51,7 @@
 #define PATH    JNI_STATIC_MD(java_lang_UNIXProcess, PATH)
 #define uid     JNI_STATIC_MD(java_lang_UNIXProcess, uid)
 #define gid     JNI_STATIC_MD(java_lang_UNIXProcess, gid)
-#define fork1 fork
+#define fork1 vfork
 #endif
 
 static void
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/java/nio/MappedByteBuffer.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/java/nio/MappedByteBuffer.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/java/nio/MappedByteBuffer.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/java/nio/MappedByteBuffer.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2001-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "java_nio_MappedByteBuffer.h"
+#include <sys/mman.h>
+#include <stddef.h>
+#include <stdlib.h>
+
+
+JNIEXPORT jboolean JNICALL
+Java_java_nio_MappedByteBuffer_isLoaded0(JNIEnv *env, jobject obj,
+                                        jlong address, jlong len)
+{
+    jboolean loaded = JNI_TRUE;
+    jint pageSize = sysconf(_SC_PAGESIZE);
+    jint numPages = (len + pageSize - 1) / pageSize;
+    int result = 0;
+    int i = 0;
+    void *a = (void *) jlong_to_ptr(address);
+#ifdef __linux__
+    unsigned char *vec = (unsigned char *)malloc(numPages * sizeof(char));
+#else
+    char *vec = (char *)malloc(numPages * sizeof(char));
+#endif
+
+    if (vec == NULL) {
+        JNU_ThrowOutOfMemoryError(env, NULL);
+        return JNI_FALSE;
+    }
+
+    result = mincore(a, (size_t)len, vec);
+    if (result != 0) {
+        free(vec);
+        JNU_ThrowIOExceptionWithLastError(env, "mincore failed");
+        return JNI_FALSE;
+    }
+
+    for (i=0; i<numPages; i++) {
+        if (vec[i] == 0) {
+            loaded = JNI_FALSE;
+            break;
+        }
+    }
+    free(vec);
+    return loaded;
+}
+
+
+JNIEXPORT jint JNICALL
+Java_java_nio_MappedByteBuffer_load0(JNIEnv *env, jobject obj, jlong address,
+                                     jlong len, jint pageSize)
+{
+    int pageIncrement = pageSize / sizeof(int);
+    int numPages = (len + pageSize - 1) / pageSize;
+    int *ptr = (int *)jlong_to_ptr(address);
+    int i = 0;
+    int j = 0;
+    int result = madvise((caddr_t)ptr, len, MADV_WILLNEED);
+
+    /* touch every page */
+    for (i=0; i<numPages; i++) {
+        j += *((volatile int *)ptr);
+        ptr += pageIncrement;
+    }
+    return j;
+}
+
+
+JNIEXPORT void JNICALL
+Java_java_nio_MappedByteBuffer_force0(JNIEnv *env, jobject obj, jlong address,
+                                      jlong len)
+{
+    jlong pageSize = sysconf(_SC_PAGESIZE);
+    unsigned long lAddress = address;
+
+    jlong offset = lAddress % pageSize;
+    void *a = (void *) jlong_to_ptr(lAddress - offset);
+    int result = msync(a, (size_t)(len + offset), MS_SYNC);
+    if (result != 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "msync failed");
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/DatagramChannelImpl.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/DatagramChannelImpl.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/DatagramChannelImpl.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/DatagramChannelImpl.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,237 @@
+/*
+ * Copyright 2001-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+
+#include <netdb.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#if __linux__
+#include <netinet/in.h>
+#endif
+
+#include "net_util.h"
+#include "net_util_md.h"
+#include "nio.h"
+#include "nio_util.h"
+
+#include "sun_nio_ch_DatagramChannelImpl.h"
+
+static jfieldID isa_addrID;     /* address in java.net.InetSocketAddress */
+static jfieldID isa_portID;     /* port in java.net.InetSocketAddress */
+static jfieldID dci_senderID;   /* sender in sun.nio.ch.DatagramChannelImpl */
+static jfieldID dci_senderAddrID; /* sender InetAddress in sun.nio.ch.DatagramChannelImpl */
+static jfieldID dci_senderPortID; /* sender port in sun.nio.ch.DatagramChannelImpl */
+static jclass isa_class;        /* java.net.InetSocketAddress */
+static jmethodID isa_ctorID;    /*   .InetSocketAddress(InetAddress, int) */
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_DatagramChannelImpl_initIDs(JNIEnv *env, jclass clazz)
+{
+    clazz = (*env)->FindClass(env, "java/net/InetSocketAddress");
+    isa_class = (*env)->NewGlobalRef(env, clazz);
+    isa_ctorID = (*env)->GetMethodID(env, clazz, "<init>",
+                                     "(Ljava/net/InetAddress;I)V");
+    isa_addrID = (*env)->GetFieldID(env, clazz, "addr",
+                                    "Ljava/net/InetAddress;");
+    isa_portID = (*env)->GetFieldID(env, clazz, "port", "I");
+
+    clazz = (*env)->FindClass(env, "sun/nio/ch/DatagramChannelImpl");
+    dci_senderID = (*env)->GetFieldID(env, clazz, "sender",
+                                      "Ljava/net/SocketAddress;");
+    dci_senderAddrID = (*env)->GetFieldID(env, clazz,
+                                          "cachedSenderInetAddress",
+                                          "Ljava/net/InetAddress;");
+    dci_senderPortID = (*env)->GetFieldID(env, clazz,
+                                          "cachedSenderPort", "I");
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_DatagramChannelImpl_disconnect0(JNIEnv *env, jobject this,
+                                                jobject fdo)
+{
+    jint fd = fdval(env, fdo);
+    int rv;
+
+#ifdef __solaris__
+    rv = connect(fd, 0, 0);
+#endif
+
+#ifdef __linux__
+    {
+        int len;
+        SOCKADDR sa;
+
+        memset(&sa, 0, sizeof(sa));
+
+#ifdef AF_INET6
+        if (ipv6_available()) {
+            struct sockaddr_in6 *him6 = (struct sockaddr_in6 *)&sa;
+            him6->sin6_family = AF_UNSPEC;
+            len = sizeof(struct sockaddr_in6);
+        } else
+#endif
+        {
+            struct sockaddr_in *him4 = (struct sockaddr_in*)&sa;
+            him4->sin_family = AF_UNSPEC;
+            len = sizeof(struct sockaddr_in);
+        }
+
+        rv = connect(fd, (struct sockaddr *)&sa, len);
+    }
+#endif
+
+    if (rv < 0)
+        handleSocketError(env, errno);
+
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_DatagramChannelImpl_receive0(JNIEnv *env, jobject this,
+                                             jobject fdo, jlong address,
+                                             jint len, jboolean connected)
+{
+    jint fd = fdval(env, fdo);
+    void *buf = (void *)jlong_to_ptr(address);
+    SOCKADDR sa;
+    socklen_t sa_len = SOCKADDR_LEN;
+    jboolean retry = JNI_FALSE;
+    jint n = 0;
+    jobject senderAddr;
+
+    if (len > MAX_PACKET_LEN) {
+        len = MAX_PACKET_LEN;
+    }
+
+    do {
+        retry = JNI_FALSE;
+        n = recvfrom(fd, buf, len, 0, (struct sockaddr *)&sa, &sa_len);
+        if (n < 0) {
+            if (errno == EWOULDBLOCK) {
+                return IOS_UNAVAILABLE;
+            }
+            if (errno == EINTR) {
+                return IOS_INTERRUPTED;
+            }
+            if (errno == ECONNREFUSED) {
+                if (connected == JNI_FALSE) {
+                    retry = JNI_TRUE;
+                } else {
+                    JNU_ThrowByName(env, JNU_JAVANETPKG
+                                    "PortUnreachableException", 0);
+                    return IOS_THROWN;
+                }
+            } else {
+                return handleSocketError(env, errno);
+            }
+        }
+    } while (retry == JNI_TRUE);
+
+    /*
+     * If the source address and port match the cached address
+     * and port in DatagramChannelImpl then we don't need to
+     * create InetAddress and InetSocketAddress objects.
+     */
+    senderAddr = (*env)->GetObjectField(env, this, dci_senderAddrID);
+    if (senderAddr != NULL) {
+        if (!NET_SockaddrEqualsInetAddress(env, (struct sockaddr *)&sa,
+                                           senderAddr)) {
+            senderAddr = NULL;
+        } else {
+            jint port = (*env)->GetIntField(env, this, dci_senderPortID);
+            if (port != NET_GetPortFromSockaddr((struct sockaddr *)&sa)) {
+                senderAddr = NULL;
+            }
+        }
+    }
+    if (senderAddr == NULL) {
+        jobject isa = NULL;
+        int port;
+        jobject ia = NET_SockaddrToInetAddress(env, (struct sockaddr *)&sa,
+                                               &port);
+
+        if (ia != NULL) {
+            isa = (*env)->NewObject(env, isa_class, isa_ctorID, ia, port);
+        }
+
+        if (isa == NULL) {
+            JNU_ThrowOutOfMemoryError(env, "heap allocation failed");
+            return IOS_THROWN;
+        }
+
+        (*env)->SetObjectField(env, this, dci_senderAddrID, ia);
+        (*env)->SetIntField(env, this, dci_senderPortID,
+                            NET_GetPortFromSockaddr((struct sockaddr *)&sa));
+        (*env)->SetObjectField(env, this, dci_senderID, isa);
+    }
+    return n;
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_DatagramChannelImpl_send0(JNIEnv *env, jobject this,
+                                            jobject fdo, jlong address,
+                                            jint len, jobject dest)
+{
+    jint fd = fdval(env, fdo);
+    void *buf = (void *)jlong_to_ptr(address);
+    SOCKADDR sa;
+    int sa_len = SOCKADDR_LEN;
+    jint n = 0;
+    jobject destAddress = (*env)->GetObjectField(env, dest, isa_addrID);
+    jint destPort = (*env)->GetIntField(env, dest, isa_portID);
+
+    if (len > MAX_PACKET_LEN) {
+        len = MAX_PACKET_LEN;
+    }
+
+    if (NET_InetAddressToSockaddr(env, destAddress, destPort,
+                                  (struct sockaddr *)&sa,
+                                  &sa_len, JNI_TRUE) != 0) {
+      return IOS_THROWN;
+    }
+
+    n = sendto(fd, buf, len, 0, (struct sockaddr *)&sa, sa_len);
+    if (n < 0) {
+        if (errno == EAGAIN) {
+            return IOS_UNAVAILABLE;
+        }
+        if (errno == EINTR) {
+            return IOS_INTERRUPTED;
+        }
+        if (errno == ECONNREFUSED) {
+            JNU_ThrowByName(env, JNU_JAVANETPKG "PortUnreachableException", 0);
+            return IOS_THROWN;
+        }
+        return handleSocketError(env, errno);
+    }
+    return n;
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/DatagramDispatcher.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/DatagramDispatcher.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/DatagramDispatcher.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/DatagramDispatcher.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "sun_nio_ch_DatagramDispatcher.h"
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+
+#include "nio_util.h"
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_DatagramDispatcher_read0(JNIEnv *env, jclass clazz,
+                         jobject fdo, jlong address, jint len)
+{
+    jint fd = fdval(env, fdo);
+    void *buf = (void *)jlong_to_ptr(address);
+    int result = recv(fd, buf, len, 0);
+    if (result < 0 && errno == ECONNREFUSED) {
+        JNU_ThrowByName(env, JNU_JAVANETPKG "PortUnreachableException", 0);
+        return -2;
+    }
+    return convertReturnVal(env, result, JNI_TRUE);
+}
+
+
+JNIEXPORT jlong JNICALL
+Java_sun_nio_ch_DatagramDispatcher_readv0(JNIEnv *env, jclass clazz,
+                              jobject fdo, jlong address, jint len)
+{
+    jint fd = fdval(env, fdo);
+    ssize_t result = 0;
+    struct iovec *iov = (struct iovec *)jlong_to_ptr(address);
+    struct msghdr m;
+    if (len > 16) {
+        len = 16;
+    }
+
+    m.msg_name = NULL;
+    m.msg_namelen = 0;
+    m.msg_iov = iov;
+    m.msg_iovlen = len;
+#ifdef __solaris__
+    m.msg_accrights = NULL;
+    m.msg_accrightslen = 0;
+#endif
+
+#ifdef __linux__
+    m.msg_control = NULL;
+    m.msg_controllen = 0;
+#endif
+
+    result = recvmsg(fd, &m, 0);
+    if (result < 0 && errno == ECONNREFUSED) {
+        JNU_ThrowByName(env, JNU_JAVANETPKG "PortUnreachableException", 0);
+        return -2;
+    }
+    return convertLongReturnVal(env, (jlong)result, JNI_TRUE);
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_DatagramDispatcher_write0(JNIEnv *env, jclass clazz,
+                              jobject fdo, jlong address, jint len)
+{
+    jint fd = fdval(env, fdo);
+    void *buf = (void *)jlong_to_ptr(address);
+    int result = send(fd, buf, len, 0);
+    if (result < 0 && errno == ECONNREFUSED) {
+        JNU_ThrowByName(env, JNU_JAVANETPKG "PortUnreachableException", 0);
+        return -2;
+    }
+    return convertReturnVal(env, result, JNI_FALSE);
+}
+
+JNIEXPORT jlong JNICALL
+Java_sun_nio_ch_DatagramDispatcher_writev0(JNIEnv *env, jclass clazz,
+                                       jobject fdo, jlong address, jint len)
+{
+    jint fd = fdval(env, fdo);
+    struct iovec *iov = (struct iovec *)jlong_to_ptr(address);
+    struct msghdr m;
+    ssize_t result = 0;
+    if (len > 16) {
+        len = 16;
+    }
+
+    m.msg_name = NULL;
+    m.msg_namelen = 0;
+    m.msg_iov = iov;
+    m.msg_iovlen = len;
+#ifdef __solaris__
+    m.msg_accrights = NULL;
+    m.msg_accrightslen = 0;
+#endif
+
+#ifdef __linux__
+    m.msg_control = NULL;
+    m.msg_controllen = 0;
+#endif
+
+    result = sendmsg(fd, &m, 0);
+    if (result < 0 && errno == ECONNREFUSED) {
+        JNU_ThrowByName(env, JNU_JAVANETPKG "PortUnreachableException", 0);
+        return -2;
+    }
+    return convertLongReturnVal(env, (jlong)result, JNI_FALSE);
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/DevPollArrayWrapper.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/DevPollArrayWrapper.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/DevPollArrayWrapper.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/DevPollArrayWrapper.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,207 @@
+/*
+ * Copyright 2001-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "sun_nio_ch_DevPollArrayWrapper.h"
+#include <sys/poll.h>
+#include <sys/resource.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+typedef uint32_t        caddr32_t;
+
+/* /dev/poll ioctl */
+#define         DPIOC   (0xD0 << 8)
+#define DP_POLL         (DPIOC | 1)     /* poll on fds in cached in /dev/poll */
+#define DP_ISPOLLED     (DPIOC | 2)     /* is this fd cached in /dev/poll */
+#define DEVPOLLSIZE     1000            /* /dev/poll table size increment */
+#define POLLREMOVE      0x0800          /* Removes fd from monitored set */
+
+/*
+ * /dev/poll DP_POLL ioctl format
+ */
+typedef struct dvpoll {
+        pollfd_t        *dp_fds;        /* pollfd array */
+        nfds_t          dp_nfds;        /* num of pollfd's in dp_fds[] */
+        int             dp_timeout;     /* time out in millisec */
+} dvpoll_t;
+
+typedef struct dvpoll32 {
+        caddr32_t       dp_fds;         /* pollfd array */
+        uint32_t        dp_nfds;        /* num of pollfd's in dp_fds[] */
+        int32_t         dp_timeout;     /* time out in millisec */
+} dvpoll32_t;
+
+#ifdef  __cplusplus
+}
+#endif
+
+#define RESTARTABLE(_cmd, _result) do { \
+  do { \
+    _result = _cmd; \
+  } while((_result == -1) && (errno == EINTR)); \
+} while(0)
+
+static int
+idevpoll(jint wfd, int dpctl, struct dvpoll a)
+{
+    jlong start, now;
+    int remaining = a.dp_timeout;
+    struct timeval t;
+    int diff;
+
+    gettimeofday(&t, NULL);
+    start = t.tv_sec * 1000 + t.tv_usec / 1000;
+
+    for (;;) {
+        /*  poll(7d) ioctl does not return remaining count */
+        int res = ioctl(wfd, dpctl, &a);
+        if (res < 0 && errno == EINTR) {
+            if (remaining >= 0) {
+                gettimeofday(&t, NULL);
+                now = t.tv_sec * 1000 + t.tv_usec / 1000;
+                diff = now - start;
+                remaining -= diff;
+                if (diff < 0 || remaining <= 0) {
+                    return 0;
+                }
+                start = now;
+            }
+        } else {
+            return res;
+        }
+    }
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_DevPollArrayWrapper_init(JNIEnv *env, jobject this)
+{
+    int wfd = open("/dev/poll", O_RDWR);
+    if (wfd < 0) {
+       JNU_ThrowIOExceptionWithLastError(env, "Error opening driver");
+       return -1;
+    }
+    return wfd;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_DevPollArrayWrapper_register(JNIEnv *env, jobject this,
+                                             jint wfd, jint fd, jint mask)
+{
+    struct pollfd a[2];
+    unsigned char *pollBytes = (unsigned char *)&a[0];
+    unsigned char *pollEnd = pollBytes + sizeof(struct pollfd) * 2;
+
+    /* We clear it first, otherwise any entries between poll invocations
+       get OR'd together */
+    a[0].fd = fd;
+    a[0].events = POLLREMOVE;
+    a[0].revents = 0;
+
+    a[1].fd = fd;
+    a[1].events = mask;
+    a[1].revents = 0;
+
+    while (pollBytes < pollEnd) {
+        int bytesWritten = write(wfd, pollBytes, (int)(pollEnd - pollBytes));
+        if (bytesWritten < 0) {
+            JNU_ThrowIOExceptionWithLastError(env, "Error writing pollfds");
+            return;
+        }
+        pollBytes += bytesWritten;
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_DevPollArrayWrapper_registerMultiple(JNIEnv *env, jobject this,
+                                                     jint wfd, jlong address,
+                                                     jint len)
+{
+    unsigned char *pollBytes = (unsigned char *)jlong_to_ptr(address);
+    unsigned char *pollEnd = pollBytes + sizeof(struct pollfd) * len;
+    while (pollBytes < pollEnd) {
+        int bytesWritten = write(wfd, pollBytes, (int)(pollEnd - pollBytes));
+        if (bytesWritten < 0) {
+            JNU_ThrowIOExceptionWithLastError(env, "Error writing pollfds");
+            return;
+        }
+        pollBytes += bytesWritten;
+    }
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_DevPollArrayWrapper_poll0(JNIEnv *env, jobject this,
+                                       jlong address, jint numfds,
+                                       jlong timeout, jint wfd)
+{
+    struct dvpoll a;
+    void *pfd = (void *) jlong_to_ptr(address);
+    int result = 0;
+
+    a.dp_fds = pfd;
+    a.dp_nfds = numfds;
+    a.dp_timeout = (int)timeout;
+
+    if (timeout <= 0) {             /* Indefinite or no wait */
+        RESTARTABLE (ioctl(wfd, DP_POLL, &a), result);
+    } else {                        /* Bounded wait; bounded restarts */
+        result = idevpoll(wfd, DP_POLL, a);
+    }
+
+    if (result < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "Error reading driver");
+        return -1;
+    }
+    return result;
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_DevPollArrayWrapper_fdLimit(JNIEnv *env, jclass this)
+{
+    struct rlimit rlp;
+    if (getrlimit(RLIMIT_NOFILE, &rlp) < 0) {
+        JNU_ThrowIOExceptionWithLastError(env,
+                                          "getrlimit failed");
+    }
+    return (jint)rlp.rlim_max;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_DevPollArrayWrapper_interrupt(JNIEnv *env, jclass this, jint fd)
+{
+    int fakebuf[1];
+    fakebuf[0] = 1;
+    if (write(fd, fakebuf, 1) < 0) {
+        JNU_ThrowIOExceptionWithLastError(env,
+                                          "Write to interrupt fd failed");
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/EPollArrayWrapper.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/EPollArrayWrapper.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/EPollArrayWrapper.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/EPollArrayWrapper.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,201 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+
+#include "sun_nio_ch_EPollArrayWrapper.h"
+
+#include <dlfcn.h>
+#include <unistd.h>
+#include <sys/resource.h>
+#include <sys/time.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/* epoll_wait(2) man page */
+
+typedef union epoll_data {
+    void *ptr;
+    int fd;
+    __uint32_t u32;
+    __uint64_t u64;
+} epoll_data_t;
+
+struct epoll_event {
+    __uint32_t events;  /* Epoll events */
+    epoll_data_t data;  /* User data variable */
+} __attribute__ ((__packed__));
+
+#ifdef  __cplusplus
+}
+#endif
+
+#define RESTARTABLE(_cmd, _result) do { \
+  do { \
+    _result = _cmd; \
+  } while((_result == -1) && (errno == EINTR)); \
+} while(0)
+
+/*
+ * epoll event notification is new in 2.6 kernel. As the offical build
+ * platform for the JDK is on a 2.4-based distribution then we must
+ * obtain the addresses of the epoll functions dynamically.
+ */
+typedef int (*epoll_create_t)(int size);
+typedef int (*epoll_ctl_t)   (int epfd, int op, int fd, struct epoll_event *event);
+typedef int (*epoll_wait_t)  (int epfd, struct epoll_event *events, int maxevents, int timeout);
+
+static epoll_create_t epoll_create_func;
+static epoll_ctl_t    epoll_ctl_func;
+static epoll_wait_t   epoll_wait_func;
+
+static int
+iepoll(int epfd, struct epoll_event *events, int numfds, jlong timeout)
+{
+    jlong start, now;
+    int remaining = timeout;
+    struct timeval t;
+    int diff;
+
+    gettimeofday(&t, NULL);
+    start = t.tv_sec * 1000 + t.tv_usec / 1000;
+
+    for (;;) {
+        int res = (*epoll_wait_func)(epfd, events, numfds, timeout);
+        if (res < 0 && errno == EINTR) {
+            if (remaining >= 0) {
+                gettimeofday(&t, NULL);
+                now = t.tv_sec * 1000 + t.tv_usec / 1000;
+                diff = now - start;
+                remaining -= diff;
+                if (diff < 0 || remaining <= 0) {
+                    return 0;
+                }
+                start = now;
+            }
+        } else {
+            return res;
+        }
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_EPollArrayWrapper_init(JNIEnv *env, jclass this)
+{
+    epoll_create_func = (epoll_create_t) dlsym(RTLD_DEFAULT, "epoll_create");
+    epoll_ctl_func    = (epoll_ctl_t)    dlsym(RTLD_DEFAULT, "epoll_ctl");
+    epoll_wait_func   = (epoll_wait_t)   dlsym(RTLD_DEFAULT, "epoll_wait");
+
+    if ((epoll_create_func == NULL) || (epoll_ctl_func == NULL) ||
+        (epoll_wait_func == NULL)) {
+        JNU_ThrowInternalError(env, "unable to get address of epoll functions, pre-2.6 kernel?");
+    }
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_EPollArrayWrapper_epollCreate(JNIEnv *env, jobject this)
+{
+    /*
+     * epoll_create expects a size as a hint to the kernel about how to
+     * dimension internal structures. We can't predict the size in advance.
+     */
+    int epfd = (*epoll_create_func)(256);
+    if (epfd < 0) {
+       JNU_ThrowIOExceptionWithLastError(env, "epoll_create failed");
+    }
+    return epfd;
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_EPollArrayWrapper_fdLimit(JNIEnv *env, jclass this)
+{
+    struct rlimit rlp;
+    if (getrlimit(RLIMIT_NOFILE, &rlp) < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "getrlimit failed");
+    }
+    return (jint)rlp.rlim_max;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_EPollArrayWrapper_epollCtl(JNIEnv *env, jobject this, jint epfd,
+                                           jint opcode, jint fd, jint events)
+{
+    struct epoll_event event;
+    int res;
+
+    event.events = events;
+    event.data.fd = fd;
+
+    RESTARTABLE((*epoll_ctl_func)(epfd, (int)opcode, (int)fd, &event), res);
+
+    /*
+     * A channel may be registered with several Selectors. When each Selector
+     * is polled a EPOLL_CTL_DEL op will be inserted into its pending update
+     * list to remove the file descriptor from epoll. The "last" Selector will
+     * close the file descriptor which automatically unregisters it from each
+     * epoll descriptor. To avoid costly synchronization between Selectors we
+     * allow pending updates to be processed, ignoring errors. The errors are
+     * harmless as the last update for the file descriptor is guaranteed to
+     * be EPOLL_CTL_DEL.
+     */
+    if (res < 0 && errno != EBADF && errno != ENOENT && errno != EPERM) {
+        JNU_ThrowIOExceptionWithLastError(env, "epoll_ctl failed");
+    }
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_EPollArrayWrapper_epollWait(JNIEnv *env, jobject this,
+                                            jlong address, jint numfds,
+                                            jlong timeout, jint epfd)
+{
+    struct epoll_event *events = jlong_to_ptr(address);
+    int res;
+
+    if (timeout <= 0) {           /* Indefinite or no wait */
+        RESTARTABLE((*epoll_wait_func)(epfd, events, numfds, timeout), res);
+    } else {                      /* Bounded wait; bounded restarts */
+        res = iepoll(epfd, events, numfds, timeout);
+    }
+
+    if (res < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "epoll_wait failed");
+    }
+    return res;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_EPollArrayWrapper_interrupt(JNIEnv *env, jobject this, jint fd)
+{
+    int fakebuf[1];
+    fakebuf[0] = 1;
+    if (write(fd, fakebuf, 1) < 0) {
+        JNU_ThrowIOExceptionWithLastError(env,"write to interrupt fd failed");
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/FileChannelImpl.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/FileChannelImpl.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/FileChannelImpl.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/FileChannelImpl.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,345 @@
+/*
+ * Copyright 2000-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include "sun_nio_ch_FileChannelImpl.h"
+#include "java_lang_Integer.h"
+#include "java_lang_Long.h"
+#include "nio.h"
+#include "nio_util.h"
+#include <dlfcn.h>
+
+static jfieldID chan_fd;        /* jobject 'fd' in sun.io.FileChannelImpl */
+
+#ifdef __solaris__
+typedef struct sendfilevec64 {
+    int     sfv_fd;         /* input fd */
+    uint_t  sfv_flag;       /* Flags. see below */
+    off64_t sfv_off;        /* offset to start reading from */
+    size_t  sfv_len;        /* amount of data */
+} sendfilevec_t;
+
+/* Function pointer for sendfilev on Solaris 8+ */
+typedef ssize_t sendfile_func(int fildes, const struct sendfilevec64 *vec,
+                              int sfvcnt, size_t *xferred);
+
+sendfile_func* my_sendfile_func = NULL;
+#endif
+
+#ifdef __linux__
+#include <sys/sendfile.h>
+
+/* Function pointer for sendfile64 on Linux 2.6 (and newer 2.4 kernels) */
+typedef ssize_t sendfile64_func(int out_fd, int in_fd, off64_t *offset, size_t count);
+
+sendfile64_func* my_sendfile64_func = NULL;
+#endif
+
+JNIEXPORT jlong JNICALL
+Java_sun_nio_ch_FileChannelImpl_initIDs(JNIEnv *env, jclass clazz)
+{
+    jlong pageSize = sysconf(_SC_PAGESIZE);
+    chan_fd = (*env)->GetFieldID(env, clazz, "fd", "Ljava/io/FileDescriptor;");
+
+#ifdef __solaris__
+    if (dlopen("/usr/lib/libsendfile.so.1", RTLD_GLOBAL | RTLD_LAZY) != NULL) {
+        my_sendfile_func = (sendfile_func*) dlsym(RTLD_DEFAULT, "sendfilev64");
+    }
+#endif
+
+#ifdef __linux__
+    my_sendfile64_func = (sendfile64_func*) dlsym(RTLD_DEFAULT, "sendfile64");
+#endif
+
+    return pageSize;
+}
+
+static jlong
+handle(JNIEnv *env, jlong rv, char *msg)
+{
+    if (rv >= 0)
+        return rv;
+    if (errno == EINTR)
+        return IOS_INTERRUPTED;
+    JNU_ThrowIOExceptionWithLastError(env, msg);
+    return IOS_THROWN;
+}
+
+
+JNIEXPORT jlong JNICALL
+Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this,
+                                     jint prot, jlong off, jlong len)
+{
+    void *mapAddress = 0;
+    jobject fdo = (*env)->GetObjectField(env, this, chan_fd);
+    jint fd = fdval(env, fdo);
+    int protections = 0;
+    int flags = 0;
+
+    if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) {
+        protections = PROT_READ;
+        flags = MAP_SHARED;
+    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) {
+        protections = PROT_WRITE | PROT_READ;
+        flags = MAP_SHARED;
+    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) {
+        protections =  PROT_WRITE | PROT_READ;
+        flags = MAP_PRIVATE;
+    }
+
+    mapAddress = mmap64(
+        0,                    /* Let OS decide location */
+        len,                  /* Number of bytes to map */
+        protections,          /* File permissions */
+        flags,                /* Changes are shared */
+        fd,                   /* File descriptor of mapped file */
+        off);                 /* Offset into file */
+
+    if (mapAddress == MAP_FAILED) {
+        if (errno == ENOMEM) {
+            JNU_ThrowOutOfMemoryError(env, "Map failed");
+            return IOS_THROWN;
+        }
+        return handle(env, -1, "Map failed");
+    }
+
+    return ((jlong) (unsigned long) mapAddress);
+}
+
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_FileChannelImpl_unmap0(JNIEnv *env, jobject this,
+                                       jlong address, jlong len)
+{
+    void *a = (void *)jlong_to_ptr(address);
+    return handle(env,
+                  munmap(a, (size_t)len),
+                  "Unmap failed");
+}
+
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_FileChannelImpl_truncate0(JNIEnv *env, jobject this,
+                                          jobject fdo, jlong size)
+{
+    return handle(env,
+                  ftruncate64(fdval(env, fdo), size),
+                  "Truncation failed");
+}
+
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_FileChannelImpl_force0(JNIEnv *env, jobject this,
+                                       jobject fdo, jboolean md)
+{
+    jint fd = fdval(env, fdo);
+    int result = 0;
+
+    if (md == JNI_FALSE) {
+        result = fdatasync(fd);
+    } else {
+        result = fsync(fd);
+    }
+    return handle(env, result, "Force failed");
+}
+
+
+JNIEXPORT jlong JNICALL
+Java_sun_nio_ch_FileChannelImpl_position0(JNIEnv *env, jobject this,
+                                          jobject fdo, jlong offset)
+{
+    jint fd = fdval(env, fdo);
+    jlong result = 0;
+
+    if (offset < 0) {
+        result = lseek64(fd, 0, SEEK_CUR);
+    } else {
+        result = lseek64(fd, offset, SEEK_SET);
+    }
+    return handle(env, result, "Position failed");
+}
+
+
+JNIEXPORT jlong JNICALL
+Java_sun_nio_ch_FileChannelImpl_size0(JNIEnv *env, jobject this, jobject fdo)
+{
+    struct stat64 fbuf;
+
+    if (fstat64(fdval(env, fdo), &fbuf) < 0)
+        return handle(env, -1, "Size failed");
+    return fbuf.st_size;
+}
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_FileChannelImpl_close0(JNIEnv *env, jobject this, jobject fdo)
+{
+    jint fd = fdval(env, fdo);
+    if (fd != -1) {
+        jlong result = close(fd);
+        if (result < 0) {
+            JNU_ThrowIOExceptionWithLastError(env, "Close failed");
+        }
+    }
+}
+
+JNIEXPORT jlong JNICALL
+Java_sun_nio_ch_FileChannelImpl_transferTo0(JNIEnv *env, jobject this,
+                                            jint srcFD,
+                                            jlong position, jlong count,
+                                            jint dstFD)
+{
+#ifdef __linux__
+    jlong max = (jlong)java_lang_Integer_MAX_VALUE;
+    jlong n;
+
+    if (my_sendfile64_func == NULL) {
+        off_t offset;
+        if (position > max)
+            return IOS_UNSUPPORTED_CASE;
+        if (count > max)
+            count = max;
+        offset = (off_t)position;
+        n = sendfile(dstFD, srcFD, &offset, (size_t)count);
+    } else {
+        off64_t offset = (off64_t)position;
+        n = (*my_sendfile64_func)(dstFD, srcFD, &offset, (size_t)count);
+    }
+    if (n < 0) {
+        if (errno == EAGAIN)
+            return IOS_UNAVAILABLE;
+        if ((errno == EINVAL) && ((ssize_t)count >= 0))
+            return IOS_UNSUPPORTED_CASE;
+        if (errno == EINTR) {
+            return IOS_INTERRUPTED;
+        }
+        JNU_ThrowIOExceptionWithLastError(env, "Transfer failed");
+        return IOS_THROWN;
+    }
+    return n;
+#endif
+
+#ifdef __solaris__
+    if (my_sendfile_func == NULL) {
+        return IOS_UNSUPPORTED;
+    } else {
+        sendfilevec_t sfv;
+        size_t numBytes = 0;
+        jlong result;
+
+        sfv.sfv_fd = srcFD;
+        sfv.sfv_flag = 0;
+        sfv.sfv_off = (off64_t)position;
+        sfv.sfv_len = count;
+
+        result = (*my_sendfile_func)(dstFD, &sfv, 1, &numBytes);
+
+        /* Solaris sendfilev() will return -1 even if some bytes have been
+         * transferred, so we check numBytes first.
+         */
+        if (numBytes > 0)
+            return numBytes;
+        if (result < 0) {
+            if (errno == EAGAIN)
+                return IOS_UNAVAILABLE;
+            if ((errno == EINVAL) && ((ssize_t)count >= 0))
+                return IOS_UNSUPPORTED_CASE;
+            if (errno == EINTR)
+                return IOS_INTERRUPTED;
+            JNU_ThrowIOExceptionWithLastError(env, "Transfer failed");
+            return IOS_THROWN;
+        }
+        return result;
+    }
+#endif
+}
+/*
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_FileChannelImpl_lock0(JNIEnv *env, jobject this, jobject fdo,
+                                      jboolean block, jlong pos, jlong size,
+                                      jboolean shared)
+{
+    jint fd = fdval(env, fdo);
+    jint lockResult = 0;
+    int cmd = 0;
+    struct flock64 fl;
+
+    fl.l_whence = SEEK_SET;
+    if (size == (jlong)java_lang_Long_MAX_VALUE) {
+        fl.l_len = (off64_t)0;
+    } else {
+        fl.l_len = (off64_t)size;
+    }
+    fl.l_start = (off64_t)pos;
+    if (shared == JNI_TRUE) {
+        fl.l_type = F_RDLCK;
+    } else {
+        fl.l_type = F_WRLCK;
+    }
+    if (block == JNI_TRUE) {
+        cmd = F_SETLKW64;
+    } else {
+        cmd = F_SETLK64;
+    }
+    lockResult = fcntl(fd, cmd, &fl);
+    if (lockResult < 0) {
+        if ((cmd == F_SETLK64) && (errno == EAGAIN))
+            return sun_nio_ch_FileChannelImpl_NO_LOCK;
+        if (errno == EINTR)
+            return sun_nio_ch_FileChannelImpl_INTERRUPTED;
+        JNU_ThrowIOExceptionWithLastError(env, "Lock failed");
+    }
+    return 0;
+}
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_FileChannelImpl_release0(JNIEnv *env, jobject this,
+                                         jobject fdo, jlong pos, jlong size)
+{
+    jint fd = fdval(env, fdo);
+    jint lockResult = 0;
+    struct flock64 fl;
+    int cmd = F_SETLK64;
+
+    fl.l_whence = SEEK_SET;
+    if (size == (jlong)java_lang_Long_MAX_VALUE) {
+        fl.l_len = (off64_t)0;
+    } else {
+        fl.l_len = (off64_t)size;
+    }
+    fl.l_start = (off64_t)pos;
+    fl.l_type = F_UNLCK;
+    lockResult = fcntl(fd, cmd, &fl);
+    if (lockResult < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "Release failed");
+    }
+}
+*/
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/FileDispatcher.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/FileDispatcher.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/FileDispatcher.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/FileDispatcher.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "sun_nio_ch_FileDispatcher.h"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <fcntl.h>
+#include <sys/uio.h>
+#include "nio_util.h"
+
+
+static int preCloseFD = -1;     /* File descriptor to which we dup other fd's
+                                   before closing them for real */
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_FileDispatcher_init(JNIEnv *env, jclass cl)
+{
+    int sp[2];
+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "socketpair failed");
+        return;
+    }
+    preCloseFD = sp[0];
+    close(sp[1]);
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_FileDispatcher_read0(JNIEnv *env, jclass clazz,
+                             jobject fdo, jlong address, jint len)
+{
+    jint fd = fdval(env, fdo);
+    void *buf = (void *)jlong_to_ptr(address);
+
+    return convertReturnVal(env, read(fd, buf, len), JNI_TRUE);
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_FileDispatcher_pread0(JNIEnv *env, jclass clazz, jobject fdo,
+                            jlong address, jint len, jlong offset)
+{
+    jint fd = fdval(env, fdo);
+    void *buf = (void *)jlong_to_ptr(address);
+
+    return convertReturnVal(env, pread64(fd, buf, len, offset), JNI_TRUE);
+}
+
+JNIEXPORT jlong JNICALL
+Java_sun_nio_ch_FileDispatcher_readv0(JNIEnv *env, jclass clazz,
+                              jobject fdo, jlong address, jint len)
+{
+    jint fd = fdval(env, fdo);
+    struct iovec *iov = (struct iovec *)jlong_to_ptr(address);
+    if (len > 16) {
+        len = 16;
+    }
+    return convertLongReturnVal(env, readv(fd, iov, len), JNI_TRUE);
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_FileDispatcher_write0(JNIEnv *env, jclass clazz,
+                              jobject fdo, jlong address, jint len)
+{
+    jint fd = fdval(env, fdo);
+    void *buf = (void *)jlong_to_ptr(address);
+
+    return convertReturnVal(env, write(fd, buf, len), JNI_FALSE);
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_FileDispatcher_pwrite0(JNIEnv *env, jclass clazz, jobject fdo,
+                            jlong address, jint len, jlong offset)
+{
+    jint fd = fdval(env, fdo);
+    void *buf = (void *)jlong_to_ptr(address);
+
+    return convertReturnVal(env, pwrite64(fd, buf, len, offset), JNI_FALSE);
+}
+
+JNIEXPORT jlong JNICALL
+Java_sun_nio_ch_FileDispatcher_writev0(JNIEnv *env, jclass clazz,
+                                       jobject fdo, jlong address, jint len)
+{
+    jint fd = fdval(env, fdo);
+    struct iovec *iov = (struct iovec *)jlong_to_ptr(address);
+    if (len > 16) {
+        len = 16;
+    }
+    return convertLongReturnVal(env, writev(fd, iov, len), JNI_FALSE);
+}
+
+static void closeFileDescriptor(JNIEnv *env, int fd) {
+    if (fd != -1) {
+        int result = close(fd);
+        if (result < 0)
+            JNU_ThrowIOExceptionWithLastError(env, "Close failed");
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_FileDispatcher_close0(JNIEnv *env, jclass clazz, jobject fdo)
+{
+    jint fd = fdval(env, fdo);
+    closeFileDescriptor(env, fd);
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_FileDispatcher_preClose0(JNIEnv *env, jclass clazz, jobject fdo)
+{
+    jint fd = fdval(env, fdo);
+    if (preCloseFD >= 0) {
+        if (dup2(preCloseFD, fd) < 0)
+            JNU_ThrowIOExceptionWithLastError(env, "dup2 failed");
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_FileDispatcher_closeIntFD(JNIEnv *env, jclass clazz, jint fd)
+{
+    closeFileDescriptor(env, fd);
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/FileKey.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/FileKey.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/FileKey.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/FileKey.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "nio.h"
+#include "nio_util.h"
+#include "sun_nio_ch_FileKey.h"
+
+static jfieldID key_st_dev;    /* id for FileKey.st_dev */
+static jfieldID key_st_ino;    /* id for FileKey.st_ino */
+
+#define RESTARTABLE(_cmd, _result) do { \
+  do { \
+    _result = _cmd; \
+  } while ((_result == -1) && (errno == EINTR)); \
+} while(0)
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_FileKey_initIDs(JNIEnv *env, jclass clazz)
+{
+    key_st_dev = (*env)->GetFieldID(env, clazz, "st_dev", "J");
+    key_st_ino = (*env)->GetFieldID(env, clazz, "st_ino", "J");
+}
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_FileKey_init(JNIEnv *env, jobject this, jobject fdo)
+{
+    struct stat64 fbuf;
+    int res;
+
+    RESTARTABLE(fstat64(fdval(env, fdo), &fbuf), res);
+    if (res < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "fstat64 failed");
+    } else {
+        (*env)->SetLongField(env, this, key_st_dev, (jlong)fbuf.st_dev);
+        (*env)->SetLongField(env, this, key_st_ino, (jlong)fbuf.st_ino);
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/InheritedChannel.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/InheritedChannel.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/InheritedChannel.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/InheritedChannel.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2003-2004 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "jni.h"
+
+#include "jni.h"
+#include "jni_util.h"
+#include "net_util.h"
+
+#include "sun_nio_ch_InheritedChannel.h"
+
+static int matchFamily(struct sockaddr *sa) {
+    int family = sa->sa_family;
+#ifdef AF_INET6
+    if (ipv6_available()) {
+        return (family == AF_INET6);
+    }
+#endif
+    return (family == AF_INET);
+}
+
+JNIEXPORT jobject JNICALL
+Java_sun_nio_ch_InheritedChannel_peerAddress0(JNIEnv *env, jclass cla, jint fd)
+{
+    struct sockaddr *sa;
+    socklen_t sa_len;
+    jobject remote_ia = NULL;
+    jint remote_port;
+
+    NET_AllocSockaddr(&sa, (int *)&sa_len);
+    if (getpeername(fd, sa, &sa_len) == 0) {
+        if (matchFamily(sa)) {
+            remote_ia = NET_SockaddrToInetAddress(env, sa, (int *)&remote_port);
+        }
+    }
+    free((void *)sa);
+
+    return remote_ia;
+}
+
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_InheritedChannel_peerPort0(JNIEnv *env, jclass cla, jint fd)
+{
+    struct sockaddr *sa;
+    socklen_t sa_len;
+    jint remote_port = -1;
+
+    NET_AllocSockaddr(&sa, (int *)&sa_len);
+    if (getpeername(fd, sa, &sa_len) == 0) {
+        if (matchFamily(sa)) {
+            NET_SockaddrToInetAddress(env, sa, (int *)&remote_port);
+        }
+    }
+    free((void *)sa);
+
+    return remote_port;
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_InheritedChannel_soType0(JNIEnv *env, jclass cla, jint fd)
+{
+    int sotype;
+    socklen_t arglen=sizeof(sotype);
+    if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&sotype, &arglen) == 0) {
+        if (sotype == SOCK_STREAM)
+            return sun_nio_ch_InheritedChannel_SOCK_STREAM;
+        if (sotype == SOCK_DGRAM)
+            return sun_nio_ch_InheritedChannel_SOCK_DGRAM;
+    }
+    return sun_nio_ch_InheritedChannel_UNKNOWN;
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_InheritedChannel_dup(JNIEnv *env, jclass cla, jint fd)
+{
+   int newfd = dup(fd);
+   if (newfd < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "dup failed");
+   }
+   return (jint)newfd;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_InheritedChannel_dup2(JNIEnv *env, jclass cla, jint fd, jint fd2)
+{
+   if (dup2(fd, fd2) < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "dup2 failed");
+   }
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_InheritedChannel_open0(JNIEnv *env, jclass cla, jstring path, jint oflag)
+{
+    const char* str;
+    int oflag_actual;
+
+    /* convert to OS specific value */
+    switch (oflag) {
+        case sun_nio_ch_InheritedChannel_O_RDWR :
+            oflag_actual = O_RDWR;
+            break;
+        case sun_nio_ch_InheritedChannel_O_RDONLY :
+            oflag_actual = O_RDONLY;
+            break;
+        case sun_nio_ch_InheritedChannel_O_WRONLY :
+            oflag_actual = O_WRONLY;
+            break;
+        default :
+            JNU_ThrowInternalError(env, "Unrecognized file mode");
+            return -1;
+    }
+
+    str = JNU_GetStringPlatformChars(env, path, NULL);
+    if (str == NULL) {
+        return (jint)-1;
+    } else {
+        int fd = open(str, oflag_actual);
+        if (fd < 0) {
+            JNU_ThrowIOExceptionWithLastError(env, str);
+        }
+        JNU_ReleaseStringPlatformChars(env, path, str);
+        return (jint)fd;
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_InheritedChannel_close0(JNIEnv *env, jclass cla, jint fd)
+{
+    if (close(fd) < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "close failed");
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/IOUtil.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/IOUtil.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/IOUtil.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/IOUtil.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,179 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include <sys/types.h>
+#include <string.h>
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "sun_nio_ch_IOUtil.h"
+#include "nio.h"
+#include "nio_util.h"
+
+static jfieldID fd_fdID;        /* for jint 'fd' in java.io.FileDescriptor */
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_IOUtil_initIDs(JNIEnv *env, jclass clazz)
+{
+    clazz = (*env)->FindClass(env, "java/io/FileDescriptor");
+    fd_fdID = (*env)->GetFieldID(env, clazz, "fd", "I");
+}
+
+JNIEXPORT jboolean JNICALL
+Java_sun_nio_ch_IOUtil_randomBytes(JNIEnv *env, jclass clazz,
+                                  jbyteArray randArray)
+{
+    JNU_ThrowByName(env, "java/lang/UnsupportedOperationException", NULL);
+    return JNI_FALSE;
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_IOUtil_fdVal(JNIEnv *env, jclass clazz, jobject fdo)
+{
+    return (*env)->GetIntField(env, fdo, fd_fdID);
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_IOUtil_setfdVal(JNIEnv *env, jclass clazz, jobject fdo, jint val)
+{
+    (*env)->SetIntField(env, fdo, fd_fdID, val);
+}
+
+static int
+configureBlocking(int fd, jboolean blocking)
+{
+    int flags = fcntl(fd, F_GETFL);
+
+    if ((blocking == JNI_FALSE) && !(flags & O_NONBLOCK))
+        return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
+    else if ((blocking == JNI_TRUE) && (flags & O_NONBLOCK))
+        return fcntl(fd, F_SETFL, flags & ~O_NONBLOCK);
+    return 0;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_IOUtil_configureBlocking(JNIEnv *env, jclass clazz,
+                                         jobject fdo, jboolean blocking)
+{
+    if (configureBlocking(fdval(env, fdo), blocking) < 0)
+        JNU_ThrowIOExceptionWithLastError(env, "Configure blocking failed");
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_IOUtil_initPipe(JNIEnv *env, jobject this,
+                                    jintArray intArray, jboolean block)
+{
+    int fd[2];
+    jint *ptr = 0;
+
+    if (pipe(fd) < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "Pipe failed");
+        return;
+    }
+    if (block == JNI_FALSE) {
+        if ((configureBlocking(fd[0], JNI_FALSE) < 0)
+            || (configureBlocking(fd[1], JNI_FALSE) < 0)) {
+            JNU_ThrowIOExceptionWithLastError(env, "Configure blocking failed");
+        }
+    }
+    ptr = (*env)->GetPrimitiveArrayCritical(env, intArray, 0);
+    ptr[0] = fd[0];
+    ptr[1] = fd[1];
+    (*env)->ReleasePrimitiveArrayCritical(env, intArray, ptr, 0);
+}
+
+JNIEXPORT jboolean JNICALL
+Java_sun_nio_ch_IOUtil_drain(JNIEnv *env, jclass cl, jint fd)
+{
+    char buf[128];
+    int tn = 0;
+
+    for (;;) {
+        int n = read(fd, buf, sizeof(buf));
+        tn += n;
+        if ((n < 0) && (errno != EAGAIN))
+            JNU_ThrowIOExceptionWithLastError(env, "Drain");
+        if (n == (int)sizeof(buf))
+            continue;
+        return (tn > 0) ? JNI_TRUE : JNI_FALSE;
+    }
+}
+
+
+/* Declared in nio_util.h for use elsewhere in NIO */
+
+jint
+convertReturnVal(JNIEnv *env, jint n, jboolean reading)
+{
+    if (n > 0) /* Number of bytes written */
+        return n;
+    if (n < 0) {
+        if (errno == EAGAIN)
+            return IOS_UNAVAILABLE;
+        if (errno == EINTR)
+            return IOS_INTERRUPTED;
+    }
+    if (n == 0) {
+        if (reading) {
+            return IOS_EOF; /* EOF is -1 in javaland */
+        } else {
+            return 0;
+        }
+    }
+    JNU_ThrowIOExceptionWithLastError(env, "Read/write failed");
+    return IOS_THROWN;
+}
+
+/* Declared in nio_util.h for use elsewhere in NIO */
+
+jlong
+convertLongReturnVal(JNIEnv *env, jlong n, jboolean reading)
+{
+    if (n > 0) /* Number of bytes written */
+        return n;
+    if (n < 0) {
+        if (errno == EAGAIN)
+            return IOS_UNAVAILABLE;
+        if (errno == EINTR)
+            return IOS_INTERRUPTED;
+    }
+    if (n == 0) {
+        if (reading) {
+            return IOS_EOF; /* EOF is -1 in javaland */
+        } else {
+            return 0;
+        }
+    }
+    JNU_ThrowIOExceptionWithLastError(env, "Read/write failed");
+    return IOS_THROWN;
+}
+
+jint
+fdval(JNIEnv *env, jobject fdo)
+{
+    return (*env)->GetIntField(env, fdo, fd_fdID);
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/NativeThread.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/NativeThread.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/NativeThread.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/NativeThread.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2002-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include <sys/types.h>
+#include <string.h>
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "sun_nio_ch_NativeThread.h"
+#include "nio_util.h"
+
+
+#ifdef __linux__
+#include <pthread.h>
+#include <sys/signal.h>
+
+/* Also defined in src/solaris/native/java/net/linux_close.c */
+#define INTERRUPT_SIGNAL (__SIGRTMAX - 2)
+
+static void
+nullHandler(int sig)
+{
+}
+
+#endif
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_NativeThread_init(JNIEnv *env, jclass cl)
+{
+#ifdef __linux__
+
+    /* Install the null handler for INTERRUPT_SIGNAL.  This might overwrite the
+     * handler previously installed by java/net/linux_close.c, but that's okay
+     * since neither handler actually does anything.  We install our own
+     * handler here simply out of paranoia; ultimately the two mechanisms
+     * should somehow be unified, perhaps within the VM.
+     */
+
+    sigset_t ss;
+    struct sigaction sa, osa;
+    sa.sa_handler = nullHandler;
+    sa.sa_flags = 0;
+    sigemptyset(&sa.sa_mask);
+    if (sigaction(INTERRUPT_SIGNAL, &sa, &osa) < 0)
+        JNU_ThrowIOExceptionWithLastError(env, "sigaction");
+
+#endif
+}
+
+JNIEXPORT jlong JNICALL
+Java_sun_nio_ch_NativeThread_current(JNIEnv *env, jclass cl)
+{
+#ifdef __linux__
+    return (long)pthread_self();
+#else
+    return -1;
+#endif
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_NativeThread_signal(JNIEnv *env, jclass cl, jlong thread)
+{
+#ifdef __linux__
+    if (pthread_kill((pthread_t)thread, INTERRUPT_SIGNAL))
+        JNU_ThrowIOExceptionWithLastError(env, "Thread signal failed");
+#endif
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/Net.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/Net.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/Net.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/Net.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,326 @@
+/*
+ * Copyright 2001-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "sun_nio_ch_Net.h"
+#include "net_util.h"
+#include "net_util_md.h"
+#include "nio_util.h"
+#include "java_net_SocketOptions.h"
+#include "nio.h"
+
+#ifdef __linux__
+#include <sys/utsname.h>
+
+#define IPV6_MULTICAST_IF 17
+#ifndef SO_BSDCOMPAT
+#define SO_BSDCOMPAT  14
+#endif
+#endif
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_Net_initIDs(JNIEnv *env, jclass clazz)
+{
+    /* Here because Windows native code does need to init IDs */
+}
+
+JNIEXPORT int JNICALL
+Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean stream,
+                            jboolean reuse)
+{
+    int fd;
+
+#ifdef AF_INET6
+    if (ipv6_available())
+        fd = socket(AF_INET6, (stream ? SOCK_STREAM : SOCK_DGRAM), 0);
+    else
+#endif /* AF_INET6 */
+        fd = socket(AF_INET, (stream ? SOCK_STREAM : SOCK_DGRAM), 0);
+
+    if (fd < 0) {
+        return handleSocketError(env, errno);
+    }
+    if (reuse) {
+        int arg = 1;
+        if (NET_SetSockOpt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg,
+                           sizeof(arg)) < 0) {
+            JNU_ThrowByNameWithLastError(env,
+                                         JNU_JAVANETPKG "SocketException",
+                                         "sun.nio.ch.Net.setIntOption");
+        }
+    }
+    return fd;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_Net_bind(JNIEnv *env, jclass clazz, /* ## Needs rest of PSI gunk */
+                         jobject fdo, jobject ia, int port)
+{
+    SOCKADDR sa;
+    int sa_len = SOCKADDR_LEN;
+    int rv = 0;
+
+    NET_InetAddressToSockaddr(env, ia, port, (struct sockaddr *)&sa, &sa_len);
+
+    rv = NET_Bind(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);
+    if (rv != 0) {
+        handleSocketError(env, errno);
+    }
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_Net_connect(JNIEnv *env, jclass clazz,
+                                jobject fdo, jobject iao, jint port,
+                                jint trafficClass)
+{
+    SOCKADDR sa;
+    int sa_len = SOCKADDR_LEN;
+    int rv;
+
+    NET_InetAddressToSockaddr(env, iao, port, (struct sockaddr *) &sa, &sa_len);
+
+#ifdef AF_INET6
+#if 0
+    if (trafficClass != 0 && ipv6_available()) { /* ## FIX */
+        NET_SetTrafficClass((struct sockaddr *)&sa, trafficClass);
+    }
+#endif
+#endif
+
+    rv = connect(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);
+    if (rv != 0) {
+        if (errno == EINPROGRESS) {
+            return IOS_UNAVAILABLE;
+        } else if (errno == EINTR) {
+            return IOS_INTERRUPTED;
+        }
+        return handleSocketError(env, errno);
+    }
+    return 1;
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_Net_localPort(JNIEnv *env, jclass clazz, jobject fdo)
+{
+    SOCKADDR sa;
+    socklen_t sa_len = SOCKADDR_LEN;
+    if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {
+        handleSocketError(env, errno);
+        return -1;
+    }
+    return NET_GetPortFromSockaddr((struct sockaddr *)&sa);
+}
+
+JNIEXPORT jobject JNICALL
+Java_sun_nio_ch_Net_localInetAddress(JNIEnv *env, jclass clazz, jobject fdo)
+{
+    SOCKADDR sa;
+    socklen_t sa_len = SOCKADDR_LEN;
+    int port;
+    if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {
+        handleSocketError(env, errno);
+        return NULL;
+    }
+    return NET_SockaddrToInetAddress(env, (struct sockaddr *)&sa, &port);
+}
+
+
+#ifdef NEEDED
+
+/* ## This is gross.  We should generate platform-specific constant
+ * ## definitions into a .java file and use those directly.
+ */
+
+static int
+mapOption(JNIEnv *env, int opt, int *klevel, int *kopt)
+{
+
+    switch (opt) {
+
+    case java_net_SocketOptions_IP_TOS:
+        *klevel = IPPROTO_IP;
+        *kopt = IP_TOS;
+        break;
+
+    case java_net_SocketOptions_SO_BROADCAST:
+    case java_net_SocketOptions_SO_KEEPALIVE:
+    case java_net_SocketOptions_SO_LINGER:
+    case java_net_SocketOptions_SO_OOBINLINE:
+    case java_net_SocketOptions_SO_RCVBUF:
+    case java_net_SocketOptions_SO_REUSEADDR:
+    case java_net_SocketOptions_SO_SNDBUF:
+        *klevel = SOL_SOCKET;
+        break;
+
+    case java_net_SocketOptions_TCP_NODELAY:
+        *klevel = IPPROTO_IP;
+        *kopt = TCP_NODELAY;
+        return 0;
+
+    default:
+        JNU_ThrowByName(env, "java/lang/IllegalArgumentException", NULL);
+        return -1;
+    }
+
+    switch (opt) {
+
+    case java_net_SocketOptions_SO_BROADCAST:   *kopt = SO_BROADCAST;  break;
+    case java_net_SocketOptions_SO_KEEPALIVE:   *kopt = SO_KEEPALIVE;  break;
+    case java_net_SocketOptions_SO_LINGER:      *kopt = SO_LINGER;  break;
+    case java_net_SocketOptions_SO_OOBINLINE:   *kopt = SO_OOBINLINE;  break;
+    case java_net_SocketOptions_SO_RCVBUF:      *kopt = SO_RCVBUF;  break;
+    case java_net_SocketOptions_SO_REUSEADDR:   *kopt = SO_REUSEADDR;  break;
+    case java_net_SocketOptions_SO_SNDBUF:      *kopt = SO_SNDBUF;  break;
+
+    default:
+        return -1;
+    }
+
+    return 0;
+}
+#endif
+
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_Net_getIntOption0(JNIEnv *env, jclass clazz,
+                                  jobject fdo, jint opt)
+{
+    int klevel, kopt;
+    int result;
+    struct linger linger;
+    void *arg;
+    int arglen;
+
+    if (NET_MapSocketOption(opt, &klevel, &kopt) < 0) {
+        JNU_ThrowByNameWithLastError(env,
+                                     JNU_JAVANETPKG "SocketException",
+                                     "Unsupported socket option");
+        return -1;
+    }
+
+    if (opt == java_net_SocketOptions_SO_LINGER) {
+        arg = (void *)&linger;
+        arglen = sizeof(linger);
+    } else {
+        arg = (void *)&result;
+        arglen = sizeof(result);
+    }
+
+    if (NET_GetSockOpt(fdval(env, fdo), klevel, kopt, arg, &arglen) < 0) {
+        JNU_ThrowByNameWithLastError(env,
+                                     JNU_JAVANETPKG "SocketException",
+                                     "sun.nio.ch.Net.getIntOption");
+        return -1;
+    }
+
+    if (opt == java_net_SocketOptions_SO_LINGER)
+        return linger.l_onoff ? linger.l_linger : -1;
+    else
+        return result;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_Net_setIntOption0(JNIEnv *env, jclass clazz,
+                                  jobject fdo, jint opt, jint arg)
+{
+    int klevel, kopt;
+    int result;
+    struct linger linger;
+    void *parg;
+    int arglen;
+
+    if (NET_MapSocketOption(opt, &klevel, &kopt) < 0) {
+        JNU_ThrowByNameWithLastError(env,
+                                     JNU_JAVANETPKG "SocketException",
+                                     "Unsupported socket option");
+        return;
+    }
+
+    if (opt == java_net_SocketOptions_SO_LINGER) {
+        parg = (void *)&linger;
+        arglen = sizeof(linger);
+        if (arg >= 0) {
+            linger.l_onoff = 1;
+            linger.l_linger = arg;
+        } else {
+            linger.l_onoff = 0;
+            linger.l_linger = 0;
+        }
+    } else {
+        parg = (void *)&arg;
+        arglen = sizeof(arg);
+    }
+
+    if (NET_SetSockOpt(fdval(env, fdo), klevel, kopt, parg, arglen) < 0) {
+        JNU_ThrowByNameWithLastError(env,
+                                     JNU_JAVANETPKG "SocketException",
+                                     "sun.nio.ch.Net.setIntOption");
+    }
+}
+
+
+
+/* Declared in nio_util.h */
+
+jint
+handleSocketError(JNIEnv *env, jint errorValue)
+{
+    char *xn;
+    switch (errorValue) {
+        case EINPROGRESS:       /* Non-blocking connect */
+            return 0;
+        case EPROTO:
+            xn = JNU_JAVANETPKG "ProtocolException";
+            break;
+        case ECONNREFUSED:
+            xn = JNU_JAVANETPKG "ConnectException";
+            break;
+        case ETIMEDOUT:
+            xn = JNU_JAVANETPKG "ConnectException";
+            break;
+        case EHOSTUNREACH:
+            xn = JNU_JAVANETPKG "NoRouteToHostException";
+            break;
+        case EADDRINUSE:  /* Fall through */
+        case EADDRNOTAVAIL:
+            xn = JNU_JAVANETPKG "BindException";
+            break;
+        default:
+            xn = JNU_JAVANETPKG "SocketException";
+            break;
+    }
+    errno = errorValue;
+    JNU_ThrowByNameWithLastError(env, xn, "NioSocketError");
+    return IOS_THROWN;
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/nio_util.h phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/nio_util.h
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/nio_util.h	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/nio_util.h	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2001-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include <sys/types.h>
+
+
+/* NIO utility procedures */
+
+
+/* Defined in IOUtil.c */
+
+jint fdval(JNIEnv *env, jobject fdo);
+
+jint convertReturnVal(JNIEnv *env, jint n, jboolean reading);
+jlong convertLongReturnVal(JNIEnv *env, jlong n, jboolean reading);
+
+
+/* Defined in Net.c */
+
+jint handleSocketError(JNIEnv *env, jint errorValue);
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/PollArrayWrapper.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/PollArrayWrapper.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/PollArrayWrapper.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/PollArrayWrapper.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2001-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "sun_nio_ch_PollArrayWrapper.h"
+#include <poll.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+#define RESTARTABLE(_cmd, _result) do { \
+  do { \
+    _result = _cmd; \
+  } while((_result == -1) && (errno == EINTR)); \
+} while(0)
+
+static int
+ipoll(struct pollfd fds[], unsigned int nfds, int timeout)
+{
+    jlong start, now;
+    int remaining = timeout;
+    struct timeval t;
+    int diff;
+
+    gettimeofday(&t, NULL);
+    start = t.tv_sec * 1000 + t.tv_usec / 1000;
+
+    for (;;) {
+        int res = poll(fds, nfds, remaining);
+        if (res < 0 && errno == EINTR) {
+            if (remaining >= 0) {
+                gettimeofday(&t, NULL);
+                now = t.tv_sec * 1000 + t.tv_usec / 1000;
+                diff = now - start;
+                remaining -= diff;
+                if (diff < 0 || remaining <= 0) {
+                    return 0;
+                }
+                start = now;
+            }
+        } else {
+            return res;
+        }
+    }
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_PollArrayWrapper_poll0(JNIEnv *env, jobject this,
+                                       jlong address, jint numfds,
+                                       jlong timeout)
+{
+    struct pollfd *a;
+    int err = 0;
+
+    a = (struct pollfd *) jlong_to_ptr(address);
+
+    if (timeout <= 0) {           /* Indefinite or no wait */
+        RESTARTABLE (poll(a, numfds, timeout), err);
+    } else {                     /* Bounded wait; bounded restarts */
+        err = ipoll(a, numfds, timeout);
+    }
+
+    if (err < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "Poll failed");
+    }
+    return (jint)err;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_PollArrayWrapper_interrupt(JNIEnv *env, jobject this, jint fd)
+{
+    int fakebuf[1];
+    fakebuf[0] = 1;
+    if (write(fd, fakebuf, 1) < 0) {
+         JNU_ThrowIOExceptionWithLastError(env,
+                                          "Write to interrupt fd failed");
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/ServerSocketChannelImpl.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/ServerSocketChannelImpl.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/ServerSocketChannelImpl.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/ServerSocketChannelImpl.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include <stdlib.h>
+#include <netdb.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#if __linux__
+#include <netinet/in.h>
+#endif
+
+#if defined(__solaris__) && !defined(_SOCKLEN_T)
+typedef size_t socklen_t;       /* New in SunOS 5.7, so need this for 5.6 */
+#endif
+
+#include "jni.h"
+#include "jni_util.h"
+#include "net_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "sun_nio_ch_ServerSocketChannelImpl.h"
+#include "nio.h"
+#include "nio_util.h"
+
+
+static jfieldID fd_fdID;        /* java.io.FileDescriptor.fd */
+static jclass isa_class;        /* java.net.InetSocketAddress */
+static jmethodID isa_ctorID;    /*   .InetSocketAddress(InetAddress, int) */
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_ServerSocketChannelImpl_initIDs(JNIEnv *env, jclass c)
+{
+    jclass cls;
+
+    cls = (*env)->FindClass(env, "java/io/FileDescriptor");
+    fd_fdID = (*env)->GetFieldID(env, cls, "fd", "I");
+
+    cls = (*env)->FindClass(env, "java/net/InetSocketAddress");
+    isa_class = (*env)->NewGlobalRef(env, cls);
+    isa_ctorID = (*env)->GetMethodID(env, cls, "<init>",
+                                     "(Ljava/net/InetAddress;I)V");
+}
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_ServerSocketChannelImpl_listen(JNIEnv *env, jclass cl,
+                                               jobject fdo, jint backlog)
+{
+    if (listen(fdval(env, fdo), backlog) < 0)
+        handleSocketError(env, errno);
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_ServerSocketChannelImpl_accept0(JNIEnv *env, jobject this,
+                                                jobject ssfdo, jobject newfdo,
+                                                jobjectArray isaa)
+{
+    jint ssfd = (*env)->GetIntField(env, ssfdo, fd_fdID);
+    jint newfd;
+    struct sockaddr *sa;
+    int alloc_len;
+    jobject remote_ia = 0;
+    jobject isa;
+    jint remote_port;
+
+    NET_AllocSockaddr(&sa, &alloc_len);
+
+    /*
+     * accept connection but ignore ECONNABORTED indicating that
+     * a connection was eagerly accepted but was reset before
+     * accept() was called.
+     */
+    for (;;) {
+        socklen_t sa_len = alloc_len;
+        newfd = accept(ssfd, sa, &sa_len);
+        if (newfd >= 0) {
+            break;
+        }
+        if (errno != ECONNABORTED) {
+            break;
+        }
+        /* ECONNABORTED => restart accept */
+    }
+
+    if (newfd < 0) {
+        free((void *)sa);
+        if (errno == EAGAIN)
+            return IOS_UNAVAILABLE;
+        if (errno == EINTR)
+            return IOS_INTERRUPTED;
+        JNU_ThrowIOExceptionWithLastError(env, "Accept failed");
+        return IOS_THROWN;
+    }
+
+    (*env)->SetIntField(env, newfdo, fd_fdID, newfd);
+    remote_ia = NET_SockaddrToInetAddress(env, sa, (int *)&remote_port);
+    free((void *)sa);
+    isa = (*env)->NewObject(env, isa_class, isa_ctorID,
+                            remote_ia, remote_port);
+    (*env)->SetObjectArrayElement(env, isaa, 0, isa);
+    return 1;
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/SocketChannelImpl.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/SocketChannelImpl.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/SocketChannelImpl.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/SocketChannelImpl.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include <netdb.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <poll.h>
+
+#if __linux__
+#include <netinet/in.h>
+#endif
+
+#if defined(__solaris__) && !defined(_SOCKLEN_T)
+typedef size_t socklen_t;       /* New in SunOS 5.7, so need this for 5.6 */
+#endif
+
+#include "jni.h"
+#include "jni_util.h"
+#include "net_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "sun_nio_ch_SocketChannelImpl.h"
+#include "nio_util.h"
+#include "nio.h"
+
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_SocketChannelImpl_checkConnect(JNIEnv *env, jobject this,
+                                               jobject fdo, jboolean block,
+                                               jboolean ready)
+{
+    int error = 0;
+    socklen_t n = sizeof(int);
+    jint fd = fdval(env, fdo);
+    int result = 0;
+    struct pollfd poller;
+
+    poller.revents = 1;
+    if (!ready) {
+        poller.fd = fd;
+        poller.events = POLLOUT;
+        poller.revents = 0;
+        result = poll(&poller, 1, block ? -1 : 0);
+        if (result < 0) {
+            JNU_ThrowIOExceptionWithLastError(env, "Poll failed");
+            return IOS_THROWN;
+        }
+        if (!block && (result == 0))
+            return IOS_UNAVAILABLE;
+    }
+
+    if (poller.revents) {
+        errno = 0;
+        result = getsockopt(fd, SOL_SOCKET, SO_ERROR, &error, &n);
+        if (result < 0) {
+            handleSocketError(env, errno);
+            return JNI_FALSE;
+        } else if (error) {
+            handleSocketError(env, error);
+            return JNI_FALSE;
+        }
+        return 1;
+    }
+    return 0;
+}
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_SocketChannelImpl_shutdown(JNIEnv *env, jclass cl,
+                                           jobject fdo, jint how)
+{
+    if (shutdown(fdval(env, fdo), how) < 0)
+        handleSocketError(env, errno);
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/SocketDispatcher.c phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/SocketDispatcher.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/linux/native/sun/nio/ch/SocketDispatcher.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/linux/native/sun/nio/ch/SocketDispatcher.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2000-2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "sun_nio_ch_FileDispatcher.h"
+
+/* this is a fake c file to make the build happy since there is no
+   real SocketDispatcher.c file on Solaris but there is on windows. */
+
+static jfieldID fd_fdID;        /* for jint 'fd' in java.io.FileDescriptor */
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/mips/javavm/runtime/invokeNative_mips.S phoneme_advanced-mr2-dev-b122/cdc/src/mips/javavm/runtime/invokeNative_mips.S
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/mips/javavm/runtime/invokeNative_mips.S	2009-07-06 18:37:55.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/mips/javavm/runtime/invokeNative_mips.S	2009-12-31 11:05:51.000000000 -0500
@@ -412,7 +412,7 @@
 #elif (CVM_ENDIANNESS == CVM_LITTLE_ENDIAN)
 	swc1	$f0, 0(a3)
 	swc1	$f1, 4(a3)
-#elif
+#else
 #error "must #define CVM_ENDIANNESS"
 #endif
 	li	v0, 2   /* 2 indicates double-word return */
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/mips/javavm/runtime/invokeNative_mips.S.nofloat phoneme_advanced-mr2-dev-b122/cdc/src/mips/javavm/runtime/invokeNative_mips.S.nofloat
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/mips/javavm/runtime/invokeNative_mips.S.nofloat	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/mips/javavm/runtime/invokeNative_mips.S.nofloat	2009-12-31 11:03:07.000000000 -0500
@@ -0,0 +1,469 @@
+/*
+ * @(#)invokeNative_mips.S	1.12 06/10/10
+ *
+ * Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.  
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+ *   
+ * This program is free software; you can redistribute it and/or  
+ * modify it under the terms of the GNU General Public License version  
+ * 2 only, as published by the Free Software Foundation.   
+ *   
+ * This program is distributed in the hope that it will be useful, but  
+ * WITHOUT ANY WARRANTY; without even the implied warranty of  
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+ * General Public License version 2 for more details (a copy is  
+ * included at /legal/license.txt).   
+ *   
+ * You should have received a copy of the GNU General Public License  
+ * version 2 along with this work; if not, write to the Free Software  
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+ * 02110-1301 USA   
+ *   
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+ * Clara, CA 95054 or visit www.sun.com if you need additional  
+ * information or have any questions. 
+ *
+ */
+
+#include "javavm/include/asmmacros_cpu.h"
+#include "javavm/include/porting/jit/jit.h"
+#include "javavm/include/porting/endianness.h"
+
+#if (defined(CVMCPU_HAS_64BIT_REGISTERS) &&		\
+     !defined(CVMMIPS_HAS_64BIT_FP_REGISTERS)) ||	\
+    (!defined(CVMCPU_HAS_64BIT_REGISTERS) &&		\
+     defined(CVMMIPS_HAS_64BIT_FP_REGISTERS))
+#error "CVMCPU_HAS_64BIT_REGISTERS != CVMMIPS_HAS_64BIT_FP_REGISTERS"
+#endif
+
+	.text
+	.align	4
+/*
+  SUBROUTINE CVMjniInvokeNative
+ 
+  This function translates the "Java" calling convention into the "C"
+  calling convention used in native methods. Java VM passes all the 
+  arguments in the Java stack, and expects the results to be placed there 
+  as well. We therefore have to copy the arguments into the C stack (or 
+  registers), and place the return values back into the Java stack.
+ 
+  With a small sacrifise in efficiency, this approach avoids having to
+  generate a stub function for every native methods.
+ 
+  The first argument to CVMjniInvokeNative is a pointer to the JNI
+  environment, which should be passed unmodified as the first argument
+  to the native method.
+ 
+  The second argument is a pointer to the "real" native method function.
+ 
+  The third argument (stk) is a pointer to the Java stack, where all
+  the arguments are stored (as stk[0], stk[1], etc.).
+ 
+  The fourth argument is the terse signature of the native method.
+ 
+  The fifth argument is the total size (in 32-bit words) of the
+  arguments on the Java stack. Note that the Java stack does not have
+  any alignment requirement, and stores all arguments consecutively in
+  words and double words. The argument size includes the "this" pointer
+  for non-static methods.
+ 
+  The sixth argument is 0 for non-static methods, or a jclass
+  for static methods. Non-static native methods receive an object
+  reference as the second argument (which is simply the address of
+  stk[0]). The "real" method arguments to non-static methods begin at
+  stk[1]. Static native methods receive a class reference as the second
+  argument.
+ 
+  The return value of the native method is placed at stk[0] for
+  word-sized results, or at stk[0] and stk[1] for
+  double-word-sized results. The return value of CVMjniInvokeNative is
+  0 if the native method returns void, 1 if the native
+  method returns a word, 2 if the native method returns a
+  double word, or -1 if the native method returns an object.
+*/
+
+/*
+   Note for mipsEEel (EmotionEngine)
+
+ o Argument passing convention of MIPS O32ABI is shown below.
+   Basically the first 4 words of arguments are placed in registers (a0-a3).
+   The rest are on the stack.
+   The Return value is passed by using register v0 (and v1 if a 64bit value).
+
+
+                  |      |
+                  |      |
+                  |locals|
+         +------+ +------+Low Memory
+      a0 | arg1 | |  --  | <- (sp)
+      a1 | arg2 | |  --  |
+      a2 | arg3 | |  --  |
+      a3 | arg4 | |  --  |
+         +------+ | arg5 |
+                  | arg6 |High Memory
+
+
+ o Since the first argument is scalar (void* env), all the arguments are
+   passed through the scalar registers and the stack (no floating-point
+   register is involved).
+
+ o Double and int64_t (long in Java) arguments require doubleword align.
+
+ o Scalar registers a0-a3, t0-t9, v0 and v1 can be used without
+   being saved. Scalar registers s0-s7 need to be preserved across calls.
+
+ o The floating return value is passed by using register f0
+
+ o Stack alignment must be 4 words (128 bit) (mipsEEel specific).
+
+*/
+
+ENTRY(CVMjniInvokeNative)
+	.globl arg_jumps 
+	.globl ret_jumps
+
+/*
+  Arguments:
+ 
+  a0	   JNI environment
+  a1	   native function
+  a2	   Java stack top
+  a3	   method descriptor
+  stk1	   number of argument words to be passed to native function
+  stk2	   class for static methods, or 0 for non-static methods
+  stk3     result pointer
+ 
+  Results:	
+  v0	return value word count or -1 for object
+*/
+
+#define SIGPTR	a3
+#define SIGBYTE t2
+#define JSTKPTR t0
+#define CSTKPTR t4
+
+#define RETTYPE s0
+#define SIGBUFF t3
+#define SWITCHBASE t1
+
+#define FuncPtr	t9
+
+#define TYPEMASK 0xf
+#define TYPESHIFT 4
+
+/* size of an argment on the stack in bytes */
+#ifdef CVMCPU_HAS_64BIT_REGISTERS
+#define ARGSIZE 8
+#else
+#define ARGSIZE 4
+#endif
+
+/* consts for stack layout */
+#define SAVESIZE (4*4)
+
+	/* sp: 4 word aligned - needed for 64-bit systems */
+	framesize = (SAVESIZE + 15) & ~15 
+
+#define stk1	framesize+4*ARGSIZE(fp)
+#define stk2	framesize+5*ARGSIZE(fp)
+#define stk3	framesize+6*ARGSIZE(fp)
+
+
+	.frame	fp, framesize, ra
+
+	maskra = 1 << 31
+	maskfp = 1 << 30
+	maskgp = 1 << 28
+	masks0 = 1 << 16
+	mask = maskra|maskfp|maskgp|masks0
+
+	frameoffset = -4
+
+	.mask	mask,frameoffset
+
+	/* setup %gp */
+	.set noreorder
+	.cpload $25
+	.set reorder
+
+	subu	sp, sp, framesize  /* grow stack */
+
+	_ra = framesize+frameoffset
+	_fp = framesize+frameoffset-4
+	__gp = framesize+frameoffset-8
+	_s0 = framesize+frameoffset-12
+
+	sw	ra,_ra(sp)
+	sw	fp,_fp(sp)
+	sw	gp,__gp(sp)
+	sw	s0,_s0(sp)
+
+	move	fp, sp
+
+/*
+ * transferring arguments
+ *  -first 4 in register
+ *  -The first argument (a0) is already the JNI env.
+ *  -The next one is a2 or stk2 if it's non-zero (for static methods).
+ */
+
+	move	FuncPtr, a1
+	move	JSTKPTR, a2	/* keep a backup for a2 */
+
+	lw	SIGBUFF, (SIGPTR)  /* preload signature */
+	addiu	SIGPTR, SIGPTR, 4
+	andi	RETTYPE, SIGBUFF, TYPEMASK /* save return type for later use */
+	srl	SIGBUFF, SIGBUFF, TYPESHIFT
+
+	la	SWITCHBASE, arg_jumps /* load the address of the jump table */
+
+	/*
+	 * java ints only take up one word on the java stack but 2 words
+	 * on the C stack on 64-bit systems. Also, on 32-bit systems a 32-bit
+	 * argument can take up 2 words if followed by a 64-bit argument
+	 * because of alignment requirements for 64-bit arguments. Because
+	 * of this we're extra conservative and multiply stk1 by 8
+	 * rather than take the time to count the actual number of words
+	 * we need to allocate on the C stack.
+	 */
+	lw	a1, stk1
+	sll	a1, 3
+
+	addi	a1, 2*ARGSIZE  /* first 2 args */
+	/* sp: 4 word aligned - needed for 64-bit systems */
+	addi	a1, 15
+	srl	a1, 4
+	sll	a1, 4
+	
+	subu	sp, a1          /* grow stack for the function call */
+	addiu	CSTKPTR, sp, 2*ARGSIZE  /* first 2 args */
+
+	/* See if the called method is static (non-0) or non-static (0) */
+	/* NOTE: This can be done better with movn if MIPS4 supported. */
+	lw	a1, stk2
+	bne	a1, zero, $isStatic
+
+	move	a1, JSTKPTR
+	addiu	JSTKPTR, JSTKPTR, 4
+$isStatic:
+
+#define NEXT_ARG \
+	andi	SIGBYTE, SIGBUFF, TYPEMASK; \
+	sll	SIGBYTE, 2;                 \
+	addu	a2, SWITCHBASE, SIGBYTE;    \
+	lw	a2, (a2);                   \
+	srl	SIGBUFF, TYPESHIFT;	    \
+	jr	a2;                         \
+
+$args_loop:
+	NEXT_ARG
+
+$arg_32:		/* move a 32-bit value from [JSTKPTR] to [CSTKPTR]. */
+	lw	a2, (JSTKPTR)
+	addiu	JSTKPTR, JSTKPTR, 4
+#ifdef CVMCPU_HAS_64BIT_REGISTERS
+	sw	a2, (CSTKPTR)
+#else
+	sd	a2, (CSTKPTR)
+#endif
+	addiu	CSTKPTR, CSTKPTR, ARGSIZE
+	NEXT_ARG
+
+#ifdef CVMMIPS_HAS_64BIT_FP_REGISTERS
+$farg_32:		/* move a 32-bit float from [JSTKPTR] to [CSTKPTR]. */
+	lwc1	$f0, (JSTKPTR)
+	addiu	JSTKPTR, JSTKPTR, 4
+	sdc1	$f0, (CSTKPTR)
+	addiu	CSTKPTR, CSTKPTR, ARGSIZE
+	NEXT_ARG
+#endif
+	
+$arg_64:
+#ifndef CVMCPU_HAS_64BIT_REGISTERS
+	/* need 64 bit aligned, but may not already be if not 64-bit system */
+	addi	CSTKPTR, CSTKPTR, 7
+	srl	CSTKPTR, CSTKPTR, 3
+	sll	CSTKPTR, CSTKPTR, 3
+#endif
+
+	lw	a2, (JSTKPTR)
+	lw	t6, 4(JSTKPTR)
+	sw	a2, (CSTKPTR)
+	addiu	JSTKPTR, JSTKPTR, 8
+	sw	t6, 4(CSTKPTR)
+	addiu	CSTKPTR, CSTKPTR, 8
+	NEXT_ARG
+
+$arg_object:
+	lw	a2, (JSTKPTR)
+	beq	a2, zero, $is_null /* null check */
+
+	addi	a2, JSTKPTR, 0
+$is_null:
+	addiu	JSTKPTR, JSTKPTR, 4
+	sw	a2, (CSTKPTR)
+	addiu	CSTKPTR, CSTKPTR, ARGSIZE
+	NEXT_ARG
+
+$arg_reload:
+	/* get another word full of types
+	 * then re-dispatch
+	 * since most signatures are short, this doesn't happen
+	 * very often. */
+	lw	SIGBUFF, (SIGPTR)  /* preload signature */
+	addiu	SIGPTR, SIGPTR, 4
+	NEXT_ARG
+
+$args_done:
+	/*
+	 * Depending on the mips calling conventions in place, various
+	 * arguments are loaded into registers. We load argument registers
+	 * optimistically. If there are no such args, this doesn't hurt
+	 * anything.
+	 */
+
+#ifdef CVMCPU_HAS_64BIT_REGISTERS
+#define LOADI ld
+#define LOADF ldc1
+#else
+#define LOADI lw
+#define LOADF lwc1
+#endif
+
+	LOADI	a2, 2*ARGSIZE(sp)
+	LOADI	a3, 3*ARGSIZE(sp)
+#if (CVMCPU_MAX_ARG_REGS == 8)
+	LOADI	a4, 4*ARGSIZE(sp)
+	LOADI	a5, 5*ARGSIZE(sp)
+	LOADI	a6, 6*ARGSIZE(sp)
+	LOADI	a7, 7*ARGSIZE(sp)
+#endif
+
+#ifdef CVMMIPS_FPR_ARG_AFTER_GPR_ARG
+	LOADF	$f14, 2*ARGSIZE(sp)
+	LOADF	$f15, 3*ARGSIZE(sp)
+#if (CVMCPU_MAX_ARG_REGS == 8)
+	LOADF	$f16, 4*ARGSIZE(sp)
+	LOADF	$f17, 5*ARGSIZE(sp)
+	LOADF	$f18, 6*ARGSIZE(sp)
+	LOADF	$f19, 7*ARGSIZE(sp)
+#endif
+#endif /* CVMMIPS_FPR_ARG_AFTER_GPR_ARG */
+
+	jalr	FuncPtr
+	lw	gp, __gp(fp)  /* restore gp from the stack */
+
+	la	SWITCHBASE, ret_jumps /* load the address of the jump table */
+
+	lw	a3, stk3		/* pointer to result buffer */
+
+	/*
+	 * thread the return address to the
+	 * proper code for our return type
+	 */
+
+	sll	RETTYPE, 2
+	addu	a1, SWITCHBASE, RETTYPE
+	lw	a1, (a1)
+	move	sp, fp
+	jr	a1
+
+#define RETURN			\
+	lw	ra, _ra(sp);	\
+	lw	fp, _fp(sp);	\
+	lw	s0, _s0(sp);	\
+	addiu	sp, framesize;	\
+	jr	ra;		\
+
+$ret_obj:
+	sw	v0, (a3)
+	li	v0, -1	/* -1 indicates object return */
+	RETURN
+	
+$ret_s32:	
+	sw	v0, (a3)
+	li	v0, 1	/* 1 indicates single-word return */
+	RETURN
+
+#ifndef __mips_soft_float
+$ret_f32:
+/*	swc1	$f0, (a3) */
+	sw	v0, (a3)
+	li	v0, 1	/* 1 indicates single-word return */
+	RETURN
+#endif
+
+$ret_s64:
+#ifdef CVMCPU_HAS_64BIT_REGISTERS
+	sd	v0, 0(a3)
+#else
+	sw	v0, 0(a3)
+	sw	v1, 4(a3)
+#endif
+	li	v0, 2	/* 2 indicates double-word return */
+	RETURN
+
+#ifndef __mips_soft_float
+$ret_f64:
+#ifdef CVMMIPS_HAS_64BIT_FP_REGISTERS
+	sdc1	$f0, (a3)
+#elif (CVM_ENDIANNESS == CVM_BIG_ENDIAN)
+	swc1	$f1, 0(a3)
+	swc1	$f0, 4(a3)
+#elif (CVM_ENDIANNESS == CVM_LITTLE_ENDIAN)
+/*	swc1	$f0, 0(a3)
+	swc1	$f1, 4(a3)*/
+	sw	v0, 0(a3)
+	sw	v1, 4(a3)
+#else
+#error "must #define CVM_ENDIANNESS"
+#endif
+	li	v0, 2   /* 2 indicates double-word return */
+	RETURN
+#endif
+
+$ret_void:
+	li	v0, 0	/* 0 indicates void return */
+	RETURN
+
+	SET_SIZE(CVMjniInvokeNative)
+
+	.data
+ret_jumps:		
+	.word	$ret_void	/* error */
+	.word	$ret_void	/* ENDFUNC shouldn't get called */
+	.word	$ret_void	/* void */
+	.word	$ret_s32	/* int */
+	.word	$ret_s32	/* short */
+	.word	$ret_s32	/* char */
+	.word	$ret_s64	/* long */
+	.word	$ret_s32	/* byte */
+#ifndef __mips_soft_float
+	.word	$ret_f32	/* float */
+	.word	$ret_f64	/* double */
+#else
+	.word	$ret_s32	/* float */
+	.word	$ret_s64	/* double */
+#endif
+	.word	$ret_s32	/* bool */
+	.word	$ret_obj
+	.word	$ret_void	/* this is invalid and shouldn't get called */
+
+arg_jumps:
+	.word	$arg_reload	/* no more data this word: go get more */
+	.word	$args_done 	/* end-of-args */
+	.word	$ret_void	/* this is invalid and shouldn't get called */
+	.word	$arg_32		/* int */
+	.word	$arg_32		/* short */
+	.word	$arg_32		/* char */
+	.word	$arg_64		/* long */
+	.word	$arg_32		/* byte */
+#ifdef CVMMIPS_HAS_64BIT_FP_REGISTERS
+	.word	$farg_32	/* float */
+#else
+	.word	$arg_32		/* float */
+#endif
+	.word	$arg_64		/* double */
+	.word	$arg_32		/* bool */
+	.word	$arg_object
+	.word	$ret_void	/* this is invalid and shouldn't get called */
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/mips/javavm/runtime/invokeNative_mips.S.orig phoneme_advanced-mr2-dev-b122/cdc/src/mips/javavm/runtime/invokeNative_mips.S.orig
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/mips/javavm/runtime/invokeNative_mips.S.orig	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/mips/javavm/runtime/invokeNative_mips.S.orig	2009-07-06 18:37:55.000000000 -0400
@@ -0,0 +1,466 @@
+/*
+ * @(#)invokeNative_mips.S	1.12 06/10/10
+ *
+ * Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.  
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+ *   
+ * This program is free software; you can redistribute it and/or  
+ * modify it under the terms of the GNU General Public License version  
+ * 2 only, as published by the Free Software Foundation.   
+ *   
+ * This program is distributed in the hope that it will be useful, but  
+ * WITHOUT ANY WARRANTY; without even the implied warranty of  
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+ * General Public License version 2 for more details (a copy is  
+ * included at /legal/license.txt).   
+ *   
+ * You should have received a copy of the GNU General Public License  
+ * version 2 along with this work; if not, write to the Free Software  
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+ * 02110-1301 USA   
+ *   
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+ * Clara, CA 95054 or visit www.sun.com if you need additional  
+ * information or have any questions. 
+ *
+ */
+
+#include "javavm/include/asmmacros_cpu.h"
+#include "javavm/include/porting/jit/jit.h"
+#include "javavm/include/porting/endianness.h"
+
+#if (defined(CVMCPU_HAS_64BIT_REGISTERS) &&		\
+     !defined(CVMMIPS_HAS_64BIT_FP_REGISTERS)) ||	\
+    (!defined(CVMCPU_HAS_64BIT_REGISTERS) &&		\
+     defined(CVMMIPS_HAS_64BIT_FP_REGISTERS))
+#error "CVMCPU_HAS_64BIT_REGISTERS != CVMMIPS_HAS_64BIT_FP_REGISTERS"
+#endif
+
+	.text
+	.align	4
+/*
+  SUBROUTINE CVMjniInvokeNative
+ 
+  This function translates the "Java" calling convention into the "C"
+  calling convention used in native methods. Java VM passes all the 
+  arguments in the Java stack, and expects the results to be placed there 
+  as well. We therefore have to copy the arguments into the C stack (or 
+  registers), and place the return values back into the Java stack.
+ 
+  With a small sacrifise in efficiency, this approach avoids having to
+  generate a stub function for every native methods.
+ 
+  The first argument to CVMjniInvokeNative is a pointer to the JNI
+  environment, which should be passed unmodified as the first argument
+  to the native method.
+ 
+  The second argument is a pointer to the "real" native method function.
+ 
+  The third argument (stk) is a pointer to the Java stack, where all
+  the arguments are stored (as stk[0], stk[1], etc.).
+ 
+  The fourth argument is the terse signature of the native method.
+ 
+  The fifth argument is the total size (in 32-bit words) of the
+  arguments on the Java stack. Note that the Java stack does not have
+  any alignment requirement, and stores all arguments consecutively in
+  words and double words. The argument size includes the "this" pointer
+  for non-static methods.
+ 
+  The sixth argument is 0 for non-static methods, or a jclass
+  for static methods. Non-static native methods receive an object
+  reference as the second argument (which is simply the address of
+  stk[0]). The "real" method arguments to non-static methods begin at
+  stk[1]. Static native methods receive a class reference as the second
+  argument.
+ 
+  The return value of the native method is placed at stk[0] for
+  word-sized results, or at stk[0] and stk[1] for
+  double-word-sized results. The return value of CVMjniInvokeNative is
+  0 if the native method returns void, 1 if the native
+  method returns a word, 2 if the native method returns a
+  double word, or -1 if the native method returns an object.
+*/
+
+/*
+   Note for mipsEEel (EmotionEngine)
+
+ o Argument passing convention of MIPS O32ABI is shown below.
+   Basically the first 4 words of arguments are placed in registers (a0-a3).
+   The rest are on the stack.
+   The Return value is passed by using register v0 (and v1 if a 64bit value).
+
+
+                  |      |
+                  |      |
+                  |locals|
+         +------+ +------+Low Memory
+      a0 | arg1 | |  --  | <- (sp)
+      a1 | arg2 | |  --  |
+      a2 | arg3 | |  --  |
+      a3 | arg4 | |  --  |
+         +------+ | arg5 |
+                  | arg6 |High Memory
+
+
+ o Since the first argument is scalar (void* env), all the arguments are
+   passed through the scalar registers and the stack (no floating-point
+   register is involved).
+
+ o Double and int64_t (long in Java) arguments require doubleword align.
+
+ o Scalar registers a0-a3, t0-t9, v0 and v1 can be used without
+   being saved. Scalar registers s0-s7 need to be preserved across calls.
+
+ o The floating return value is passed by using register f0
+
+ o Stack alignment must be 4 words (128 bit) (mipsEEel specific).
+
+*/
+
+ENTRY(CVMjniInvokeNative)
+	.globl arg_jumps 
+	.globl ret_jumps
+
+/*
+  Arguments:
+ 
+  a0	   JNI environment
+  a1	   native function
+  a2	   Java stack top
+  a3	   method descriptor
+  stk1	   number of argument words to be passed to native function
+  stk2	   class for static methods, or 0 for non-static methods
+  stk3     result pointer
+ 
+  Results:	
+  v0	return value word count or -1 for object
+*/
+
+#define SIGPTR	a3
+#define SIGBYTE t2
+#define JSTKPTR t0
+#define CSTKPTR t4
+
+#define RETTYPE s0
+#define SIGBUFF t3
+#define SWITCHBASE t1
+
+#define FuncPtr	t9
+
+#define TYPEMASK 0xf
+#define TYPESHIFT 4
+
+/* size of an argment on the stack in bytes */
+#ifdef CVMCPU_HAS_64BIT_REGISTERS
+#define ARGSIZE 8
+#else
+#define ARGSIZE 4
+#endif
+
+/* consts for stack layout */
+#define SAVESIZE (4*4)
+
+	/* sp: 4 word aligned - needed for 64-bit systems */
+	framesize = (SAVESIZE + 15) & ~15 
+
+#define stk1	framesize+4*ARGSIZE(fp)
+#define stk2	framesize+5*ARGSIZE(fp)
+#define stk3	framesize+6*ARGSIZE(fp)
+
+
+	.frame	fp, framesize, ra
+
+	maskra = 1 << 31
+	maskfp = 1 << 30
+	maskgp = 1 << 28
+	masks0 = 1 << 16
+	mask = maskra|maskfp|maskgp|masks0
+
+	frameoffset = -4
+
+	.mask	mask,frameoffset
+
+	/* setup %gp */
+	.set noreorder
+	.cpload $25
+	.set reorder
+
+	subu	sp, sp, framesize  /* grow stack */
+
+	_ra = framesize+frameoffset
+	_fp = framesize+frameoffset-4
+	__gp = framesize+frameoffset-8
+	_s0 = framesize+frameoffset-12
+
+	sw	ra,_ra(sp)
+	sw	fp,_fp(sp)
+	sw	gp,__gp(sp)
+	sw	s0,_s0(sp)
+
+	move	fp, sp
+
+/*
+ * transferring arguments
+ *  -first 4 in register
+ *  -The first argument (a0) is already the JNI env.
+ *  -The next one is a2 or stk2 if it's non-zero (for static methods).
+ */
+
+	move	FuncPtr, a1
+	move	JSTKPTR, a2	/* keep a backup for a2 */
+
+	lw	SIGBUFF, (SIGPTR)  /* preload signature */
+	addiu	SIGPTR, SIGPTR, 4
+	andi	RETTYPE, SIGBUFF, TYPEMASK /* save return type for later use */
+	srl	SIGBUFF, SIGBUFF, TYPESHIFT
+
+	la	SWITCHBASE, arg_jumps /* load the address of the jump table */
+
+	/*
+	 * java ints only take up one word on the java stack but 2 words
+	 * on the C stack on 64-bit systems. Also, on 32-bit systems a 32-bit
+	 * argument can take up 2 words if followed by a 64-bit argument
+	 * because of alignment requirements for 64-bit arguments. Because
+	 * of this we're extra conservative and multiply stk1 by 8
+	 * rather than take the time to count the actual number of words
+	 * we need to allocate on the C stack.
+	 */
+	lw	a1, stk1
+	sll	a1, 3
+
+	addi	a1, 2*ARGSIZE  /* first 2 args */
+	/* sp: 4 word aligned - needed for 64-bit systems */
+	addi	a1, 15
+	srl	a1, 4
+	sll	a1, 4
+	
+	subu	sp, a1          /* grow stack for the function call */
+	addiu	CSTKPTR, sp, 2*ARGSIZE  /* first 2 args */
+
+	/* See if the called method is static (non-0) or non-static (0) */
+	/* NOTE: This can be done better with movn if MIPS4 supported. */
+	lw	a1, stk2
+	bne	a1, zero, $isStatic
+
+	move	a1, JSTKPTR
+	addiu	JSTKPTR, JSTKPTR, 4
+$isStatic:
+
+#define NEXT_ARG \
+	andi	SIGBYTE, SIGBUFF, TYPEMASK; \
+	sll	SIGBYTE, 2;                 \
+	addu	a2, SWITCHBASE, SIGBYTE;    \
+	lw	a2, (a2);                   \
+	srl	SIGBUFF, TYPESHIFT;	    \
+	jr	a2;                         \
+
+$args_loop:
+	NEXT_ARG
+
+$arg_32:		/* move a 32-bit value from [JSTKPTR] to [CSTKPTR]. */
+	lw	a2, (JSTKPTR)
+	addiu	JSTKPTR, JSTKPTR, 4
+#ifdef CVMCPU_HAS_64BIT_REGISTERS
+	sw	a2, (CSTKPTR)
+#else
+	sd	a2, (CSTKPTR)
+#endif
+	addiu	CSTKPTR, CSTKPTR, ARGSIZE
+	NEXT_ARG
+
+#ifdef CVMMIPS_HAS_64BIT_FP_REGISTERS
+$farg_32:		/* move a 32-bit float from [JSTKPTR] to [CSTKPTR]. */
+	lwc1	$f0, (JSTKPTR)
+	addiu	JSTKPTR, JSTKPTR, 4
+	sdc1	$f0, (CSTKPTR)
+	addiu	CSTKPTR, CSTKPTR, ARGSIZE
+	NEXT_ARG
+#endif
+	
+$arg_64:
+#ifndef CVMCPU_HAS_64BIT_REGISTERS
+	/* need 64 bit aligned, but may not already be if not 64-bit system */
+	addi	CSTKPTR, CSTKPTR, 7
+	srl	CSTKPTR, CSTKPTR, 3
+	sll	CSTKPTR, CSTKPTR, 3
+#endif
+
+	lw	a2, (JSTKPTR)
+	lw	t6, 4(JSTKPTR)
+	sw	a2, (CSTKPTR)
+	addiu	JSTKPTR, JSTKPTR, 8
+	sw	t6, 4(CSTKPTR)
+	addiu	CSTKPTR, CSTKPTR, 8
+	NEXT_ARG
+
+$arg_object:
+	lw	a2, (JSTKPTR)
+	beq	a2, zero, $is_null /* null check */
+
+	addi	a2, JSTKPTR, 0
+$is_null:
+	addiu	JSTKPTR, JSTKPTR, 4
+	sw	a2, (CSTKPTR)
+	addiu	CSTKPTR, CSTKPTR, ARGSIZE
+	NEXT_ARG
+
+$arg_reload:
+	/* get another word full of types
+	 * then re-dispatch
+	 * since most signatures are short, this doesn't happen
+	 * very often. */
+	lw	SIGBUFF, (SIGPTR)  /* preload signature */
+	addiu	SIGPTR, SIGPTR, 4
+	NEXT_ARG
+
+$args_done:
+	/*
+	 * Depending on the mips calling conventions in place, various
+	 * arguments are loaded into registers. We load argument registers
+	 * optimistically. If there are no such args, this doesn't hurt
+	 * anything.
+	 */
+
+#ifdef CVMCPU_HAS_64BIT_REGISTERS
+#define LOADI ld
+#define LOADF ldc1
+#else
+#define LOADI lw
+#define LOADF lwc1
+#endif
+
+	LOADI	a2, 2*ARGSIZE(sp)
+	LOADI	a3, 3*ARGSIZE(sp)
+#if (CVMCPU_MAX_ARG_REGS == 8)
+	LOADI	a4, 4*ARGSIZE(sp)
+	LOADI	a5, 5*ARGSIZE(sp)
+	LOADI	a6, 6*ARGSIZE(sp)
+	LOADI	a7, 7*ARGSIZE(sp)
+#endif
+
+#ifdef CVMMIPS_FPR_ARG_AFTER_GPR_ARG
+	LOADF	$f14, 2*ARGSIZE(sp)
+	LOADF	$f15, 3*ARGSIZE(sp)
+#if (CVMCPU_MAX_ARG_REGS == 8)
+	LOADF	$f16, 4*ARGSIZE(sp)
+	LOADF	$f17, 5*ARGSIZE(sp)
+	LOADF	$f18, 6*ARGSIZE(sp)
+	LOADF	$f19, 7*ARGSIZE(sp)
+#endif
+#endif /* CVMMIPS_FPR_ARG_AFTER_GPR_ARG */
+
+	jalr	FuncPtr
+	lw	gp, __gp(fp)  /* restore gp from the stack */
+
+	la	SWITCHBASE, ret_jumps /* load the address of the jump table */
+
+	lw	a3, stk3		/* pointer to result buffer */
+
+	/*
+	 * thread the return address to the
+	 * proper code for our return type
+	 */
+
+	sll	RETTYPE, 2
+	addu	a1, SWITCHBASE, RETTYPE
+	lw	a1, (a1)
+	move	sp, fp
+	jr	a1
+
+#define RETURN			\
+	lw	ra, _ra(sp);	\
+	lw	fp, _fp(sp);	\
+	lw	s0, _s0(sp);	\
+	addiu	sp, framesize;	\
+	jr	ra;		\
+
+$ret_obj:
+	sw	v0, (a3)
+	li	v0, -1	/* -1 indicates object return */
+	RETURN
+	
+$ret_s32:	
+	sw	v0, (a3)
+	li	v0, 1	/* 1 indicates single-word return */
+	RETURN
+
+#ifndef __mips_soft_float
+$ret_f32:
+	swc1	$f0, (a3)
+	li	v0, 1	/* 1 indicates single-word return */
+	RETURN
+#endif
+
+$ret_s64:
+#ifdef CVMCPU_HAS_64BIT_REGISTERS
+	sd	v0, 0(a3)
+#else
+	sw	v0, 0(a3)
+	sw	v1, 4(a3)
+#endif
+	li	v0, 2	/* 2 indicates double-word return */
+	RETURN
+
+#ifndef __mips_soft_float
+$ret_f64:
+#ifdef CVMMIPS_HAS_64BIT_FP_REGISTERS
+	sdc1	$f0, (a3)
+#elif (CVM_ENDIANNESS == CVM_BIG_ENDIAN)
+	swc1	$f1, 0(a3)
+	swc1	$f0, 4(a3)
+#elif (CVM_ENDIANNESS == CVM_LITTLE_ENDIAN)
+	swc1	$f0, 0(a3)
+	swc1	$f1, 4(a3)
+#elif
+#error "must #define CVM_ENDIANNESS"
+#endif
+	li	v0, 2   /* 2 indicates double-word return */
+	RETURN
+#endif
+
+$ret_void:
+	li	v0, 0	/* 0 indicates void return */
+	RETURN
+
+	SET_SIZE(CVMjniInvokeNative)
+
+	.data
+ret_jumps:		
+	.word	$ret_void	/* error */
+	.word	$ret_void	/* ENDFUNC shouldn't get called */
+	.word	$ret_void	/* void */
+	.word	$ret_s32	/* int */
+	.word	$ret_s32	/* short */
+	.word	$ret_s32	/* char */
+	.word	$ret_s64	/* long */
+	.word	$ret_s32	/* byte */
+#ifndef __mips_soft_float
+	.word	$ret_f32	/* float */
+	.word	$ret_f64	/* double */
+#else
+	.word	$ret_s32	/* float */
+	.word	$ret_s64	/* double */
+#endif
+	.word	$ret_s32	/* bool */
+	.word	$ret_obj
+	.word	$ret_void	/* this is invalid and shouldn't get called */
+
+arg_jumps:
+	.word	$arg_reload	/* no more data this word: go get more */
+	.word	$args_done 	/* end-of-args */
+	.word	$ret_void	/* this is invalid and shouldn't get called */
+	.word	$arg_32		/* int */
+	.word	$arg_32		/* short */
+	.word	$arg_32		/* char */
+	.word	$arg_64		/* long */
+	.word	$arg_32		/* byte */
+#ifdef CVMMIPS_HAS_64BIT_FP_REGISTERS
+	.word	$farg_32	/* float */
+#else
+	.word	$arg_32		/* float */
+#endif
+	.word	$arg_64		/* double */
+	.word	$arg_32		/* bool */
+	.word	$arg_object
+	.word	$ret_void	/* this is invalid and shouldn't get called */
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/portlibs/posix/posix_threads_md.c phoneme_advanced-mr2-dev-b122/cdc/src/portlibs/posix/posix_threads_md.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/portlibs/posix/posix_threads_md.c	2009-07-06 18:35:18.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/portlibs/posix/posix_threads_md.c	2011-01-21 15:37:30.000000000 -0500
@@ -33,10 +33,42 @@
 #include <errno.h>
 #include <assert.h>
 
+#ifdef LINUX_THREAD_PRIORITY_HACK
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+#endif
+
 struct args {
     void (*func)(void *);
     void *arg;
+#ifdef LINUX_THREAD_PRIORITY_HACK
+    CVMThreadID *tid;
+#endif
+};
+
+#ifdef LINUX_THREAD_PRIORITY_HACK
+/* From openjdk */
+int java_to_os_priority[11] = {
+  19,              // 0 Entry should never be used
+
+   4,              // 1 MinPriority
+   3,              // 2
+   2,              // 3
+
+   1,              // 4
+   0,              // 5 NormPriority
+  -1,              // 6
+
+  -2,              // 7
+  -3,              // 8
+  -4,              // 9 NearMaxPriority
+
+  -5               // 10 MaxPriority
 };
+#endif
 
 static void *
 start_func(void *a)
@@ -44,6 +76,10 @@
     struct args *args = (struct args *)a;
     void (*func)(void *) = args->func;
     void *arg = args->arg;
+#ifdef LINUX_THREAD_PRIORITY_HACK
+    args->tid->threadid=syscall(SYS_gettid);
+    setpriority(PRIO_PROCESS, args->tid->threadid, java_to_os_priority[args->tid->priority]);
+#endif
     free(a);
     (*func)(arg);
     return 0;
@@ -65,6 +101,12 @@
     }
     args->func = func;
     args->arg = arg;
+#ifdef LINUX_THREAD_PRIORITY_HACK
+    args->tid=tid;
+    if(priority<1) priority=1;
+    if(priority>10) priority=10;
+    tid->priority=priority;
+#endif
     pthread_attr_init(&attr);
     if (stackSize != 0) {
 	errno = pthread_attr_setstacksize(&attr, stackSize);
@@ -72,10 +114,13 @@
 	    perror("pthread_attr_setstacksize");
 	}
     }
+    
+#ifndef LINUX_THREAD_PRIORITY_HACK
     pthread_attr_getschedparam(&attr, &param);
     /* %comment d001 */
     param.sched_priority = priority;
     pthread_attr_setschedparam(&attr, &param);
+#endif
 
     /* Don't leave thread/stack around after exit for join */
     pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
@@ -90,7 +135,7 @@
 	return CVM_FALSE;
     } else {
 	POSIX_COOKIE(tid) = pthreadID;
-	return CVM_TRUE;
+    return CVM_TRUE;
     }
 }
 
@@ -144,18 +189,29 @@
 void
 POSIXthreadSetPriority(CVMThreadID *t, CVMInt32 priority)
 {
+#ifdef LINUX_THREAD_PRIORITY_HACK
+    if(priority<1) priority=1;
+    if(priority>10) priority=10;
+    t->priority=priority;
+    setpriority(PRIO_PROCESS, t->threadid, java_to_os_priority[t->priority]);
+#else
     struct sched_param param;
     int policy;
     pthread_getschedparam(POSIX_COOKIE(t), &policy, &param);
     param.sched_priority = priority;
     pthread_setschedparam(POSIX_COOKIE(t), policy, &param);
+#endif
 }
 
 void
 POSIXthreadGetPriority(CVMThreadID *t, CVMInt32 *priority)
 {
+#ifdef LINUX_THREAD_PRIORITY_HACK
+    *priority = t->priority=priority;
+#else
     struct sched_param param;
     int policy;
     pthread_getschedparam(POSIX_COOKIE(t), &policy, &param);
     *priority = param.sched_priority;
+#endif
 }
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/Closeable.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/Closeable.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/Closeable.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/Closeable.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,32 @@
+/*
+ * @(#)Closeable.java	1.5 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package java.io;
+
+import java.io.IOException;
+
+/**
+ * A <tt>Closeable</tt> is a source or destination of data that can be closed. 
+ * The close method is invoked to release resources that the object is 
+ * holding (such as open files).
+ *
+ * @version 1.5 05/11/17
+ * @since 1.5
+ */
+
+public interface Closeable {
+
+    /**
+     * Closes this stream and releases any system resources associated
+     * with it. If the stream is already closed then invoking this 
+     * method has no effect. 
+     *
+     * @throws IOException if an I/O error occurs
+     */
+    public void close() throws IOException;
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileDescriptor.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileDescriptor.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileDescriptor.java	2009-07-06 18:37:34.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileDescriptor.java	2009-07-06 19:25:13.000000000 -0400
@@ -37,9 +37,9 @@
  * <p>
  * Applications should not create their own file descriptors.
  *
- * @version 1.18, 02/02/00
- * @see	    java.io.FileInputStream
- * @see	    java.io.FileOutputStream
+ * @author  Pavani Diwanji
+ * @see     java.io.FileInputStream
+ * @see     java.io.FileOutputStream
  * @since   JDK1.0
  */
 public final class FileDescriptor {
@@ -47,15 +47,27 @@
     private int fd;
 
     /**
+     * A counter for tracking the FIS/FOS/RAF instances that
+     * use this FileDescriptor. The FIS/FOS.finalize() will not release
+     * the FileDescriptor if it is still under user by a stream.
+     */
+    private Object useLock;
+    private int useCount;
+
+    /**
      * Constructs an (invalid) FileDescriptor
      * object.
      */
     public /**/ FileDescriptor() {
-	fd = -1;
+        fd = -1;
+        useCount = 0;
+        useLock = new Object();
     }
 
     private /* */ FileDescriptor(int fd) {
-	this.fd = fd;
+        this.fd = fd;
+        useCount = 0;
+        useLock = new Object();
     }
 
     /**
@@ -92,7 +104,7 @@
      *          <code>false</code> otherwise.
      */
     public boolean valid() {
-	return fd != -1;
+        return fd != -1;
     }
 
     /**
@@ -102,7 +114,7 @@
      * relevant device(s).  In particular, if this FileDescriptor
      * refers to a physical storage medium, such as a file in a file
      * system, sync will not return until all in-memory modified copies
-     * of buffers associated with this FileDesecriptor have been
+     * of buffers associated with this FileDescriptor have been
      * written to the physical medium.
      *
      * sync is meant to be used by code that requires physical
@@ -118,9 +130,9 @@
      * OutputStream.flush) before that data will be affected by sync.
      *
      * @exception SyncFailedException
-     *	      Thrown when the buffers cannot be flushed,
-     *	      or because the system cannot guarantee that all the
-     *	      buffers have been synchronized with physical media.
+     *        Thrown when the buffers cannot be flushed,
+     *        or because the system cannot guarantee that all the
+     *        buffers have been synchronized with physical media.
      * @since     JDK1.1
      */
     public native void sync() throws SyncFailedException;
@@ -129,6 +141,47 @@
     private static native void initIDs();
 
     static {
-	initIDs();
+        initIDs();
+    }
+
+    // Set up JavaIOFileDescriptorAccess in SharedSecrets
+/* NARFLEX   static {
+        sun.misc.SharedSecrets.setJavaIOFileDescriptorAccess(
+            new sun.misc.JavaIOFileDescriptorAccess() {
+                public void set(FileDescriptor obj, int fd) {
+                    obj.fd = fd;
+                }
+
+                public int get(FileDescriptor obj) {
+                    return obj.fd;
+                }
+
+                public void setHandle(FileDescriptor obj, long handle) {
+                    throw new UnsupportedOperationException();
+                }
+
+                public long getHandle(FileDescriptor obj) {
+                    throw new UnsupportedOperationException();
+                }
+            }
+        );
+    } */
+
+    // package private methods used by FIS, FOS and RAF
+
+    int incrementAndGetUseCount() {
+        synchronized(useLock)
+        {
+            useCount++;
+            return useCount;
+        }
+    }
+
+    int decrementAndGetUseCount() {
+        synchronized(useLock)
+        {
+            useCount--;
+            return useCount;
+        }
     }
 }
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileDescriptor.java.orig phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileDescriptor.java.orig
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileDescriptor.java.orig	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileDescriptor.java.orig	2009-07-06 18:37:34.000000000 -0400
@@ -0,0 +1,134 @@
+/*
+ * @(#)FileDescriptor.java	1.26 06/10/10
+ *
+ * Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.  
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+ *   
+ * This program is free software; you can redistribute it and/or  
+ * modify it under the terms of the GNU General Public License version  
+ * 2 only, as published by the Free Software Foundation.   
+ *   
+ * This program is distributed in the hope that it will be useful, but  
+ * WITHOUT ANY WARRANTY; without even the implied warranty of  
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+ * General Public License version 2 for more details (a copy is  
+ * included at /legal/license.txt).   
+ *   
+ * You should have received a copy of the GNU General Public License  
+ * version 2 along with this work; if not, write to the Free Software  
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+ * 02110-1301 USA   
+ *   
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+ * Clara, CA 95054 or visit www.sun.com if you need additional  
+ * information or have any questions. 
+ *
+ */
+
+package java.io;
+
+/**
+ * Instances of the file descriptor class serve as an opaque handle
+ * to the underlying machine-specific structure representing an open
+ * file, an open socket, or another source or sink of bytes. The
+ * main practical use for a file descriptor is to create a
+ * <code>FileInputStream</code> or <code>FileOutputStream</code> to
+ * contain it.
+ * <p>
+ * Applications should not create their own file descriptors.
+ *
+ * @version 1.18, 02/02/00
+ * @see	    java.io.FileInputStream
+ * @see	    java.io.FileOutputStream
+ * @since   JDK1.0
+ */
+public final class FileDescriptor {
+
+    private int fd;
+
+    /**
+     * Constructs an (invalid) FileDescriptor
+     * object.
+     */
+    public /**/ FileDescriptor() {
+	fd = -1;
+    }
+
+    private /* */ FileDescriptor(int fd) {
+	this.fd = fd;
+    }
+
+    /**
+     * A handle to the standard input stream. Usually, this file
+     * descriptor is not used directly, but rather via the input stream
+     * known as <code>System.in</code>.
+     *
+     * @see     java.lang.System#in
+     */
+    public static final FileDescriptor in = new FileDescriptor(0);
+
+    /**
+     * A handle to the standard output stream. Usually, this file
+     * descriptor is not used directly, but rather via the output stream
+     * known as <code>System.out</code>.
+     * @see     java.lang.System#out
+     */
+    public static final FileDescriptor out = new FileDescriptor(1);
+
+    /**
+     * A handle to the standard error stream. Usually, this file
+     * descriptor is not used directly, but rather via the output stream
+     * known as <code>System.err</code>.
+     *
+     * @see     java.lang.System#err
+     */
+    public static final FileDescriptor err = new FileDescriptor(2);
+
+    /**
+     * Tests if this file descriptor object is valid.
+     *
+     * @return  <code>true</code> if the file descriptor object represents a
+     *          valid, open file, socket, or other active I/O connection;
+     *          <code>false</code> otherwise.
+     */
+    public boolean valid() {
+	return fd != -1;
+    }
+
+    /**
+     * Force all system buffers to synchronize with the underlying
+     * device.  This method returns after all modified data and
+     * attributes of this FileDescriptor have been written to the
+     * relevant device(s).  In particular, if this FileDescriptor
+     * refers to a physical storage medium, such as a file in a file
+     * system, sync will not return until all in-memory modified copies
+     * of buffers associated with this FileDesecriptor have been
+     * written to the physical medium.
+     *
+     * sync is meant to be used by code that requires physical
+     * storage (such as a file) to be in a known state  For
+     * example, a class that provided a simple transaction facility
+     * might use sync to ensure that all changes to a file caused
+     * by a given transaction were recorded on a storage medium.
+     *
+     * sync only affects buffers downstream of this FileDescriptor.  If
+     * any in-memory buffering is being done by the application (for
+     * example, by a BufferedOutputStream object), those buffers must
+     * be flushed into the FileDescriptor (for example, by invoking
+     * OutputStream.flush) before that data will be affected by sync.
+     *
+     * @exception SyncFailedException
+     *	      Thrown when the buffers cannot be flushed,
+     *	      or because the system cannot guarantee that all the
+     *	      buffers have been synchronized with physical media.
+     * @since     JDK1.1
+     */
+    public native void sync() throws SyncFailedException;
+
+    /* This routine initializes JNI field offsets for the class */
+    private static native void initIDs();
+
+    static {
+	initIDs();
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileDescriptor.java.rej phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileDescriptor.java.rej
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileDescriptor.java.rej	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileDescriptor.java.rej	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,57 @@
+***************
+*** 1,28 ****
+  /*
+-  * @(#)FileDescriptor.java	1.26 06/10/10
+   *
+-  * Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.  
+-  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+-  *   
+-  * This program is free software; you can redistribute it and/or  
+-  * modify it under the terms of the GNU General Public License version  
+-  * 2 only, as published by the Free Software Foundation.   
+-  *   
+-  * This program is distributed in the hope that it will be useful, but  
+-  * WITHOUT ANY WARRANTY; without even the implied warranty of  
+-  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+-  * General Public License version 2 for more details (a copy is  
+-  * included at /legal/license.txt).   
+-  *   
+-  * You should have received a copy of the GNU General Public License  
+-  * version 2 along with this work; if not, write to the Free Software  
+-  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+-  * 02110-1301 USA   
+-  *   
+-  * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+-  * Clara, CA 95054 or visit www.sun.com if you need additional  
+-  * information or have any questions. 
+   *
+   */
+  
+  package java.io;
+--- 1,26 ----
+  /*
++  * Copyright 1995-2008 Sun Microsystems, Inc.  All Rights Reserved.
++  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+   *
++  * This code is free software; you can redistribute it and/or modify it
++  * under the terms of the GNU General Public License version 2 only, as
++  * published by the Free Software Foundation.  Sun designates this
++  * particular file as subject to the "Classpath" exception as provided
++  * by Sun in the LICENSE file that accompanied this code.
+   *
++  * This code is distributed in the hope that it will be useful, but WITHOUT
++  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++  * version 2 for more details (a copy is included in the LICENSE file that
++  * accompanied this code).
++  *
++  * You should have received a copy of the GNU General Public License version
++  * 2 along with this work; if not, write to the Free Software Foundation,
++  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
++  *
++  * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
++  * CA 95054 USA or visit www.sun.com if you need additional information or
++  * have any questions.
+   */
+  
+  package java.io;
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileInputStream.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileInputStream.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileInputStream.java	2009-07-06 18:37:34.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileInputStream.java	2009-07-06 19:33:05.000000000 -0400
@@ -1,313 +1,407 @@
-/*
- * @(#)FileInputStream.java	1.60 06/10/10
- *
- * Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.  
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
- *   
- * This program is free software; you can redistribute it and/or  
- * modify it under the terms of the GNU General Public License version  
- * 2 only, as published by the Free Software Foundation.   
- *   
- * This program is distributed in the hope that it will be useful, but  
- * WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
- * General Public License version 2 for more details (a copy is  
- * included at /legal/license.txt).   
- *   
- * You should have received a copy of the GNU General Public License  
- * version 2 along with this work; if not, write to the Free Software  
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
- * 02110-1301 USA   
- *   
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
- * Clara, CA 95054 or visit www.sun.com if you need additional  
- * information or have any questions. 
- *
- */
-
-package java.io;
-
-
-/**
- * A <code>FileInputStream</code> obtains input bytes
- * from a file in a file system. What files
- * are  available depends on the host environment.
- *
- * <p><code>FileInputStream</code> is meant for reading streams of raw bytes
- * such as image data. For reading streams of characters, consider using
- * <code>FileReader</code>.
- *
- * @version 1.45, 02/02/00
- * @see     java.io.File
- * @see     java.io.FileDescriptor
- * @see	    java.io.FileOutputStream
- * @since   JDK1.0
- */
-public
-class FileInputStream extends InputStream
-{
-    /* File Descriptor - handle to the open file */
-    private FileDescriptor fd;
-
-
-    /**
-     * Creates a <code>FileInputStream</code> by
-     * opening a connection to an actual file,
-     * the file named by the path name <code>name</code>
-     * in the file system.  A new <code>FileDescriptor</code>
-     * object is created to represent this file
-     * connection.
-     * <p>
-     * First, if there is a security
-     * manager, its <code>checkRead</code> method
-     * is called with the <code>name</code> argument
-     * as its argument.
-     * <p>
-     * If the named file does not exist, is a directory rather than a regular
-     * file, or for some other reason cannot be opened for reading then a
-     * <code>FileNotFoundException</code> is thrown.
-     *
-     * @param      name   the system-dependent file name.
-     * @exception  FileNotFoundException  if the file does not exist,
-     *                   is a directory rather than a regular file,
-     *                   or for some other reason cannot be opened for
-     *                   reading.
-     * @exception  SecurityException      if a security manager exists and its
-     *               <code>checkRead</code> method denies read access
-     *               to the file.
-     * @see        java.lang.SecurityManager#checkRead(java.lang.String)
-     */
-    public FileInputStream(String name) throws FileNotFoundException {
-        this(name != null ? new File(name) : null);
-    }
-
-    /**
-     * Creates a <code>FileInputStream</code> by
-     * opening a connection to an actual file,
-     * the file named by the <code>File</code>
-     * object <code>file</code> in the file system.
-     * A new <code>FileDescriptor</code> object
-     * is created to represent this file connection.
-     * <p>
-     * First, if there is a security manager,
-     * its <code>checkRead</code> method  is called
-     * with the path represented by the <code>file</code>
-     * argument as its argument.
-     * <p>
-     * If the named file does not exist, is a directory rather than a regular
-     * file, or for some other reason cannot be opened for reading then a
-     * <code>FileNotFoundException</code> is thrown.
-     *
-     * @param      file   the file to be opened for reading.
-     * @exception  FileNotFoundException  if the file does not exist,
-     *                   is a directory rather than a regular file,
-     *                   or for some other reason cannot be opened for
-     *                   reading.
-     * @exception  SecurityException      if a security manager exists and its
-     *               <code>checkRead</code> method denies read access to the file.
-     * @see        java.io.File#getPath()
-     * @see        java.lang.SecurityManager#checkRead(java.lang.String)
-     */
-    public FileInputStream(File file) throws FileNotFoundException {
-	String name = (file != null ? file.getPath() : null);
-	SecurityManager security = System.getSecurityManager();
-	if (security != null) {
-	    security.checkRead(name);
-	}
-        if (name == null) {
-            throw new NullPointerException();
-        }
-	fd = new FileDescriptor();
-	open(name);
-    }
-
-    /**
-     * Creates a <code>FileInputStream</code> by using the file descriptor
-     * <code>fdObj</code>, which represents an existing connection to an
-     * actual file in the file system.
-     * <p>
-     * If there is a security manager, its <code>checkRead</code> method is
-     * called with the file descriptor <code>fdObj</code> as its argument to
-     * see if it's ok to read the file descriptor. If read access is denied
-     * to the file descriptor a <code>SecurityException</code> is thrown.
-     * <p>
-     * If <code>fdObj</code> is null then a <code>NullPointerException</code>
-     * is thrown.
-     *
-     * @param      fdObj   the file descriptor to be opened for reading.
-     * @throws     SecurityException      if a security manager exists and its
-     *                 <code>checkRead</code> method denies read access to the
-     *                 file descriptor.
-     * @see        SecurityManager#checkRead(java.io.FileDescriptor)
-     */
-    public FileInputStream(FileDescriptor fdObj) {
-	SecurityManager security = System.getSecurityManager();
-	if (fdObj == null) {
-	    throw new NullPointerException();
-	}
-	if (security != null) {
-	    security.checkRead(fdObj);
-	}
-	fd = fdObj;
-    }
-
-    /**
-     * Opens the specified file for reading.
-     * @param name the name of the file
-     */
-    private native void open(String name) throws FileNotFoundException;
-
-    /**
-     * Reads a byte of data from this input stream. This method blocks
-     * if no input is yet available.
-     *
-     * @return     the next byte of data, or <code>-1</code> if the end of the
-     *             file is reached.
-     * @exception  IOException  if an I/O error occurs.
-     */
-    public native int read() throws IOException;
-
-
-    /**
-     * Reads a subarray as a sequence of bytes.
-     * @param b the data to be written
-     * @param off the start offset in the data
-     * @param len the number of bytes that are written
-     * @exception IOException If an I/O error has occurred.
-     */
-    private native int readBytes(byte b[], int off, int len) throws IOException;
-
-    /**
-     * Reads up to <code>b.length</code> bytes of data from this input
-     * stream into an array of bytes. This method blocks until some input
-     * is available.
-     *
-     * @param      b   the buffer into which the data is read.
-     * @return     the total number of bytes read into the buffer, or
-     *             <code>-1</code> if there is no more data because the end of
-     *             the file has been reached.
-     * @exception  IOException  if an I/O error occurs.
-     */
-    public int read(byte b[]) throws IOException {
-	return readBytes(b, 0, b.length);
-    }
-
-    /**
-     * Reads up to <code>len</code> bytes of data from this input stream
-     * into an array of bytes. This method blocks until some input is
-     * available.
-     *
-     * @param      b     the buffer into which the data is read.
-     * @param      off   the start offset of the data.
-     * @param      len   the maximum number of bytes read.
-     * @return     the total number of bytes read into the buffer, or
-     *             <code>-1</code> if there is no more data because the end of
-     *             the file has been reached.
-     * @exception  IOException  if an I/O error occurs.
-     */
-    public int read(byte b[], int off, int len) throws IOException {
-	return readBytes(b, off, len);
-    }
-
-    /**
-     * Skips over and discards <code>n</code> bytes of data from the
-     * input stream. The <code>skip</code> method may, for a variety of
-     * reasons, end up skipping over some smaller number of bytes,
-     * possibly <code>0</code>. The actual number of bytes skipped is returned.
-     *
-     * @param      n   the number of bytes to be skipped.
-     * @return     the actual number of bytes skipped.
-     * @exception  IOException  if an I/O error occurs.
-     */
-    public native long skip(long n) throws IOException;
-
-    /**
-     * Returns the number of bytes that can be read from this file input
-     * stream without blocking.
-     *
-     * @return     the number of bytes that can be read from this file input
-     *             stream without blocking.
-     * @exception  IOException  if an I/O error occurs.
-     */
-    public native int available() throws IOException;
-
-    /**
-     * Closes this file input stream and releases any system resources
-     * associated with the stream.
-     *
-     * <p> If this stream has an associated channel then the channel is closed
-     * as well.
-     *
-     * @exception  IOException  if an I/O error occurs.
-     *
-     * @revised 1.4
-     * @spec JSR-51
-     */
-    public void close() throws IOException {
-        close0();
-    }
-
-    /**
-     * Returns the <code>FileDescriptor</code>
-     * object  that represents the connection to
-     * the actual file in the file system being
-     * used by this <code>FileInputStream</code>.
-     *
-     * @return     the file descriptor object associated with this stream.
-     * @exception  IOException  if an I/O error occurs.
-     * @see        java.io.FileDescriptor
-     */
-    public final FileDescriptor getFD() throws IOException {
-	if (fd != null) return fd;
-	throw new IOException();
-    }
-
-    /**
-     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
-     * object associated with this file input stream.
-     *
-     * <p> The initial {@link java.nio.channels.FileChannel#position()
-     * </code>position<code>} of the returned channel will be equal to the
-     * number of bytes read from the file so far.  Reading bytes from this
-     * stream will increment the channel's position.  Changing the channel's
-     * position, either explicitly or by reading, will change this stream's
-     * file position.
-     *
-     * @return  the file channel associated with this file input stream
-     *
-     * @since 1.4
-     * @spec JSR-51
-     */
-    /* Comment out due to no NIO in CDC
-    public FileChannel getChannel() {        
-	synchronized (this) {
-	    if (channel == null)
-		channel = FileChannelImpl.open(fd, true, false, this);
-	    return channel;
-	}
-    }
-    */
-
-    private static native void initIDs();
-
-    private native void close0() throws IOException;
-
-    static {
-	initIDs();
-    }
-
-    /**
-     * Ensures that the <code>close</code> method of this file input stream is
-     * called when there are no more references to it.
-     *
-     * @exception  IOException  if an I/O error occurs.
-     * @see        java.io.FileInputStream#close()
-     */
-    protected void finalize() throws IOException {
-	if (fd != null) {
-	    if (fd != fd.in) {
-		close();
-	    }
-	}
-    }
-}
+/*
+ * Copyright 1994-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.io;
+
+import java.nio.channels.FileChannel;
+import sun.nio.ch.FileChannelImpl;
+
+
+/**
+ * A <code>FileInputStream</code> obtains input bytes
+ * from a file in a file system. What files
+ * are  available depends on the host environment.
+ *
+ * <p><code>FileInputStream</code> is meant for reading streams of raw bytes
+ * such as image data. For reading streams of characters, consider using
+ * <code>FileReader</code>.
+ *
+ * @author  Arthur van Hoff
+ * @see     java.io.File
+ * @see     java.io.FileDescriptor
+ * @see     java.io.FileOutputStream
+ * @since   JDK1.0
+ */
+public
+class FileInputStream extends InputStream
+{
+    /* File Descriptor - handle to the open file */
+    private final FileDescriptor fd;
+
+    private FileChannel channel = null;
+
+    private final Object closeLock = new Object();
+    private volatile boolean closed = false;
+
+    private static final ThreadLocal runningFinalize =
+        new ThreadLocal();
+
+    private static boolean isRunningFinalize() {
+        Boolean val;
+        if ((val = (Boolean)runningFinalize.get()) != null)
+            return val.booleanValue();
+        return false;
+    }
+
+    /**
+     * Creates a <code>FileInputStream</code> by
+     * opening a connection to an actual file,
+     * the file named by the path name <code>name</code>
+     * in the file system.  A new <code>FileDescriptor</code>
+     * object is created to represent this file
+     * connection.
+     * <p>
+     * First, if there is a security
+     * manager, its <code>checkRead</code> method
+     * is called with the <code>name</code> argument
+     * as its argument.
+     * <p>
+     * If the named file does not exist, is a directory rather than a regular
+     * file, or for some other reason cannot be opened for reading then a
+     * <code>FileNotFoundException</code> is thrown.
+     *
+     * @param      name   the system-dependent file name.
+     * @exception  FileNotFoundException  if the file does not exist,
+     *                   is a directory rather than a regular file,
+     *                   or for some other reason cannot be opened for
+     *                   reading.
+     * @exception  SecurityException      if a security manager exists and its
+     *               <code>checkRead</code> method denies read access
+     *               to the file.
+     * @see        java.lang.SecurityManager#checkRead(java.lang.String)
+     */
+    public FileInputStream(String name) throws FileNotFoundException {
+        this(name != null ? new File(name) : null);
+    }
+
+    /**
+     * Creates a <code>FileInputStream</code> by
+     * opening a connection to an actual file,
+     * the file named by the <code>File</code>
+     * object <code>file</code> in the file system.
+     * A new <code>FileDescriptor</code> object
+     * is created to represent this file connection.
+     * <p>
+     * First, if there is a security manager,
+     * its <code>checkRead</code> method  is called
+     * with the path represented by the <code>file</code>
+     * argument as its argument.
+     * <p>
+     * If the named file does not exist, is a directory rather than a regular
+     * file, or for some other reason cannot be opened for reading then a
+     * <code>FileNotFoundException</code> is thrown.
+     *
+     * @param      file   the file to be opened for reading.
+     * @exception  FileNotFoundException  if the file does not exist,
+     *                   is a directory rather than a regular file,
+     *                   or for some other reason cannot be opened for
+     *                   reading.
+     * @exception  SecurityException      if a security manager exists and its
+     *               <code>checkRead</code> method denies read access to the file.
+     * @see        java.io.File#getPath()
+     * @see        java.lang.SecurityManager#checkRead(java.lang.String)
+     */
+    public FileInputStream(File file) throws FileNotFoundException {
+        String name = (file != null ? file.getPath() : null);
+        SecurityManager security = System.getSecurityManager();
+        if (security != null) {
+            security.checkRead(name);
+        }
+        if (name == null) {
+            throw new NullPointerException();
+        }
+        fd = new FileDescriptor();
+        fd.incrementAndGetUseCount();
+        open(name);
+    }
+
+    /**
+     * Creates a <code>FileInputStream</code> by using the file descriptor
+     * <code>fdObj</code>, which represents an existing connection to an
+     * actual file in the file system.
+     * <p>
+     * If there is a security manager, its <code>checkRead</code> method is
+     * called with the file descriptor <code>fdObj</code> as its argument to
+     * see if it's ok to read the file descriptor. If read access is denied
+     * to the file descriptor a <code>SecurityException</code> is thrown.
+     * <p>
+     * If <code>fdObj</code> is null then a <code>NullPointerException</code>
+     * is thrown.
+     * <p>
+     * This constructor does not throw an exception if <code>fdObj</code>
+     * is {@link java.io.FileDescriptor#valid() invalid}.
+     * However, if the methods are invoked on the resulting stream to attempt
+     * I/O on the stream, an <code>IOException</code> is thrown.
+     *
+     * @param      fdObj   the file descriptor to be opened for reading.
+     * @throws     SecurityException      if a security manager exists and its
+     *                 <code>checkRead</code> method denies read access to the
+     *                 file descriptor.
+     * @see        SecurityManager#checkRead(java.io.FileDescriptor)
+     */
+    public FileInputStream(FileDescriptor fdObj) {
+        SecurityManager security = System.getSecurityManager();
+        if (fdObj == null) {
+            throw new NullPointerException();
+        }
+        if (security != null) {
+            security.checkRead(fdObj);
+        }
+        fd = fdObj;
+
+        /*
+         * FileDescriptor is being shared by streams.
+         * Ensure that it's GC'ed only when all the streams/channels are done
+         * using it.
+         */
+        fd.incrementAndGetUseCount();
+    }
+
+    /**
+     * Opens the specified file for reading.
+     * @param name the name of the file
+     */
+    private native void open(String name) throws FileNotFoundException;
+
+    /**
+     * Reads a byte of data from this input stream. This method blocks
+     * if no input is yet available.
+     *
+     * @return     the next byte of data, or <code>-1</code> if the end of the
+     *             file is reached.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public native int read() throws IOException;
+
+    /**
+     * Reads a subarray as a sequence of bytes.
+     * @param b the data to be written
+     * @param off the start offset in the data
+     * @param len the number of bytes that are written
+     * @exception IOException If an I/O error has occurred.
+     */
+    private native int readBytes(byte b[], int off, int len) throws IOException;
+
+    /**
+     * Reads up to <code>b.length</code> bytes of data from this input
+     * stream into an array of bytes. This method blocks until some input
+     * is available.
+     *
+     * @param      b   the buffer into which the data is read.
+     * @return     the total number of bytes read into the buffer, or
+     *             <code>-1</code> if there is no more data because the end of
+     *             the file has been reached.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public int read(byte b[]) throws IOException {
+        return readBytes(b, 0, b.length);
+    }
+
+    /**
+     * Reads up to <code>len</code> bytes of data from this input stream
+     * into an array of bytes. If <code>len</code> is not zero, the method
+     * blocks until some input is available; otherwise, no
+     * bytes are read and <code>0</code> is returned.
+     *
+     * @param      b     the buffer into which the data is read.
+     * @param      off   the start offset in the destination array <code>b</code>
+     * @param      len   the maximum number of bytes read.
+     * @return     the total number of bytes read into the buffer, or
+     *             <code>-1</code> if there is no more data because the end of
+     *             the file has been reached.
+     * @exception  NullPointerException If <code>b</code> is <code>null</code>.
+     * @exception  IndexOutOfBoundsException If <code>off</code> is negative,
+     * <code>len</code> is negative, or <code>len</code> is greater than
+     * <code>b.length - off</code>
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public int read(byte b[], int off, int len) throws IOException {
+        return readBytes(b, off, len);
+    }
+
+    /**
+     * Skips over and discards <code>n</code> bytes of data from the
+     * input stream.
+     *
+     * <p>The <code>skip</code> method may, for a variety of
+     * reasons, end up skipping over some smaller number of bytes,
+     * possibly <code>0</code>. If <code>n</code> is negative, an
+     * <code>IOException</code> is thrown, even though the <code>skip</code>
+     * method of the {@link InputStream} superclass does nothing in this case.
+     * The actual number of bytes skipped is returned.
+     *
+     * <p>This method may skip more bytes than are remaining in the backing
+     * file. This produces no exception and the number of bytes skipped
+     * may include some number of bytes that were beyond the EOF of the
+     * backing file. Attempting to read from the stream after skipping past
+     * the end will result in -1 indicating the end of the file.
+     *
+     * @param      n   the number of bytes to be skipped.
+     * @return     the actual number of bytes skipped.
+     * @exception  IOException  if n is negative, if the stream does not
+     *             support seek, or if an I/O error occurs.
+     */
+    public native long skip(long n) throws IOException;
+
+    /**
+     * Returns an estimate of the number of remaining bytes that can be read (or
+     * skipped over) from this input stream without blocking by the next
+     * invocation of a method for this input stream. The next invocation might be
+     * the same thread or another thread.  A single read or skip of this
+     * many bytes will not block, but may read or skip fewer bytes.
+     *
+     * <p> In some cases, a non-blocking read (or skip) may appear to be
+     * blocked when it is merely slow, for example when reading large
+     * files over slow networks.
+     *
+     * @return     an estimate of the number of remaining bytes that can be read
+     *             (or skipped over) from this input stream without blocking.
+     * @exception  IOException  if this file input stream has been closed by calling
+     *             {@code close} or an I/O error occurs.
+     */
+    public native int available() throws IOException;
+
+    /**
+     * Closes this file input stream and releases any system resources
+     * associated with the stream.
+     *
+     * <p> If this stream has an associated channel then the channel is closed
+     * as well.
+     *
+     * @exception  IOException  if an I/O error occurs.
+     *
+     * @revised 1.4
+     * @spec JSR-51
+     */
+    public void close() throws IOException {
+        synchronized (closeLock) {
+            if (closed) {
+                return;
+            }
+            closed = true;
+        }
+        if (channel != null) {
+            /*
+             * Decrement the FD use count associated with the channel
+             * The use count is incremented whenever a new channel
+             * is obtained from this stream.
+             */
+           fd.decrementAndGetUseCount();
+           channel.close();
+        }
+
+        /*
+         * Decrement the FD use count associated with this stream
+         */
+        int useCount = fd.decrementAndGetUseCount();
+
+        /*
+         * If FileDescriptor is still in use by another stream, the finalizer
+         * will not close it.
+         */
+        if ((useCount <= 0) || !isRunningFinalize()) {
+            close0();
+        }
+    }
+
+    /**
+     * Returns the <code>FileDescriptor</code>
+     * object  that represents the connection to
+     * the actual file in the file system being
+     * used by this <code>FileInputStream</code>.
+     *
+     * @return     the file descriptor object associated with this stream.
+     * @exception  IOException  if an I/O error occurs.
+     * @see        java.io.FileDescriptor
+     */
+    public final FileDescriptor getFD() throws IOException {
+        if (fd != null) return fd;
+        throw new IOException();
+    }
+
+    /**
+     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
+     * object associated with this file input stream.
+     *
+     * <p> The initial {@link java.nio.channels.FileChannel#position()
+     * </code>position<code>} of the returned channel will be equal to the
+     * number of bytes read from the file so far.  Reading bytes from this
+     * stream will increment the channel's position.  Changing the channel's
+     * position, either explicitly or by reading, will change this stream's
+     * file position.
+     *
+     * @return  the file channel associated with this file input stream
+     *
+     * @since 1.4
+     * @spec JSR-51
+     */
+    public FileChannel getChannel() {
+        synchronized (this) {
+            if (channel == null) {
+                channel = FileChannelImpl.open(fd, true, false, this);
+
+                /*
+                 * Increment fd's use count. Invoking the channel's close()
+                 * method will result in decrementing the use count set for
+                 * the channel.
+                 */
+                fd.incrementAndGetUseCount();
+            }
+            return channel;
+        }
+    }
+
+    private static native void initIDs();
+
+    private native void close0() throws IOException;
+
+    static {
+        initIDs();
+    }
+
+    /**
+     * Ensures that the <code>close</code> method of this file input stream is
+     * called when there are no more references to it.
+     *
+     * @exception  IOException  if an I/O error occurs.
+     * @see        java.io.FileInputStream#close()
+     */
+    protected void finalize() throws IOException {
+        if ((fd != null) &&  (fd != FileDescriptor.in)) {
+
+            /*
+             * Finalizer should not release the FileDescriptor if another
+             * stream is still using it. If the user directly invokes
+             * close() then the FileDescriptor is also released.
+             */
+            runningFinalize.set(Boolean.TRUE);
+            try {
+                close();
+            } finally {
+                runningFinalize.set(Boolean.FALSE);
+            }
+        }
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileInputStream.java.orig phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileInputStream.java.orig
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileInputStream.java.orig	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileInputStream.java.orig	2009-07-06 18:37:34.000000000 -0400
@@ -0,0 +1,313 @@
+/*
+ * @(#)FileInputStream.java	1.60 06/10/10
+ *
+ * Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.  
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+ *   
+ * This program is free software; you can redistribute it and/or  
+ * modify it under the terms of the GNU General Public License version  
+ * 2 only, as published by the Free Software Foundation.   
+ *   
+ * This program is distributed in the hope that it will be useful, but  
+ * WITHOUT ANY WARRANTY; without even the implied warranty of  
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+ * General Public License version 2 for more details (a copy is  
+ * included at /legal/license.txt).   
+ *   
+ * You should have received a copy of the GNU General Public License  
+ * version 2 along with this work; if not, write to the Free Software  
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+ * 02110-1301 USA   
+ *   
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+ * Clara, CA 95054 or visit www.sun.com if you need additional  
+ * information or have any questions. 
+ *
+ */
+
+package java.io;
+
+
+/**
+ * A <code>FileInputStream</code> obtains input bytes
+ * from a file in a file system. What files
+ * are  available depends on the host environment.
+ *
+ * <p><code>FileInputStream</code> is meant for reading streams of raw bytes
+ * such as image data. For reading streams of characters, consider using
+ * <code>FileReader</code>.
+ *
+ * @version 1.45, 02/02/00
+ * @see     java.io.File
+ * @see     java.io.FileDescriptor
+ * @see	    java.io.FileOutputStream
+ * @since   JDK1.0
+ */
+public
+class FileInputStream extends InputStream
+{
+    /* File Descriptor - handle to the open file */
+    private FileDescriptor fd;
+
+
+    /**
+     * Creates a <code>FileInputStream</code> by
+     * opening a connection to an actual file,
+     * the file named by the path name <code>name</code>
+     * in the file system.  A new <code>FileDescriptor</code>
+     * object is created to represent this file
+     * connection.
+     * <p>
+     * First, if there is a security
+     * manager, its <code>checkRead</code> method
+     * is called with the <code>name</code> argument
+     * as its argument.
+     * <p>
+     * If the named file does not exist, is a directory rather than a regular
+     * file, or for some other reason cannot be opened for reading then a
+     * <code>FileNotFoundException</code> is thrown.
+     *
+     * @param      name   the system-dependent file name.
+     * @exception  FileNotFoundException  if the file does not exist,
+     *                   is a directory rather than a regular file,
+     *                   or for some other reason cannot be opened for
+     *                   reading.
+     * @exception  SecurityException      if a security manager exists and its
+     *               <code>checkRead</code> method denies read access
+     *               to the file.
+     * @see        java.lang.SecurityManager#checkRead(java.lang.String)
+     */
+    public FileInputStream(String name) throws FileNotFoundException {
+        this(name != null ? new File(name) : null);
+    }
+
+    /**
+     * Creates a <code>FileInputStream</code> by
+     * opening a connection to an actual file,
+     * the file named by the <code>File</code>
+     * object <code>file</code> in the file system.
+     * A new <code>FileDescriptor</code> object
+     * is created to represent this file connection.
+     * <p>
+     * First, if there is a security manager,
+     * its <code>checkRead</code> method  is called
+     * with the path represented by the <code>file</code>
+     * argument as its argument.
+     * <p>
+     * If the named file does not exist, is a directory rather than a regular
+     * file, or for some other reason cannot be opened for reading then a
+     * <code>FileNotFoundException</code> is thrown.
+     *
+     * @param      file   the file to be opened for reading.
+     * @exception  FileNotFoundException  if the file does not exist,
+     *                   is a directory rather than a regular file,
+     *                   or for some other reason cannot be opened for
+     *                   reading.
+     * @exception  SecurityException      if a security manager exists and its
+     *               <code>checkRead</code> method denies read access to the file.
+     * @see        java.io.File#getPath()
+     * @see        java.lang.SecurityManager#checkRead(java.lang.String)
+     */
+    public FileInputStream(File file) throws FileNotFoundException {
+	String name = (file != null ? file.getPath() : null);
+	SecurityManager security = System.getSecurityManager();
+	if (security != null) {
+	    security.checkRead(name);
+	}
+        if (name == null) {
+            throw new NullPointerException();
+        }
+	fd = new FileDescriptor();
+	open(name);
+    }
+
+    /**
+     * Creates a <code>FileInputStream</code> by using the file descriptor
+     * <code>fdObj</code>, which represents an existing connection to an
+     * actual file in the file system.
+     * <p>
+     * If there is a security manager, its <code>checkRead</code> method is
+     * called with the file descriptor <code>fdObj</code> as its argument to
+     * see if it's ok to read the file descriptor. If read access is denied
+     * to the file descriptor a <code>SecurityException</code> is thrown.
+     * <p>
+     * If <code>fdObj</code> is null then a <code>NullPointerException</code>
+     * is thrown.
+     *
+     * @param      fdObj   the file descriptor to be opened for reading.
+     * @throws     SecurityException      if a security manager exists and its
+     *                 <code>checkRead</code> method denies read access to the
+     *                 file descriptor.
+     * @see        SecurityManager#checkRead(java.io.FileDescriptor)
+     */
+    public FileInputStream(FileDescriptor fdObj) {
+	SecurityManager security = System.getSecurityManager();
+	if (fdObj == null) {
+	    throw new NullPointerException();
+	}
+	if (security != null) {
+	    security.checkRead(fdObj);
+	}
+	fd = fdObj;
+    }
+
+    /**
+     * Opens the specified file for reading.
+     * @param name the name of the file
+     */
+    private native void open(String name) throws FileNotFoundException;
+
+    /**
+     * Reads a byte of data from this input stream. This method blocks
+     * if no input is yet available.
+     *
+     * @return     the next byte of data, or <code>-1</code> if the end of the
+     *             file is reached.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public native int read() throws IOException;
+
+
+    /**
+     * Reads a subarray as a sequence of bytes.
+     * @param b the data to be written
+     * @param off the start offset in the data
+     * @param len the number of bytes that are written
+     * @exception IOException If an I/O error has occurred.
+     */
+    private native int readBytes(byte b[], int off, int len) throws IOException;
+
+    /**
+     * Reads up to <code>b.length</code> bytes of data from this input
+     * stream into an array of bytes. This method blocks until some input
+     * is available.
+     *
+     * @param      b   the buffer into which the data is read.
+     * @return     the total number of bytes read into the buffer, or
+     *             <code>-1</code> if there is no more data because the end of
+     *             the file has been reached.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public int read(byte b[]) throws IOException {
+	return readBytes(b, 0, b.length);
+    }
+
+    /**
+     * Reads up to <code>len</code> bytes of data from this input stream
+     * into an array of bytes. This method blocks until some input is
+     * available.
+     *
+     * @param      b     the buffer into which the data is read.
+     * @param      off   the start offset of the data.
+     * @param      len   the maximum number of bytes read.
+     * @return     the total number of bytes read into the buffer, or
+     *             <code>-1</code> if there is no more data because the end of
+     *             the file has been reached.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public int read(byte b[], int off, int len) throws IOException {
+	return readBytes(b, off, len);
+    }
+
+    /**
+     * Skips over and discards <code>n</code> bytes of data from the
+     * input stream. The <code>skip</code> method may, for a variety of
+     * reasons, end up skipping over some smaller number of bytes,
+     * possibly <code>0</code>. The actual number of bytes skipped is returned.
+     *
+     * @param      n   the number of bytes to be skipped.
+     * @return     the actual number of bytes skipped.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public native long skip(long n) throws IOException;
+
+    /**
+     * Returns the number of bytes that can be read from this file input
+     * stream without blocking.
+     *
+     * @return     the number of bytes that can be read from this file input
+     *             stream without blocking.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public native int available() throws IOException;
+
+    /**
+     * Closes this file input stream and releases any system resources
+     * associated with the stream.
+     *
+     * <p> If this stream has an associated channel then the channel is closed
+     * as well.
+     *
+     * @exception  IOException  if an I/O error occurs.
+     *
+     * @revised 1.4
+     * @spec JSR-51
+     */
+    public void close() throws IOException {
+        close0();
+    }
+
+    /**
+     * Returns the <code>FileDescriptor</code>
+     * object  that represents the connection to
+     * the actual file in the file system being
+     * used by this <code>FileInputStream</code>.
+     *
+     * @return     the file descriptor object associated with this stream.
+     * @exception  IOException  if an I/O error occurs.
+     * @see        java.io.FileDescriptor
+     */
+    public final FileDescriptor getFD() throws IOException {
+	if (fd != null) return fd;
+	throw new IOException();
+    }
+
+    /**
+     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
+     * object associated with this file input stream.
+     *
+     * <p> The initial {@link java.nio.channels.FileChannel#position()
+     * </code>position<code>} of the returned channel will be equal to the
+     * number of bytes read from the file so far.  Reading bytes from this
+     * stream will increment the channel's position.  Changing the channel's
+     * position, either explicitly or by reading, will change this stream's
+     * file position.
+     *
+     * @return  the file channel associated with this file input stream
+     *
+     * @since 1.4
+     * @spec JSR-51
+     */
+    /* Comment out due to no NIO in CDC
+    public FileChannel getChannel() {        
+	synchronized (this) {
+	    if (channel == null)
+		channel = FileChannelImpl.open(fd, true, false, this);
+	    return channel;
+	}
+    }
+    */
+
+    private static native void initIDs();
+
+    private native void close0() throws IOException;
+
+    static {
+	initIDs();
+    }
+
+    /**
+     * Ensures that the <code>close</code> method of this file input stream is
+     * called when there are no more references to it.
+     *
+     * @exception  IOException  if an I/O error occurs.
+     * @see        java.io.FileInputStream#close()
+     */
+    protected void finalize() throws IOException {
+	if (fd != null) {
+	    if (fd != fd.in) {
+		close();
+	    }
+	}
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileInputStream.java.rej phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileInputStream.java.rej
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileInputStream.java.rej	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileInputStream.java.rej	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,723 @@
+***************
+*** 1,313 ****
+- /*
+-  * @(#)FileInputStream.java	1.60 06/10/10
+-  *
+-  * Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.  
+-  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+-  *   
+-  * This program is free software; you can redistribute it and/or  
+-  * modify it under the terms of the GNU General Public License version  
+-  * 2 only, as published by the Free Software Foundation.   
+-  *   
+-  * This program is distributed in the hope that it will be useful, but  
+-  * WITHOUT ANY WARRANTY; without even the implied warranty of  
+-  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+-  * General Public License version 2 for more details (a copy is  
+-  * included at /legal/license.txt).   
+-  *   
+-  * You should have received a copy of the GNU General Public License  
+-  * version 2 along with this work; if not, write to the Free Software  
+-  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+-  * 02110-1301 USA   
+-  *   
+-  * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+-  * Clara, CA 95054 or visit www.sun.com if you need additional  
+-  * information or have any questions. 
+-  *
+-  */
+- 
+- package java.io;
+- 
+- 
+- /**
+-  * A <code>FileInputStream</code> obtains input bytes
+-  * from a file in a file system. What files
+-  * are  available depends on the host environment.
+-  *
+-  * <p><code>FileInputStream</code> is meant for reading streams of raw bytes
+-  * such as image data. For reading streams of characters, consider using
+-  * <code>FileReader</code>.
+-  *
+-  * @version 1.45, 02/02/00
+-  * @see     java.io.File
+-  * @see     java.io.FileDescriptor
+-  * @see	    java.io.FileOutputStream
+-  * @since   JDK1.0
+-  */
+- public
+- class FileInputStream extends InputStream
+- {
+-     /* File Descriptor - handle to the open file */
+-     private FileDescriptor fd;
+- 
+- 
+-     /**
+-      * Creates a <code>FileInputStream</code> by
+-      * opening a connection to an actual file,
+-      * the file named by the path name <code>name</code>
+-      * in the file system.  A new <code>FileDescriptor</code>
+-      * object is created to represent this file
+-      * connection.
+-      * <p>
+-      * First, if there is a security
+-      * manager, its <code>checkRead</code> method
+-      * is called with the <code>name</code> argument
+-      * as its argument.
+-      * <p>
+-      * If the named file does not exist, is a directory rather than a regular
+-      * file, or for some other reason cannot be opened for reading then a
+-      * <code>FileNotFoundException</code> is thrown.
+-      *
+-      * @param      name   the system-dependent file name.
+-      * @exception  FileNotFoundException  if the file does not exist,
+-      *                   is a directory rather than a regular file,
+-      *                   or for some other reason cannot be opened for
+-      *                   reading.
+-      * @exception  SecurityException      if a security manager exists and its
+-      *               <code>checkRead</code> method denies read access
+-      *               to the file.
+-      * @see        java.lang.SecurityManager#checkRead(java.lang.String)
+-      */
+-     public FileInputStream(String name) throws FileNotFoundException {
+-         this(name != null ? new File(name) : null);
+-     }
+- 
+-     /**
+-      * Creates a <code>FileInputStream</code> by
+-      * opening a connection to an actual file,
+-      * the file named by the <code>File</code>
+-      * object <code>file</code> in the file system.
+-      * A new <code>FileDescriptor</code> object
+-      * is created to represent this file connection.
+-      * <p>
+-      * First, if there is a security manager,
+-      * its <code>checkRead</code> method  is called
+-      * with the path represented by the <code>file</code>
+-      * argument as its argument.
+-      * <p>
+-      * If the named file does not exist, is a directory rather than a regular
+-      * file, or for some other reason cannot be opened for reading then a
+-      * <code>FileNotFoundException</code> is thrown.
+-      *
+-      * @param      file   the file to be opened for reading.
+-      * @exception  FileNotFoundException  if the file does not exist,
+-      *                   is a directory rather than a regular file,
+-      *                   or for some other reason cannot be opened for
+-      *                   reading.
+-      * @exception  SecurityException      if a security manager exists and its
+-      *               <code>checkRead</code> method denies read access to the file.
+-      * @see        java.io.File#getPath()
+-      * @see        java.lang.SecurityManager#checkRead(java.lang.String)
+-      */
+-     public FileInputStream(File file) throws FileNotFoundException {
+- 	String name = (file != null ? file.getPath() : null);
+- 	SecurityManager security = System.getSecurityManager();
+- 	if (security != null) {
+- 	    security.checkRead(name);
+- 	}
+-         if (name == null) {
+-             throw new NullPointerException();
+-         }
+- 	fd = new FileDescriptor();
+- 	open(name);
+-     }
+- 
+-     /**
+-      * Creates a <code>FileInputStream</code> by using the file descriptor
+-      * <code>fdObj</code>, which represents an existing connection to an
+-      * actual file in the file system.
+-      * <p>
+-      * If there is a security manager, its <code>checkRead</code> method is
+-      * called with the file descriptor <code>fdObj</code> as its argument to
+-      * see if it's ok to read the file descriptor. If read access is denied
+-      * to the file descriptor a <code>SecurityException</code> is thrown.
+-      * <p>
+-      * If <code>fdObj</code> is null then a <code>NullPointerException</code>
+-      * is thrown.
+-      *
+-      * @param      fdObj   the file descriptor to be opened for reading.
+-      * @throws     SecurityException      if a security manager exists and its
+-      *                 <code>checkRead</code> method denies read access to the
+-      *                 file descriptor.
+-      * @see        SecurityManager#checkRead(java.io.FileDescriptor)
+-      */
+-     public FileInputStream(FileDescriptor fdObj) {
+- 	SecurityManager security = System.getSecurityManager();
+- 	if (fdObj == null) {
+- 	    throw new NullPointerException();
+- 	}
+- 	if (security != null) {
+- 	    security.checkRead(fdObj);
+- 	}
+- 	fd = fdObj;
+-     }
+- 
+-     /**
+-      * Opens the specified file for reading.
+-      * @param name the name of the file
+-      */
+-     private native void open(String name) throws FileNotFoundException;
+- 
+-     /**
+-      * Reads a byte of data from this input stream. This method blocks
+-      * if no input is yet available.
+-      *
+-      * @return     the next byte of data, or <code>-1</code> if the end of the
+-      *             file is reached.
+-      * @exception  IOException  if an I/O error occurs.
+-      */
+-     public native int read() throws IOException;
+- 
+- 
+-     /**
+-      * Reads a subarray as a sequence of bytes.
+-      * @param b the data to be written
+-      * @param off the start offset in the data
+-      * @param len the number of bytes that are written
+-      * @exception IOException If an I/O error has occurred.
+-      */
+-     private native int readBytes(byte b[], int off, int len) throws IOException;
+- 
+-     /**
+-      * Reads up to <code>b.length</code> bytes of data from this input
+-      * stream into an array of bytes. This method blocks until some input
+-      * is available.
+-      *
+-      * @param      b   the buffer into which the data is read.
+-      * @return     the total number of bytes read into the buffer, or
+-      *             <code>-1</code> if there is no more data because the end of
+-      *             the file has been reached.
+-      * @exception  IOException  if an I/O error occurs.
+-      */
+-     public int read(byte b[]) throws IOException {
+- 	return readBytes(b, 0, b.length);
+-     }
+- 
+-     /**
+-      * Reads up to <code>len</code> bytes of data from this input stream
+-      * into an array of bytes. This method blocks until some input is
+-      * available.
+-      *
+-      * @param      b     the buffer into which the data is read.
+-      * @param      off   the start offset of the data.
+-      * @param      len   the maximum number of bytes read.
+-      * @return     the total number of bytes read into the buffer, or
+-      *             <code>-1</code> if there is no more data because the end of
+-      *             the file has been reached.
+-      * @exception  IOException  if an I/O error occurs.
+-      */
+-     public int read(byte b[], int off, int len) throws IOException {
+- 	return readBytes(b, off, len);
+-     }
+- 
+-     /**
+-      * Skips over and discards <code>n</code> bytes of data from the
+-      * input stream. The <code>skip</code> method may, for a variety of
+-      * reasons, end up skipping over some smaller number of bytes,
+-      * possibly <code>0</code>. The actual number of bytes skipped is returned.
+-      *
+-      * @param      n   the number of bytes to be skipped.
+-      * @return     the actual number of bytes skipped.
+-      * @exception  IOException  if an I/O error occurs.
+-      */
+-     public native long skip(long n) throws IOException;
+- 
+-     /**
+-      * Returns the number of bytes that can be read from this file input
+-      * stream without blocking.
+-      *
+-      * @return     the number of bytes that can be read from this file input
+-      *             stream without blocking.
+-      * @exception  IOException  if an I/O error occurs.
+-      */
+-     public native int available() throws IOException;
+- 
+-     /**
+-      * Closes this file input stream and releases any system resources
+-      * associated with the stream.
+-      *
+-      * <p> If this stream has an associated channel then the channel is closed
+-      * as well.
+-      *
+-      * @exception  IOException  if an I/O error occurs.
+-      *
+-      * @revised 1.4
+-      * @spec JSR-51
+-      */
+-     public void close() throws IOException {
+-         close0();
+-     }
+- 
+-     /**
+-      * Returns the <code>FileDescriptor</code>
+-      * object  that represents the connection to
+-      * the actual file in the file system being
+-      * used by this <code>FileInputStream</code>.
+-      *
+-      * @return     the file descriptor object associated with this stream.
+-      * @exception  IOException  if an I/O error occurs.
+-      * @see        java.io.FileDescriptor
+-      */
+-     public final FileDescriptor getFD() throws IOException {
+- 	if (fd != null) return fd;
+- 	throw new IOException();
+-     }
+- 
+-     /**
+-      * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
+-      * object associated with this file input stream.
+-      *
+-      * <p> The initial {@link java.nio.channels.FileChannel#position()
+-      * </code>position<code>} of the returned channel will be equal to the
+-      * number of bytes read from the file so far.  Reading bytes from this
+-      * stream will increment the channel's position.  Changing the channel's
+-      * position, either explicitly or by reading, will change this stream's
+-      * file position.
+-      *
+-      * @return  the file channel associated with this file input stream
+-      *
+-      * @since 1.4
+-      * @spec JSR-51
+-      */
+-     /* Comment out due to no NIO in CDC
+-     public FileChannel getChannel() {        
+- 	synchronized (this) {
+- 	    if (channel == null)
+- 		channel = FileChannelImpl.open(fd, true, false, this);
+- 	    return channel;
+- 	}
+-     }
+-     */
+- 
+-     private static native void initIDs();
+- 
+-     private native void close0() throws IOException;
+- 
+-     static {
+- 	initIDs();
+-     }
+- 
+-     /**
+-      * Ensures that the <code>close</code> method of this file input stream is
+-      * called when there are no more references to it.
+-      *
+-      * @exception  IOException  if an I/O error occurs.
+-      * @see        java.io.FileInputStream#close()
+-      */
+-     protected void finalize() throws IOException {
+- 	if (fd != null) {
+- 	    if (fd != fd.in) {
+- 		close();
+- 	    }
+- 	}
+-     }
+- }
+--- 1,407 ----
++ /*
++  * Copyright 1994-2008 Sun Microsystems, Inc.  All Rights Reserved.
++  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++  *
++  * This code is free software; you can redistribute it and/or modify it
++  * under the terms of the GNU General Public License version 2 only, as
++  * published by the Free Software Foundation.  Sun designates this
++  * particular file as subject to the "Classpath" exception as provided
++  * by Sun in the LICENSE file that accompanied this code.
++  *
++  * This code is distributed in the hope that it will be useful, but WITHOUT
++  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++  * version 2 for more details (a copy is included in the LICENSE file that
++  * accompanied this code).
++  *
++  * You should have received a copy of the GNU General Public License version
++  * 2 along with this work; if not, write to the Free Software Foundation,
++  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
++  *
++  * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
++  * CA 95054 USA or visit www.sun.com if you need additional information or
++  * have any questions.
++  */
++ 
++ package java.io;
++ 
++ import java.nio.channels.FileChannel;
++ import sun.nio.ch.FileChannelImpl;
++ 
++ 
++ /**
++  * A <code>FileInputStream</code> obtains input bytes
++  * from a file in a file system. What files
++  * are  available depends on the host environment.
++  *
++  * <p><code>FileInputStream</code> is meant for reading streams of raw bytes
++  * such as image data. For reading streams of characters, consider using
++  * <code>FileReader</code>.
++  *
++  * @author  Arthur van Hoff
++  * @see     java.io.File
++  * @see     java.io.FileDescriptor
++  * @see     java.io.FileOutputStream
++  * @since   JDK1.0
++  */
++ public
++ class FileInputStream extends InputStream
++ {
++     /* File Descriptor - handle to the open file */
++     private final FileDescriptor fd;
++ 
++     private FileChannel channel = null;
++ 
++     private final Object closeLock = new Object();
++     private volatile boolean closed = false;
++ 
++     private static final ThreadLocal runningFinalize =
++         new ThreadLocal();
++ 
++     private static boolean isRunningFinalize() {
++         Boolean val;
++         if ((val = (Boolean)runningFinalize.get()) != null)
++             return val.booleanValue();
++         return false;
++     }
++ 
++     /**
++      * Creates a <code>FileInputStream</code> by
++      * opening a connection to an actual file,
++      * the file named by the path name <code>name</code>
++      * in the file system.  A new <code>FileDescriptor</code>
++      * object is created to represent this file
++      * connection.
++      * <p>
++      * First, if there is a security
++      * manager, its <code>checkRead</code> method
++      * is called with the <code>name</code> argument
++      * as its argument.
++      * <p>
++      * If the named file does not exist, is a directory rather than a regular
++      * file, or for some other reason cannot be opened for reading then a
++      * <code>FileNotFoundException</code> is thrown.
++      *
++      * @param      name   the system-dependent file name.
++      * @exception  FileNotFoundException  if the file does not exist,
++      *                   is a directory rather than a regular file,
++      *                   or for some other reason cannot be opened for
++      *                   reading.
++      * @exception  SecurityException      if a security manager exists and its
++      *               <code>checkRead</code> method denies read access
++      *               to the file.
++      * @see        java.lang.SecurityManager#checkRead(java.lang.String)
++      */
++     public FileInputStream(String name) throws FileNotFoundException {
++         this(name != null ? new File(name) : null);
++     }
++ 
++     /**
++      * Creates a <code>FileInputStream</code> by
++      * opening a connection to an actual file,
++      * the file named by the <code>File</code>
++      * object <code>file</code> in the file system.
++      * A new <code>FileDescriptor</code> object
++      * is created to represent this file connection.
++      * <p>
++      * First, if there is a security manager,
++      * its <code>checkRead</code> method  is called
++      * with the path represented by the <code>file</code>
++      * argument as its argument.
++      * <p>
++      * If the named file does not exist, is a directory rather than a regular
++      * file, or for some other reason cannot be opened for reading then a
++      * <code>FileNotFoundException</code> is thrown.
++      *
++      * @param      file   the file to be opened for reading.
++      * @exception  FileNotFoundException  if the file does not exist,
++      *                   is a directory rather than a regular file,
++      *                   or for some other reason cannot be opened for
++      *                   reading.
++      * @exception  SecurityException      if a security manager exists and its
++      *               <code>checkRead</code> method denies read access to the file.
++      * @see        java.io.File#getPath()
++      * @see        java.lang.SecurityManager#checkRead(java.lang.String)
++      */
++     public FileInputStream(File file) throws FileNotFoundException {
++         String name = (file != null ? file.getPath() : null);
++         SecurityManager security = System.getSecurityManager();
++         if (security != null) {
++             security.checkRead(name);
++         }
++         if (name == null) {
++             throw new NullPointerException();
++         }
++         fd = new FileDescriptor();
++         fd.incrementAndGetUseCount();
++         open(name);
++     }
++ 
++     /**
++      * Creates a <code>FileInputStream</code> by using the file descriptor
++      * <code>fdObj</code>, which represents an existing connection to an
++      * actual file in the file system.
++      * <p>
++      * If there is a security manager, its <code>checkRead</code> method is
++      * called with the file descriptor <code>fdObj</code> as its argument to
++      * see if it's ok to read the file descriptor. If read access is denied
++      * to the file descriptor a <code>SecurityException</code> is thrown.
++      * <p>
++      * If <code>fdObj</code> is null then a <code>NullPointerException</code>
++      * is thrown.
++      * <p>
++      * This constructor does not throw an exception if <code>fdObj</code>
++      * is {@link java.io.FileDescriptor#valid() invalid}.
++      * However, if the methods are invoked on the resulting stream to attempt
++      * I/O on the stream, an <code>IOException</code> is thrown.
++      *
++      * @param      fdObj   the file descriptor to be opened for reading.
++      * @throws     SecurityException      if a security manager exists and its
++      *                 <code>checkRead</code> method denies read access to the
++      *                 file descriptor.
++      * @see        SecurityManager#checkRead(java.io.FileDescriptor)
++      */
++     public FileInputStream(FileDescriptor fdObj) {
++         SecurityManager security = System.getSecurityManager();
++         if (fdObj == null) {
++             throw new NullPointerException();
++         }
++         if (security != null) {
++             security.checkRead(fdObj);
++         }
++         fd = fdObj;
++ 
++         /*
++          * FileDescriptor is being shared by streams.
++          * Ensure that it's GC'ed only when all the streams/channels are done
++          * using it.
++          */
++         fd.incrementAndGetUseCount();
++     }
++ 
++     /**
++      * Opens the specified file for reading.
++      * @param name the name of the file
++      */
++     private native void open(String name) throws FileNotFoundException;
++ 
++     /**
++      * Reads a byte of data from this input stream. This method blocks
++      * if no input is yet available.
++      *
++      * @return     the next byte of data, or <code>-1</code> if the end of the
++      *             file is reached.
++      * @exception  IOException  if an I/O error occurs.
++      */
++     public native int read() throws IOException;
++ 
++     /**
++      * Reads a subarray as a sequence of bytes.
++      * @param b the data to be written
++      * @param off the start offset in the data
++      * @param len the number of bytes that are written
++      * @exception IOException If an I/O error has occurred.
++      */
++     private native int readBytes(byte b[], int off, int len) throws IOException;
++ 
++     /**
++      * Reads up to <code>b.length</code> bytes of data from this input
++      * stream into an array of bytes. This method blocks until some input
++      * is available.
++      *
++      * @param      b   the buffer into which the data is read.
++      * @return     the total number of bytes read into the buffer, or
++      *             <code>-1</code> if there is no more data because the end of
++      *             the file has been reached.
++      * @exception  IOException  if an I/O error occurs.
++      */
++     public int read(byte b[]) throws IOException {
++         return readBytes(b, 0, b.length);
++     }
++ 
++     /**
++      * Reads up to <code>len</code> bytes of data from this input stream
++      * into an array of bytes. If <code>len</code> is not zero, the method
++      * blocks until some input is available; otherwise, no
++      * bytes are read and <code>0</code> is returned.
++      *
++      * @param      b     the buffer into which the data is read.
++      * @param      off   the start offset in the destination array <code>b</code>
++      * @param      len   the maximum number of bytes read.
++      * @return     the total number of bytes read into the buffer, or
++      *             <code>-1</code> if there is no more data because the end of
++      *             the file has been reached.
++      * @exception  NullPointerException If <code>b</code> is <code>null</code>.
++      * @exception  IndexOutOfBoundsException If <code>off</code> is negative,
++      * <code>len</code> is negative, or <code>len</code> is greater than
++      * <code>b.length - off</code>
++      * @exception  IOException  if an I/O error occurs.
++      */
++     public int read(byte b[], int off, int len) throws IOException {
++         return readBytes(b, off, len);
++     }
++ 
++     /**
++      * Skips over and discards <code>n</code> bytes of data from the
++      * input stream.
++      *
++      * <p>The <code>skip</code> method may, for a variety of
++      * reasons, end up skipping over some smaller number of bytes,
++      * possibly <code>0</code>. If <code>n</code> is negative, an
++      * <code>IOException</code> is thrown, even though the <code>skip</code>
++      * method of the {@link InputStream} superclass does nothing in this case.
++      * The actual number of bytes skipped is returned.
++      *
++      * <p>This method may skip more bytes than are remaining in the backing
++      * file. This produces no exception and the number of bytes skipped
++      * may include some number of bytes that were beyond the EOF of the
++      * backing file. Attempting to read from the stream after skipping past
++      * the end will result in -1 indicating the end of the file.
++      *
++      * @param      n   the number of bytes to be skipped.
++      * @return     the actual number of bytes skipped.
++      * @exception  IOException  if n is negative, if the stream does not
++      *             support seek, or if an I/O error occurs.
++      */
++     public native long skip(long n) throws IOException;
++ 
++     /**
++      * Returns an estimate of the number of remaining bytes that can be read (or
++      * skipped over) from this input stream without blocking by the next
++      * invocation of a method for this input stream. The next invocation might be
++      * the same thread or another thread.  A single read or skip of this
++      * many bytes will not block, but may read or skip fewer bytes.
++      *
++      * <p> In some cases, a non-blocking read (or skip) may appear to be
++      * blocked when it is merely slow, for example when reading large
++      * files over slow networks.
++      *
++      * @return     an estimate of the number of remaining bytes that can be read
++      *             (or skipped over) from this input stream without blocking.
++      * @exception  IOException  if this file input stream has been closed by calling
++      *             {@code close} or an I/O error occurs.
++      */
++     public native int available() throws IOException;
++ 
++     /**
++      * Closes this file input stream and releases any system resources
++      * associated with the stream.
++      *
++      * <p> If this stream has an associated channel then the channel is closed
++      * as well.
++      *
++      * @exception  IOException  if an I/O error occurs.
++      *
++      * @revised 1.4
++      * @spec JSR-51
++      */
++     public void close() throws IOException {
++         synchronized (closeLock) {
++             if (closed) {
++                 return;
++             }
++             closed = true;
++         }
++         if (channel != null) {
++             /*
++              * Decrement the FD use count associated with the channel
++              * The use count is incremented whenever a new channel
++              * is obtained from this stream.
++              */
++            fd.decrementAndGetUseCount();
++            channel.close();
++         }
++ 
++         /*
++          * Decrement the FD use count associated with this stream
++          */
++         int useCount = fd.decrementAndGetUseCount();
++ 
++         /*
++          * If FileDescriptor is still in use by another stream, the finalizer
++          * will not close it.
++          */
++         if ((useCount <= 0) || !isRunningFinalize()) {
++             close0();
++         }
++     }
++ 
++     /**
++      * Returns the <code>FileDescriptor</code>
++      * object  that represents the connection to
++      * the actual file in the file system being
++      * used by this <code>FileInputStream</code>.
++      *
++      * @return     the file descriptor object associated with this stream.
++      * @exception  IOException  if an I/O error occurs.
++      * @see        java.io.FileDescriptor
++      */
++     public final FileDescriptor getFD() throws IOException {
++         if (fd != null) return fd;
++         throw new IOException();
++     }
++ 
++     /**
++      * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
++      * object associated with this file input stream.
++      *
++      * <p> The initial {@link java.nio.channels.FileChannel#position()
++      * </code>position<code>} of the returned channel will be equal to the
++      * number of bytes read from the file so far.  Reading bytes from this
++      * stream will increment the channel's position.  Changing the channel's
++      * position, either explicitly or by reading, will change this stream's
++      * file position.
++      *
++      * @return  the file channel associated with this file input stream
++      *
++      * @since 1.4
++      * @spec JSR-51
++      */
++     public FileChannel getChannel() {
++         synchronized (this) {
++             if (channel == null) {
++                 channel = FileChannelImpl.open(fd, true, false, this);
++ 
++                 /*
++                  * Increment fd's use count. Invoking the channel's close()
++                  * method will result in decrementing the use count set for
++                  * the channel.
++                  */
++                 fd.incrementAndGetUseCount();
++             }
++             return channel;
++         }
++     }
++ 
++     private static native void initIDs();
++ 
++     private native void close0() throws IOException;
++ 
++     static {
++         initIDs();
++     }
++ 
++     /**
++      * Ensures that the <code>close</code> method of this file input stream is
++      * called when there are no more references to it.
++      *
++      * @exception  IOException  if an I/O error occurs.
++      * @see        java.io.FileInputStream#close()
++      */
++     protected void finalize() throws IOException {
++         if ((fd != null) &&  (fd != FileDescriptor.in)) {
++ 
++             /*
++              * Finalizer should not release the FileDescriptor if another
++              * stream is still using it. If the user directly invokes
++              * close() then the FileDescriptor is also released.
++              */
++             runningFinalize.set(Boolean.TRUE);
++             try {
++                 close();
++             } finally {
++                 runningFinalize.set(Boolean.FALSE);
++             }
++         }
++     }
++ }
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileOutputStream.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileOutputStream.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileOutputStream.java	2009-07-06 18:37:34.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileOutputStream.java	2009-07-06 19:33:10.000000000 -0400
@@ -1,363 +1,431 @@
-/*
- * @(#)FileOutputStream.java	1.54 06/10/10
- *
- * Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.  
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
- *   
- * This program is free software; you can redistribute it and/or  
- * modify it under the terms of the GNU General Public License version  
- * 2 only, as published by the Free Software Foundation.   
- *   
- * This program is distributed in the hope that it will be useful, but  
- * WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
- * General Public License version 2 for more details (a copy is  
- * included at /legal/license.txt).   
- *   
- * You should have received a copy of the GNU General Public License  
- * version 2 along with this work; if not, write to the Free Software  
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
- * 02110-1301 USA   
- *   
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
- * Clara, CA 95054 or visit www.sun.com if you need additional  
- * information or have any questions. 
- *
- */
-
-package java.io;
-
-
-
-/**
- * A file output stream is an output stream for writing data to a 
- * <code>File</code> or to a <code>FileDescriptor</code>. Whether or not
- * a file is available or may be created depends upon the underlying
- * platform.  Some platforms, in particular, allow a file to be opened
- * for writing by only one <tt>FileOutputStream</tt> (or other
- * file-writing object) at a time.  In such situations the constructors in
- * this class will fail if the file involved is already open.
- *
- * <p><code>FileOutputStream</code> is meant for writing streams of raw bytes
- * such as image data. For writing streams of characters, consider using
- * <code>FileWriter</code>.
- *
- * @version 1.39, 02/02/00
- * @see     java.io.File
- * @see     java.io.FileDescriptor
- * @see     java.io.FileInputStream
- * @since   JDK1.0
- */
-public
-class FileOutputStream extends OutputStream
-{
-    /**
-     * The system dependent file descriptor. The value is
-     * 1 more than actual file descriptor. This means that
-     * the default value 0 indicates that the file is not open.
-     */
-    private FileDescriptor fd;
-
-    private boolean append = false;
-
-    /**
-     * Creates an output file stream to write to the file with the 
-     * specified name. A new <code>FileDescriptor</code> object is 
-     * created to represent this file connection.
-     * <p>
-     * First, if there is a security manager, its <code>checkWrite</code> 
-     * method is called with <code>name</code> as its argument.
-     * <p>
-     * If the file exists but is a directory rather than a regular file, does
-     * not exist but cannot be created, or cannot be opened for any other
-     * reason then a <code>FileNotFoundException</code> is thrown.
-     *
-     * @param      name   the system-dependent filename
-     * @exception  FileNotFoundException  if the file exists but is a directory
-     *                   rather than a regular file, does not exist but cannot
-     *                   be created, or cannot be opened for any other reason
-     * @exception  SecurityException  if a security manager exists and its
-     *               <code>checkWrite</code> method denies write access
-     *               to the file.
-     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
-     */
-    public FileOutputStream(String name) throws FileNotFoundException {
-	this(name != null ? new File(name) : null, false);
-    }
-
-    /**
-     * Creates an output file stream to write to the file with the specified
-     * <code>name</code>.  If the second argument is <code>true</code>, then
-     * bytes will be written to the end of the file rather than the beginning.
-     * A new <code>FileDescriptor</code> object is created to represent this
-     * file connection.
-     * <p>
-     * First, if there is a security manager, its <code>checkWrite</code> 
-     * method is called with <code>name</code> as its argument.
-     * <p>
-     * If the file exists but is a directory rather than a regular file, does
-     * not exist but cannot be created, or cannot be opened for any other
-     * reason then a <code>FileNotFoundException</code> is thrown.
-     * 
-     * @param     name        the system-dependent file name
-     * @param     append      if <code>true</code>, then bytes will be written
-     *                   to the end of the file rather than the beginning
-     * @exception  FileNotFoundException  if the file exists but is a directory
-     *                   rather than a regular file, does not exist but cannot
-     *                   be created, or cannot be opened for any other reason.
-     * @exception  SecurityException  if a security manager exists and its
-     *               <code>checkWrite</code> method denies write access
-     *               to the file.
-     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
-     * @since     JDK1.1
-     */
-    public FileOutputStream(String name, boolean append)
-        throws FileNotFoundException
-    {
-        this(name != null ? new File(name) : null, append);
-    }
-
-    /**
-     * Creates a file output stream to write to the file represented by 
-     * the specified <code>File</code> object. A new 
-     * <code>FileDescriptor</code> object is created to represent this 
-     * file connection.
-     * <p>
-     * First, if there is a security manager, its <code>checkWrite</code> 
-     * method is called with the path represented by the <code>file</code> 
-     * argument as its argument.
-     * <p>
-     * If the file exists but is a directory rather than a regular file, does
-     * not exist but cannot be created, or cannot be opened for any other
-     * reason then a <code>FileNotFoundException</code> is thrown.
-     *
-     * @param      file               the file to be opened for writing.
-     * @exception  FileNotFoundException  if the file exists but is a directory
-     *                   rather than a regular file, does not exist but cannot
-     *                   be created, or cannot be opened for any other reason
-     * @exception  SecurityException  if a security manager exists and its
-     *               <code>checkWrite</code> method denies write access
-     *               to the file.
-     * @see        java.io.File#getPath()
-     * @see        java.lang.SecurityException
-     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
-     */
-    public FileOutputStream(File file) throws FileNotFoundException {
-	this(file, false);
-    }
-
-    /**
-     * Creates a file output stream to write to the file represented by 
-     * the specified <code>File</code> object. If the second argument is
-     * <code>true</code>, then bytes will be written to the end of the file
-     * rather than the beginning. A new <code>FileDescriptor</code> object is
-     * created to represent this file connection.
-     * <p>
-     * First, if there is a security manager, its <code>checkWrite</code> 
-     * method is called with the path represented by the <code>file</code> 
-     * argument as its argument.
-     * <p>
-     * If the file exists but is a directory rather than a regular file, does
-     * not exist but cannot be created, or cannot be opened for any other
-     * reason then a <code>FileNotFoundException</code> is thrown.
-     *
-     * @param      file               the file to be opened for writing.
-     * @param     append      if <code>true</code>, then bytes will be written
-     *                   to the end of the file rather than the beginning
-     * @exception  FileNotFoundException  if the file exists but is a directory
-     *                   rather than a regular file, does not exist but cannot
-     *                   be created, or cannot be opened for any other reason
-     * @exception  SecurityException  if a security manager exists and its
-     *               <code>checkWrite</code> method denies write access
-     *               to the file.
-     * @see        java.io.File#getPath()
-     * @see        java.lang.SecurityException
-     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
-     * @since 1.4
-     */
-    public FileOutputStream(File file, boolean append)
-        throws FileNotFoundException
-    {
-        String name = (file != null ? file.getPath() : null);
-	SecurityManager security = System.getSecurityManager();
-	if (security != null) {
-	    security.checkWrite(name);
-	}
-        if (name == null) {
-            throw new NullPointerException();
-        }
-	fd = new FileDescriptor();
-        this.append = append;
-	if (append) {
-	    openAppend(name);
-	} else {
-	    open(name);
-	}
-    }
-
-    /**
-     * Creates an output file stream to write to the specified file 
-     * descriptor, which represents an existing connection to an actual 
-     * file in the file system.
-     * <p>
-     * First, if there is a security manager, its <code>checkWrite</code> 
-     * method is called with the file descriptor <code>fdObj</code> 
-     * argument as its argument.
-     *
-     * @param      fdObj   the file descriptor to be opened for writing
-     * @exception  SecurityException  if a security manager exists and its
-     *               <code>checkWrite</code> method denies
-     *               write access to the file descriptor
-     * @see        java.lang.SecurityManager#checkWrite(java.io.FileDescriptor)
-     */
-    public FileOutputStream(FileDescriptor fdObj) {
-	SecurityManager security = System.getSecurityManager();
-	if (fdObj == null) {
-	    throw new NullPointerException();
-	}
-	if (security != null) {
-	    security.checkWrite(fdObj);
-	}
-	fd = fdObj;
-    }
-
-    /**
-     * Opens a file, with the specified name, for writing.
-     * @param name name of file to be opened
-     */
-    private native void open(String name) throws FileNotFoundException;
-
-    /**
-     * Opens a file, with the specified name, for appending.
-     * @param name name of file to be opened
-     */
-    private native void openAppend(String name) throws FileNotFoundException;
-
-    /**
-     * Writes the specified byte to this file output stream. Implements 
-     * the <code>write</code> method of <code>OutputStream</code>.
-     *
-     * @param      b   the byte to be written.
-     * @exception  IOException  if an I/O error occurs.
-     */
-    public native void write(int b) throws IOException;
-
-    /**
-     * Writes a sub array as a sequence of bytes.
-     * @param b the data to be written
-     * @param off the start offset in the data
-     * @param len the number of bytes that are written
-     * @exception IOException If an I/O error has occurred.
-     */
-    private native void writeBytes(byte b[], int off, int len) throws IOException;
-
-    /**
-     * Writes <code>b.length</code> bytes from the specified byte array 
-     * to this file output stream. 
-     *
-     * @param      b   the data.
-     * @exception  IOException  if an I/O error occurs.
-     */
-    public void write(byte b[]) throws IOException {
-	writeBytes(b, 0, b.length);
-    }
-
-    /**
-     * Writes <code>len</code> bytes from the specified byte array 
-     * starting at offset <code>off</code> to this file output stream. 
-     *
-     * @param      b     the data.
-     * @param      off   the start offset in the data.
-     * @param      len   the number of bytes to write.
-     * @exception  IOException  if an I/O error occurs.
-     */
-    public void write(byte b[], int off, int len) throws IOException {
-	writeBytes(b, off, len);
-    }
-
-    /**
-     * Closes this file output stream and releases any system resources 
-     * associated with this stream. This file output stream may no longer 
-     * be used for writing bytes. 
-     *
-     * <p> If this stream has an associated channel then the channel is closed
-     * as well.
-     *
-     * @exception  IOException  if an I/O error occurs.
-     *
-     * @revised 1.4
-     * @spec JSR-51
-     */
-    public void close() throws IOException {
-        close0();
-    }
-
-    /**
-     * Returns the file descriptor associated with this stream.
-     *
-     * @return  the <code>FileDescriptor</code> object that represents 
-     *          the connection to the file in the file system being used 
-     *          by this <code>FileOutputStream</code> object. 
-     * 
-     * @exception  IOException  if an I/O error occurs.
-     * @see        java.io.FileDescriptor
-     */
-     public final FileDescriptor getFD()  throws IOException {
-	if (fd != null) return fd;
-	throw new IOException();
-     }
-    
-    /**
-     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
-     * object associated with this file output stream. </p>
-     *
-     * <p> The initial {@link java.nio.channels.FileChannel#position()
-     * </code>position<code>} of the returned channel will be equal to the
-     * number of bytes written to the file so far unless this stream is in
-     * append mode, in which case it will be equal to the size of the file.
-     * Writing bytes to this stream will increment the channel's position
-     * accordingly.  Changing the channel's position, either explicitly or by
-     * writing, will change this stream's file position.
-     *
-     * @return  the file channel associated with this file output stream
-     *
-     * @since 1.4
-     * @spec JSR-51
-     */
-    /*
-    public FileChannel getChannel() {
-	synchronized (this) {
-	    if (channel == null)
-		channel = FileChannelImpl.open(fd, false, true, this, append);
-	    return channel;
-	}
-    }
-    */
-
-    /**
-     * Cleans up the connection to the file, and ensures that the 
-     * <code>close</code> method of this file output stream is
-     * called when there are no more references to this stream. 
-     *
-     * @exception  IOException  if an I/O error occurs.
-     * @see        java.io.FileInputStream#close()
-     */
-    protected void finalize() throws IOException {
- 	if (fd != null) {
- 	    if (fd == fd.out || fd == fd.err) {
- 		flush();
- 	    } else {
- 		close();
- 	    }
- 	}
-    }
-
-    private native void close0() throws IOException;
-
-    private static native void initIDs();
-    
-    static {
-	initIDs();
-    }
-
-}
+/*
+ * Copyright 1994-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.io;
+
+import java.nio.channels.FileChannel;
+import sun.nio.ch.FileChannelImpl;
+
+
+/**
+ * A file output stream is an output stream for writing data to a
+ * <code>File</code> or to a <code>FileDescriptor</code>. Whether or not
+ * a file is available or may be created depends upon the underlying
+ * platform.  Some platforms, in particular, allow a file to be opened
+ * for writing by only one <tt>FileOutputStream</tt> (or other
+ * file-writing object) at a time.  In such situations the constructors in
+ * this class will fail if the file involved is already open.
+ *
+ * <p><code>FileOutputStream</code> is meant for writing streams of raw bytes
+ * such as image data. For writing streams of characters, consider using
+ * <code>FileWriter</code>.
+ *
+ * @author  Arthur van Hoff
+ * @see     java.io.File
+ * @see     java.io.FileDescriptor
+ * @see     java.io.FileInputStream
+ * @since   JDK1.0
+ */
+public
+class FileOutputStream extends OutputStream
+{
+    /**
+     * The system dependent file descriptor.
+     */
+    private final FileDescriptor fd;
+
+    private FileChannel channel= null;
+
+    private final Object closeLock = new Object();
+    private volatile boolean closed = false;
+    private static final ThreadLocal runningFinalize =
+        new ThreadLocal();
+
+    private static boolean isRunningFinalize() {
+        Boolean val;
+        if ((val = (Boolean)runningFinalize.get()) != null)
+            return val.booleanValue();
+        return false;
+    }
+
+    /**
+     * Creates a file output stream to write to the file with the
+     * specified name. A new <code>FileDescriptor</code> object is
+     * created to represent this file connection.
+     * <p>
+     * First, if there is a security manager, its <code>checkWrite</code>
+     * method is called with <code>name</code> as its argument.
+     * <p>
+     * If the file exists but is a directory rather than a regular file, does
+     * not exist but cannot be created, or cannot be opened for any other
+     * reason then a <code>FileNotFoundException</code> is thrown.
+     *
+     * @param      name   the system-dependent filename
+     * @exception  FileNotFoundException  if the file exists but is a directory
+     *                   rather than a regular file, does not exist but cannot
+     *                   be created, or cannot be opened for any other reason
+     * @exception  SecurityException  if a security manager exists and its
+     *               <code>checkWrite</code> method denies write access
+     *               to the file.
+     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+     */
+    public FileOutputStream(String name) throws FileNotFoundException {
+        this(name != null ? new File(name) : null, false);
+    }
+
+    /**
+     * Creates a file output stream to write to the file with the specified
+     * name.  If the second argument is <code>true</code>, then
+     * bytes will be written to the end of the file rather than the beginning.
+     * A new <code>FileDescriptor</code> object is created to represent this
+     * file connection.
+     * <p>
+     * First, if there is a security manager, its <code>checkWrite</code>
+     * method is called with <code>name</code> as its argument.
+     * <p>
+     * If the file exists but is a directory rather than a regular file, does
+     * not exist but cannot be created, or cannot be opened for any other
+     * reason then a <code>FileNotFoundException</code> is thrown.
+     *
+     * @param     name        the system-dependent file name
+     * @param     append      if <code>true</code>, then bytes will be written
+     *                   to the end of the file rather than the beginning
+     * @exception  FileNotFoundException  if the file exists but is a directory
+     *                   rather than a regular file, does not exist but cannot
+     *                   be created, or cannot be opened for any other reason.
+     * @exception  SecurityException  if a security manager exists and its
+     *               <code>checkWrite</code> method denies write access
+     *               to the file.
+     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+     * @since     JDK1.1
+     */
+    public FileOutputStream(String name, boolean append)
+        throws FileNotFoundException
+    {
+        this(name != null ? new File(name) : null, append);
+    }
+
+    /**
+     * Creates a file output stream to write to the file represented by
+     * the specified <code>File</code> object. A new
+     * <code>FileDescriptor</code> object is created to represent this
+     * file connection.
+     * <p>
+     * First, if there is a security manager, its <code>checkWrite</code>
+     * method is called with the path represented by the <code>file</code>
+     * argument as its argument.
+     * <p>
+     * If the file exists but is a directory rather than a regular file, does
+     * not exist but cannot be created, or cannot be opened for any other
+     * reason then a <code>FileNotFoundException</code> is thrown.
+     *
+     * @param      file               the file to be opened for writing.
+     * @exception  FileNotFoundException  if the file exists but is a directory
+     *                   rather than a regular file, does not exist but cannot
+     *                   be created, or cannot be opened for any other reason
+     * @exception  SecurityException  if a security manager exists and its
+     *               <code>checkWrite</code> method denies write access
+     *               to the file.
+     * @see        java.io.File#getPath()
+     * @see        java.lang.SecurityException
+     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+     */
+    public FileOutputStream(File file) throws FileNotFoundException {
+        this(file, false);
+    }
+
+    /**
+     * Creates a file output stream to write to the file represented by
+     * the specified <code>File</code> object. If the second argument is
+     * <code>true</code>, then bytes will be written to the end of the file
+     * rather than the beginning. A new <code>FileDescriptor</code> object is
+     * created to represent this file connection.
+     * <p>
+     * First, if there is a security manager, its <code>checkWrite</code>
+     * method is called with the path represented by the <code>file</code>
+     * argument as its argument.
+     * <p>
+     * If the file exists but is a directory rather than a regular file, does
+     * not exist but cannot be created, or cannot be opened for any other
+     * reason then a <code>FileNotFoundException</code> is thrown.
+     *
+     * @param      file               the file to be opened for writing.
+     * @param     append      if <code>true</code>, then bytes will be written
+     *                   to the end of the file rather than the beginning
+     * @exception  FileNotFoundException  if the file exists but is a directory
+     *                   rather than a regular file, does not exist but cannot
+     *                   be created, or cannot be opened for any other reason
+     * @exception  SecurityException  if a security manager exists and its
+     *               <code>checkWrite</code> method denies write access
+     *               to the file.
+     * @see        java.io.File#getPath()
+     * @see        java.lang.SecurityException
+     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+     * @since 1.4
+     */
+    public FileOutputStream(File file, boolean append)
+        throws FileNotFoundException
+    {
+        String name = (file != null ? file.getPath() : null);
+        SecurityManager security = System.getSecurityManager();
+        if (security != null) {
+            security.checkWrite(name);
+        }
+        if (name == null) {
+            throw new NullPointerException();
+        }
+        fd = new FileDescriptor();
+        fd.incrementAndGetUseCount();
+        if(append)
+            openAppend(name);
+        else
+            openAppend(name);
+    }
+
+    /**
+     * Creates a file output stream to write to the specified file
+     * descriptor, which represents an existing connection to an actual
+     * file in the file system.
+     * <p>
+     * First, if there is a security manager, its <code>checkWrite</code>
+     * method is called with the file descriptor <code>fdObj</code>
+     * argument as its argument.
+     * <p>
+     * If <code>fdObj</code> is null then a <code>NullPointerException</code>
+     * is thrown.
+     * <p>
+     * This constructor does not throw an exception if <code>fdObj</code>
+     * is {@link java.io.FileDescriptor#valid() invalid}.
+     * However, if the methods are invoked on the resulting stream to attempt
+     * I/O on the stream, an <code>IOException</code> is thrown.
+     *
+     * @param      fdObj   the file descriptor to be opened for writing
+     * @exception  SecurityException  if a security manager exists and its
+     *               <code>checkWrite</code> method denies
+     *               write access to the file descriptor
+     * @see        java.lang.SecurityManager#checkWrite(java.io.FileDescriptor)
+     */
+    public FileOutputStream(FileDescriptor fdObj) {
+        SecurityManager security = System.getSecurityManager();
+        if (fdObj == null) {
+            throw new NullPointerException();
+        }
+        if (security != null) {
+            security.checkWrite(fdObj);
+        }
+        fd = fdObj;
+
+        /*
+         * FileDescriptor is being shared by streams.
+         * Ensure that it's GC'ed only when all the streams/channels are done
+         * using it.
+         */
+        fd.incrementAndGetUseCount();
+    }
+
+    /**
+     * Opens a file, with the specified name, for overwriting or appending.
+     * @param name name of file to be opened
+     * @param append whether the file is to be opened in append mode
+     */
+    private native void open(String name)
+        throws FileNotFoundException;
+
+    private native void openAppend(String name)
+        throws FileNotFoundException;
+
+    /**
+     * Writes the specified byte to this file output stream. Implements
+     * the <code>write</code> method of <code>OutputStream</code>.
+     *
+     * @param      b   the byte to be written.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public native void write(int b) throws IOException;
+
+    /**
+     * Writes a sub array as a sequence of bytes.
+     * @param b the data to be written
+     * @param off the start offset in the data
+     * @param len the number of bytes that are written
+     * @exception IOException If an I/O error has occurred.
+     */
+    private native void writeBytes(byte b[], int off, int len) throws IOException;
+
+    /**
+     * Writes <code>b.length</code> bytes from the specified byte array
+     * to this file output stream.
+     *
+     * @param      b   the data.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public void write(byte b[]) throws IOException {
+        writeBytes(b, 0, b.length);
+    }
+
+    /**
+     * Writes <code>len</code> bytes from the specified byte array
+     * starting at offset <code>off</code> to this file output stream.
+     *
+     * @param      b     the data.
+     * @param      off   the start offset in the data.
+     * @param      len   the number of bytes to write.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public void write(byte b[], int off, int len) throws IOException {
+        writeBytes(b, off, len);
+    }
+
+    /**
+     * Closes this file output stream and releases any system resources
+     * associated with this stream. This file output stream may no longer
+     * be used for writing bytes.
+     *
+     * <p> If this stream has an associated channel then the channel is closed
+     * as well.
+     *
+     * @exception  IOException  if an I/O error occurs.
+     *
+     * @revised 1.4
+     * @spec JSR-51
+     */
+    public void close() throws IOException {
+        synchronized (closeLock) {
+            if (closed) {
+                return;
+            }
+            closed = true;
+        }
+
+        if (channel != null) {
+            /*
+             * Decrement FD use count associated with the channel
+             * The use count is incremented whenever a new channel
+             * is obtained from this stream.
+             */
+            fd.decrementAndGetUseCount();
+            channel.close();
+        }
+
+        /*
+         * Decrement FD use count associated with this stream
+         */
+        int useCount = fd.decrementAndGetUseCount();
+
+        /*
+         * If FileDescriptor is still in use by another stream, the finalizer
+         * will not close it.
+         */
+        if ((useCount <= 0) || !isRunningFinalize()) {
+            close0();
+        }
+    }
+
+    /**
+     * Returns the file descriptor associated with this stream.
+     *
+     * @return  the <code>FileDescriptor</code> object that represents
+     *          the connection to the file in the file system being used
+     *          by this <code>FileOutputStream</code> object.
+     *
+     * @exception  IOException  if an I/O error occurs.
+     * @see        java.io.FileDescriptor
+     */
+     public final FileDescriptor getFD()  throws IOException {
+        if (fd != null) return fd;
+        throw new IOException();
+     }
+
+    /**
+     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
+     * object associated with this file output stream. </p>
+     *
+     * <p> The initial {@link java.nio.channels.FileChannel#position()
+     * </code>position<code>} of the returned channel will be equal to the
+     * number of bytes written to the file so far unless this stream is in
+     * append mode, in which case it will be equal to the size of the file.
+     * Writing bytes to this stream will increment the channel's position
+     * accordingly.  Changing the channel's position, either explicitly or by
+     * writing, will change this stream's file position.
+     *
+     * @return  the file channel associated with this file output stream
+     *
+     * @since 1.4
+     * @spec JSR-51
+     */
+    public FileChannel getChannel() {
+        synchronized (this) {
+            if (channel == null) {
+                channel = FileChannelImpl.open(fd, false, true, this);
+
+                /*
+                 * Increment fd's use count. Invoking the channel's close()
+                 * method will result in decrementing the use count set for
+                 * the channel.
+                 */
+                fd.incrementAndGetUseCount();
+            }
+            return channel;
+        }
+    }
+
+    /**
+     * Cleans up the connection to the file, and ensures that the
+     * <code>close</code> method of this file output stream is
+     * called when there are no more references to this stream.
+     *
+     * @exception  IOException  if an I/O error occurs.
+     * @see        java.io.FileInputStream#close()
+     */
+    protected void finalize() throws IOException {
+        if (fd != null) {
+            if (fd == FileDescriptor.out || fd == FileDescriptor.err) {
+                flush();
+            } else {
+
+                /*
+                 * Finalizer should not release the FileDescriptor if another
+                 * stream is still using it. If the user directly invokes
+                 * close() then the FileDescriptor is also released.
+                 */
+                runningFinalize.set(Boolean.TRUE);
+                try {
+                    close();
+                } finally {
+                    runningFinalize.set(Boolean.FALSE);
+                }
+            }
+        }
+    }
+
+    private native void close0() throws IOException;
+
+    private static native void initIDs();
+
+    static {
+        initIDs();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileOutputStream.java.orig phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileOutputStream.java.orig
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileOutputStream.java.orig	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileOutputStream.java.orig	2009-07-06 18:37:34.000000000 -0400
@@ -0,0 +1,363 @@
+/*
+ * @(#)FileOutputStream.java	1.54 06/10/10
+ *
+ * Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.  
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+ *   
+ * This program is free software; you can redistribute it and/or  
+ * modify it under the terms of the GNU General Public License version  
+ * 2 only, as published by the Free Software Foundation.   
+ *   
+ * This program is distributed in the hope that it will be useful, but  
+ * WITHOUT ANY WARRANTY; without even the implied warranty of  
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+ * General Public License version 2 for more details (a copy is  
+ * included at /legal/license.txt).   
+ *   
+ * You should have received a copy of the GNU General Public License  
+ * version 2 along with this work; if not, write to the Free Software  
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+ * 02110-1301 USA   
+ *   
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+ * Clara, CA 95054 or visit www.sun.com if you need additional  
+ * information or have any questions. 
+ *
+ */
+
+package java.io;
+
+
+
+/**
+ * A file output stream is an output stream for writing data to a 
+ * <code>File</code> or to a <code>FileDescriptor</code>. Whether or not
+ * a file is available or may be created depends upon the underlying
+ * platform.  Some platforms, in particular, allow a file to be opened
+ * for writing by only one <tt>FileOutputStream</tt> (or other
+ * file-writing object) at a time.  In such situations the constructors in
+ * this class will fail if the file involved is already open.
+ *
+ * <p><code>FileOutputStream</code> is meant for writing streams of raw bytes
+ * such as image data. For writing streams of characters, consider using
+ * <code>FileWriter</code>.
+ *
+ * @version 1.39, 02/02/00
+ * @see     java.io.File
+ * @see     java.io.FileDescriptor
+ * @see     java.io.FileInputStream
+ * @since   JDK1.0
+ */
+public
+class FileOutputStream extends OutputStream
+{
+    /**
+     * The system dependent file descriptor. The value is
+     * 1 more than actual file descriptor. This means that
+     * the default value 0 indicates that the file is not open.
+     */
+    private FileDescriptor fd;
+
+    private boolean append = false;
+
+    /**
+     * Creates an output file stream to write to the file with the 
+     * specified name. A new <code>FileDescriptor</code> object is 
+     * created to represent this file connection.
+     * <p>
+     * First, if there is a security manager, its <code>checkWrite</code> 
+     * method is called with <code>name</code> as its argument.
+     * <p>
+     * If the file exists but is a directory rather than a regular file, does
+     * not exist but cannot be created, or cannot be opened for any other
+     * reason then a <code>FileNotFoundException</code> is thrown.
+     *
+     * @param      name   the system-dependent filename
+     * @exception  FileNotFoundException  if the file exists but is a directory
+     *                   rather than a regular file, does not exist but cannot
+     *                   be created, or cannot be opened for any other reason
+     * @exception  SecurityException  if a security manager exists and its
+     *               <code>checkWrite</code> method denies write access
+     *               to the file.
+     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+     */
+    public FileOutputStream(String name) throws FileNotFoundException {
+	this(name != null ? new File(name) : null, false);
+    }
+
+    /**
+     * Creates an output file stream to write to the file with the specified
+     * <code>name</code>.  If the second argument is <code>true</code>, then
+     * bytes will be written to the end of the file rather than the beginning.
+     * A new <code>FileDescriptor</code> object is created to represent this
+     * file connection.
+     * <p>
+     * First, if there is a security manager, its <code>checkWrite</code> 
+     * method is called with <code>name</code> as its argument.
+     * <p>
+     * If the file exists but is a directory rather than a regular file, does
+     * not exist but cannot be created, or cannot be opened for any other
+     * reason then a <code>FileNotFoundException</code> is thrown.
+     * 
+     * @param     name        the system-dependent file name
+     * @param     append      if <code>true</code>, then bytes will be written
+     *                   to the end of the file rather than the beginning
+     * @exception  FileNotFoundException  if the file exists but is a directory
+     *                   rather than a regular file, does not exist but cannot
+     *                   be created, or cannot be opened for any other reason.
+     * @exception  SecurityException  if a security manager exists and its
+     *               <code>checkWrite</code> method denies write access
+     *               to the file.
+     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+     * @since     JDK1.1
+     */
+    public FileOutputStream(String name, boolean append)
+        throws FileNotFoundException
+    {
+        this(name != null ? new File(name) : null, append);
+    }
+
+    /**
+     * Creates a file output stream to write to the file represented by 
+     * the specified <code>File</code> object. A new 
+     * <code>FileDescriptor</code> object is created to represent this 
+     * file connection.
+     * <p>
+     * First, if there is a security manager, its <code>checkWrite</code> 
+     * method is called with the path represented by the <code>file</code> 
+     * argument as its argument.
+     * <p>
+     * If the file exists but is a directory rather than a regular file, does
+     * not exist but cannot be created, or cannot be opened for any other
+     * reason then a <code>FileNotFoundException</code> is thrown.
+     *
+     * @param      file               the file to be opened for writing.
+     * @exception  FileNotFoundException  if the file exists but is a directory
+     *                   rather than a regular file, does not exist but cannot
+     *                   be created, or cannot be opened for any other reason
+     * @exception  SecurityException  if a security manager exists and its
+     *               <code>checkWrite</code> method denies write access
+     *               to the file.
+     * @see        java.io.File#getPath()
+     * @see        java.lang.SecurityException
+     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+     */
+    public FileOutputStream(File file) throws FileNotFoundException {
+	this(file, false);
+    }
+
+    /**
+     * Creates a file output stream to write to the file represented by 
+     * the specified <code>File</code> object. If the second argument is
+     * <code>true</code>, then bytes will be written to the end of the file
+     * rather than the beginning. A new <code>FileDescriptor</code> object is
+     * created to represent this file connection.
+     * <p>
+     * First, if there is a security manager, its <code>checkWrite</code> 
+     * method is called with the path represented by the <code>file</code> 
+     * argument as its argument.
+     * <p>
+     * If the file exists but is a directory rather than a regular file, does
+     * not exist but cannot be created, or cannot be opened for any other
+     * reason then a <code>FileNotFoundException</code> is thrown.
+     *
+     * @param      file               the file to be opened for writing.
+     * @param     append      if <code>true</code>, then bytes will be written
+     *                   to the end of the file rather than the beginning
+     * @exception  FileNotFoundException  if the file exists but is a directory
+     *                   rather than a regular file, does not exist but cannot
+     *                   be created, or cannot be opened for any other reason
+     * @exception  SecurityException  if a security manager exists and its
+     *               <code>checkWrite</code> method denies write access
+     *               to the file.
+     * @see        java.io.File#getPath()
+     * @see        java.lang.SecurityException
+     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+     * @since 1.4
+     */
+    public FileOutputStream(File file, boolean append)
+        throws FileNotFoundException
+    {
+        String name = (file != null ? file.getPath() : null);
+	SecurityManager security = System.getSecurityManager();
+	if (security != null) {
+	    security.checkWrite(name);
+	}
+        if (name == null) {
+            throw new NullPointerException();
+        }
+	fd = new FileDescriptor();
+        this.append = append;
+	if (append) {
+	    openAppend(name);
+	} else {
+	    open(name);
+	}
+    }
+
+    /**
+     * Creates an output file stream to write to the specified file 
+     * descriptor, which represents an existing connection to an actual 
+     * file in the file system.
+     * <p>
+     * First, if there is a security manager, its <code>checkWrite</code> 
+     * method is called with the file descriptor <code>fdObj</code> 
+     * argument as its argument.
+     *
+     * @param      fdObj   the file descriptor to be opened for writing
+     * @exception  SecurityException  if a security manager exists and its
+     *               <code>checkWrite</code> method denies
+     *               write access to the file descriptor
+     * @see        java.lang.SecurityManager#checkWrite(java.io.FileDescriptor)
+     */
+    public FileOutputStream(FileDescriptor fdObj) {
+	SecurityManager security = System.getSecurityManager();
+	if (fdObj == null) {
+	    throw new NullPointerException();
+	}
+	if (security != null) {
+	    security.checkWrite(fdObj);
+	}
+	fd = fdObj;
+    }
+
+    /**
+     * Opens a file, with the specified name, for writing.
+     * @param name name of file to be opened
+     */
+    private native void open(String name) throws FileNotFoundException;
+
+    /**
+     * Opens a file, with the specified name, for appending.
+     * @param name name of file to be opened
+     */
+    private native void openAppend(String name) throws FileNotFoundException;
+
+    /**
+     * Writes the specified byte to this file output stream. Implements 
+     * the <code>write</code> method of <code>OutputStream</code>.
+     *
+     * @param      b   the byte to be written.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public native void write(int b) throws IOException;
+
+    /**
+     * Writes a sub array as a sequence of bytes.
+     * @param b the data to be written
+     * @param off the start offset in the data
+     * @param len the number of bytes that are written
+     * @exception IOException If an I/O error has occurred.
+     */
+    private native void writeBytes(byte b[], int off, int len) throws IOException;
+
+    /**
+     * Writes <code>b.length</code> bytes from the specified byte array 
+     * to this file output stream. 
+     *
+     * @param      b   the data.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public void write(byte b[]) throws IOException {
+	writeBytes(b, 0, b.length);
+    }
+
+    /**
+     * Writes <code>len</code> bytes from the specified byte array 
+     * starting at offset <code>off</code> to this file output stream. 
+     *
+     * @param      b     the data.
+     * @param      off   the start offset in the data.
+     * @param      len   the number of bytes to write.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public void write(byte b[], int off, int len) throws IOException {
+	writeBytes(b, off, len);
+    }
+
+    /**
+     * Closes this file output stream and releases any system resources 
+     * associated with this stream. This file output stream may no longer 
+     * be used for writing bytes. 
+     *
+     * <p> If this stream has an associated channel then the channel is closed
+     * as well.
+     *
+     * @exception  IOException  if an I/O error occurs.
+     *
+     * @revised 1.4
+     * @spec JSR-51
+     */
+    public void close() throws IOException {
+        close0();
+    }
+
+    /**
+     * Returns the file descriptor associated with this stream.
+     *
+     * @return  the <code>FileDescriptor</code> object that represents 
+     *          the connection to the file in the file system being used 
+     *          by this <code>FileOutputStream</code> object. 
+     * 
+     * @exception  IOException  if an I/O error occurs.
+     * @see        java.io.FileDescriptor
+     */
+     public final FileDescriptor getFD()  throws IOException {
+	if (fd != null) return fd;
+	throw new IOException();
+     }
+    
+    /**
+     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
+     * object associated with this file output stream. </p>
+     *
+     * <p> The initial {@link java.nio.channels.FileChannel#position()
+     * </code>position<code>} of the returned channel will be equal to the
+     * number of bytes written to the file so far unless this stream is in
+     * append mode, in which case it will be equal to the size of the file.
+     * Writing bytes to this stream will increment the channel's position
+     * accordingly.  Changing the channel's position, either explicitly or by
+     * writing, will change this stream's file position.
+     *
+     * @return  the file channel associated with this file output stream
+     *
+     * @since 1.4
+     * @spec JSR-51
+     */
+    /*
+    public FileChannel getChannel() {
+	synchronized (this) {
+	    if (channel == null)
+		channel = FileChannelImpl.open(fd, false, true, this, append);
+	    return channel;
+	}
+    }
+    */
+
+    /**
+     * Cleans up the connection to the file, and ensures that the 
+     * <code>close</code> method of this file output stream is
+     * called when there are no more references to this stream. 
+     *
+     * @exception  IOException  if an I/O error occurs.
+     * @see        java.io.FileInputStream#close()
+     */
+    protected void finalize() throws IOException {
+ 	if (fd != null) {
+ 	    if (fd == fd.out || fd == fd.err) {
+ 		flush();
+ 	    } else {
+ 		close();
+ 	    }
+ 	}
+    }
+
+    private native void close0() throws IOException;
+
+    private static native void initIDs();
+    
+    static {
+	initIDs();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileOutputStream.java.rej phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileOutputStream.java.rej
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/FileOutputStream.java.rej	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/FileOutputStream.java.rej	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,797 @@
+***************
+*** 1,363 ****
+- /*
+-  * @(#)FileOutputStream.java	1.54 06/10/10
+-  *
+-  * Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.  
+-  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+-  *   
+-  * This program is free software; you can redistribute it and/or  
+-  * modify it under the terms of the GNU General Public License version  
+-  * 2 only, as published by the Free Software Foundation.   
+-  *   
+-  * This program is distributed in the hope that it will be useful, but  
+-  * WITHOUT ANY WARRANTY; without even the implied warranty of  
+-  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+-  * General Public License version 2 for more details (a copy is  
+-  * included at /legal/license.txt).   
+-  *   
+-  * You should have received a copy of the GNU General Public License  
+-  * version 2 along with this work; if not, write to the Free Software  
+-  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+-  * 02110-1301 USA   
+-  *   
+-  * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+-  * Clara, CA 95054 or visit www.sun.com if you need additional  
+-  * information or have any questions. 
+-  *
+-  */
+- 
+- package java.io;
+- 
+- 
+- 
+- /**
+-  * A file output stream is an output stream for writing data to a 
+-  * <code>File</code> or to a <code>FileDescriptor</code>. Whether or not
+-  * a file is available or may be created depends upon the underlying
+-  * platform.  Some platforms, in particular, allow a file to be opened
+-  * for writing by only one <tt>FileOutputStream</tt> (or other
+-  * file-writing object) at a time.  In such situations the constructors in
+-  * this class will fail if the file involved is already open.
+-  *
+-  * <p><code>FileOutputStream</code> is meant for writing streams of raw bytes
+-  * such as image data. For writing streams of characters, consider using
+-  * <code>FileWriter</code>.
+-  *
+-  * @version 1.39, 02/02/00
+-  * @see     java.io.File
+-  * @see     java.io.FileDescriptor
+-  * @see     java.io.FileInputStream
+-  * @since   JDK1.0
+-  */
+- public
+- class FileOutputStream extends OutputStream
+- {
+-     /**
+-      * The system dependent file descriptor. The value is
+-      * 1 more than actual file descriptor. This means that
+-      * the default value 0 indicates that the file is not open.
+-      */
+-     private FileDescriptor fd;
+- 
+-     private boolean append = false;
+- 
+-     /**
+-      * Creates an output file stream to write to the file with the 
+-      * specified name. A new <code>FileDescriptor</code> object is 
+-      * created to represent this file connection.
+-      * <p>
+-      * First, if there is a security manager, its <code>checkWrite</code> 
+-      * method is called with <code>name</code> as its argument.
+-      * <p>
+-      * If the file exists but is a directory rather than a regular file, does
+-      * not exist but cannot be created, or cannot be opened for any other
+-      * reason then a <code>FileNotFoundException</code> is thrown.
+-      *
+-      * @param      name   the system-dependent filename
+-      * @exception  FileNotFoundException  if the file exists but is a directory
+-      *                   rather than a regular file, does not exist but cannot
+-      *                   be created, or cannot be opened for any other reason
+-      * @exception  SecurityException  if a security manager exists and its
+-      *               <code>checkWrite</code> method denies write access
+-      *               to the file.
+-      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+-      */
+-     public FileOutputStream(String name) throws FileNotFoundException {
+- 	this(name != null ? new File(name) : null, false);
+-     }
+- 
+-     /**
+-      * Creates an output file stream to write to the file with the specified
+-      * <code>name</code>.  If the second argument is <code>true</code>, then
+-      * bytes will be written to the end of the file rather than the beginning.
+-      * A new <code>FileDescriptor</code> object is created to represent this
+-      * file connection.
+-      * <p>
+-      * First, if there is a security manager, its <code>checkWrite</code> 
+-      * method is called with <code>name</code> as its argument.
+-      * <p>
+-      * If the file exists but is a directory rather than a regular file, does
+-      * not exist but cannot be created, or cannot be opened for any other
+-      * reason then a <code>FileNotFoundException</code> is thrown.
+-      * 
+-      * @param     name        the system-dependent file name
+-      * @param     append      if <code>true</code>, then bytes will be written
+-      *                   to the end of the file rather than the beginning
+-      * @exception  FileNotFoundException  if the file exists but is a directory
+-      *                   rather than a regular file, does not exist but cannot
+-      *                   be created, or cannot be opened for any other reason.
+-      * @exception  SecurityException  if a security manager exists and its
+-      *               <code>checkWrite</code> method denies write access
+-      *               to the file.
+-      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+-      * @since     JDK1.1
+-      */
+-     public FileOutputStream(String name, boolean append)
+-         throws FileNotFoundException
+-     {
+-         this(name != null ? new File(name) : null, append);
+-     }
+- 
+-     /**
+-      * Creates a file output stream to write to the file represented by 
+-      * the specified <code>File</code> object. A new 
+-      * <code>FileDescriptor</code> object is created to represent this 
+-      * file connection.
+-      * <p>
+-      * First, if there is a security manager, its <code>checkWrite</code> 
+-      * method is called with the path represented by the <code>file</code> 
+-      * argument as its argument.
+-      * <p>
+-      * If the file exists but is a directory rather than a regular file, does
+-      * not exist but cannot be created, or cannot be opened for any other
+-      * reason then a <code>FileNotFoundException</code> is thrown.
+-      *
+-      * @param      file               the file to be opened for writing.
+-      * @exception  FileNotFoundException  if the file exists but is a directory
+-      *                   rather than a regular file, does not exist but cannot
+-      *                   be created, or cannot be opened for any other reason
+-      * @exception  SecurityException  if a security manager exists and its
+-      *               <code>checkWrite</code> method denies write access
+-      *               to the file.
+-      * @see        java.io.File#getPath()
+-      * @see        java.lang.SecurityException
+-      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+-      */
+-     public FileOutputStream(File file) throws FileNotFoundException {
+- 	this(file, false);
+-     }
+- 
+-     /**
+-      * Creates a file output stream to write to the file represented by 
+-      * the specified <code>File</code> object. If the second argument is
+-      * <code>true</code>, then bytes will be written to the end of the file
+-      * rather than the beginning. A new <code>FileDescriptor</code> object is
+-      * created to represent this file connection.
+-      * <p>
+-      * First, if there is a security manager, its <code>checkWrite</code> 
+-      * method is called with the path represented by the <code>file</code> 
+-      * argument as its argument.
+-      * <p>
+-      * If the file exists but is a directory rather than a regular file, does
+-      * not exist but cannot be created, or cannot be opened for any other
+-      * reason then a <code>FileNotFoundException</code> is thrown.
+-      *
+-      * @param      file               the file to be opened for writing.
+-      * @param     append      if <code>true</code>, then bytes will be written
+-      *                   to the end of the file rather than the beginning
+-      * @exception  FileNotFoundException  if the file exists but is a directory
+-      *                   rather than a regular file, does not exist but cannot
+-      *                   be created, or cannot be opened for any other reason
+-      * @exception  SecurityException  if a security manager exists and its
+-      *               <code>checkWrite</code> method denies write access
+-      *               to the file.
+-      * @see        java.io.File#getPath()
+-      * @see        java.lang.SecurityException
+-      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+-      * @since 1.4
+-      */
+-     public FileOutputStream(File file, boolean append)
+-         throws FileNotFoundException
+-     {
+-         String name = (file != null ? file.getPath() : null);
+- 	SecurityManager security = System.getSecurityManager();
+- 	if (security != null) {
+- 	    security.checkWrite(name);
+- 	}
+-         if (name == null) {
+-             throw new NullPointerException();
+-         }
+- 	fd = new FileDescriptor();
+-         this.append = append;
+- 	if (append) {
+- 	    openAppend(name);
+- 	} else {
+- 	    open(name);
+- 	}
+-     }
+- 
+-     /**
+-      * Creates an output file stream to write to the specified file 
+-      * descriptor, which represents an existing connection to an actual 
+-      * file in the file system.
+-      * <p>
+-      * First, if there is a security manager, its <code>checkWrite</code> 
+-      * method is called with the file descriptor <code>fdObj</code> 
+-      * argument as its argument.
+-      *
+-      * @param      fdObj   the file descriptor to be opened for writing
+-      * @exception  SecurityException  if a security manager exists and its
+-      *               <code>checkWrite</code> method denies
+-      *               write access to the file descriptor
+-      * @see        java.lang.SecurityManager#checkWrite(java.io.FileDescriptor)
+-      */
+-     public FileOutputStream(FileDescriptor fdObj) {
+- 	SecurityManager security = System.getSecurityManager();
+- 	if (fdObj == null) {
+- 	    throw new NullPointerException();
+- 	}
+- 	if (security != null) {
+- 	    security.checkWrite(fdObj);
+- 	}
+- 	fd = fdObj;
+-     }
+- 
+-     /**
+-      * Opens a file, with the specified name, for writing.
+-      * @param name name of file to be opened
+-      */
+-     private native void open(String name) throws FileNotFoundException;
+- 
+-     /**
+-      * Opens a file, with the specified name, for appending.
+-      * @param name name of file to be opened
+-      */
+-     private native void openAppend(String name) throws FileNotFoundException;
+- 
+-     /**
+-      * Writes the specified byte to this file output stream. Implements 
+-      * the <code>write</code> method of <code>OutputStream</code>.
+-      *
+-      * @param      b   the byte to be written.
+-      * @exception  IOException  if an I/O error occurs.
+-      */
+-     public native void write(int b) throws IOException;
+- 
+-     /**
+-      * Writes a sub array as a sequence of bytes.
+-      * @param b the data to be written
+-      * @param off the start offset in the data
+-      * @param len the number of bytes that are written
+-      * @exception IOException If an I/O error has occurred.
+-      */
+-     private native void writeBytes(byte b[], int off, int len) throws IOException;
+- 
+-     /**
+-      * Writes <code>b.length</code> bytes from the specified byte array 
+-      * to this file output stream. 
+-      *
+-      * @param      b   the data.
+-      * @exception  IOException  if an I/O error occurs.
+-      */
+-     public void write(byte b[]) throws IOException {
+- 	writeBytes(b, 0, b.length);
+-     }
+- 
+-     /**
+-      * Writes <code>len</code> bytes from the specified byte array 
+-      * starting at offset <code>off</code> to this file output stream. 
+-      *
+-      * @param      b     the data.
+-      * @param      off   the start offset in the data.
+-      * @param      len   the number of bytes to write.
+-      * @exception  IOException  if an I/O error occurs.
+-      */
+-     public void write(byte b[], int off, int len) throws IOException {
+- 	writeBytes(b, off, len);
+-     }
+- 
+-     /**
+-      * Closes this file output stream and releases any system resources 
+-      * associated with this stream. This file output stream may no longer 
+-      * be used for writing bytes. 
+-      *
+-      * <p> If this stream has an associated channel then the channel is closed
+-      * as well.
+-      *
+-      * @exception  IOException  if an I/O error occurs.
+-      *
+-      * @revised 1.4
+-      * @spec JSR-51
+-      */
+-     public void close() throws IOException {
+-         close0();
+-     }
+- 
+-     /**
+-      * Returns the file descriptor associated with this stream.
+-      *
+-      * @return  the <code>FileDescriptor</code> object that represents 
+-      *          the connection to the file in the file system being used 
+-      *          by this <code>FileOutputStream</code> object. 
+-      * 
+-      * @exception  IOException  if an I/O error occurs.
+-      * @see        java.io.FileDescriptor
+-      */
+-      public final FileDescriptor getFD()  throws IOException {
+- 	if (fd != null) return fd;
+- 	throw new IOException();
+-      }
+-     
+-     /**
+-      * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
+-      * object associated with this file output stream. </p>
+-      *
+-      * <p> The initial {@link java.nio.channels.FileChannel#position()
+-      * </code>position<code>} of the returned channel will be equal to the
+-      * number of bytes written to the file so far unless this stream is in
+-      * append mode, in which case it will be equal to the size of the file.
+-      * Writing bytes to this stream will increment the channel's position
+-      * accordingly.  Changing the channel's position, either explicitly or by
+-      * writing, will change this stream's file position.
+-      *
+-      * @return  the file channel associated with this file output stream
+-      *
+-      * @since 1.4
+-      * @spec JSR-51
+-      */
+-     /*
+-     public FileChannel getChannel() {
+- 	synchronized (this) {
+- 	    if (channel == null)
+- 		channel = FileChannelImpl.open(fd, false, true, this, append);
+- 	    return channel;
+- 	}
+-     }
+-     */
+- 
+-     /**
+-      * Cleans up the connection to the file, and ensures that the 
+-      * <code>close</code> method of this file output stream is
+-      * called when there are no more references to this stream. 
+-      *
+-      * @exception  IOException  if an I/O error occurs.
+-      * @see        java.io.FileInputStream#close()
+-      */
+-     protected void finalize() throws IOException {
+-  	if (fd != null) {
+-  	    if (fd == fd.out || fd == fd.err) {
+-  		flush();
+-  	    } else {
+-  		close();
+-  	    }
+-  	}
+-     }
+- 
+-     private native void close0() throws IOException;
+- 
+-     private static native void initIDs();
+-     
+-     static {
+- 	initIDs();
+-     }
+- 
+- }
+--- 1,431 ----
++ /*
++  * Copyright 1994-2008 Sun Microsystems, Inc.  All Rights Reserved.
++  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++  *
++  * This code is free software; you can redistribute it and/or modify it
++  * under the terms of the GNU General Public License version 2 only, as
++  * published by the Free Software Foundation.  Sun designates this
++  * particular file as subject to the "Classpath" exception as provided
++  * by Sun in the LICENSE file that accompanied this code.
++  *
++  * This code is distributed in the hope that it will be useful, but WITHOUT
++  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++  * version 2 for more details (a copy is included in the LICENSE file that
++  * accompanied this code).
++  *
++  * You should have received a copy of the GNU General Public License version
++  * 2 along with this work; if not, write to the Free Software Foundation,
++  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
++  *
++  * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
++  * CA 95054 USA or visit www.sun.com if you need additional information or
++  * have any questions.
++  */
++ 
++ package java.io;
++ 
++ import java.nio.channels.FileChannel;
++ import sun.nio.ch.FileChannelImpl;
++ 
++ 
++ /**
++  * A file output stream is an output stream for writing data to a
++  * <code>File</code> or to a <code>FileDescriptor</code>. Whether or not
++  * a file is available or may be created depends upon the underlying
++  * platform.  Some platforms, in particular, allow a file to be opened
++  * for writing by only one <tt>FileOutputStream</tt> (or other
++  * file-writing object) at a time.  In such situations the constructors in
++  * this class will fail if the file involved is already open.
++  *
++  * <p><code>FileOutputStream</code> is meant for writing streams of raw bytes
++  * such as image data. For writing streams of characters, consider using
++  * <code>FileWriter</code>.
++  *
++  * @author  Arthur van Hoff
++  * @see     java.io.File
++  * @see     java.io.FileDescriptor
++  * @see     java.io.FileInputStream
++  * @since   JDK1.0
++  */
++ public
++ class FileOutputStream extends OutputStream
++ {
++     /**
++      * The system dependent file descriptor.
++      */
++     private final FileDescriptor fd;
++ 
++     private FileChannel channel= null;
++ 
++     private final Object closeLock = new Object();
++     private volatile boolean closed = false;
++     private static final ThreadLocal runningFinalize =
++         new ThreadLocal();
++ 
++     private static boolean isRunningFinalize() {
++         Boolean val;
++         if ((val = (Boolean)runningFinalize.get()) != null)
++             return val.booleanValue();
++         return false;
++     }
++ 
++     /**
++      * Creates a file output stream to write to the file with the
++      * specified name. A new <code>FileDescriptor</code> object is
++      * created to represent this file connection.
++      * <p>
++      * First, if there is a security manager, its <code>checkWrite</code>
++      * method is called with <code>name</code> as its argument.
++      * <p>
++      * If the file exists but is a directory rather than a regular file, does
++      * not exist but cannot be created, or cannot be opened for any other
++      * reason then a <code>FileNotFoundException</code> is thrown.
++      *
++      * @param      name   the system-dependent filename
++      * @exception  FileNotFoundException  if the file exists but is a directory
++      *                   rather than a regular file, does not exist but cannot
++      *                   be created, or cannot be opened for any other reason
++      * @exception  SecurityException  if a security manager exists and its
++      *               <code>checkWrite</code> method denies write access
++      *               to the file.
++      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
++      */
++     public FileOutputStream(String name) throws FileNotFoundException {
++         this(name != null ? new File(name) : null, false);
++     }
++ 
++     /**
++      * Creates a file output stream to write to the file with the specified
++      * name.  If the second argument is <code>true</code>, then
++      * bytes will be written to the end of the file rather than the beginning.
++      * A new <code>FileDescriptor</code> object is created to represent this
++      * file connection.
++      * <p>
++      * First, if there is a security manager, its <code>checkWrite</code>
++      * method is called with <code>name</code> as its argument.
++      * <p>
++      * If the file exists but is a directory rather than a regular file, does
++      * not exist but cannot be created, or cannot be opened for any other
++      * reason then a <code>FileNotFoundException</code> is thrown.
++      *
++      * @param     name        the system-dependent file name
++      * @param     append      if <code>true</code>, then bytes will be written
++      *                   to the end of the file rather than the beginning
++      * @exception  FileNotFoundException  if the file exists but is a directory
++      *                   rather than a regular file, does not exist but cannot
++      *                   be created, or cannot be opened for any other reason.
++      * @exception  SecurityException  if a security manager exists and its
++      *               <code>checkWrite</code> method denies write access
++      *               to the file.
++      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
++      * @since     JDK1.1
++      */
++     public FileOutputStream(String name, boolean append)
++         throws FileNotFoundException
++     {
++         this(name != null ? new File(name) : null, append);
++     }
++ 
++     /**
++      * Creates a file output stream to write to the file represented by
++      * the specified <code>File</code> object. A new
++      * <code>FileDescriptor</code> object is created to represent this
++      * file connection.
++      * <p>
++      * First, if there is a security manager, its <code>checkWrite</code>
++      * method is called with the path represented by the <code>file</code>
++      * argument as its argument.
++      * <p>
++      * If the file exists but is a directory rather than a regular file, does
++      * not exist but cannot be created, or cannot be opened for any other
++      * reason then a <code>FileNotFoundException</code> is thrown.
++      *
++      * @param      file               the file to be opened for writing.
++      * @exception  FileNotFoundException  if the file exists but is a directory
++      *                   rather than a regular file, does not exist but cannot
++      *                   be created, or cannot be opened for any other reason
++      * @exception  SecurityException  if a security manager exists and its
++      *               <code>checkWrite</code> method denies write access
++      *               to the file.
++      * @see        java.io.File#getPath()
++      * @see        java.lang.SecurityException
++      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
++      */
++     public FileOutputStream(File file) throws FileNotFoundException {
++         this(file, false);
++     }
++ 
++     /**
++      * Creates a file output stream to write to the file represented by
++      * the specified <code>File</code> object. If the second argument is
++      * <code>true</code>, then bytes will be written to the end of the file
++      * rather than the beginning. A new <code>FileDescriptor</code> object is
++      * created to represent this file connection.
++      * <p>
++      * First, if there is a security manager, its <code>checkWrite</code>
++      * method is called with the path represented by the <code>file</code>
++      * argument as its argument.
++      * <p>
++      * If the file exists but is a directory rather than a regular file, does
++      * not exist but cannot be created, or cannot be opened for any other
++      * reason then a <code>FileNotFoundException</code> is thrown.
++      *
++      * @param      file               the file to be opened for writing.
++      * @param     append      if <code>true</code>, then bytes will be written
++      *                   to the end of the file rather than the beginning
++      * @exception  FileNotFoundException  if the file exists but is a directory
++      *                   rather than a regular file, does not exist but cannot
++      *                   be created, or cannot be opened for any other reason
++      * @exception  SecurityException  if a security manager exists and its
++      *               <code>checkWrite</code> method denies write access
++      *               to the file.
++      * @see        java.io.File#getPath()
++      * @see        java.lang.SecurityException
++      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
++      * @since 1.4
++      */
++     public FileOutputStream(File file, boolean append)
++         throws FileNotFoundException
++     {
++         String name = (file != null ? file.getPath() : null);
++         SecurityManager security = System.getSecurityManager();
++         if (security != null) {
++             security.checkWrite(name);
++         }
++         if (name == null) {
++             throw new NullPointerException();
++         }
++         fd = new FileDescriptor();
++         fd.incrementAndGetUseCount();
++         if(append)
++             openAppend(name);
++         else
++             openAppend(name);
++     }
++ 
++     /**
++      * Creates a file output stream to write to the specified file
++      * descriptor, which represents an existing connection to an actual
++      * file in the file system.
++      * <p>
++      * First, if there is a security manager, its <code>checkWrite</code>
++      * method is called with the file descriptor <code>fdObj</code>
++      * argument as its argument.
++      * <p>
++      * If <code>fdObj</code> is null then a <code>NullPointerException</code>
++      * is thrown.
++      * <p>
++      * This constructor does not throw an exception if <code>fdObj</code>
++      * is {@link java.io.FileDescriptor#valid() invalid}.
++      * However, if the methods are invoked on the resulting stream to attempt
++      * I/O on the stream, an <code>IOException</code> is thrown.
++      *
++      * @param      fdObj   the file descriptor to be opened for writing
++      * @exception  SecurityException  if a security manager exists and its
++      *               <code>checkWrite</code> method denies
++      *               write access to the file descriptor
++      * @see        java.lang.SecurityManager#checkWrite(java.io.FileDescriptor)
++      */
++     public FileOutputStream(FileDescriptor fdObj) {
++         SecurityManager security = System.getSecurityManager();
++         if (fdObj == null) {
++             throw new NullPointerException();
++         }
++         if (security != null) {
++             security.checkWrite(fdObj);
++         }
++         fd = fdObj;
++ 
++         /*
++          * FileDescriptor is being shared by streams.
++          * Ensure that it's GC'ed only when all the streams/channels are done
++          * using it.
++          */
++         fd.incrementAndGetUseCount();
++     }
++ 
++     /**
++      * Opens a file, with the specified name, for overwriting or appending.
++      * @param name name of file to be opened
++      * @param append whether the file is to be opened in append mode
++      */
++     private native void open(String name)
++         throws FileNotFoundException;
++ 
++     private native void openAppend(String name)
++         throws FileNotFoundException;
++ 
++     /**
++      * Writes the specified byte to this file output stream. Implements
++      * the <code>write</code> method of <code>OutputStream</code>.
++      *
++      * @param      b   the byte to be written.
++      * @exception  IOException  if an I/O error occurs.
++      */
++     public native void write(int b) throws IOException;
++ 
++     /**
++      * Writes a sub array as a sequence of bytes.
++      * @param b the data to be written
++      * @param off the start offset in the data
++      * @param len the number of bytes that are written
++      * @exception IOException If an I/O error has occurred.
++      */
++     private native void writeBytes(byte b[], int off, int len) throws IOException;
++ 
++     /**
++      * Writes <code>b.length</code> bytes from the specified byte array
++      * to this file output stream.
++      *
++      * @param      b   the data.
++      * @exception  IOException  if an I/O error occurs.
++      */
++     public void write(byte b[]) throws IOException {
++         writeBytes(b, 0, b.length);
++     }
++ 
++     /**
++      * Writes <code>len</code> bytes from the specified byte array
++      * starting at offset <code>off</code> to this file output stream.
++      *
++      * @param      b     the data.
++      * @param      off   the start offset in the data.
++      * @param      len   the number of bytes to write.
++      * @exception  IOException  if an I/O error occurs.
++      */
++     public void write(byte b[], int off, int len) throws IOException {
++         writeBytes(b, off, len);
++     }
++ 
++     /**
++      * Closes this file output stream and releases any system resources
++      * associated with this stream. This file output stream may no longer
++      * be used for writing bytes.
++      *
++      * <p> If this stream has an associated channel then the channel is closed
++      * as well.
++      *
++      * @exception  IOException  if an I/O error occurs.
++      *
++      * @revised 1.4
++      * @spec JSR-51
++      */
++     public void close() throws IOException {
++         synchronized (closeLock) {
++             if (closed) {
++                 return;
++             }
++             closed = true;
++         }
++ 
++         if (channel != null) {
++             /*
++              * Decrement FD use count associated with the channel
++              * The use count is incremented whenever a new channel
++              * is obtained from this stream.
++              */
++             fd.decrementAndGetUseCount();
++             channel.close();
++         }
++ 
++         /*
++          * Decrement FD use count associated with this stream
++          */
++         int useCount = fd.decrementAndGetUseCount();
++ 
++         /*
++          * If FileDescriptor is still in use by another stream, the finalizer
++          * will not close it.
++          */
++         if ((useCount <= 0) || !isRunningFinalize()) {
++             close0();
++         }
++     }
++ 
++     /**
++      * Returns the file descriptor associated with this stream.
++      *
++      * @return  the <code>FileDescriptor</code> object that represents
++      *          the connection to the file in the file system being used
++      *          by this <code>FileOutputStream</code> object.
++      *
++      * @exception  IOException  if an I/O error occurs.
++      * @see        java.io.FileDescriptor
++      */
++      public final FileDescriptor getFD()  throws IOException {
++         if (fd != null) return fd;
++         throw new IOException();
++      }
++ 
++     /**
++      * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
++      * object associated with this file output stream. </p>
++      *
++      * <p> The initial {@link java.nio.channels.FileChannel#position()
++      * </code>position<code>} of the returned channel will be equal to the
++      * number of bytes written to the file so far unless this stream is in
++      * append mode, in which case it will be equal to the size of the file.
++      * Writing bytes to this stream will increment the channel's position
++      * accordingly.  Changing the channel's position, either explicitly or by
++      * writing, will change this stream's file position.
++      *
++      * @return  the file channel associated with this file output stream
++      *
++      * @since 1.4
++      * @spec JSR-51
++      */
++     public FileChannel getChannel() {
++         synchronized (this) {
++             if (channel == null) {
++                 channel = FileChannelImpl.open(fd, false, true, this);
++ 
++                 /*
++                  * Increment fd's use count. Invoking the channel's close()
++                  * method will result in decrementing the use count set for
++                  * the channel.
++                  */
++                 fd.incrementAndGetUseCount();
++             }
++             return channel;
++         }
++     }
++ 
++     /**
++      * Cleans up the connection to the file, and ensures that the
++      * <code>close</code> method of this file output stream is
++      * called when there are no more references to this stream.
++      *
++      * @exception  IOException  if an I/O error occurs.
++      * @see        java.io.FileInputStream#close()
++      */
++     protected void finalize() throws IOException {
++         if (fd != null) {
++             if (fd == FileDescriptor.out || fd == FileDescriptor.err) {
++                 flush();
++             } else {
++ 
++                 /*
++                  * Finalizer should not release the FileDescriptor if another
++                  * stream is still using it. If the user directly invokes
++                  * close() then the FileDescriptor is also released.
++                  */
++                 runningFinalize.set(Boolean.TRUE);
++                 try {
++                     close();
++                 } finally {
++                     runningFinalize.set(Boolean.FALSE);
++                 }
++             }
++         }
++     }
++ 
++     private native void close0() throws IOException;
++ 
++     private static native void initIDs();
++ 
++     static {
++         initIDs();
++     }
++ 
++ }
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/InputStream.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/InputStream.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/InputStream.java	2009-07-06 18:37:34.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/InputStream.java	2009-07-06 19:25:13.000000000 -0400
@@ -44,7 +44,7 @@
  * @see     java.io.PushbackInputStream
  * @since   JDK1.0
  */
-public abstract class InputStream {
+public abstract class InputStream implements Closeable {
 
     // SKIP_BUFFER_SIZE is used to determine the size of skipBuffer
     private static final int SKIP_BUFFER_SIZE = 2048;
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/OutputStream.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/OutputStream.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/io/OutputStream.java	2009-07-06 18:37:34.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/io/OutputStream.java	2009-07-06 19:25:13.000000000 -0400
@@ -45,7 +45,7 @@
  * @see     java.io.OutputStream#write(int)
  * @since   JDK1.0
  */
-public abstract class OutputStream {
+public abstract class OutputStream implements Closeable{
     /**
      * Writes the specified byte to this output stream. The general 
      * contract for <code>write</code> is that one byte is written 
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/lang/Appendable.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/lang/Appendable.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/lang/Appendable.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/lang/Appendable.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,104 @@
+/*
+ * @(#)Appendable.java	1.4 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package java.lang;
+
+import java.io.IOException;
+
+/**
+ * An object to which <tt>char</tt> sequences and values can be appended.  The
+ * <tt>Appendable</tt> interface must be implemented by any class whose
+ * instances are intended to receive formatted output from a {@link
+ * java.util.Formatter}.
+ *
+ * <p> The characters to be appended should be valid Unicode characters as
+ * described in <a href="Character.html#unicode">Unicode Character
+ * Representation</a>.  Note that supplementary characters may be composed of
+ * multiple 16-bit <tt>char</tt> values.
+ *
+ * <p> Appendables are not necessarily safe for multithreaded access.  Thread
+ * safety is the responsibility of classes that extend and implement this
+ * interface.
+ *
+ * <p> Since this interface may be implemented by existing classes
+ * with different styles of error handling there is no guarantee that
+ * errors will be propagated to the invoker.
+ *
+ * @version 	1.4, 11/17/05
+ * @since 1.5
+ */
+public interface Appendable {
+
+    /**
+     * Appends the specified character sequence to this <tt>Appendable</tt>.
+     *
+     * <p> Depending on which class implements the character sequence
+     * <tt>csq</tt>, the entire sequence may not be appended.  For
+     * instance, if <tt>csq</tt> is a {@link java.nio.CharBuffer} then
+     * the subsequence to append is defined by the buffer's position and limit.
+     *
+     * @param  csq
+     *         The character sequence to append.  If <tt>csq</tt> is
+     *         <tt>null</tt>, then the four characters <tt>"null"</tt> are
+     *         appended to this Appendable.
+     *
+     * @return  A reference to this <tt>Appendable</tt>
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     */
+    Appendable append(CharSequence csq) throws IOException;
+
+    /**
+     * Appends a subsequence of the specified character sequence to this
+     * <tt>Appendable</tt>.
+     *
+     * <p> An invocation of this method of the form <tt>out.append(csq, start,
+     * end)</tt> when <tt>csq</tt> is not <tt>null</tt>, behaves in
+     * exactly the same way as the invocation
+     *
+     * <pre>
+     *     out.append(csq.subSequence(start, end)) </pre>
+     *
+     * @param  csq
+     *         The character sequence from which a subsequence will be
+     *         appended.  If <tt>csq</tt> is <tt>null</tt>, then characters
+     *         will be appended as if <tt>csq</tt> contained the four
+     *         characters <tt>"null"</tt>.
+     *
+     * @param  start
+     *         The index of the first character in the subsequence
+     *
+     * @param  end
+     *         The index of the character following the last character in the
+     *         subsequence
+     *
+     * @return  A reference to this <tt>Appendable</tt>
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>start</tt> or <tt>end</tt> are negative, <tt>start</tt>
+     *          is greater than <tt>end</tt>, or <tt>end</tt> is greater than
+     *          <tt>csq.length()</tt>
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     */
+    Appendable append(CharSequence csq, int start, int end) throws IOException;
+
+    /**
+     * Appends the specified character to this <tt>Appendable</tt>.
+     *
+     * @param  c
+     *         The character to append
+     *
+     * @return  A reference to this <tt>Appendable</tt>
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     */
+    Appendable append(char c) throws IOException;
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/lang/Readable.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/lang/Readable.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/lang/Readable.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/lang/Readable.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,38 @@
+/*
+ * @(#)Readable.java	1.4 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package java.lang;
+
+import java.io.IOException;
+
+/**
+ * A <tt>Readable</tt> is a source of characters. Characters from
+ * a <tt>Readable</tt> are made available to callers of the read
+ * method via a {@link java.nio.CharBuffer CharBuffer}.
+ *
+ * @version 1.4 05/11/17
+ * @since 1.5
+ */
+
+public interface Readable {
+
+    /**
+     * Attempts to read characters into the specified character buffer.
+     * The buffer is used as a repository of characters as-is: the only
+     * changes made are the results of a put operation. No flipping or
+     * rewinding of the buffer is performed.
+     *
+     * @param cb the buffer to read characters into
+     * @return @return The number of <tt>char</tt> values added to the buffer,
+     *                 or -1 if this source of characters is at its end
+     * @throws IOException if an I/O error occurs
+     * @throws NullPointerException if cb is null
+     * @throws ReadOnlyBufferException if cb is a read only buffer
+     */
+    public int read(java.nio.CharBuffer cb) throws IOException;
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/Bits.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/Bits.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/Bits.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/Bits.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,714 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import sun.misc.Unsafe;
+import sun.misc.VM;
+
+/**
+ * Access to bits, native and otherwise.
+ */
+
+class Bits {                            // package-private
+
+    private Bits() { }
+
+
+    // -- Swapping --
+
+    static short swap(short x) {
+        return (short)((x << 8) |
+                       ((char)x >>> 8));
+    }
+
+    static char swap(char x) {
+        return (char)((x << 8) |
+                      (x >>> 8));
+    }
+
+    static int swap(int x) {
+        return ((x << 24) |
+                ((x & 0x0000ff00) <<  8) |
+                ((x & 0x00ff0000) >>> 8) |
+                (x >>> 24));
+    }
+
+    static long swap(long x) {
+        return (((long)swap((int)x) << 32) |
+                ((long)swap((int)(x >>> 32)) & 0xffffffffL));
+    }
+
+
+    // -- get/put char --
+
+    static private char makeChar(byte b1, byte b0) {
+        return (char)((b1 << 8) | (b0 & 0xff));
+    }
+
+    static char getCharL(ByteBuffer bb, int bi) {
+        return makeChar(bb._get(bi + 1),
+                        bb._get(bi + 0));
+    }
+
+    static char getCharL(long a) {
+        return makeChar(_get(a + 1),
+                        _get(a + 0));
+    }
+
+    static char getCharB(ByteBuffer bb, int bi) {
+        return makeChar(bb._get(bi + 0),
+                        bb._get(bi + 1));
+    }
+
+    static char getCharB(long a) {
+        return makeChar(_get(a + 0),
+                        _get(a + 1));
+    }
+
+    static char getChar(ByteBuffer bb, int bi, boolean bigEndian) {
+        return (bigEndian ? getCharB(bb, bi) : getCharL(bb, bi));
+    }
+
+    static char getChar(long a, boolean bigEndian) {
+        return (bigEndian ? getCharB(a) : getCharL(a));
+    }
+
+    private static byte char1(char x) { return (byte)(x >> 8); }
+    private static byte char0(char x) { return (byte)(x >> 0); }
+
+    static void putCharL(ByteBuffer bb, int bi, char x) {
+        bb._put(bi + 0, char0(x));
+        bb._put(bi + 1, char1(x));
+    }
+
+    static void putCharL(long a, char x) {
+        _put(a + 0, char0(x));
+        _put(a + 1, char1(x));
+    }
+
+    static void putCharB(ByteBuffer bb, int bi, char x) {
+        bb._put(bi + 0, char1(x));
+        bb._put(bi + 1, char0(x));
+    }
+
+    static void putCharB(long a, char x) {
+        _put(a + 0, char1(x));
+        _put(a + 1, char0(x));
+    }
+
+    static void putChar(ByteBuffer bb, int bi, char x, boolean bigEndian) {
+        if (bigEndian)
+            putCharB(bb, bi, x);
+        else
+            putCharL(bb, bi, x);
+    }
+
+    static void putChar(long a, char x, boolean bigEndian) {
+        if (bigEndian)
+            putCharB(a, x);
+        else
+            putCharL(a, x);
+    }
+
+
+    // -- get/put short --
+
+    static private short makeShort(byte b1, byte b0) {
+        return (short)((b1 << 8) | (b0 & 0xff));
+    }
+
+    static short getShortL(ByteBuffer bb, int bi) {
+        return makeShort(bb._get(bi + 1),
+                         bb._get(bi + 0));
+    }
+
+    static short getShortL(long a) {
+        return makeShort(_get(a + 1),
+                         _get(a));
+    }
+
+    static short getShortB(ByteBuffer bb, int bi) {
+        return makeShort(bb._get(bi + 0),
+                         bb._get(bi + 1));
+    }
+
+    static short getShortB(long a) {
+        return makeShort(_get(a),
+                         _get(a + 1));
+    }
+
+    static short getShort(ByteBuffer bb, int bi, boolean bigEndian) {
+        return (bigEndian ? getShortB(bb, bi) : getShortL(bb, bi));
+    }
+
+    static short getShort(long a, boolean bigEndian) {
+        return (bigEndian ? getShortB(a) : getShortL(a));
+    }
+
+    private static byte short1(short x) { return (byte)(x >> 8); }
+    private static byte short0(short x) { return (byte)(x >> 0); }
+
+    static void putShortL(ByteBuffer bb, int bi, short x) {
+        bb._put(bi + 0, short0(x));
+        bb._put(bi + 1, short1(x));
+    }
+
+    static void putShortL(long a, short x) {
+        _put(a, short0(x));
+        _put(a + 1, short1(x));
+    }
+
+    static void putShortB(ByteBuffer bb, int bi, short x) {
+        bb._put(bi + 0, short1(x));
+        bb._put(bi + 1, short0(x));
+    }
+
+    static void putShortB(long a, short x) {
+        _put(a, short1(x));
+        _put(a + 1, short0(x));
+    }
+
+    static void putShort(ByteBuffer bb, int bi, short x, boolean bigEndian) {
+        if (bigEndian)
+            putShortB(bb, bi, x);
+        else
+            putShortL(bb, bi, x);
+    }
+
+    static void putShort(long a, short x, boolean bigEndian) {
+        if (bigEndian)
+            putShortB(a, x);
+        else
+            putShortL(a, x);
+    }
+
+
+    // -- get/put int --
+
+    static private int makeInt(byte b3, byte b2, byte b1, byte b0) {
+        return (((b3 & 0xff) << 24) |
+                ((b2 & 0xff) << 16) |
+                ((b1 & 0xff) <<  8) |
+                ((b0 & 0xff) <<  0));
+    }
+
+    static int getIntL(ByteBuffer bb, int bi) {
+        return makeInt(bb._get(bi + 3),
+                       bb._get(bi + 2),
+                       bb._get(bi + 1),
+                       bb._get(bi + 0));
+    }
+
+    static int getIntL(long a) {
+        return makeInt(_get(a + 3),
+                       _get(a + 2),
+                       _get(a + 1),
+                       _get(a + 0));
+    }
+
+    static int getIntB(ByteBuffer bb, int bi) {
+        return makeInt(bb._get(bi + 0),
+                       bb._get(bi + 1),
+                       bb._get(bi + 2),
+                       bb._get(bi + 3));
+    }
+
+    static int getIntB(long a) {
+        return makeInt(_get(a + 0),
+                       _get(a + 1),
+                       _get(a + 2),
+                       _get(a + 3));
+    }
+
+    static int getInt(ByteBuffer bb, int bi, boolean bigEndian) {
+        return (bigEndian ? getIntB(bb, bi) : getIntL(bb, bi));
+    }
+
+    static int getInt(long a, boolean bigEndian) {
+        return (bigEndian ? getIntB(a) : getIntL(a));
+    }
+
+    private static byte int3(int x) { return (byte)(x >> 24); }
+    private static byte int2(int x) { return (byte)(x >> 16); }
+    private static byte int1(int x) { return (byte)(x >>  8); }
+    private static byte int0(int x) { return (byte)(x >>  0); }
+
+    static void putIntL(ByteBuffer bb, int bi, int x) {
+        bb._put(bi + 3, int3(x));
+        bb._put(bi + 2, int2(x));
+        bb._put(bi + 1, int1(x));
+        bb._put(bi + 0, int0(x));
+    }
+
+    static void putIntL(long a, int x) {
+        _put(a + 3, int3(x));
+        _put(a + 2, int2(x));
+        _put(a + 1, int1(x));
+        _put(a + 0, int0(x));
+    }
+
+    static void putIntB(ByteBuffer bb, int bi, int x) {
+        bb._put(bi + 0, int3(x));
+        bb._put(bi + 1, int2(x));
+        bb._put(bi + 2, int1(x));
+        bb._put(bi + 3, int0(x));
+    }
+
+    static void putIntB(long a, int x) {
+        _put(a + 0, int3(x));
+        _put(a + 1, int2(x));
+        _put(a + 2, int1(x));
+        _put(a + 3, int0(x));
+    }
+
+    static void putInt(ByteBuffer bb, int bi, int x, boolean bigEndian) {
+        if (bigEndian)
+            putIntB(bb, bi, x);
+        else
+            putIntL(bb, bi, x);
+    }
+
+    static void putInt(long a, int x, boolean bigEndian) {
+        if (bigEndian)
+            putIntB(a, x);
+        else
+            putIntL(a, x);
+    }
+
+
+    // -- get/put long --
+
+    static private long makeLong(byte b7, byte b6, byte b5, byte b4,
+                                 byte b3, byte b2, byte b1, byte b0)
+    {
+        return ((((long)b7 & 0xff) << 56) |
+                (((long)b6 & 0xff) << 48) |
+                (((long)b5 & 0xff) << 40) |
+                (((long)b4 & 0xff) << 32) |
+                (((long)b3 & 0xff) << 24) |
+                (((long)b2 & 0xff) << 16) |
+                (((long)b1 & 0xff) <<  8) |
+                (((long)b0 & 0xff) <<  0));
+    }
+
+    static long getLongL(ByteBuffer bb, int bi) {
+        return makeLong(bb._get(bi + 7),
+                        bb._get(bi + 6),
+                        bb._get(bi + 5),
+                        bb._get(bi + 4),
+                        bb._get(bi + 3),
+                        bb._get(bi + 2),
+                        bb._get(bi + 1),
+                        bb._get(bi + 0));
+    }
+
+    static long getLongL(long a) {
+        return makeLong(_get(a + 7),
+                        _get(a + 6),
+                        _get(a + 5),
+                        _get(a + 4),
+                        _get(a + 3),
+                        _get(a + 2),
+                        _get(a + 1),
+                        _get(a + 0));
+    }
+
+    static long getLongB(ByteBuffer bb, int bi) {
+        return makeLong(bb._get(bi + 0),
+                        bb._get(bi + 1),
+                        bb._get(bi + 2),
+                        bb._get(bi + 3),
+                        bb._get(bi + 4),
+                        bb._get(bi + 5),
+                        bb._get(bi + 6),
+                        bb._get(bi + 7));
+    }
+
+    static long getLongB(long a) {
+        return makeLong(_get(a + 0),
+                        _get(a + 1),
+                        _get(a + 2),
+                        _get(a + 3),
+                        _get(a + 4),
+                        _get(a + 5),
+                        _get(a + 6),
+                        _get(a + 7));
+    }
+
+    static long getLong(ByteBuffer bb, int bi, boolean bigEndian) {
+        return (bigEndian ? getLongB(bb, bi) : getLongL(bb, bi));
+    }
+
+    static long getLong(long a, boolean bigEndian) {
+        return (bigEndian ? getLongB(a) : getLongL(a));
+    }
+
+    private static byte long7(long x) { return (byte)(x >> 56); }
+    private static byte long6(long x) { return (byte)(x >> 48); }
+    private static byte long5(long x) { return (byte)(x >> 40); }
+    private static byte long4(long x) { return (byte)(x >> 32); }
+    private static byte long3(long x) { return (byte)(x >> 24); }
+    private static byte long2(long x) { return (byte)(x >> 16); }
+    private static byte long1(long x) { return (byte)(x >>  8); }
+    private static byte long0(long x) { return (byte)(x >>  0); }
+
+    static void putLongL(ByteBuffer bb, int bi, long x) {
+        bb._put(bi + 7, long7(x));
+        bb._put(bi + 6, long6(x));
+        bb._put(bi + 5, long5(x));
+        bb._put(bi + 4, long4(x));
+        bb._put(bi + 3, long3(x));
+        bb._put(bi + 2, long2(x));
+        bb._put(bi + 1, long1(x));
+        bb._put(bi + 0, long0(x));
+    }
+
+    static void putLongL(long a, long x) {
+        _put(a + 7, long7(x));
+        _put(a + 6, long6(x));
+        _put(a + 5, long5(x));
+        _put(a + 4, long4(x));
+        _put(a + 3, long3(x));
+        _put(a + 2, long2(x));
+        _put(a + 1, long1(x));
+        _put(a + 0, long0(x));
+    }
+
+    static void putLongB(ByteBuffer bb, int bi, long x) {
+        bb._put(bi + 0, long7(x));
+        bb._put(bi + 1, long6(x));
+        bb._put(bi + 2, long5(x));
+        bb._put(bi + 3, long4(x));
+        bb._put(bi + 4, long3(x));
+        bb._put(bi + 5, long2(x));
+        bb._put(bi + 6, long1(x));
+        bb._put(bi + 7, long0(x));
+    }
+
+    static void putLongB(long a, long x) {
+        _put(a + 0, long7(x));
+        _put(a + 1, long6(x));
+        _put(a + 2, long5(x));
+        _put(a + 3, long4(x));
+        _put(a + 4, long3(x));
+        _put(a + 5, long2(x));
+        _put(a + 6, long1(x));
+        _put(a + 7, long0(x));
+    }
+
+    static void putLong(ByteBuffer bb, int bi, long x, boolean bigEndian) {
+        if (bigEndian)
+            putLongB(bb, bi, x);
+        else
+            putLongL(bb, bi, x);
+    }
+
+    static void putLong(long a, long x, boolean bigEndian) {
+        if (bigEndian)
+            putLongB(a, x);
+        else
+            putLongL(a, x);
+    }
+
+
+    // -- get/put float --
+
+    static float getFloatL(ByteBuffer bb, int bi) {
+        return Float.intBitsToFloat(getIntL(bb, bi));
+    }
+
+    static float getFloatL(long a) {
+        return Float.intBitsToFloat(getIntL(a));
+    }
+
+    static float getFloatB(ByteBuffer bb, int bi) {
+        return Float.intBitsToFloat(getIntB(bb, bi));
+    }
+
+    static float getFloatB(long a) {
+        return Float.intBitsToFloat(getIntB(a));
+    }
+
+    static float getFloat(ByteBuffer bb, int bi, boolean bigEndian) {
+        return (bigEndian ? getFloatB(bb, bi) : getFloatL(bb, bi));
+    }
+
+    static float getFloat(long a, boolean bigEndian) {
+        return (bigEndian ? getFloatB(a) : getFloatL(a));
+    }
+
+    static void putFloatL(ByteBuffer bb, int bi, float x) {
+        putIntL(bb, bi, Float.floatToRawIntBits(x));
+    }
+
+    static void putFloatL(long a, float x) {
+        putIntL(a, Float.floatToRawIntBits(x));
+    }
+
+    static void putFloatB(ByteBuffer bb, int bi, float x) {
+        putIntB(bb, bi, Float.floatToRawIntBits(x));
+    }
+
+    static void putFloatB(long a, float x) {
+        putIntB(a, Float.floatToRawIntBits(x));
+    }
+
+    static void putFloat(ByteBuffer bb, int bi, float x, boolean bigEndian) {
+        if (bigEndian)
+            putFloatB(bb, bi, x);
+        else
+            putFloatL(bb, bi, x);
+    }
+
+    static void putFloat(long a, float x, boolean bigEndian) {
+        if (bigEndian)
+            putFloatB(a, x);
+        else
+            putFloatL(a, x);
+    }
+
+
+    // -- get/put double --
+
+    static double getDoubleL(ByteBuffer bb, int bi) {
+        return Double.longBitsToDouble(getLongL(bb, bi));
+    }
+
+    static double getDoubleL(long a) {
+        return Double.longBitsToDouble(getLongL(a));
+    }
+
+    static double getDoubleB(ByteBuffer bb, int bi) {
+        return Double.longBitsToDouble(getLongB(bb, bi));
+    }
+
+    static double getDoubleB(long a) {
+        return Double.longBitsToDouble(getLongB(a));
+    }
+
+    static double getDouble(ByteBuffer bb, int bi, boolean bigEndian) {
+        return (bigEndian ? getDoubleB(bb, bi) : getDoubleL(bb, bi));
+    }
+
+    static double getDouble(long a, boolean bigEndian) {
+        return (bigEndian ? getDoubleB(a) : getDoubleL(a));
+    }
+
+    static void putDoubleL(ByteBuffer bb, int bi, double x) {
+        putLongL(bb, bi, Double.doubleToRawLongBits(x));
+    }
+
+    static void putDoubleL(long a, double x) {
+        putLongL(a, Double.doubleToRawLongBits(x));
+    }
+
+    static void putDoubleB(ByteBuffer bb, int bi, double x) {
+        putLongB(bb, bi, Double.doubleToRawLongBits(x));
+    }
+
+    static void putDoubleB(long a, double x) {
+        putLongB(a, Double.doubleToRawLongBits(x));
+    }
+
+    static void putDouble(ByteBuffer bb, int bi, double x, boolean bigEndian) {
+        if (bigEndian)
+            putDoubleB(bb, bi, x);
+        else
+            putDoubleL(bb, bi, x);
+    }
+
+    static void putDouble(long a, double x, boolean bigEndian) {
+        if (bigEndian)
+            putDoubleB(a, x);
+        else
+            putDoubleL(a, x);
+    }
+
+
+    // -- Unsafe access --
+
+    private static final Unsafe unsafe = Unsafe.getUnsafe();
+
+    private static byte _get(long a) {
+        return unsafe.getByte(a);
+    }
+
+    private static void _put(long a, byte b) {
+        unsafe.putByte(a, b);
+    }
+
+    static Unsafe unsafe() {
+        return unsafe;
+    }
+
+
+    // -- Processor and memory-system properties --
+
+    private static final ByteOrder byteOrder;
+
+    static ByteOrder byteOrder() {
+        if (byteOrder == null)
+            throw new Error("Unknown byte order");
+        return byteOrder;
+    }
+
+    static {
+        long a = unsafe.allocateMemory(8);
+        try {
+            unsafe.putLong(a, 0x0102030405060708L);
+            byte b = unsafe.getByte(a);
+            switch (b) {
+            case 0x01: byteOrder = ByteOrder.BIG_ENDIAN;     break;
+            case 0x08: byteOrder = ByteOrder.LITTLE_ENDIAN;  break;
+            default:
+                assert false;
+                byteOrder = null;
+            }
+        } finally {
+            unsafe.freeMemory(a);
+        }
+    }
+
+
+    private static int pageSize = -1;
+
+    static int pageSize() {
+        if (pageSize == -1)
+            pageSize = unsafe().pageSize();
+        return pageSize;
+    }
+
+
+    private static boolean unaligned;
+    private static boolean unalignedKnown = false;
+
+    static boolean unaligned() {
+        if (unalignedKnown)
+            return unaligned;
+        String arch = (String)AccessController.doPrivileged(
+            new sun.security.action.GetPropertyAction("os.arch"));
+        unaligned = arch.equals("i386") || arch.equals("x86")
+            || arch.equals("amd64");
+        unalignedKnown = true;
+        return unaligned;
+    }
+
+
+    // -- Direct memory management --
+
+    // A user-settable upper limit on the maximum amount of allocatable
+    // direct buffer memory.  This value may be changed during VM
+    // initialization if it is launched with "-XX:MaxDirectMemorySize=<size>".
+    private static volatile long maxMemory = VM.maxDirectMemory();
+    private static volatile long reservedMemory = 0;
+    private static boolean memoryLimitSet = false;
+
+    // These methods should be called whenever direct memory is allocated or
+    // freed.  They allow the user to control the amount of direct memory
+    // which a process may access.  All sizes are specified in bytes.
+    static void reserveMemory(long size) {
+
+        synchronized (Bits.class) {
+            if (!memoryLimitSet && VM.isBooted()) {
+                maxMemory = VM.maxDirectMemory();
+                memoryLimitSet = true;
+            }
+            if (size <= maxMemory - reservedMemory) {
+                reservedMemory += size;
+                return;
+            }
+        }
+
+        System.gc();
+        try {
+            Thread.sleep(100);
+        } catch (InterruptedException x) {
+            // Restore interrupt status
+            Thread.currentThread().interrupt();
+        }
+        synchronized (Bits.class) {
+            if (reservedMemory + size > maxMemory)
+                throw new OutOfMemoryError("Direct buffer memory");
+            reservedMemory += size;
+        }
+
+    }
+
+    static synchronized void unreserveMemory(long size) {
+        if (reservedMemory > 0) {
+            reservedMemory -= size;
+            assert (reservedMemory > -1);
+        }
+    }
+
+
+    // -- Bulk get/put acceleration --
+
+    // These numbers represent the point at which we have empirically
+    // determined that the average cost of a JNI call exceeds the expense
+    // of an element by element copy.  These numbers may change over time.
+    static final int JNI_COPY_TO_ARRAY_THRESHOLD   = 6;
+    static final int JNI_COPY_FROM_ARRAY_THRESHOLD = 6;
+
+    // These methods do no bounds checking.  Verification that the copy will not
+    // result in memory corruption should be done prior to invocation.
+    // All positions and lengths are specified in bytes.
+
+    static native void copyFromByteArray(Object src, long srcPos, long dstAddr,
+                                         long length);
+    static native void copyToByteArray(long srcAddr, Object dst, long dstPos,
+                                       long length);
+
+    static void copyFromCharArray(Object src, long srcPos, long dstAddr,
+                                  long length)
+    {
+        copyFromShortArray(src, srcPos, dstAddr, length);
+    }
+
+    static void copyToCharArray(long srcAddr, Object dst, long dstPos,
+                                long length)
+    {
+        copyToShortArray(srcAddr, dst, dstPos, length);
+    }
+
+    static native void copyFromShortArray(Object src, long srcPos, long dstAddr,
+                                          long length);
+    static native void copyToShortArray(long srcAddr, Object dst, long dstPos,
+                                        long length);
+
+    static native void copyFromIntArray(Object src, long srcPos, long dstAddr,
+                                        long length);
+    static native void copyToIntArray(long srcAddr, Object dst, long dstPos,
+                                        long length);
+
+    static native void copyFromLongArray(Object src, long srcPos, long dstAddr,
+                                         long length);
+    static native void copyToLongArray(long srcAddr, Object dst, long dstPos,
+                                       long length);
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/Buffer.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/Buffer.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/Buffer.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/Buffer.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,551 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio;
+
+
+/**
+ * A container for data of a specific primitive type.
+ *
+ * <p> A buffer is a linear, finite sequence of elements of a specific
+ * primitive type.  Aside from its content, the essential properties of a
+ * buffer are its capacity, limit, and position: </p>
+ *
+ * <blockquote>
+ *
+ *   <p> A buffer's <i>capacity</i> is the number of elements it contains.  The
+ *   capacity of a buffer is never negative and never changes.  </p>
+ *
+ *   <p> A buffer's <i>limit</i> is the index of the first element that should
+ *   not be read or written.  A buffer's limit is never negative and is never
+ *   greater than its capacity.  </p>
+ *
+ *   <p> A buffer's <i>position</i> is the index of the next element to be
+ *   read or written.  A buffer's position is never negative and is never
+ *   greater than its limit.  </p>
+ *
+ * </blockquote>
+ *
+ * <p> There is one subclass of this class for each non-boolean primitive type.
+ *
+ *
+ * <h4> Transferring data </h4>
+ *
+ * <p> Each subclass of this class defines two categories of <i>get</i> and
+ * <i>put</i> operations: </p>
+ *
+ * <blockquote>
+ *
+ *   <p> <i>Relative</i> operations read or write one or more elements starting
+ *   at the current position and then increment the position by the number of
+ *   elements transferred.  If the requested transfer exceeds the limit then a
+ *   relative <i>get</i> operation throws a {@link BufferUnderflowException}
+ *   and a relative <i>put</i> operation throws a {@link
+ *   BufferOverflowException}; in either case, no data is transferred.  </p>
+ *
+ *   <p> <i>Absolute</i> operations take an explicit element index and do not
+ *   affect the position.  Absolute <i>get</i> and <i>put</i> operations throw
+ *   an {@link IndexOutOfBoundsException} if the index argument exceeds the
+ *   limit.  </p>
+ *
+ * </blockquote>
+ *
+ * <p> Data may also, of course, be transferred in to or out of a buffer by the
+ * I/O operations of an appropriate channel, which are always relative to the
+ * current position.
+ *
+ *
+ * <h4> Marking and resetting </h4>
+ *
+ * <p> A buffer's <i>mark</i> is the index to which its position will be reset
+ * when the {@link #reset reset} method is invoked.  The mark is not always
+ * defined, but when it is defined it is never negative and is never greater
+ * than the position.  If the mark is defined then it is discarded when the
+ * position or the limit is adjusted to a value smaller than the mark.  If the
+ * mark is not defined then invoking the {@link #reset reset} method causes an
+ * {@link InvalidMarkException} to be thrown.
+ *
+ *
+ * <h4> Invariants </h4>
+ *
+ * <p> The following invariant holds for the mark, position, limit, and
+ * capacity values:
+ *
+ * <blockquote>
+ *     <tt>0</tt> <tt>&lt;=</tt>
+ *     <i>mark</i> <tt>&lt;=</tt>
+ *     <i>position</i> <tt>&lt;=</tt>
+ *     <i>limit</i> <tt>&lt;=</tt>
+ *     <i>capacity</i>
+ * </blockquote>
+ *
+ * <p> A newly-created buffer always has a position of zero and a mark that is
+ * undefined.  The initial limit may be zero, or it may be some other value
+ * that depends upon the type of the buffer and the manner in which it is
+ * constructed.  Each element of a newly-allocated buffer is initialized
+ * to zero.
+ *
+ *
+ * <h4> Clearing, flipping, and rewinding </h4>
+ *
+ * <p> In addition to methods for accessing the position, limit, and capacity
+ * values and for marking and resetting, this class also defines the following
+ * operations upon buffers:
+ *
+ * <ul>
+ *
+ *   <li><p> {@link #clear} makes a buffer ready for a new sequence of
+ *   channel-read or relative <i>put</i> operations: It sets the limit to the
+ *   capacity and the position to zero.  </p></li>
+ *
+ *   <li><p> {@link #flip} makes a buffer ready for a new sequence of
+ *   channel-write or relative <i>get</i> operations: It sets the limit to the
+ *   current position and then sets the position to zero.  </p></li>
+ *
+ *   <li><p> {@link #rewind} makes a buffer ready for re-reading the data that
+ *   it already contains: It leaves the limit unchanged and sets the position
+ *   to zero.  </p></li>
+ *
+ * </ul>
+ *
+ *
+ * <h4> Read-only buffers </h4>
+ *
+ * <p> Every buffer is readable, but not every buffer is writable.  The
+ * mutation methods of each buffer class are specified as <i>optional
+ * operations</i> that will throw a {@link ReadOnlyBufferException} when
+ * invoked upon a read-only buffer.  A read-only buffer does not allow its
+ * content to be changed, but its mark, position, and limit values are mutable.
+ * Whether or not a buffer is read-only may be determined by invoking its
+ * {@link #isReadOnly isReadOnly} method.
+ *
+ *
+ * <h4> Thread safety </h4>
+ *
+ * <p> Buffers are not safe for use by multiple concurrent threads.  If a
+ * buffer is to be used by more than one thread then access to the buffer
+ * should be controlled by appropriate synchronization.
+ *
+ *
+ * <h4> Invocation chaining </h4>
+ *
+ * <p> Methods in this class that do not otherwise have a value to return are
+ * specified to return the buffer upon which they are invoked.  This allows
+ * method invocations to be chained; for example, the sequence of statements
+ *
+ * <blockquote><pre>
+ * b.flip();
+ * b.position(23);
+ * b.limit(42);</pre></blockquote>
+ *
+ * can be replaced by the single, more compact statement
+ *
+ * <blockquote><pre>
+ * b.flip().position(23).limit(42);</pre></blockquote>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public abstract class Buffer {
+
+    // Invariants: mark <= position <= limit <= capacity
+    private int mark = -1;
+    private int position = 0;
+    private int limit;
+    private int capacity;
+
+    // Used only by direct buffers
+    // NOTE: hoisted here for speed in JNI GetDirectBufferAddress
+    long address;
+
+    // Creates a new buffer with the given mark, position, limit, and capacity,
+    // after checking invariants.
+    //
+    Buffer(int mark, int pos, int lim, int cap) {       // package-private
+        if (cap < 0)
+            throw new IllegalArgumentException("Negative capacity: " + cap);
+        this.capacity = cap;
+        limit(lim);
+        position(pos);
+        if (mark >= 0) {
+            if (mark > pos)
+                throw new IllegalArgumentException("mark > position: ("
+                                                   + mark + " > " + pos + ")");
+            this.mark = mark;
+        }
+    }
+
+    /**
+     * Returns this buffer's capacity. </p>
+     *
+     * @return  The capacity of this buffer
+     */
+    public final int capacity() {
+        return capacity;
+    }
+
+    /**
+     * Returns this buffer's position. </p>
+     *
+     * @return  The position of this buffer
+     */
+    public final int position() {
+        return position;
+    }
+
+    /**
+     * Sets this buffer's position.  If the mark is defined and larger than the
+     * new position then it is discarded. </p>
+     *
+     * @param  newPosition
+     *         The new position value; must be non-negative
+     *         and no larger than the current limit
+     *
+     * @return  This buffer
+     *
+     * @throws  IllegalArgumentException
+     *          If the preconditions on <tt>newPosition</tt> do not hold
+     */
+    public final Buffer position(int newPosition) {
+        if ((newPosition > limit) || (newPosition < 0))
+            throw new IllegalArgumentException();
+        position = newPosition;
+        if (mark > position) mark = -1;
+        return this;
+    }
+
+    /**
+     * Returns this buffer's limit. </p>
+     *
+     * @return  The limit of this buffer
+     */
+    public final int limit() {
+        return limit;
+    }
+
+    /**
+     * Sets this buffer's limit.  If the position is larger than the new limit
+     * then it is set to the new limit.  If the mark is defined and larger than
+     * the new limit then it is discarded. </p>
+     *
+     * @param  newLimit
+     *         The new limit value; must be non-negative
+     *         and no larger than this buffer's capacity
+     *
+     * @return  This buffer
+     *
+     * @throws  IllegalArgumentException
+     *          If the preconditions on <tt>newLimit</tt> do not hold
+     */
+    public final Buffer limit(int newLimit) {
+        if ((newLimit > capacity) || (newLimit < 0))
+            throw new IllegalArgumentException();
+        limit = newLimit;
+        if (position > limit) position = limit;
+        if (mark > limit) mark = -1;
+        return this;
+    }
+
+    /**
+     * Sets this buffer's mark at its position. </p>
+     *
+     * @return  This buffer
+     */
+    public final Buffer mark() {
+        mark = position;
+        return this;
+    }
+
+    /**
+     * Resets this buffer's position to the previously-marked position.
+     *
+     * <p> Invoking this method neither changes nor discards the mark's
+     * value. </p>
+     *
+     * @return  This buffer
+     *
+     * @throws  InvalidMarkException
+     *          If the mark has not been set
+     */
+    public final Buffer reset() {
+        int m = mark;
+        if (m < 0)
+            throw new InvalidMarkException();
+        position = m;
+        return this;
+    }
+
+    /**
+     * Clears this buffer.  The position is set to zero, the limit is set to
+     * the capacity, and the mark is discarded.
+     *
+     * <p> Invoke this method before using a sequence of channel-read or
+     * <i>put</i> operations to fill this buffer.  For example:
+     *
+     * <blockquote><pre>
+     * buf.clear();     // Prepare buffer for reading
+     * in.read(buf);    // Read data</pre></blockquote>
+     *
+     * <p> This method does not actually erase the data in the buffer, but it
+     * is named as if it did because it will most often be used in situations
+     * in which that might as well be the case. </p>
+     *
+     * @return  This buffer
+     */
+    public final Buffer clear() {
+        position = 0;
+        limit = capacity;
+        mark = -1;
+        return this;
+    }
+
+    /**
+     * Flips this buffer.  The limit is set to the current position and then
+     * the position is set to zero.  If the mark is defined then it is
+     * discarded.
+     *
+     * <p> After a sequence of channel-read or <i>put</i> operations, invoke
+     * this method to prepare for a sequence of channel-write or relative
+     * <i>get</i> operations.  For example:
+     *
+     * <blockquote><pre>
+     * buf.put(magic);    // Prepend header
+     * in.read(buf);      // Read data into rest of buffer
+     * buf.flip();        // Flip buffer
+     * out.write(buf);    // Write header + data to channel</pre></blockquote>
+     *
+     * <p> This method is often used in conjunction with the {@link
+     * java.nio.ByteBuffer#compact compact} method when transferring data from
+     * one place to another.  </p>
+     *
+     * @return  This buffer
+     */
+    public final Buffer flip() {
+        limit = position;
+        position = 0;
+        mark = -1;
+        return this;
+    }
+
+    /**
+     * Rewinds this buffer.  The position is set to zero and the mark is
+     * discarded.
+     *
+     * <p> Invoke this method before a sequence of channel-write or <i>get</i>
+     * operations, assuming that the limit has already been set
+     * appropriately.  For example:
+     *
+     * <blockquote><pre>
+     * out.write(buf);    // Write remaining data
+     * buf.rewind();      // Rewind buffer
+     * buf.get(array);    // Copy data into array</pre></blockquote>
+     *
+     * @return  This buffer
+     */
+    public final Buffer rewind() {
+        position = 0;
+        mark = -1;
+        return this;
+    }
+
+    /**
+     * Returns the number of elements between the current position and the
+     * limit. </p>
+     *
+     * @return  The number of elements remaining in this buffer
+     */
+    public final int remaining() {
+        return limit - position;
+    }
+
+    /**
+     * Tells whether there are any elements between the current position and
+     * the limit. </p>
+     *
+     * @return  <tt>true</tt> if, and only if, there is at least one element
+     *          remaining in this buffer
+     */
+    public final boolean hasRemaining() {
+        return position < limit;
+    }
+
+    /**
+     * Tells whether or not this buffer is read-only. </p>
+     *
+     * @return  <tt>true</tt> if, and only if, this buffer is read-only
+     */
+    public abstract boolean isReadOnly();
+
+    /**
+     * Tells whether or not this buffer is backed by an accessible
+     * array.
+     *
+     * <p> If this method returns <tt>true</tt> then the {@link #array() array}
+     * and {@link #arrayOffset() arrayOffset} methods may safely be invoked.
+     * </p>
+     *
+     * @return  <tt>true</tt> if, and only if, this buffer
+     *          is backed by an array and is not read-only
+     *
+     * @since 1.6
+     */
+//    public abstract boolean hasArray();
+
+    /**
+     * Returns the array that backs this
+     * buffer&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> This method is intended to allow array-backed buffers to be
+     * passed to native code more efficiently. Concrete subclasses
+     * provide more strongly-typed return values for this method.
+     *
+     * <p> Modifications to this buffer's content will cause the returned
+     * array's content to be modified, and vice versa.
+     *
+     * <p> Invoke the {@link #hasArray hasArray} method before invoking this
+     * method in order to ensure that this buffer has an accessible backing
+     * array.  </p>
+     *
+     * @return  The array that backs this buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is backed by an array but is read-only
+     *
+     * @throws  UnsupportedOperationException
+     *          If this buffer is not backed by an accessible array
+     *
+     * @since 1.6
+     */
+  //  public abstract Object array();
+
+    /**
+     * Returns the offset within this buffer's backing array of the first
+     * element of the buffer&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> If this buffer is backed by an array then buffer position <i>p</i>
+     * corresponds to array index <i>p</i>&nbsp;+&nbsp;<tt>arrayOffset()</tt>.
+     *
+     * <p> Invoke the {@link #hasArray hasArray} method before invoking this
+     * method in order to ensure that this buffer has an accessible backing
+     * array.  </p>
+     *
+     * @return  The offset within this buffer's array
+     *          of the first element of the buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is backed by an array but is read-only
+     *
+     * @throws  UnsupportedOperationException
+     *          If this buffer is not backed by an accessible array
+     *
+     * @since 1.6
+     */
+    //public abstract int arrayOffset();
+
+    /**
+     * Tells whether or not this buffer is
+     * <a href="ByteBuffer.html#direct"><i>direct</i></a>. </p>
+     *
+     * @return  <tt>true</tt> if, and only if, this buffer is direct
+     *
+     * @since 1.6
+     */
+    //public abstract boolean isDirect();
+
+
+    // -- Package-private methods for bounds checking, etc. --
+
+    /**
+     * Checks the current position against the limit, throwing a {@link
+     * BufferUnderflowException} if it is not smaller than the limit, and then
+     * increments the position. </p>
+     *
+     * @return  The current position value, before it is incremented
+     */
+    final int nextGetIndex() {                          // package-private
+        if (position >= limit)
+            throw new BufferUnderflowException();
+        return position++;
+    }
+
+    final int nextGetIndex(int nb) {                    // package-private
+        if (limit - position < nb)
+            throw new BufferUnderflowException();
+        int p = position;
+        position += nb;
+        return p;
+    }
+
+    /**
+     * Checks the current position against the limit, throwing a {@link
+     * BufferOverflowException} if it is not smaller than the limit, and then
+     * increments the position. </p>
+     *
+     * @return  The current position value, before it is incremented
+     */
+    final int nextPutIndex() {                          // package-private
+        if (position >= limit)
+            throw new BufferOverflowException();
+        return position++;
+    }
+
+    final int nextPutIndex(int nb) {                    // package-private
+        if (limit - position < nb)
+            throw new BufferOverflowException();
+        int p = position;
+        position += nb;
+        return p;
+    }
+
+    /**
+     * Checks the given index against the limit, throwing an {@link
+     * IndexOutOfBoundsException} if it is not smaller than the limit
+     * or is smaller than zero.
+     */
+    final int checkIndex(int i) {                       // package-private
+        if ((i < 0) || (i >= limit))
+            throw new IndexOutOfBoundsException();
+        return i;
+    }
+
+    final int checkIndex(int i, int nb) {               // package-private
+        if ((i < 0) || (nb > limit - i))
+            throw new IndexOutOfBoundsException();
+        return i;
+    }
+
+    final int markValue() {                             // package-private
+        return mark;
+    }
+
+    static void checkBounds(int off, int len, int size) { // package-private
+        if ((off | len | (off + len) | (size - (off + len))) < 0)
+            throw new IndexOutOfBoundsException();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/BufferOverflowException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/BufferOverflowException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/BufferOverflowException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/BufferOverflowException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio;
+
+
+/**
+ * Unchecked exception thrown when a relative <i>put</i> operation reaches
+ * the target buffer's limit.
+ *
+ * @since 1.4
+ */
+
+public class BufferOverflowException
+    extends RuntimeException
+{
+
+    private static final long serialVersionUID = -5484897634319144535L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public BufferOverflowException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/BufferUnderflowException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/BufferUnderflowException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/BufferUnderflowException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/BufferUnderflowException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio;
+
+
+/**
+ * Unchecked exception thrown when a relative <i>get</i> operation reaches
+ * the source buffer's limit.
+ *
+ * @since 1.4
+ */
+
+public class BufferUnderflowException
+    extends RuntimeException
+{
+
+    private static final long serialVersionUID = -1713313658691622206L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public BufferUnderflowException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/ByteBuffer.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/ByteBuffer.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/ByteBuffer.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/ByteBuffer.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,1906 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio;
+
+
+
+
+
+/**
+ * A byte buffer.
+ *
+ * <p> This class defines six categories of operations upon
+ * byte buffers:
+ *
+ * <ul>
+ *
+ *   <li><p> Absolute and relative {@link #get() </code><i>get</i><code>} and
+ *   {@link #put(byte) </code><i>put</i><code>} methods that read and write
+ *   single bytes; </p></li>
+ *
+ *   <li><p> Relative {@link #get(byte[]) </code><i>bulk get</i><code>}
+ *   methods that transfer contiguous sequences of bytes from this buffer
+ *   into an array; </p></li>
+ *
+ *   <li><p> Relative {@link #put(byte[]) </code><i>bulk put</i><code>}
+ *   methods that transfer contiguous sequences of bytes from a
+ *   byte array or some other byte
+ *   buffer into this buffer; </p></li>
+ *
+
+ *
+ *   <li><p> Absolute and relative {@link #getChar() </code><i>get</i><code>}
+ *   and {@link #putChar(char) </code><i>put</i><code>} methods that read and
+ *   write values of other primitive types, translating them to and from
+ *   sequences of bytes in a particular byte order; </p></li>
+ *
+ *   <li><p> Methods for creating <i><a href="#views">view buffers</a></i>,
+ *   which allow a byte buffer to be viewed as a buffer containing values of
+ *   some other primitive type; and </p></li>
+ *
+
+ *
+ *   <li><p> Methods for {@link #compact </code>compacting<code>}, {@link
+ *   #duplicate </code>duplicating<code>}, and {@link #slice
+ *   </code>slicing<code>} a byte buffer.  </p></li>
+ *
+ * </ul>
+ *
+ * <p> Byte buffers can be created either by {@link #allocate
+ * </code><i>allocation</i><code>}, which allocates space for the buffer's
+ *
+
+ *
+ * content, or by {@link #wrap(byte[]) </code><i>wrapping</i><code>} an
+ * existing byte array  into a buffer.
+ *
+
+
+
+
+
+
+
+ *
+
+ *
+ * <a name="direct">
+ * <h4> Direct <i>vs.</i> non-direct buffers </h4>
+ *
+ * <p> A byte buffer is either <i>direct</i> or <i>non-direct</i>.  Given a
+ * direct byte buffer, the Java virtual machine will make a best effort to
+ * perform native I/O operations directly upon it.  That is, it will attempt to
+ * avoid copying the buffer's content to (or from) an intermediate buffer
+ * before (or after) each invocation of one of the underlying operating
+ * system's native I/O operations.
+ *
+ * <p> A direct byte buffer may be created by invoking the {@link
+ * #allocateDirect(int) allocateDirect} factory method of this class.  The
+ * buffers returned by this method typically have somewhat higher allocation
+ * and deallocation costs than non-direct buffers.  The contents of direct
+ * buffers may reside outside of the normal garbage-collected heap, and so
+ * their impact upon the memory footprint of an application might not be
+ * obvious.  It is therefore recommended that direct buffers be allocated
+ * primarily for large, long-lived buffers that are subject to the underlying
+ * system's native I/O operations.  In general it is best to allocate direct
+ * buffers only when they yield a measureable gain in program performance.
+ *
+ * <p> A direct byte buffer may also be created by {@link
+ * java.nio.channels.FileChannel#map </code>mapping<code>} a region of a file
+ * directly into memory.  An implementation of the Java platform may optionally
+ * support the creation of direct byte buffers from native code via JNI.  If an
+ * instance of one of these kinds of buffers refers to an inaccessible region
+ * of memory then an attempt to access that region will not change the buffer's
+ * content and will cause an unspecified exception to be thrown either at the
+ * time of the access or at some later time.
+ *
+ * <p> Whether a byte buffer is direct or non-direct may be determined by
+ * invoking its {@link #isDirect isDirect} method.  This method is provided so
+ * that explicit buffer management can be done in performance-critical code.
+ *
+ *
+ * <a name="bin">
+ * <h4> Access to binary data </h4>
+ *
+ * <p> This class defines methods for reading and writing values of all other
+ * primitive types, except <tt>boolean</tt>.  Primitive values are translated
+ * to (or from) sequences of bytes according to the buffer's current byte
+ * order, which may be retrieved and modified via the {@link #order order}
+ * methods.  Specific byte orders are represented by instances of the {@link
+ * ByteOrder} class.  The initial order of a byte buffer is always {@link
+ * ByteOrder#BIG_ENDIAN BIG_ENDIAN}.
+ *
+ * <p> For access to heterogeneous binary data, that is, sequences of values of
+ * different types, this class defines a family of absolute and relative
+ * <i>get</i> and <i>put</i> methods for each type.  For 32-bit floating-point
+ * values, for example, this class defines:
+ *
+ * <blockquote><pre>
+ * float  {@link #getFloat()}
+ * float  {@link #getFloat(int) getFloat(int index)}
+ *  void  {@link #putFloat(float) putFloat(float f)}
+ *  void  {@link #putFloat(int,float) putFloat(int index, float f)}</pre></blockquote>
+ *
+ * <p> Corresponding methods are defined for the types <tt>char</tt>,
+ * <tt>short</tt>, <tt>int</tt>, <tt>long</tt>, and <tt>double</tt>.  The index
+ * parameters of the absolute <i>get</i> and <i>put</i> methods are in terms of
+ * bytes rather than of the type being read or written.
+ *
+ * <a name="views">
+ *
+ * <p> For access to homogeneous binary data, that is, sequences of values of
+ * the same type, this class defines methods that can create <i>views</i> of a
+ * given byte buffer.  A <i>view buffer</i> is simply another buffer whose
+ * content is backed by the byte buffer.  Changes to the byte buffer's content
+ * will be visible in the view buffer, and vice versa; the two buffers'
+ * position, limit, and mark values are independent.  The {@link
+ * #asFloatBuffer() asFloatBuffer} method, for example, creates an instance of
+ * the {@link FloatBuffer} class that is backed by the byte buffer upon which
+ * the method is invoked.  Corresponding view-creation methods are defined for
+ * the types <tt>char</tt>, <tt>short</tt>, <tt>int</tt>, <tt>long</tt>, and
+ * <tt>double</tt>.
+ *
+ * <p> View buffers have three important advantages over the families of
+ * type-specific <i>get</i> and <i>put</i> methods described above:
+ *
+ * <ul>
+ *
+ *   <li><p> A view buffer is indexed not in terms of bytes but rather in terms
+ *   of the type-specific size of its values;  </p></li>
+ *
+ *   <li><p> A view buffer provides relative bulk <i>get</i> and <i>put</i>
+ *   methods that can transfer contiguous sequences of values between a buffer
+ *   and an array or some other buffer of the same type; and  </p></li>
+ *
+ *   <li><p> A view buffer is potentially much more efficient because it will
+ *   be direct if, and only if, its backing byte buffer is direct.  </p></li>
+ *
+ * </ul>
+ *
+ * <p> The byte order of a view buffer is fixed to be that of its byte buffer
+ * at the time that the view is created.  </p>
+ *
+
+*
+
+
+
+
+
+
+
+
+
+
+
+*
+
+
+
+
+
+
+
+
+ *
+
+ * <h4> Invocation chaining </h4>
+
+ *
+ * <p> Methods in this class that do not otherwise have a value to return are
+ * specified to return the buffer upon which they are invoked.  This allows
+ * method invocations to be chained.
+ *
+
+ *
+ * The sequence of statements
+ *
+ * <blockquote><pre>
+ * bb.putInt(0xCAFEBABE);
+ * bb.putShort(3);
+ * bb.putShort(45);</pre></blockquote>
+ *
+ * can, for example, be replaced by the single statement
+ *
+ * <blockquote><pre>
+ * bb.putInt(0xCAFEBABE).putShort(3).putShort(45);</pre></blockquote>
+ *
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public abstract class ByteBuffer
+    extends Buffer
+    implements Comparable
+{
+
+    // These fields are declared here rather than in Heap-X-Buffer in order to
+    // reduce the number of virtual method invocations needed to access these
+    // values, which is especially costly when coding small buffers.
+    //
+    final byte[] hb;                  // Non-null only for heap buffers
+    final int offset;
+    boolean isReadOnly;                 // Valid only for heap buffers
+
+    // Creates a new buffer with the given mark, position, limit, capacity,
+    // backing array, and array offset
+    //
+    ByteBuffer(int mark, int pos, int lim, int cap,   // package-private
+                 byte[] hb, int offset)
+    {
+        super(mark, pos, lim, cap);
+        this.hb = hb;
+        this.offset = offset;
+    }
+
+    // Creates a new buffer with the given mark, position, limit, and capacity
+    //
+    ByteBuffer(int mark, int pos, int lim, int cap) { // package-private
+        this(mark, pos, lim, cap, null, 0);
+    }
+
+
+
+    /**
+     * Allocates a new direct byte buffer.
+     *
+     * <p> The new buffer's position will be zero, its limit will be its
+     * capacity, its mark will be undefined, and each of its elements will be
+     * initialized to zero.  Whether or not it has a
+     * {@link #hasArray </code>backing array<code>} is unspecified.
+     *
+     * @param  capacity
+     *         The new buffer's capacity, in bytes
+     *
+     * @return  The new byte buffer
+     *
+     * @throws  IllegalArgumentException
+     *          If the <tt>capacity</tt> is a negative integer
+     */
+    public static ByteBuffer allocateDirect(int capacity) {
+        return new DirectByteBuffer(capacity);
+    }
+
+
+
+    /**
+     * Allocates a new byte buffer.
+     *
+     * <p> The new buffer's position will be zero, its limit will be its
+     * capacity, its mark will be undefined, and each of its elements will be
+     * initialized to zero.  It will have a {@link #array
+     * </code>backing array<code>}, and its {@link #arrayOffset </code>array
+     * offset<code>} will be zero.
+     *
+     * @param  capacity
+     *         The new buffer's capacity, in bytes
+     *
+     * @return  The new byte buffer
+     *
+     * @throws  IllegalArgumentException
+     *          If the <tt>capacity</tt> is a negative integer
+     */
+    public static ByteBuffer allocate(int capacity) {
+        if (capacity < 0)
+            throw new IllegalArgumentException();
+        return new HeapByteBuffer(capacity, capacity);
+    }
+
+    /**
+     * Wraps a byte array into a buffer.
+     *
+     * <p> The new buffer will be backed by the given byte array;
+     * that is, modifications to the buffer will cause the array to be modified
+     * and vice versa.  The new buffer's capacity will be
+     * <tt>array.length</tt>, its position will be <tt>offset</tt>, its limit
+     * will be <tt>offset + length</tt>, and its mark will be undefined.  Its
+     * {@link #array </code>backing array<code>} will be the given array, and
+     * its {@link #arrayOffset </code>array offset<code>} will be zero.  </p>
+     *
+     * @param  array
+     *         The array that will back the new buffer
+     *
+     * @param  offset
+     *         The offset of the subarray to be used; must be non-negative and
+     *         no larger than <tt>array.length</tt>.  The new buffer's position
+     *         will be set to this value.
+     *
+     * @param  length
+     *         The length of the subarray to be used;
+     *         must be non-negative and no larger than
+     *         <tt>array.length - offset</tt>.
+     *         The new buffer's limit will be set to <tt>offset + length</tt>.
+     *
+     * @return  The new byte buffer
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If the preconditions on the <tt>offset</tt> and <tt>length</tt>
+     *          parameters do not hold
+     */
+    public static ByteBuffer wrap(byte[] array,
+                                    int offset, int length)
+    {
+        try {
+            return new HeapByteBuffer(array, offset, length);
+        } catch (IllegalArgumentException x) {
+            throw new IndexOutOfBoundsException();
+        }
+    }
+
+    /**
+     * Wraps a byte array into a buffer.
+     *
+     * <p> The new buffer will be backed by the given byte array;
+     * that is, modifications to the buffer will cause the array to be modified
+     * and vice versa.  The new buffer's capacity and limit will be
+     * <tt>array.length</tt>, its position will be zero, and its mark will be
+     * undefined.  Its {@link #array </code>backing array<code>} will be the
+     * given array, and its {@link #arrayOffset </code>array offset<code>} will
+     * be zero.  </p>
+     *
+     * @param  array
+     *         The array that will back this buffer
+     *
+     * @return  The new byte buffer
+     */
+    public static ByteBuffer wrap(byte[] array) {
+        return wrap(array, 0, array.length);
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    /**
+     * Creates a new byte buffer whose content is a shared subsequence of
+     * this buffer's content.
+     *
+     * <p> The content of the new buffer will start at this buffer's current
+     * position.  Changes to this buffer's content will be visible in the new
+     * buffer, and vice versa; the two buffers' position, limit, and mark
+     * values will be independent.
+     *
+     * <p> The new buffer's position will be zero, its capacity and its limit
+     * will be the number of bytes remaining in this buffer, and its mark
+     * will be undefined.  The new buffer will be direct if, and only if, this
+     * buffer is direct, and it will be read-only if, and only if, this buffer
+     * is read-only.  </p>
+     *
+     * @return  The new byte buffer
+     */
+    public abstract ByteBuffer slice();
+
+    /**
+     * Creates a new byte buffer that shares this buffer's content.
+     *
+     * <p> The content of the new buffer will be that of this buffer.  Changes
+     * to this buffer's content will be visible in the new buffer, and vice
+     * versa; the two buffers' position, limit, and mark values will be
+     * independent.
+     *
+     * <p> The new buffer's capacity, limit, position, and mark values will be
+     * identical to those of this buffer.  The new buffer will be direct if,
+     * and only if, this buffer is direct, and it will be read-only if, and
+     * only if, this buffer is read-only.  </p>
+     *
+     * @return  The new byte buffer
+     */
+    public abstract ByteBuffer duplicate();
+
+    /**
+     * Creates a new, read-only byte buffer that shares this buffer's
+     * content.
+     *
+     * <p> The content of the new buffer will be that of this buffer.  Changes
+     * to this buffer's content will be visible in the new buffer; the new
+     * buffer itself, however, will be read-only and will not allow the shared
+     * content to be modified.  The two buffers' position, limit, and mark
+     * values will be independent.
+     *
+     * <p> The new buffer's capacity, limit, position, and mark values will be
+     * identical to those of this buffer.
+     *
+     * <p> If this buffer is itself read-only then this method behaves in
+     * exactly the same way as the {@link #duplicate duplicate} method.  </p>
+     *
+     * @return  The new, read-only byte buffer
+     */
+    public abstract ByteBuffer asReadOnlyBuffer();
+
+
+    // -- Singleton get/put methods --
+
+    /**
+     * Relative <i>get</i> method.  Reads the byte at this buffer's
+     * current position, and then increments the position. </p>
+     *
+     * @return  The byte at the buffer's current position
+     *
+     * @throws  BufferUnderflowException
+     *          If the buffer's current position is not smaller than its limit
+     */
+    public abstract byte get();
+
+    /**
+     * Relative <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes the given byte into this buffer at the current
+     * position, and then increments the position. </p>
+     *
+     * @param  b
+     *         The byte to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  BufferOverflowException
+     *          If this buffer's current position is not smaller than its limit
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer put(byte b);
+
+    /**
+     * Absolute <i>get</i> method.  Reads the byte at the given
+     * index. </p>
+     *
+     * @param  index
+     *         The index from which the byte will be read
+     *
+     * @return  The byte at the given index
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit
+     */
+    public abstract byte get(int index);
+
+    /**
+     * Absolute <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes the given byte into this buffer at the given
+     * index. </p>
+     *
+     * @param  index
+     *         The index at which the byte will be written
+     *
+     * @param  b
+     *         The byte value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer put(int index, byte b);
+
+
+    // -- Bulk get operations --
+
+    /**
+     * Relative bulk <i>get</i> method.
+     *
+     * <p> This method transfers bytes from this buffer into the given
+     * destination array.  If there are fewer bytes remaining in the
+     * buffer than are required to satisfy the request, that is, if
+     * <tt>length</tt>&nbsp;<tt>&gt;</tt>&nbsp;<tt>remaining()</tt>, then no
+     * bytes are transferred and a {@link BufferUnderflowException} is
+     * thrown.
+     *
+     * <p> Otherwise, this method copies <tt>length</tt> bytes from this
+     * buffer into the given array, starting at the current position of this
+     * buffer and at the given offset in the array.  The position of this
+     * buffer is then incremented by <tt>length</tt>.
+     *
+     * <p> In other words, an invocation of this method of the form
+     * <tt>src.get(dst,&nbsp;off,&nbsp;len)</tt> has exactly the same effect as
+     * the loop
+     *
+     * <pre>
+     *     for (int i = off; i < off + len; i++)
+     *         dst[i] = src.get(); </pre>
+     *
+     * except that it first checks that there are sufficient bytes in
+     * this buffer and it is potentially much more efficient. </p>
+     *
+     * @param  dst
+     *         The array into which bytes are to be written
+     *
+     * @param  offset
+     *         The offset within the array of the first byte to be
+     *         written; must be non-negative and no larger than
+     *         <tt>dst.length</tt>
+     *
+     * @param  length
+     *         The maximum number of bytes to be written to the given
+     *         array; must be non-negative and no larger than
+     *         <tt>dst.length - offset</tt>
+     *
+     * @return  This buffer
+     *
+     * @throws  BufferUnderflowException
+     *          If there are fewer than <tt>length</tt> bytes
+     *          remaining in this buffer
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If the preconditions on the <tt>offset</tt> and <tt>length</tt>
+     *          parameters do not hold
+     */
+    public ByteBuffer get(byte[] dst, int offset, int length) {
+        checkBounds(offset, length, dst.length);
+        if (length > remaining())
+            throw new BufferUnderflowException();
+        int end = offset + length;
+        for (int i = offset; i < end; i++)
+            dst[i] = get();
+        return this;
+    }
+
+    /**
+     * Relative bulk <i>get</i> method.
+     *
+     * <p> This method transfers bytes from this buffer into the given
+     * destination array.  An invocation of this method of the form
+     * <tt>src.get(a)</tt> behaves in exactly the same way as the invocation
+     *
+     * <pre>
+     *     src.get(a, 0, a.length) </pre>
+     *
+     * @return  This buffer
+     *
+     * @throws  BufferUnderflowException
+     *          If there are fewer than <tt>length</tt> bytes
+     *          remaining in this buffer
+     */
+    public ByteBuffer get(byte[] dst) {
+        return get(dst, 0, dst.length);
+    }
+
+
+    // -- Bulk put operations --
+
+    /**
+     * Relative bulk <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> This method transfers the bytes remaining in the given source
+     * buffer into this buffer.  If there are more bytes remaining in the
+     * source buffer than in this buffer, that is, if
+     * <tt>src.remaining()</tt>&nbsp;<tt>&gt;</tt>&nbsp;<tt>remaining()</tt>,
+     * then no bytes are transferred and a {@link
+     * BufferOverflowException} is thrown.
+     *
+     * <p> Otherwise, this method copies
+     * <i>n</i>&nbsp;=&nbsp;<tt>src.remaining()</tt> bytes from the given
+     * buffer into this buffer, starting at each buffer's current position.
+     * The positions of both buffers are then incremented by <i>n</i>.
+     *
+     * <p> In other words, an invocation of this method of the form
+     * <tt>dst.put(src)</tt> has exactly the same effect as the loop
+     *
+     * <pre>
+     *     while (src.hasRemaining())
+     *         dst.put(src.get()); </pre>
+     *
+     * except that it first checks that there is sufficient space in this
+     * buffer and it is potentially much more efficient. </p>
+     *
+     * @param  src
+     *         The source buffer from which bytes are to be read;
+     *         must not be this buffer
+     *
+     * @return  This buffer
+     *
+     * @throws  BufferOverflowException
+     *          If there is insufficient space in this buffer
+     *          for the remaining bytes in the source buffer
+     *
+     * @throws  IllegalArgumentException
+     *          If the source buffer is this buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public ByteBuffer put(ByteBuffer src) {
+        if (src == this)
+            throw new IllegalArgumentException();
+        int n = src.remaining();
+        if (n > remaining())
+            throw new BufferOverflowException();
+        for (int i = 0; i < n; i++)
+            put(src.get());
+        return this;
+    }
+
+    /**
+     * Relative bulk <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> This method transfers bytes into this buffer from the given
+     * source array.  If there are more bytes to be copied from the array
+     * than remain in this buffer, that is, if
+     * <tt>length</tt>&nbsp;<tt>&gt;</tt>&nbsp;<tt>remaining()</tt>, then no
+     * bytes are transferred and a {@link BufferOverflowException} is
+     * thrown.
+     *
+     * <p> Otherwise, this method copies <tt>length</tt> bytes from the
+     * given array into this buffer, starting at the given offset in the array
+     * and at the current position of this buffer.  The position of this buffer
+     * is then incremented by <tt>length</tt>.
+     *
+     * <p> In other words, an invocation of this method of the form
+     * <tt>dst.put(src,&nbsp;off,&nbsp;len)</tt> has exactly the same effect as
+     * the loop
+     *
+     * <pre>
+     *     for (int i = off; i < off + len; i++)
+     *         dst.put(a[i]); </pre>
+     *
+     * except that it first checks that there is sufficient space in this
+     * buffer and it is potentially much more efficient. </p>
+     *
+     * @param  src
+     *         The array from which bytes are to be read
+     *
+     * @param  offset
+     *         The offset within the array of the first byte to be read;
+     *         must be non-negative and no larger than <tt>array.length</tt>
+     *
+     * @param  length
+     *         The number of bytes to be read from the given array;
+     *         must be non-negative and no larger than
+     *         <tt>array.length - offset</tt>
+     *
+     * @return  This buffer
+     *
+     * @throws  BufferOverflowException
+     *          If there is insufficient space in this buffer
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If the preconditions on the <tt>offset</tt> and <tt>length</tt>
+     *          parameters do not hold
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public ByteBuffer put(byte[] src, int offset, int length) {
+        checkBounds(offset, length, src.length);
+        if (length > remaining())
+            throw new BufferOverflowException();
+        int end = offset + length;
+        for (int i = offset; i < end; i++)
+            this.put(src[i]);
+        return this;
+    }
+
+    /**
+     * Relative bulk <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> This method transfers the entire content of the given source
+     * byte array into this buffer.  An invocation of this method of the
+     * form <tt>dst.put(a)</tt> behaves in exactly the same way as the
+     * invocation
+     *
+     * <pre>
+     *     dst.put(a, 0, a.length) </pre>
+     *
+     * @return  This buffer
+     *
+     * @throws  BufferOverflowException
+     *          If there is insufficient space in this buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public final ByteBuffer put(byte[] src) {
+        return put(src, 0, src.length);
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    // -- Other stuff --
+
+    /**
+     * Tells whether or not this buffer is backed by an accessible byte
+     * array.
+     *
+     * <p> If this method returns <tt>true</tt> then the {@link #array() array}
+     * and {@link #arrayOffset() arrayOffset} methods may safely be invoked.
+     * </p>
+     *
+     * @return  <tt>true</tt> if, and only if, this buffer
+     *          is backed by an array and is not read-only
+     */
+    public final boolean hasArray() {
+        return (hb != null) && !isReadOnly;
+    }
+
+    /**
+     * Returns the byte array that backs this
+     * buffer&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Modifications to this buffer's content will cause the returned
+     * array's content to be modified, and vice versa.
+     *
+     * <p> Invoke the {@link #hasArray hasArray} method before invoking this
+     * method in order to ensure that this buffer has an accessible backing
+     * array.  </p>
+     *
+     * @return  The array that backs this buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is backed by an array but is read-only
+     *
+     * @throws  UnsupportedOperationException
+     *          If this buffer is not backed by an accessible array
+     */
+    public final byte[] array() {
+        if (hb == null)
+            throw new UnsupportedOperationException();
+        if (isReadOnly)
+            throw new ReadOnlyBufferException();
+        return hb;
+    }
+
+    /**
+     * Returns the offset within this buffer's backing array of the first
+     * element of the buffer&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> If this buffer is backed by an array then buffer position <i>p</i>
+     * corresponds to array index <i>p</i>&nbsp;+&nbsp;<tt>arrayOffset()</tt>.
+     *
+     * <p> Invoke the {@link #hasArray hasArray} method before invoking this
+     * method in order to ensure that this buffer has an accessible backing
+     * array.  </p>
+     *
+     * @return  The offset within this buffer's array
+     *          of the first element of the buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is backed by an array but is read-only
+     *
+     * @throws  UnsupportedOperationException
+     *          If this buffer is not backed by an accessible array
+     */
+    public final int arrayOffset() {
+        if (hb == null)
+            throw new UnsupportedOperationException();
+        if (isReadOnly)
+            throw new ReadOnlyBufferException();
+        return offset;
+    }
+
+    /**
+     * Compacts this buffer&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> The bytes between the buffer's current position and its limit,
+     * if any, are copied to the beginning of the buffer.  That is, the
+     * byte at index <i>p</i>&nbsp;=&nbsp;<tt>position()</tt> is copied
+     * to index zero, the byte at index <i>p</i>&nbsp;+&nbsp;1 is copied
+     * to index one, and so forth until the byte at index
+     * <tt>limit()</tt>&nbsp;-&nbsp;1 is copied to index
+     * <i>n</i>&nbsp;=&nbsp;<tt>limit()</tt>&nbsp;-&nbsp;<tt>1</tt>&nbsp;-&nbsp;<i>p</i>.
+     * The buffer's position is then set to <i>n+1</i> and its limit is set to
+     * its capacity.  The mark, if defined, is discarded.
+     *
+     * <p> The buffer's position is set to the number of bytes copied,
+     * rather than to zero, so that an invocation of this method can be
+     * followed immediately by an invocation of another relative <i>put</i>
+     * method. </p>
+     *
+
+     *
+     * <p> Invoke this method after writing data from a buffer in case the
+     * write was incomplete.  The following loop, for example, copies bytes
+     * from one channel to another via the buffer <tt>buf</tt>:
+     *
+     * <blockquote><pre>
+     * buf.clear();          // Prepare buffer for use
+     * while (in.read(buf) >= 0 || buf.position != 0) {
+     *     buf.flip();
+     *     out.write(buf);
+     *     buf.compact();    // In case of partial write
+     * }</pre></blockquote>
+     *
+
+     *
+     * @return  This buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer compact();
+
+    /**
+     * Tells whether or not this byte buffer is direct. </p>
+     *
+     * @return  <tt>true</tt> if, and only if, this buffer is direct
+     */
+    public abstract boolean isDirect();
+
+
+
+    /**
+     * Returns a string summarizing the state of this buffer.  </p>
+     *
+     * @return  A summary string
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(getClass().getName());
+        sb.append("[pos=");
+        sb.append(position());
+        sb.append(" lim=");
+        sb.append(limit());
+        sb.append(" cap=");
+        sb.append(capacity());
+        sb.append("]");
+        return sb.toString();
+    }
+
+
+
+
+
+
+    /**
+     * Returns the current hash code of this buffer.
+     *
+     * <p> The hash code of a byte buffer depends only upon its remaining
+     * elements; that is, upon the elements from <tt>position()</tt> up to, and
+     * including, the element at <tt>limit()</tt>&nbsp;-&nbsp;<tt>1</tt>.
+     *
+     * <p> Because buffer hash codes are content-dependent, it is inadvisable
+     * to use buffers as keys in hash maps or similar data structures unless it
+     * is known that their contents will not change.  </p>
+     *
+     * @return  The current hash code of this buffer
+     */
+    public int hashCode() {
+        int h = 1;
+        int p = position();
+        for (int i = limit() - 1; i >= p; i--)
+            h = 31 * h + (int)get(i);
+        return h;
+    }
+
+    /**
+     * Tells whether or not this buffer is equal to another object.
+     *
+     * <p> Two byte buffers are equal if, and only if,
+     *
+     * <p><ol>
+     *
+     *   <li><p> They have the same element type,  </p></li>
+     *
+     *   <li><p> They have the same number of remaining elements, and
+     *   </p></li>
+     *
+     *   <li><p> The two sequences of remaining elements, considered
+     *   independently of their starting positions, are pointwise equal.
+     *   </p></li>
+     *
+     * </ol>
+     *
+     * <p> A byte buffer is not equal to any other type of object.  </p>
+     *
+     * @param  ob  The object to which this buffer is to be compared
+     *
+     * @return  <tt>true</tt> if, and only if, this buffer is equal to the
+     *           given object
+     */
+    public boolean equals(Object ob) {
+        if (this == ob)
+            return true;
+        if (!(ob instanceof ByteBuffer))
+            return false;
+        ByteBuffer that = (ByteBuffer)ob;
+        if (this.remaining() != that.remaining())
+            return false;
+        int p = this.position();
+        for (int i = this.limit() - 1, j = that.limit() - 1; i >= p; i--, j--) {
+            byte v1 = this.get(i);
+            byte v2 = that.get(j);
+            if (v1 != v2) {
+                if ((v1 != v1) && (v2 != v2))   // For float and double
+                    continue;
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Compares this buffer to another.
+     *
+     * <p> Two byte buffers are compared by comparing their sequences of
+     * remaining elements lexicographically, without regard to the starting
+     * position of each sequence within its corresponding buffer.
+     *
+     * <p> A byte buffer is not comparable to any other type of object.
+     *
+     * @return  A negative integer, zero, or a positive integer as this buffer
+     *          is less than, equal to, or greater than the given buffer
+     */
+    public int compareTo(Object o) {
+		ByteBuffer that = (ByteBuffer) o;
+        int n = this.position() + Math.min(this.remaining(), that.remaining());
+        for (int i = this.position(), j = that.position(); i < n; i++, j++) {
+            byte v1 = this.get(i);
+            byte v2 = that.get(j);
+            if (v1 == v2)
+                continue;
+            if ((v1 != v1) && (v2 != v2))       // For float and double
+                continue;
+            if (v1 < v2)
+                return -1;
+            return +1;
+        }
+        return this.remaining() - that.remaining();
+    }
+
+
+
+    // -- Other char stuff --
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    // -- Other byte stuff: Access to binary data --
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    boolean bigEndian                                   // package-private
+        = true;
+    boolean nativeByteOrder                             // package-private
+        = (Bits.byteOrder() == ByteOrder.BIG_ENDIAN);
+
+    /**
+     * Retrieves this buffer's byte order.
+     *
+     * <p> The byte order is used when reading or writing multibyte values, and
+     * when creating buffers that are views of this byte buffer.  The order of
+     * a newly-created byte buffer is always {@link ByteOrder#BIG_ENDIAN
+     * BIG_ENDIAN}.  </p>
+     *
+     * @return  This buffer's byte order
+     */
+    public final ByteOrder order() {
+        return bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
+    }
+
+    /**
+     * Modifies this buffer's byte order.  </p>
+     *
+     * @param  bo
+     *         The new byte order,
+     *         either {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}
+     *         or {@link ByteOrder#LITTLE_ENDIAN LITTLE_ENDIAN}
+     *
+     * @return  This buffer
+     */
+    public final ByteBuffer order(ByteOrder bo) {
+        bigEndian = (bo == ByteOrder.BIG_ENDIAN);
+        nativeByteOrder =
+            (bigEndian == (Bits.byteOrder() == ByteOrder.BIG_ENDIAN));
+        return this;
+    }
+
+    // Unchecked accessors, for use by ByteBufferAs-X-Buffer classes
+    //
+    abstract byte _get(int i);                          // package-private
+    abstract void _put(int i, byte b);                  // package-private
+
+
+    /**
+     * Relative <i>get</i> method for reading a char value.
+     *
+     * <p> Reads the next two bytes at this buffer's current position,
+     * composing them into a char value according to the current byte order,
+     * and then increments the position by two.  </p>
+     *
+     * @return  The char value at the buffer's current position
+     *
+     * @throws  BufferUnderflowException
+     *          If there are fewer than two bytes
+     *          remaining in this buffer
+     */
+    public abstract char getChar();
+
+    /**
+     * Relative <i>put</i> method for writing a char
+     * value&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes two bytes containing the given char value, in the
+     * current byte order, into this buffer at the current position, and then
+     * increments the position by two.  </p>
+     *
+     * @param  value
+     *         The char value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  BufferOverflowException
+     *          If there are fewer than two bytes
+     *          remaining in this buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer putChar(char value);
+
+    /**
+     * Absolute <i>get</i> method for reading a char value.
+     *
+     * <p> Reads two bytes at the given index, composing them into a
+     * char value according to the current byte order.  </p>
+     *
+     * @param  index
+     *         The index from which the bytes will be read
+     *
+     * @return  The char value at the given index
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit,
+     *          minus one
+     */
+    public abstract char getChar(int index);
+
+    /**
+     * Absolute <i>put</i> method for writing a char
+     * value&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes two bytes containing the given char value, in the
+     * current byte order, into this buffer at the given index.  </p>
+     *
+     * @param  index
+     *         The index at which the bytes will be written
+     *
+     * @param  value
+     *         The char value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit,
+     *          minus one
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer putChar(int index, char value);
+
+
+    /**
+     * Relative <i>get</i> method for reading a short value.
+     *
+     * <p> Reads the next two bytes at this buffer's current position,
+     * composing them into a short value according to the current byte order,
+     * and then increments the position by two.  </p>
+     *
+     * @return  The short value at the buffer's current position
+     *
+     * @throws  BufferUnderflowException
+     *          If there are fewer than two bytes
+     *          remaining in this buffer
+     */
+    public abstract short getShort();
+
+    /**
+     * Relative <i>put</i> method for writing a short
+     * value&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes two bytes containing the given short value, in the
+     * current byte order, into this buffer at the current position, and then
+     * increments the position by two.  </p>
+     *
+     * @param  value
+     *         The short value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  BufferOverflowException
+     *          If there are fewer than two bytes
+     *          remaining in this buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer putShort(short value);
+
+    /**
+     * Absolute <i>get</i> method for reading a short value.
+     *
+     * <p> Reads two bytes at the given index, composing them into a
+     * short value according to the current byte order.  </p>
+     *
+     * @param  index
+     *         The index from which the bytes will be read
+     *
+     * @return  The short value at the given index
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit,
+     *          minus one
+     */
+    public abstract short getShort(int index);
+
+    /**
+     * Absolute <i>put</i> method for writing a short
+     * value&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes two bytes containing the given short value, in the
+     * current byte order, into this buffer at the given index.  </p>
+     *
+     * @param  index
+     *         The index at which the bytes will be written
+     *
+     * @param  value
+     *         The short value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit,
+     *          minus one
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer putShort(int index, short value);
+
+    /**
+     * Relative <i>get</i> method for reading an int value.
+     *
+     * <p> Reads the next four bytes at this buffer's current position,
+     * composing them into an int value according to the current byte order,
+     * and then increments the position by four.  </p>
+     *
+     * @return  The int value at the buffer's current position
+     *
+     * @throws  BufferUnderflowException
+     *          If there are fewer than four bytes
+     *          remaining in this buffer
+     */
+    public abstract int getInt();
+
+    /**
+     * Relative <i>put</i> method for writing an int
+     * value&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes four bytes containing the given int value, in the
+     * current byte order, into this buffer at the current position, and then
+     * increments the position by four.  </p>
+     *
+     * @param  value
+     *         The int value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  BufferOverflowException
+     *          If there are fewer than four bytes
+     *          remaining in this buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer putInt(int value);
+
+    /**
+     * Absolute <i>get</i> method for reading an int value.
+     *
+     * <p> Reads four bytes at the given index, composing them into a
+     * int value according to the current byte order.  </p>
+     *
+     * @param  index
+     *         The index from which the bytes will be read
+     *
+     * @return  The int value at the given index
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit,
+     *          minus three
+     */
+    public abstract int getInt(int index);
+
+    /**
+     * Absolute <i>put</i> method for writing an int
+     * value&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes four bytes containing the given int value, in the
+     * current byte order, into this buffer at the given index.  </p>
+     *
+     * @param  index
+     *         The index at which the bytes will be written
+     *
+     * @param  value
+     *         The int value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit,
+     *          minus three
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer putInt(int index, int value);
+
+
+    /**
+     * Relative <i>get</i> method for reading a long value.
+     *
+     * <p> Reads the next eight bytes at this buffer's current position,
+     * composing them into a long value according to the current byte order,
+     * and then increments the position by eight.  </p>
+     *
+     * @return  The long value at the buffer's current position
+     *
+     * @throws  BufferUnderflowException
+     *          If there are fewer than eight bytes
+     *          remaining in this buffer
+     */
+    public abstract long getLong();
+
+    /**
+     * Relative <i>put</i> method for writing a long
+     * value&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes eight bytes containing the given long value, in the
+     * current byte order, into this buffer at the current position, and then
+     * increments the position by eight.  </p>
+     *
+     * @param  value
+     *         The long value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  BufferOverflowException
+     *          If there are fewer than eight bytes
+     *          remaining in this buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer putLong(long value);
+
+    /**
+     * Absolute <i>get</i> method for reading a long value.
+     *
+     * <p> Reads eight bytes at the given index, composing them into a
+     * long value according to the current byte order.  </p>
+     *
+     * @param  index
+     *         The index from which the bytes will be read
+     *
+     * @return  The long value at the given index
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit,
+     *          minus seven
+     */
+    public abstract long getLong(int index);
+
+    /**
+     * Absolute <i>put</i> method for writing a long
+     * value&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes eight bytes containing the given long value, in the
+     * current byte order, into this buffer at the given index.  </p>
+     *
+     * @param  index
+     *         The index at which the bytes will be written
+     *
+     * @param  value
+     *         The long value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit,
+     *          minus seven
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer putLong(int index, long value);
+
+
+    /**
+     * Relative <i>get</i> method for reading a float value.
+     *
+     * <p> Reads the next four bytes at this buffer's current position,
+     * composing them into a float value according to the current byte order,
+     * and then increments the position by four.  </p>
+     *
+     * @return  The float value at the buffer's current position
+     *
+     * @throws  BufferUnderflowException
+     *          If there are fewer than four bytes
+     *          remaining in this buffer
+     */
+    public abstract float getFloat();
+
+    /**
+     * Relative <i>put</i> method for writing a float
+     * value&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes four bytes containing the given float value, in the
+     * current byte order, into this buffer at the current position, and then
+     * increments the position by four.  </p>
+     *
+     * @param  value
+     *         The float value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  BufferOverflowException
+     *          If there are fewer than four bytes
+     *          remaining in this buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer putFloat(float value);
+
+    /**
+     * Absolute <i>get</i> method for reading a float value.
+     *
+     * <p> Reads four bytes at the given index, composing them into a
+     * float value according to the current byte order.  </p>
+     *
+     * @param  index
+     *         The index from which the bytes will be read
+     *
+     * @return  The float value at the given index
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit,
+     *          minus three
+     */
+    public abstract float getFloat(int index);
+
+    /**
+     * Absolute <i>put</i> method for writing a float
+     * value&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes four bytes containing the given float value, in the
+     * current byte order, into this buffer at the given index.  </p>
+     *
+     * @param  index
+     *         The index at which the bytes will be written
+     *
+     * @param  value
+     *         The float value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit,
+     *          minus three
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer putFloat(int index, float value);
+
+    /**
+     * Relative <i>get</i> method for reading a double value.
+     *
+     * <p> Reads the next eight bytes at this buffer's current position,
+     * composing them into a double value according to the current byte order,
+     * and then increments the position by eight.  </p>
+     *
+     * @return  The double value at the buffer's current position
+     *
+     * @throws  BufferUnderflowException
+     *          If there are fewer than eight bytes
+     *          remaining in this buffer
+     */
+    public abstract double getDouble();
+
+    /**
+     * Relative <i>put</i> method for writing a double
+     * value&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes eight bytes containing the given double value, in the
+     * current byte order, into this buffer at the current position, and then
+     * increments the position by eight.  </p>
+     *
+     * @param  value
+     *         The double value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  BufferOverflowException
+     *          If there are fewer than eight bytes
+     *          remaining in this buffer
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer putDouble(double value);
+
+    /**
+     * Absolute <i>get</i> method for reading a double value.
+     *
+     * <p> Reads eight bytes at the given index, composing them into a
+     * double value according to the current byte order.  </p>
+     *
+     * @param  index
+     *         The index from which the bytes will be read
+     *
+     * @return  The double value at the given index
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit,
+     *          minus seven
+     */
+    public abstract double getDouble(int index);
+
+    /**
+     * Absolute <i>put</i> method for writing a double
+     * value&nbsp;&nbsp;<i>(optional operation)</i>.
+     *
+     * <p> Writes eight bytes containing the given double value, in the
+     * current byte order, into this buffer at the given index.  </p>
+     *
+     * @param  index
+     *         The index at which the bytes will be written
+     *
+     * @param  value
+     *         The double value to be written
+     *
+     * @return  This buffer
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If <tt>index</tt> is negative
+     *          or not smaller than the buffer's limit,
+     *          minus seven
+     *
+     * @throws  ReadOnlyBufferException
+     *          If this buffer is read-only
+     */
+    public abstract ByteBuffer putDouble(int index, double value);
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/ByteOrder.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/ByteOrder.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/ByteOrder.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/ByteOrder.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio;
+
+
+/**
+ * A typesafe enumeration for byte orders.
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public final class ByteOrder {
+
+    private String name;
+
+    private ByteOrder(String name) {
+        this.name = name;
+    }
+
+    /**
+     * Constant denoting big-endian byte order.  In this order, the bytes of a
+     * multibyte value are ordered from most significant to least significant.
+     * </p>
+     */
+    public static final ByteOrder BIG_ENDIAN
+        = new ByteOrder("BIG_ENDIAN");
+
+    /**
+     * Constant denoting little-endian byte order.  In this order, the bytes of
+     * a multibyte value are ordered from least significant to most
+     * significant.  </p>
+     */
+    public static final ByteOrder LITTLE_ENDIAN
+        = new ByteOrder("LITTLE_ENDIAN");
+
+    /**
+     * Retrieves the native byte order of the underlying platform.
+     *
+     * <p> This method is defined so that performance-sensitive Java code can
+     * allocate direct buffers with the same byte order as the hardware.
+     * Native code libraries are often more efficient when such buffers are
+     * used.  </p>
+     *
+     * @return  The native byte order of the hardware upon which this Java
+     *          virtual machine is running
+     */
+    public static ByteOrder nativeOrder() {
+        return Bits.byteOrder();
+    }
+
+    /**
+     * Constructs a string describing this object.
+     *
+     * <p> This method returns the string <tt>"BIG_ENDIAN"</tt> for {@link
+     * #BIG_ENDIAN} and <tt>"LITTLE_ENDIAN"</tt> for {@link #LITTLE_ENDIAN}.
+     * </p>
+     *
+     * @return  The specified string
+     */
+    public String toString() {
+        return name;
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/AlreadyConnectedException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/AlreadyConnectedException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/AlreadyConnectedException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/AlreadyConnectedException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to connect a {@link
+ * SocketChannel} that is already connected.
+ *
+ * @since 1.4
+ */
+
+public class AlreadyConnectedException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = -7331895245053773357L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public AlreadyConnectedException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/AsynchronousCloseException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/AsynchronousCloseException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/AsynchronousCloseException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/AsynchronousCloseException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Checked exception received by a thread when another thread closes the
+ * channel or the part of the channel upon which it is blocked in an I/O
+ * operation.
+ *
+ * @since 1.4
+ */
+
+public class AsynchronousCloseException
+    extends ClosedChannelException
+{
+
+    private static final long serialVersionUID = 6891178312432313966L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public AsynchronousCloseException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ByteChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ByteChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ByteChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ByteChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2000-2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+
+
+/**
+ * A channel that can read and write bytes.  This interface simply unifies
+ * {@link ReadableByteChannel} and {@link WritableByteChannel}; it does not
+ * specify any new operations.
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public interface ByteChannel
+    extends ReadableByteChannel, WritableByteChannel
+{
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/CancelledKeyException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/CancelledKeyException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/CancelledKeyException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/CancelledKeyException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to use
+ * a selection key that is no longer valid.
+ *
+ * @since 1.4
+ */
+
+public class CancelledKeyException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = -8438032138028814268L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public CancelledKeyException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/Channel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/Channel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/Channel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/Channel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2000-2003 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+import java.io.Closeable;
+
+
+/**
+ * A nexus for I/O operations.
+ *
+ * <p> A channel represents an open connection to an entity such as a hardware
+ * device, a file, a network socket, or a program component that is capable of
+ * performing one or more distinct I/O operations, for example reading or
+ * writing.
+ *
+ * <p> A channel is either open or closed.  A channel is open upon creation,
+ * and once closed it remains closed.  Once a channel is closed, any attempt to
+ * invoke an I/O operation upon it will cause a {@link ClosedChannelException}
+ * to be thrown.  Whether or not a channel is open may be tested by invoking
+ * its {@link #isOpen isOpen} method.
+ *
+ * <p> Channels are, in general, intended to be safe for multithreaded access
+ * as described in the specifications of the interfaces and classes that extend
+ * and implement this interface.
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public interface Channel extends Closeable {
+
+    /**
+     * Tells whether or not this channel is open.  </p>
+     *
+     * @return <tt>true</tt> if, and only if, this channel is open
+     */
+    public boolean isOpen();
+
+    /**
+     * Closes this channel.
+     *
+     * <p> After a channel is closed, any further attempt to invoke I/O
+     * operations upon it will cause a {@link ClosedChannelException} to be
+     * thrown.
+     *
+     * <p> If this channel is already closed then invoking this method has no
+     * effect.
+     *
+     * <p> This method may be invoked at any time.  If some other thread has
+     * already invoked it, however, then another invocation will block until
+     * the first invocation is complete, after which it will return without
+     * effect. </p>
+     *
+     * @throws  IOException  If an I/O error occurs
+     */
+    public void close() throws IOException;
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/Channels.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/Channels.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/Channels.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/Channels.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,459 @@
+/*
+ * Copyright 2000-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.Reader;
+import java.io.Writer;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.BufferOverflowException;
+import java.nio.BufferUnderflowException;
+import java.nio.channels.spi.AbstractInterruptibleChannel;
+import sun.nio.ch.ChannelInputStream;
+
+
+/**
+ * Utility methods for channels and streams.
+ *
+ * <p> This class defines static methods that support the interoperation of the
+ * stream classes of the <tt>{@link java.io}</tt> package with the channel
+ * classes of this package.  </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author Mike McCloskey
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public final class Channels {
+
+    private Channels() { }              // No instantiation
+
+
+    /**
+     * Write all remaining bytes in buffer to the given channel.
+     * If the channel is selectable then it must be configured blocking.
+     */
+    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)
+        throws IOException
+    {
+        while (bb.remaining() > 0) {
+            int n = ch.write(bb);
+            if (n <= 0)
+                throw new RuntimeException("no bytes written");
+        }
+    }
+
+    /**
+     * Write all remaining bytes in buffer to the given channel.
+     *
+     * @throws  IllegalBlockingException
+     *          If the channel is selectable and configured non-blocking.
+     */
+    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)
+        throws IOException
+    {
+        if (ch instanceof SelectableChannel) {
+            SelectableChannel sc = (SelectableChannel)ch;
+            synchronized (sc.blockingLock()) {
+                if (!sc.isBlocking())
+                    throw new IllegalBlockingModeException();
+                writeFullyImpl(ch, bb);
+            }
+        } else {
+            writeFullyImpl(ch, bb);
+        }
+    }
+
+    // -- Byte streams from channels --
+
+    /**
+     * Constructs a stream that reads bytes from the given channel.
+     *
+     * <p> The <tt>read</tt> methods of the resulting stream will throw an
+     * {@link IllegalBlockingModeException} if invoked while the underlying
+     * channel is in non-blocking mode.  The stream will not be buffered, and
+     * it will not support the {@link InputStream#mark mark} or {@link
+     * InputStream#reset reset} methods.  The stream will be safe for access by
+     * multiple concurrent threads.  Closing the stream will in turn cause the
+     * channel to be closed.  </p>
+     *
+     * @param  ch
+     *         The channel from which bytes will be read
+     *
+     * @return  A new input stream
+     */
+    public static InputStream newInputStream(ReadableByteChannel ch) {
+        return new sun.nio.ch.ChannelInputStream(ch);
+    }
+
+    /**
+     * Constructs a stream that writes bytes to the given channel.
+     *
+     * <p> The <tt>write</tt> methods of the resulting stream will throw an
+     * {@link IllegalBlockingModeException} if invoked while the underlying
+     * channel is in non-blocking mode.  The stream will not be buffered.  The
+     * stream will be safe for access by multiple concurrent threads.  Closing
+     * the stream will in turn cause the channel to be closed.  </p>
+     *
+     * @param  ch
+     *         The channel to which bytes will be written
+     *
+     * @return  A new output stream
+     */
+    public static OutputStream newOutputStream(final WritableByteChannel ch) {
+        return new OutputStream() {
+
+                private ByteBuffer bb = null;
+                private byte[] bs = null;       // Invoker's previous array
+                private byte[] b1 = null;
+
+                public synchronized void write(int b) throws IOException {
+                   if (b1 == null)
+                        b1 = new byte[1];
+                    b1[0] = (byte)b;
+                    this.write(b1);
+                }
+
+                public synchronized void write(byte[] bs, int off, int len)
+                    throws IOException
+                {
+                    if ((off < 0) || (off > bs.length) || (len < 0) ||
+                        ((off + len) > bs.length) || ((off + len) < 0)) {
+                        throw new IndexOutOfBoundsException();
+                    } else if (len == 0) {
+                        return;
+                    }
+                    ByteBuffer bb = ((this.bs == bs)
+                                     ? this.bb
+                                     : ByteBuffer.wrap(bs));
+                    bb.limit(Math.min(off + len, bb.capacity()));
+                    bb.position(off);
+                    this.bb = bb;
+                    this.bs = bs;
+                    Channels.writeFully(ch, bb);
+                }
+
+                public void close() throws IOException {
+                    ch.close();
+                }
+
+            };
+    }
+
+
+    // -- Channels from streams --
+
+    /**
+     * Constructs a channel that reads bytes from the given stream.
+     *
+     * <p> The resulting channel will not be buffered; it will simply redirect
+     * its I/O operations to the given stream.  Closing the channel will in
+     * turn cause the stream to be closed.  </p>
+     *
+     * @param  in
+     *         The stream from which bytes are to be read
+     *
+     * @return  A new readable byte channel
+     */
+    public static ReadableByteChannel newChannel(final InputStream in) {
+        if (in == null) {
+            throw new NullPointerException();
+        }
+
+        if (in instanceof FileInputStream &&
+            FileInputStream.class.equals(in.getClass())) {
+               return ((FileInputStream)in).getChannel();
+        }
+
+        return new ReadableByteChannelImpl(in);
+    }
+
+    private static class ReadableByteChannelImpl
+        extends AbstractInterruptibleChannel    // Not really interruptible
+        implements ReadableByteChannel
+    {
+        InputStream in;
+        private static final int TRANSFER_SIZE = 8192;
+        private byte buf[] = new byte[0];
+        private boolean open = true;
+        private Object readLock = new Object();
+
+        ReadableByteChannelImpl(InputStream in) {
+            this.in = in;
+        }
+
+        public int read(ByteBuffer dst) throws IOException {
+            int len = dst.remaining();
+            int totalRead = 0;
+            int bytesRead = 0;
+            synchronized (readLock) {
+                while (totalRead < len) {
+                    int bytesToRead = Math.min((len - totalRead),
+                                               TRANSFER_SIZE);
+                    if (buf.length < bytesToRead)
+                        buf = new byte[bytesToRead];
+                    if ((totalRead > 0) && !(in.available() > 0))
+                        break; // block at most once
+                    try {
+                        begin();
+                        bytesRead = in.read(buf, 0, bytesToRead);
+                    } finally {
+                        end(bytesRead > 0);
+                    }
+                    if (bytesRead < 0)
+                        break;
+                    else
+                        totalRead += bytesRead;
+                    dst.put(buf, 0, bytesRead);
+                }
+                if ((bytesRead < 0) && (totalRead == 0))
+                    return -1;
+
+                return totalRead;
+            }
+        }
+
+        protected void implCloseChannel() throws IOException {
+            in.close();
+            open = false;
+        }
+    }
+
+
+    /**
+     * Constructs a channel that writes bytes to the given stream.
+     *
+     * <p> The resulting channel will not be buffered; it will simply redirect
+     * its I/O operations to the given stream.  Closing the channel will in
+     * turn cause the stream to be closed.  </p>
+     *
+     * @param  out
+     *         The stream to which bytes are to be written
+     *
+     * @return  A new writable byte channel
+     */
+    public static WritableByteChannel newChannel(final OutputStream out) {
+        if (out == null) {
+            throw new NullPointerException();
+        }
+
+        if (out instanceof FileOutputStream &&
+            FileOutputStream.class.equals(out.getClass())) {
+                return ((FileOutputStream)out).getChannel();
+        }
+
+        return new WritableByteChannelImpl(out);
+    }
+
+    private static class WritableByteChannelImpl
+        extends AbstractInterruptibleChannel    // Not really interruptible
+        implements WritableByteChannel
+    {
+        OutputStream out;
+        private static final int TRANSFER_SIZE = 8192;
+        private byte buf[] = new byte[0];
+        private boolean open = true;
+        private Object writeLock = new Object();
+
+        WritableByteChannelImpl(OutputStream out) {
+            this.out = out;
+        }
+
+        public int write(ByteBuffer src) throws IOException {
+            int len = src.remaining();
+            int totalWritten = 0;
+            synchronized (writeLock) {
+                while (totalWritten < len) {
+                    int bytesToWrite = Math.min((len - totalWritten),
+                                                TRANSFER_SIZE);
+                    if (buf.length < bytesToWrite)
+                        buf = new byte[bytesToWrite];
+                    src.get(buf, 0, bytesToWrite);
+                    try {
+                        begin();
+                        out.write(buf, 0, bytesToWrite);
+                    } finally {
+                        end(bytesToWrite > 0);
+                    }
+                    totalWritten += bytesToWrite;
+                }
+                return totalWritten;
+            }
+        }
+
+        protected void implCloseChannel() throws IOException {
+            out.close();
+            open = false;
+        }
+    }
+
+
+    // -- Character streams from channels --
+
+    /**
+     * Constructs a reader that decodes bytes from the given channel using the
+     * given decoder.
+     *
+     * <p> The resulting stream will contain an internal input buffer of at
+     * least <tt>minBufferCap</tt> bytes.  The stream's <tt>read</tt> methods
+     * will, as needed, fill the buffer by reading bytes from the underlying
+     * channel; if the channel is in non-blocking mode when bytes are to be
+     * read then an {@link IllegalBlockingModeException} will be thrown.  The
+     * resulting stream will not otherwise be buffered, and it will not support
+     * the {@link Reader#mark mark} or {@link Reader#reset reset} methods.
+     * Closing the stream will in turn cause the channel to be closed.  </p>
+     *
+     * @param  ch
+     *         The channel from which bytes will be read
+     *
+     * @param  dec
+     *         The charset decoder to be used
+     *
+     * @param  minBufferCap
+     *         The minimum capacity of the internal byte buffer,
+     *         or <tt>-1</tt> if an implementation-dependent
+     *         default capacity is to be used
+     *
+     * @return  A new reader
+     */
+/*    public static Reader newReader(ReadableByteChannel ch,
+                                   CharsetDecoder dec,
+                                   int minBufferCap)
+    {
+        dec.reset();
+        return StreamDecoder.forDecoder(ch, dec, minBufferCap);
+    }
+*/
+    /**
+     * Constructs a reader that decodes bytes from the given channel according
+     * to the named charset.
+     *
+     * <p> An invocation of this method of the form
+     *
+     * <blockquote><pre>
+     * Channels.newReader(ch, csname)</pre></blockquote>
+     *
+     * behaves in exactly the same way as the expression
+     *
+     * <blockquote><pre>
+     * Channels.newReader(ch,
+     *                    Charset.forName(csName)
+     *                        .newDecoder(),
+     *                    -1);</pre></blockquote>
+     *
+     * @param  ch
+     *         The channel from which bytes will be read
+     *
+     * @param  csName
+     *         The name of the charset to be used
+     *
+     * @return  A new reader
+     *
+     * @throws  UnsupportedCharsetException
+     *          If no support for the named charset is available
+     *          in this instance of the Java virtual machine
+     */
+/*    public static Reader newReader(ReadableByteChannel ch,
+                                   String csName)
+    {
+        return newReader(ch, Charset.forName(csName).newDecoder(), -1);
+    }
+*/
+    /**
+     * Constructs a writer that encodes characters using the given encoder and
+     * writes the resulting bytes to the given channel.
+     *
+     * <p> The resulting stream will contain an internal output buffer of at
+     * least <tt>minBufferCap</tt> bytes.  The stream's <tt>write</tt> methods
+     * will, as needed, flush the buffer by writing bytes to the underlying
+     * channel; if the channel is in non-blocking mode when bytes are to be
+     * written then an {@link IllegalBlockingModeException} will be thrown.
+     * The resulting stream will not otherwise be buffered.  Closing the stream
+     * will in turn cause the channel to be closed.  </p>
+     *
+     * @param  ch
+     *         The channel to which bytes will be written
+     *
+     * @param  enc
+     *         The charset encoder to be used
+     *
+     * @param  minBufferCap
+     *         The minimum capacity of the internal byte buffer,
+     *         or <tt>-1</tt> if an implementation-dependent
+     *         default capacity is to be used
+     *
+     * @return  A new writer
+     */
+/*    public static Writer newWriter(final WritableByteChannel ch,
+                                   final CharsetEncoder enc,
+                                   final int minBufferCap)
+    {
+        enc.reset();
+        return StreamEncoder.forEncoder(ch, enc, minBufferCap);
+    }
+*/
+    /**
+     * Constructs a writer that encodes characters according to the named
+     * charset and writes the resulting bytes to the given channel.
+     *
+     * <p> An invocation of this method of the form
+     *
+     * <blockquote><pre>
+     * Channels.newWriter(ch, csname)</pre></blockquote>
+     *
+     * behaves in exactly the same way as the expression
+     *
+     * <blockquote><pre>
+     * Channels.newWriter(ch,
+     *                    Charset.forName(csName)
+     *                        .newEncoder(),
+     *                    -1);</pre></blockquote>
+     *
+     * @param  ch
+     *         The channel to which bytes will be written
+     *
+     * @param  csName
+     *         The name of the charset to be used
+     *
+     * @return  A new writer
+     *
+     * @throws  UnsupportedCharsetException
+     *          If no support for the named charset is available
+     *          in this instance of the Java virtual machine
+     */
+ /*   public static Writer newWriter(WritableByteChannel ch,
+                                   String csName)
+    {
+        return newWriter(ch, Charset.forName(csName).newEncoder(), -1);
+    }
+*/
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ClosedByInterruptException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ClosedByInterruptException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ClosedByInterruptException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ClosedByInterruptException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Checked exception received by a thread when another thread interrupts it
+ * while it is blocked in an I/O operation upon a channel.  Before this
+ * exception is thrown the channel will have been closed and the interrupt
+ * status of the previously-blocked thread will have been set.
+ *
+ * @since 1.4
+ */
+
+public class ClosedByInterruptException
+    extends AsynchronousCloseException
+{
+
+    private static final long serialVersionUID = -4488191543534286750L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public ClosedByInterruptException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ClosedChannelException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ClosedChannelException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ClosedChannelException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ClosedChannelException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Checked exception thrown when an attempt is made to invoke or complete an
+ * I/O operation upon channel that is closed, or at least closed to that
+ * operation.  That this exception is thrown does not necessarily imply that
+ * the channel is completely closed.  A socket channel whose write half has
+ * been shut down, for example, may still be open for reading.
+ *
+ * @since 1.4
+ */
+
+public class ClosedChannelException
+    extends java.io.IOException
+{
+
+    private static final long serialVersionUID = 882777185433553857L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public ClosedChannelException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ClosedSelectorException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ClosedSelectorException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ClosedSelectorException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ClosedSelectorException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to invoke an I/O
+ * operation upon a closed selector.
+ *
+ * @since 1.4
+ */
+
+public class ClosedSelectorException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = 6466297122317847835L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public ClosedSelectorException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ConnectionPendingException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ConnectionPendingException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ConnectionPendingException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ConnectionPendingException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to connect a {@link
+ * SocketChannel} for which a non-blocking connection operation is already in
+ * progress.
+ *
+ * @since 1.4
+ */
+
+public class ConnectionPendingException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = 2008393366501760879L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public ConnectionPendingException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/exceptions phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/exceptions
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/exceptions	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/exceptions	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,148 @@
+#
+# Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Sun designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Sun in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+# CA 95054 USA or visit www.sun.com if you need additional information or
+# have any questions.
+#
+
+# Generated exception classes for java.nio.channels
+
+SINCE=1.4
+PACKAGE=java.nio.channels
+# This year should only change if the generated source is modified.
+COPYRIGHT_YEARS=2000-2007
+
+
+SUPER=java.io.IOException
+
+gen ClosedChannelException "
+ * Checked exception thrown when an attempt is made to invoke or complete an
+ * I/O operation upon channel that is closed, or at least closed to that
+ * operation.  That this exception is thrown does not necessarily imply that
+ * the channel is completely closed.  A socket channel whose write half has
+ * been shut down, for example, may still be open for reading." \
+ 882777185433553857L
+
+gen FileLockInterruptionException "
+ * Checked exception received by a thread when another thread interrupts it
+ * while it is waiting to acquire a file lock.  Before this exception is thrown
+ * the interrupt status of the previously-blocked thread will have been set." \
+ 7104080643653532383L
+
+
+SUPER=ClosedChannelException
+
+gen AsynchronousCloseException "
+ * Checked exception received by a thread when another thread closes the
+ * channel or the part of the channel upon which it is blocked in an I/O
+ * operation." \
+ 6891178312432313966L
+
+
+SUPER=AsynchronousCloseException
+
+gen ClosedByInterruptException "
+ * Checked exception received by a thread when another thread interrupts it
+ * while it is blocked in an I/O operation upon a channel.  Before this
+ * exception is thrown the channel will have been closed and the interrupt
+ * status of the previously-blocked thread will have been set." \
+ -4488191543534286750L
+
+
+SUPER=IllegalArgumentException
+
+gen IllegalSelectorException "
+ * Unchecked exception thrown when an attempt is made to register a channel
+ * with a selector that was not created by the provider that created the
+ * channel." \
+ -8406323347253320987L
+
+gen UnresolvedAddressException "
+ * Unchecked exception thrown when an attempt is made to invoke a network
+ * operation upon an unresolved socket address." \
+ 6136959093620794148L
+
+gen UnsupportedAddressTypeException "
+ * Unchecked exception thrown when an attempt is made to bind or connect
+ * to a socket address of a type that is not supported." \
+ -2964323842829700493L
+
+
+SUPER=IllegalStateException
+
+gen AlreadyConnectedException "
+ * Unchecked exception thrown when an attempt is made to connect a {@link
+ * SocketChannel} that is already connected." \
+ -7331895245053773357L
+
+gen ConnectionPendingException "
+ * Unchecked exception thrown when an attempt is made to connect a {@link
+ * SocketChannel} for which a non-blocking connection operation is already in
+ * progress." \
+ 2008393366501760879L
+
+gen ClosedSelectorException "
+ * Unchecked exception thrown when an attempt is made to invoke an I/O
+ * operation upon a closed selector." \
+ 6466297122317847835L
+
+gen CancelledKeyException "
+ * Unchecked exception thrown when an attempt is made to use
+ * a selection key that is no longer valid." \
+ -8438032138028814268L
+
+gen IllegalBlockingModeException "
+ * Unchecked exception thrown when a blocking-mode-specific operation
+ * is invoked upon a channel in the incorrect blocking mode." \
+ -3335774961855590474L
+
+gen NoConnectionPendingException "
+ * Unchecked exception thrown when the {@link SocketChannel#finishConnect
+ * finishConnect} method of a {@link SocketChannel} is invoked without first
+ * successfully invoking its {@link SocketChannel#connect connect} method." \
+ -8296561183633134743L
+
+gen NonReadableChannelException "
+ * Unchecked exception thrown when an attempt is made to read
+ * from a channel that was not originally opened for reading." \
+ -3200915679294993514L
+
+gen NonWritableChannelException "
+ * Unchecked exception thrown when an attempt is made to write
+ * to a channel that was not originally opened for writing." \
+ -7071230488279011621L
+
+gen NotYetBoundException "
+ * Unchecked exception thrown when an attempt is made to invoke an I/O
+ * operation upon a server socket channel that is not yet bound." \
+ 4640999303950202242L
+
+gen NotYetConnectedException "
+ * Unchecked exception thrown when an attempt is made to invoke an I/O
+ * operation upon a socket channel that is not yet connected." \
+ 4697316551909513464L
+
+gen OverlappingFileLockException "
+ * Unchecked exception thrown when an attempt is made to acquire a lock on a
+ * region of a file that overlaps a region already locked by the same Java
+ * virtual machine, or when another thread is already waiting to lock an
+ * overlapping region of the same file." \
+ 2047812138163068433L
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/FileChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/FileChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/FileChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/FileChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,743 @@
+/*
+ * Copyright 2000-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.*;
+import java.nio.ByteBuffer;
+import java.nio.MappedByteBuffer;
+import java.nio.channels.spi.AbstractInterruptibleChannel;
+
+
+/**
+ * A channel for reading, writing, mapping, and manipulating a file.
+ *
+ * <p> A file channel has a current <i>position</i> within its file which can
+ * be both {@link #position() </code>queried<code>} and {@link #position(long)
+ * </code>modified<code>}.  The file itself contains a variable-length sequence
+ * of bytes that can be read and written and whose current {@link #size
+ * </code><i>size</i><code>} can be queried.  The size of the file increases
+ * when bytes are written beyond its current size; the size of the file
+ * decreases when it is {@link #truncate </code><i>truncated</i><code>}.  The
+ * file may also have some associated <i>metadata</i> such as access
+ * permissions, content type, and last-modification time; this class does not
+ * define methods for metadata access.
+ *
+ * <p> In addition to the familiar read, write, and close operations of byte
+ * channels, this class defines the following file-specific operations: </p>
+ *
+ * <ul>
+ *
+ *   <li><p> Bytes may be {@link #read(ByteBuffer, long) </code>read<code>} or
+ *   {@link #write(ByteBuffer, long) </code>written<code>} at an absolute
+ *   position in a file in a way that does not affect the channel's current
+ *   position.  </p></li>
+ *
+ *   <li><p> A region of a file may be {@link #map </code>mapped<code>}
+ *   directly into memory; for large files this is often much more efficient
+ *   than invoking the usual <tt>read</tt> or <tt>write</tt> methods.
+ *   </p></li>
+ *
+ *   <li><p> Updates made to a file may be {@link #force </code>forced
+ *   out<code>} to the underlying storage device, ensuring that data are not
+ *   lost in the event of a system crash.  </p></li>
+ *
+ *   <li><p> Bytes can be transferred from a file {@link #transferTo </code>to
+ *   some other channel<code>}, and {@link #transferFrom </code>vice
+ *   versa<code>}, in a way that can be optimized by many operating systems
+ *   into a very fast transfer directly to or from the filesystem cache.
+ *   </p></li>
+ *
+ *   <li><p> A region of a file may be {@link FileLock </code>locked<code>}
+ *   against access by other programs.  </p></li>
+ *
+ * </ul>
+ *
+ * <p> File channels are safe for use by multiple concurrent threads.  The
+ * {@link Channel#close close} method may be invoked at any time, as specified
+ * by the {@link Channel} interface.  Only one operation that involves the
+ * channel's position or can change its file's size may be in progress at any
+ * given time; attempts to initiate a second such operation while the first is
+ * still in progress will block until the first operation completes.  Other
+ * operations, in particular those that take an explicit position, may proceed
+ * concurrently; whether they in fact do so is dependent upon the underlying
+ * implementation and is therefore unspecified.
+ *
+ * <p> The view of a file provided by an instance of this class is guaranteed
+ * to be consistent with other views of the same file provided by other
+ * instances in the same program.  The view provided by an instance of this
+ * class may or may not, however, be consistent with the views seen by other
+ * concurrently-running programs due to caching performed by the underlying
+ * operating system and delays induced by network-filesystem protocols.  This
+ * is true regardless of the language in which these other programs are
+ * written, and whether they are running on the same machine or on some other
+ * machine.  The exact nature of any such inconsistencies are system-dependent
+ * and are therefore unspecified.
+ *
+ * <p> This class does not define methods for opening existing files or for
+ * creating new ones; such methods may be added in a future release.  In this
+ * release a file channel can be obtained from an existing {@link
+ * java.io.FileInputStream#getChannel FileInputStream}, {@link
+ * java.io.FileOutputStream#getChannel FileOutputStream}, or {@link
+ * java.io.RandomAccessFile#getChannel RandomAccessFile} object by invoking
+ * that object's <tt>getChannel</tt> method, which returns a file channel that
+ * is connected to the same underlying file.
+ *
+ * <p> The state of a file channel is intimately connected to that of the
+ * object whose <tt>getChannel</tt> method returned the channel.  Changing the
+ * channel's position, whether explicitly or by reading or writing bytes, will
+ * change the file position of the originating object, and vice versa.
+ * Changing the file's length via the file channel will change the length seen
+ * via the originating object, and vice versa.  Changing the file's content by
+ * writing bytes will change the content seen by the originating object, and
+ * vice versa.
+ *
+ * <a name="open-mode"><p> At various points this class specifies that an
+ * instance that is "open for reading," "open for writing," or "open for
+ * reading and writing" is required.  A channel obtained via the {@link
+ * java.io.FileInputStream#getChannel getChannel} method of a {@link
+ * java.io.FileInputStream} instance will be open for reading.  A channel
+ * obtained via the {@link java.io.FileOutputStream#getChannel getChannel}
+ * method of a {@link java.io.FileOutputStream} instance will be open for
+ * writing.  Finally, a channel obtained via the {@link
+ * java.io.RandomAccessFile#getChannel getChannel} method of a {@link
+ * java.io.RandomAccessFile} instance will be open for reading if the instance
+ * was created with mode <tt>"r"</tt> and will be open for reading and writing
+ * if the instance was created with mode <tt>"rw"</tt>.
+ *
+ * <a name="append-mode"><p> A file channel that is open for writing may be in
+ * <i>append mode</i>, for example if it was obtained from a file-output stream
+ * that was created by invoking the {@link
+ * java.io.FileOutputStream#FileOutputStream(java.io.File,boolean)
+ * FileOutputStream(File,boolean)} constructor and passing <tt>true</tt> for
+ * the second parameter.  In this mode each invocation of a relative write
+ * operation first advances the position to the end of the file and then writes
+ * the requested data.  Whether the advancement of the position and the writing
+ * of the data are done in a single atomic operation is system-dependent and
+ * therefore unspecified.
+ *
+ *
+ * @see java.io.FileInputStream#getChannel()
+ * @see java.io.FileOutputStream#getChannel()
+ * @see java.io.RandomAccessFile#getChannel()
+ *
+ * @author Mark Reinhold
+ * @author Mike McCloskey
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public abstract class FileChannel
+    extends AbstractInterruptibleChannel
+    implements ByteChannel, GatheringByteChannel, ScatteringByteChannel
+{
+
+    /**
+     * Initializes a new instance of this class.
+     */
+    protected FileChannel() { }
+
+
+    // -- Channel operations --
+
+    /**
+     * Reads a sequence of bytes from this channel into the given buffer.
+     *
+     * <p> Bytes are read starting at this channel's current file position, and
+     * then the file position is updated with the number of bytes actually
+     * read.  Otherwise this method behaves exactly as specified in the {@link
+     * ReadableByteChannel} interface. </p>
+     */
+    public abstract int read(ByteBuffer dst) throws IOException;
+
+    /**
+     * Reads a sequence of bytes from this channel into a subsequence of the
+     * given buffers.
+     *
+     * <p> Bytes are read starting at this channel's current file position, and
+     * then the file position is updated with the number of bytes actually
+     * read.  Otherwise this method behaves exactly as specified in the {@link
+     * ScatteringByteChannel} interface.  </p>
+     */
+    public abstract long read(ByteBuffer[] dsts, int offset, int length)
+        throws IOException;
+
+    /**
+     * Reads a sequence of bytes from this channel into the given buffers.
+     *
+     * <p> Bytes are read starting at this channel's current file position, and
+     * then the file position is updated with the number of bytes actually
+     * read.  Otherwise this method behaves exactly as specified in the {@link
+     * ScatteringByteChannel} interface.  </p>
+     */
+    public final long read(ByteBuffer[] dsts) throws IOException {
+        return read(dsts, 0, dsts.length);
+    }
+
+    /**
+     * Writes a sequence of bytes to this channel from the given buffer.
+     *
+     * <p> Bytes are written starting at this channel's current file position
+     * unless the channel is in append mode, in which case the position is
+     * first advanced to the end of the file.  The file is grown, if necessary,
+     * to accommodate the written bytes, and then the file position is updated
+     * with the number of bytes actually written.  Otherwise this method
+     * behaves exactly as specified by the {@link WritableByteChannel}
+     * interface. </p>
+     */
+    public abstract int write(ByteBuffer src) throws IOException;
+
+    /**
+     * Writes a sequence of bytes to this channel from a subsequence of the
+     * given buffers.
+     *
+     * <p> Bytes are written starting at this channel's current file position
+     * unless the channel is in append mode, in which case the position is
+     * first advanced to the end of the file.  The file is grown, if necessary,
+     * to accommodate the written bytes, and then the file position is updated
+     * with the number of bytes actually written.  Otherwise this method
+     * behaves exactly as specified in the {@link GatheringByteChannel}
+     * interface.  </p>
+     */
+    public abstract long write(ByteBuffer[] srcs, int offset, int length)
+        throws IOException;
+
+    /**
+     * Writes a sequence of bytes to this channel from the given buffers.
+     *
+     * <p> Bytes are written starting at this channel's current file position
+     * unless the channel is in append mode, in which case the position is
+     * first advanced to the end of the file.  The file is grown, if necessary,
+     * to accommodate the written bytes, and then the file position is updated
+     * with the number of bytes actually written.  Otherwise this method
+     * behaves exactly as specified in the {@link GatheringByteChannel}
+     * interface.  </p>
+     */
+    public final long write(ByteBuffer[] srcs) throws IOException {
+        return write(srcs, 0, srcs.length);
+    }
+
+
+    // -- Other operations --
+
+    /**
+     * Returns this channel's file position.  </p>
+     *
+     * @return  This channel's file position,
+     *          a non-negative integer counting the number of bytes
+     *          from the beginning of the file to the current position
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public abstract long position() throws IOException;
+
+    /**
+     * Sets this channel's file position.
+     *
+     * <p> Setting the position to a value that is greater than the file's
+     * current size is legal but does not change the size of the file.  A later
+     * attempt to read bytes at such a position will immediately return an
+     * end-of-file indication.  A later attempt to write bytes at such a
+     * position will cause the file to be grown to accommodate the new bytes;
+     * the values of any bytes between the previous end-of-file and the
+     * newly-written bytes are unspecified.  </p>
+     *
+     * @param  newPosition
+     *         The new position, a non-negative integer counting
+     *         the number of bytes from the beginning of the file
+     *
+     * @return  This file channel
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  IllegalArgumentException
+     *          If the new position is negative
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public abstract FileChannel position(long newPosition) throws IOException;
+
+    /**
+     * Returns the current size of this channel's file. </p>
+     *
+     * @return  The current size of this channel's file,
+     *          measured in bytes
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public abstract long size() throws IOException;
+
+    /**
+     * Truncates this channel's file to the given size.
+     *
+     * <p> If the given size is less than the file's current size then the file
+     * is truncated, discarding any bytes beyond the new end of the file.  If
+     * the given size is greater than or equal to the file's current size then
+     * the file is not modified.  In either case, if this channel's file
+     * position is greater than the given size then it is set to that size.
+     * </p>
+     *
+     * @param  size
+     *         The new size, a non-negative byte count
+     *
+     * @return  This file channel
+     *
+     * @throws  NonWritableChannelException
+     *          If this channel was not opened for writing
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  IllegalArgumentException
+     *          If the new size is negative
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public abstract FileChannel truncate(long size) throws IOException;
+
+    /**
+     * Forces any updates to this channel's file to be written to the storage
+     * device that contains it.
+     *
+     * <p> If this channel's file resides on a local storage device then when
+     * this method returns it is guaranteed that all changes made to the file
+     * since this channel was created, or since this method was last invoked,
+     * will have been written to that device.  This is useful for ensuring that
+     * critical information is not lost in the event of a system crash.
+     *
+     * <p> If the file does not reside on a local device then no such guarantee
+     * is made.
+     *
+     * <p> The <tt>metaData</tt> parameter can be used to limit the number of
+     * I/O operations that this method is required to perform.  Passing
+     * <tt>false</tt> for this parameter indicates that only updates to the
+     * file's content need be written to storage; passing <tt>true</tt>
+     * indicates that updates to both the file's content and metadata must be
+     * written, which generally requires at least one more I/O operation.
+     * Whether this parameter actually has any effect is dependent upon the
+     * underlying operating system and is therefore unspecified.
+     *
+     * <p> Invoking this method may cause an I/O operation to occur even if the
+     * channel was only opened for reading.  Some operating systems, for
+     * example, maintain a last-access time as part of a file's metadata, and
+     * this time is updated whenever the file is read.  Whether or not this is
+     * actually done is system-dependent and is therefore unspecified.
+     *
+     * <p> This method is only guaranteed to force changes that were made to
+     * this channel's file via the methods defined in this class.  It may or
+     * may not force changes that were made by modifying the content of a
+     * {@link MappedByteBuffer </code>mapped byte buffer<code>} obtained by
+     * invoking the {@link #map map} method.  Invoking the {@link
+     * MappedByteBuffer#force force} method of the mapped byte buffer will
+     * force changes made to the buffer's content to be written.  </p>
+     *
+     * @param   metaData
+     *          If <tt>true</tt> then this method is required to force changes
+     *          to both the file's content and metadata to be written to
+     *          storage; otherwise, it need only force content changes to be
+     *          written
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public abstract void force(boolean metaData) throws IOException;
+
+    /**
+     * Transfers bytes from this channel's file to the given writable byte
+     * channel.
+     *
+     * <p> An attempt is made to read up to <tt>count</tt> bytes starting at
+     * the given <tt>position</tt> in this channel's file and write them to the
+     * target channel.  An invocation of this method may or may not transfer
+     * all of the requested bytes; whether or not it does so depends upon the
+     * natures and states of the channels.  Fewer than the requested number of
+     * bytes are transferred if this channel's file contains fewer than
+     * <tt>count</tt> bytes starting at the given <tt>position</tt>, or if the
+     * target channel is non-blocking and it has fewer than <tt>count</tt>
+     * bytes free in its output buffer.
+     *
+     * <p> This method does not modify this channel's position.  If the given
+     * position is greater than the file's current size then no bytes are
+     * transferred.  If the target channel has a position then bytes are
+     * written starting at that position and then the position is incremented
+     * by the number of bytes written.
+     *
+     * <p> This method is potentially much more efficient than a simple loop
+     * that reads from this channel and writes to the target channel.  Many
+     * operating systems can transfer bytes directly from the filesystem cache
+     * to the target channel without actually copying them.  </p>
+     *
+     * @param  position
+     *         The position within the file at which the transfer is to begin;
+     *         must be non-negative
+     *
+     * @param  count
+     *         The maximum number of bytes to be transferred; must be
+     *         non-negative
+     *
+     * @param  target
+     *         The target channel
+     *
+     * @return  The number of bytes, possibly zero,
+     *          that were actually transferred
+     *
+     * @throws IllegalArgumentException
+     *         If the preconditions on the parameters do not hold
+     *
+     * @throws  NonReadableChannelException
+     *          If this channel was not opened for reading
+     *
+     * @throws  NonWritableChannelException
+     *          If the target channel was not opened for writing
+     *
+     * @throws  ClosedChannelException
+     *          If either this channel or the target channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes either channel
+     *          while the transfer is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread while the
+     *          transfer is in progress, thereby closing both channels and
+     *          setting the current thread's interrupt status
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public abstract long transferTo(long position, long count,
+                                    WritableByteChannel target)
+        throws IOException;
+
+    /**
+     * Transfers bytes into this channel's file from the given readable byte
+     * channel.
+     *
+     * <p> An attempt is made to read up to <tt>count</tt> bytes from the
+     * source channel and write them to this channel's file starting at the
+     * given <tt>position</tt>.  An invocation of this method may or may not
+     * transfer all of the requested bytes; whether or not it does so depends
+     * upon the natures and states of the channels.  Fewer than the requested
+     * number of bytes will be transferred if the source channel has fewer than
+     * <tt>count</tt> bytes remaining, or if the source channel is non-blocking
+     * and has fewer than <tt>count</tt> bytes immediately available in its
+     * input buffer.
+     *
+     * <p> This method does not modify this channel's position.  If the given
+     * position is greater than the file's current size then no bytes are
+     * transferred.  If the source channel has a position then bytes are read
+     * starting at that position and then the position is incremented by the
+     * number of bytes read.
+     *
+     * <p> This method is potentially much more efficient than a simple loop
+     * that reads from the source channel and writes to this channel.  Many
+     * operating systems can transfer bytes directly from the source channel
+     * into the filesystem cache without actually copying them.  </p>
+     *
+     * @param  src
+     *         The source channel
+     *
+     * @param  position
+     *         The position within the file at which the transfer is to begin;
+     *         must be non-negative
+     *
+     * @param  count
+     *         The maximum number of bytes to be transferred; must be
+     *         non-negative
+     *
+     * @return  The number of bytes, possibly zero,
+     *          that were actually transferred
+     *
+     * @throws IllegalArgumentException
+     *         If the preconditions on the parameters do not hold
+     *
+     * @throws  NonReadableChannelException
+     *          If the source channel was not opened for reading
+     *
+     * @throws  NonWritableChannelException
+     *          If this channel was not opened for writing
+     *
+     * @throws  ClosedChannelException
+     *          If either this channel or the source channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes either channel
+     *          while the transfer is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread while the
+     *          transfer is in progress, thereby closing both channels and
+     *          setting the current thread's interrupt status
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public abstract long transferFrom(ReadableByteChannel src,
+                                      long position, long count)
+        throws IOException;
+
+    /**
+     * Reads a sequence of bytes from this channel into the given buffer,
+     * starting at the given file position.
+     *
+     * <p> This method works in the same manner as the {@link
+     * #read(ByteBuffer)} method, except that bytes are read starting at the
+     * given file position rather than at the channel's current position.  This
+     * method does not modify this channel's position.  If the given position
+     * is greater than the file's current size then no bytes are read.  </p>
+     *
+     * @param  dst
+     *         The buffer into which bytes are to be transferred
+     *
+     * @param  position
+     *         The file position at which the transfer is to begin;
+     *         must be non-negative
+     *
+     * @return  The number of bytes read, possibly zero, or <tt>-1</tt> if the
+     *          given position is greater than or equal to the file's current
+     *          size
+     *
+     * @throws  IllegalArgumentException
+     *          If the position is negative
+     *
+     * @throws  NonReadableChannelException
+     *          If this channel was not opened for reading
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes this channel
+     *          while the read operation is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread
+     *          while the read operation is in progress, thereby
+     *          closing the channel and setting the current thread's
+     *          interrupt status
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public abstract int read(ByteBuffer dst, long position) throws IOException;
+
+    /**
+     * Writes a sequence of bytes to this channel from the given buffer,
+     * starting at the given file position.
+     *
+     * <p> This method works in the same manner as the {@link
+     * #write(ByteBuffer)} method, except that bytes are written starting at
+     * the given file position rather than at the channel's current position.
+     * This method does not modify this channel's position.  If the given
+     * position is greater than the file's current size then the file will be
+     * grown to accommodate the new bytes; the values of any bytes between the
+     * previous end-of-file and the newly-written bytes are unspecified.  </p>
+     *
+     * @param  src
+     *         The buffer from which bytes are to be transferred
+     *
+     * @param  position
+     *         The file position at which the transfer is to begin;
+     *         must be non-negative
+     *
+     * @return  The number of bytes written, possibly zero
+     *
+     * @throws  IllegalArgumentException
+     *          If the position is negative
+     *
+     * @throws  NonWritableChannelException
+     *          If this channel was not opened for writing
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes this channel
+     *          while the write operation is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread
+     *          while the write operation is in progress, thereby
+     *          closing the channel and setting the current thread's
+     *          interrupt status
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public abstract int write(ByteBuffer src, long position) throws IOException;
+
+
+    // -- Memory-mapped buffers --
+
+    /**
+     * A typesafe enumeration for file-mapping modes.
+     *
+     * @since 1.4
+     *
+     * @see java.nio.channels.FileChannel#map
+     */
+    public static class MapMode {
+
+        /**
+         * Mode for a read-only mapping.
+         */
+        public static final MapMode READ_ONLY
+            = new MapMode("READ_ONLY");
+
+        /**
+         * Mode for a read/write mapping.
+         */
+        public static final MapMode READ_WRITE
+            = new MapMode("READ_WRITE");
+
+        /**
+         * Mode for a private (copy-on-write) mapping.
+         */
+        public static final MapMode PRIVATE
+            = new MapMode("PRIVATE");
+
+        private final String name;
+
+        private MapMode(String name) {
+            this.name = name;
+        }
+
+        /**
+         * Returns a string describing this file-mapping mode.
+         *
+         * @return  A descriptive string
+         */
+        public String toString() {
+            return name;
+        }
+
+    }
+
+    /**
+     * Maps a region of this channel's file directly into memory.
+     *
+     * <p> A region of a file may be mapped into memory in one of three modes:
+     * </p>
+     *
+     * <ul type=disc>
+     *
+     *   <li><p> <i>Read-only:</i> Any attempt to modify the resulting buffer
+     *   will cause a {@link java.nio.ReadOnlyBufferException} to be thrown.
+     *   ({@link MapMode#READ_ONLY MapMode.READ_ONLY}) </p></li>
+     *
+     *   <li><p> <i>Read/write:</i> Changes made to the resulting buffer will
+     *   eventually be propagated to the file; they may or may not be made
+     *   visible to other programs that have mapped the same file.  ({@link
+     *   MapMode#READ_WRITE MapMode.READ_WRITE}) </p></li>
+     *
+     *   <li><p> <i>Private:</i> Changes made to the resulting buffer will not
+     *   be propagated to the file and will not be visible to other programs
+     *   that have mapped the same file; instead, they will cause private
+     *   copies of the modified portions of the buffer to be created.  ({@link
+     *   MapMode#PRIVATE MapMode.PRIVATE}) </p></li>
+     *
+     * </ul>
+     *
+     * <p> For a read-only mapping, this channel must have been opened for
+     * reading; for a read/write or private mapping, this channel must have
+     * been opened for both reading and writing.
+     *
+     * <p> The {@link MappedByteBuffer </code>mapped byte buffer<code>}
+     * returned by this method will have a position of zero and a limit and
+     * capacity of <tt>size</tt>; its mark will be undefined.  The buffer and
+     * the mapping that it represents will remain valid until the buffer itself
+     * is garbage-collected.
+     *
+     * <p> A mapping, once established, is not dependent upon the file channel
+     * that was used to create it.  Closing the channel, in particular, has no
+     * effect upon the validity of the mapping.
+     *
+     * <p> Many of the details of memory-mapped files are inherently dependent
+     * upon the underlying operating system and are therefore unspecified.  The
+     * behavior of this method when the requested region is not completely
+     * contained within this channel's file is unspecified.  Whether changes
+     * made to the content or size of the underlying file, by this program or
+     * another, are propagated to the buffer is unspecified.  The rate at which
+     * changes to the buffer are propagated to the file is unspecified.
+     *
+     * <p> For most operating systems, mapping a file into memory is more
+     * expensive than reading or writing a few tens of kilobytes of data via
+     * the usual {@link #read read} and {@link #write write} methods.  From the
+     * standpoint of performance it is generally only worth mapping relatively
+     * large files into memory.  </p>
+     *
+     * @param  mode
+     *         One of the constants {@link MapMode#READ_ONLY READ_ONLY}, {@link
+     *         MapMode#READ_WRITE READ_WRITE}, or {@link MapMode#PRIVATE
+     *         PRIVATE} defined in the {@link MapMode} class, according to
+     *         whether the file is to be mapped read-only, read/write, or
+     *         privately (copy-on-write), respectively
+     *
+     * @param  position
+     *         The position within the file at which the mapped region
+     *         is to start; must be non-negative
+     *
+     * @param  size
+     *         The size of the region to be mapped; must be non-negative and
+     *         no greater than {@link java.lang.Integer#MAX_VALUE}
+     *
+     * @throws NonReadableChannelException
+     *         If the <tt>mode</tt> is {@link MapMode#READ_ONLY READ_ONLY} but
+     *         this channel was not opened for reading
+     *
+     * @throws NonWritableChannelException
+     *         If the <tt>mode</tt> is {@link MapMode#READ_WRITE READ_WRITE} or
+     *         {@link MapMode#PRIVATE PRIVATE} but this channel was not opened
+     *         for both reading and writing
+     *
+     * @throws IllegalArgumentException
+     *         If the preconditions on the parameters do not hold
+     *
+     * @throws IOException
+     *         If some other I/O error occurs
+     *
+     * @see java.nio.channels.FileChannel.MapMode
+     * @see java.nio.MappedByteBuffer
+     */
+    public abstract MappedByteBuffer map(MapMode mode,
+                                         long position, long size)
+        throws IOException;
+
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/FileLockInterruptionException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/FileLockInterruptionException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/FileLockInterruptionException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/FileLockInterruptionException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Checked exception received by a thread when another thread interrupts it
+ * while it is waiting to acquire a file lock.  Before this exception is thrown
+ * the interrupt status of the previously-blocked thread will have been set.
+ *
+ * @since 1.4
+ */
+
+public class FileLockInterruptionException
+    extends java.io.IOException
+{
+
+    private static final long serialVersionUID = 7104080643653532383L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public FileLockInterruptionException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/FileLock.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/FileLock.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/FileLock.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/FileLock.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,261 @@
+/*
+ * Copyright 2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+
+
+/**
+ * A token representing a lock on a region of a file.
+ *
+ * <p> A file-lock object is created each time a lock is acquired on a file via
+ * one of the {@link FileChannel#lock(long,long,boolean) lock} or {@link
+ * FileChannel#tryLock(long,long,boolean) tryLock} methods of the {@link
+ * FileChannel} class.
+ *
+ * <p> A file-lock object is initially valid.  It remains valid until the lock
+ * is released by invoking the {@link #release release} method, by closing the
+ * channel that was used to acquire it, or by the termination of the Java
+ * virtual machine, whichever comes first.  The validity of a lock may be
+ * tested by invoking its {@link #isValid isValid} method.
+ *
+ * <p> A file lock is either <i>exclusive</i> or <i>shared</i>.  A shared lock
+ * prevents other concurrently-running programs from acquiring an overlapping
+ * exclusive lock, but does allow them to acquire overlapping shared locks.  An
+ * exclusive lock prevents other programs from acquiring an overlapping lock of
+ * either type.  Once it is released, a lock has no further effect on the locks
+ * that may be acquired by other programs.
+ *
+ * <p> Whether a lock is exclusive or shared may be determined by invoking its
+ * {@link #isShared isShared} method.  Some platforms do not support shared
+ * locks, in which case a request for a shared lock is automatically converted
+ * into a request for an exclusive lock.
+ *
+ * <p> The locks held on a particular file by a single Java virtual machine do
+ * not overlap.  The {@link #overlaps overlaps} method may be used to test
+ * whether a candidate lock range overlaps an existing lock.
+ *
+ * <p> A file-lock object records the file channel upon whose file the lock is
+ * held, the type and validity of the lock, and the position and size of the
+ * locked region.  Only the validity of a lock is subject to change over time;
+ * all other aspects of a lock's state are immutable.
+ *
+ * <p> File locks are held on behalf of the entire Java virtual machine.
+ * They are not suitable for controlling access to a file by multiple
+ * threads within the same virtual machine.
+ *
+ * <p> File-lock objects are safe for use by multiple concurrent threads.
+ *
+ *
+ * <a name="pdep">
+ * <h4> Platform dependencies </h4>
+ *
+ * <p> This file-locking API is intended to map directly to the native locking
+ * facility of the underlying operating system.  Thus the locks held on a file
+ * should be visible to all programs that have access to the file, regardless
+ * of the language in which those programs are written.
+ *
+ * <p> Whether or not a lock actually prevents another program from accessing
+ * the content of the locked region is system-dependent and therefore
+ * unspecified.  The native file-locking facilities of some systems are merely
+ * <i>advisory</i>, meaning that programs must cooperatively observe a known
+ * locking protocol in order to guarantee data integrity.  On other systems
+ * native file locks are <i>mandatory</i>, meaning that if one program locks a
+ * region of a file then other programs are actually prevented from accessing
+ * that region in a way that would violate the lock.  On yet other systems,
+ * whether native file locks are advisory or mandatory is configurable on a
+ * per-file basis.  To ensure consistent and correct behavior across platforms,
+ * it is strongly recommended that the locks provided by this API be used as if
+ * they were advisory locks.
+ *
+ * <p> On some systems, acquiring a mandatory lock on a region of a file
+ * prevents that region from being {@link java.nio.channels.FileChannel#map
+ * </code>mapped into memory<code>}, and vice versa.  Programs that combine
+ * locking and mapping should be prepared for this combination to fail.
+ *
+ * <p> On some systems, closing a channel releases all locks held by the Java
+ * virtual machine on the underlying file regardless of whether the locks were
+ * acquired via that channel or via another channel open on the same file.  It
+ * is strongly recommended that, within a program, a unique channel be used to
+ * acquire all locks on any given file.
+ *
+ * <p> Some network filesystems permit file locking to be used with
+ * memory-mapped files only when the locked regions are page-aligned and a
+ * whole multiple of the underlying hardware's page size.  Some network
+ * filesystems do not implement file locks on regions that extend past a
+ * certain position, often 2<sup>30</sup> or 2<sup>31</sup>.  In general, great
+ * care should be taken when locking files that reside on network filesystems.
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public abstract class FileLock {
+
+    private final FileChannel channel;
+    private final long position;
+    private final long size;
+    private final boolean shared;
+
+    /**
+     * Initializes a new instance of this class.  </p>
+     *
+     * @param  channel
+     *         The file channel upon whose file this lock is held
+     *
+     * @param  position
+     *         The position within the file at which the locked region starts;
+     *         must be non-negative
+     *
+     * @param  size
+     *         The size of the locked region; must be non-negative, and the sum
+     *         <tt>position</tt>&nbsp;+&nbsp;<tt>size</tt> must be non-negative
+     *
+     * @param  shared
+     *         <tt>true</tt> if this lock is shared,
+     *         <tt>false</tt> if it is exclusive
+     *
+     * @throws IllegalArgumentException
+     *         If the preconditions on the parameters do not hold
+     */
+    protected FileLock(FileChannel channel,
+                       long position, long size, boolean shared)
+    {
+        if (position < 0)
+            throw new IllegalArgumentException("Negative position");
+        if (size < 0)
+            throw new IllegalArgumentException("Negative size");
+        if (position + size < 0)
+            throw new IllegalArgumentException("Negative position + size");
+        this.channel = channel;
+        this.position = position;
+        this.size = size;
+        this.shared = shared;
+    }
+
+    /**
+     * Returns the file channel upon whose file this lock is held.  </p>
+     *
+     * @return  The file channel
+     */
+    public final FileChannel channel() {
+        return channel;
+    }
+
+    /**
+     * Returns the position within the file of the first byte of the locked
+     * region.
+     *
+     * <p> A locked region need not be contained within, or even overlap, the
+     * actual underlying file, so the value returned by this method may exceed
+     * the file's current size.  </p>
+     *
+     * @return  The position
+     */
+    public final long position() {
+        return position;
+    }
+
+    /**
+     * Returns the size of the locked region in bytes.
+     *
+     * <p> A locked region need not be contained within, or even overlap, the
+     * actual underlying file, so the value returned by this method may exceed
+     * the file's current size.  </p>
+     *
+     * @return  The size of the locked region
+     */
+    public final long size() {
+        return size;
+    }
+
+    /**
+     * Tells whether this lock is shared.  </p>
+     *
+     * @return <tt>true</tt> if lock is shared,
+     *         <tt>false</tt> if it is exclusive
+     */
+    public final boolean isShared() {
+        return shared;
+    }
+
+    /**
+     * Tells whether or not this lock overlaps the given lock range.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if, this lock and the given lock
+     *          range overlap by at least one byte
+     */
+    public final boolean overlaps(long position, long size) {
+        if (position + size <= this.position)
+            return false;               // That is below this
+        if (this.position + this.size <= position)
+            return false;               // This is below that
+        return true;
+    }
+
+    /**
+     * Tells whether or not this lock is valid.
+     *
+     * <p> A lock object remains valid until it is released or the associated
+     * file channel is closed, whichever comes first.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if, this lock is valid
+     */
+    public abstract boolean isValid();
+
+    /**
+     * Releases this lock.
+     *
+     * <p> If this lock object is valid then invoking this method releases the
+     * lock and renders the object invalid.  If this lock object is invalid
+     * then invoking this method has no effect.  </p>
+     *
+     * @throws  ClosedChannelException
+     *          If the channel that was used to acquire this lock
+     *          is no longer open
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     */
+    public abstract void release() throws IOException;
+
+    /**
+     * Returns a string describing the range, type, and validity of this lock.
+     *
+     * @return  A descriptive string
+     */
+    public final String toString() {
+        return (this.getClass().getName()
+                + "[" + position
+                + ":" + size
+                + " " + (shared ? "shared" : "exclusive")
+                + " " + (isValid() ? "valid" : "invalid")
+                + "]");
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/GatheringByteChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/GatheringByteChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/GatheringByteChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/GatheringByteChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,166 @@
+/*
+ * Copyright 2000-2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+
+/**
+ * A channel that can write bytes from a sequence of buffers.
+ *
+ * <p> A <i>gathering</i> write operation writes, in a single invocation, a
+ * sequence of bytes from one or more of a given sequence of buffers.
+ * Gathering writes are often useful when implementing network protocols or
+ * file formats that, for example, group data into segments consisting of one
+ * or more fixed-length headers followed by a variable-length body.  Similar
+ * <i>scattering</i> read operations are defined in the {@link
+ * ScatteringByteChannel} interface.  </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public interface GatheringByteChannel
+    extends WritableByteChannel
+{
+
+    /**
+     * Writes a sequence of bytes to this channel from a subsequence of the
+     * given buffers.
+     *
+     * <p> An attempt is made to write up to <i>r</i> bytes to this channel,
+     * where <i>r</i> is the total number of bytes remaining in the specified
+     * subsequence of the given buffer array, that is,
+     *
+     * <blockquote><pre>
+     * srcs[offset].remaining()
+     *     + srcs[offset+1].remaining()
+     *     + ... + srcs[offset+length-1].remaining()</pre></blockquote>
+     *
+     * at the moment that this method is invoked.
+     *
+     * <p> Suppose that a byte sequence of length <i>n</i> is written, where
+     * <tt>0</tt>&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
+     * Up to the first <tt>srcs[offset].remaining()</tt> bytes of this sequence
+     * are written from buffer <tt>srcs[offset]</tt>, up to the next
+     * <tt>srcs[offset+1].remaining()</tt> bytes are written from buffer
+     * <tt>srcs[offset+1]</tt>, and so forth, until the entire byte sequence is
+     * written.  As many bytes as possible are written from each buffer, hence
+     * the final position of each updated buffer, except the last updated
+     * buffer, is guaranteed to be equal to that buffer's limit.
+     *
+     * <p> Unless otherwise specified, a write operation will return only after
+     * writing all of the <i>r</i> requested bytes.  Some types of channels,
+     * depending upon their state, may write only some of the bytes or possibly
+     * none at all.  A socket channel in non-blocking mode, for example, cannot
+     * write any more bytes than are free in the socket's output buffer.
+     *
+     * <p> This method may be invoked at any time.  If another thread has
+     * already initiated a write operation upon this channel, however, then an
+     * invocation of this method will block until the first operation is
+     * complete. </p>
+     *
+     * @param  srcs
+     *         The buffers from which bytes are to be retrieved
+     *
+     * @param  offset
+     *         The offset within the buffer array of the first buffer from
+     *         which bytes are to be retrieved; must be non-negative and no
+     *         larger than <tt>srcs.length</tt>
+     *
+     * @param  length
+     *         The maximum number of buffers to be accessed; must be
+     *         non-negative and no larger than
+     *         <tt>srcs.length</tt>&nbsp;-&nbsp;<tt>offset</tt>
+     *
+     * @return  The number of bytes written, possibly zero
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If the preconditions on the <tt>offset</tt> and <tt>length</tt>
+     *          parameters do not hold
+     *
+     * @throws  NonWritableChannelException
+     *          If this channel was not opened for writing
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes this channel
+     *          while the write operation is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread
+     *          while the write operation is in progress, thereby
+     *          closing the channel and setting the current thread's
+     *          interrupt status
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public long write(ByteBuffer[] srcs, int offset, int length)
+        throws IOException;
+
+
+    /**
+     * Writes a sequence of bytes to this channel from the given buffers.
+     *
+     * <p> An invocation of this method of the form <tt>c.write(srcs)</tt>
+     * behaves in exactly the same manner as the invocation
+     *
+     * <blockquote><pre>
+     * c.write(srcs, 0, srcs.length);</pre></blockquote>
+     *
+     * @param  srcs
+     *         The buffers from which bytes are to be retrieved
+     *
+     * @return  The number of bytes written, possibly zero
+     *
+     * @throws  NonWritableChannelException
+     *          If this channel was not opened for writing
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes this channel
+     *          while the write operation is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread
+     *          while the write operation is in progress, thereby
+     *          closing the channel and setting the current thread's
+     *          interrupt status
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public long write(ByteBuffer[] srcs) throws IOException;
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/IllegalBlockingModeException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/IllegalBlockingModeException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/IllegalBlockingModeException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/IllegalBlockingModeException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when a blocking-mode-specific operation
+ * is invoked upon a channel in the incorrect blocking mode.
+ *
+ * @since 1.4
+ */
+
+public class IllegalBlockingModeException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = -3335774961855590474L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public IllegalBlockingModeException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/IllegalSelectorException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/IllegalSelectorException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/IllegalSelectorException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/IllegalSelectorException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to register a channel
+ * with a selector that was not created by the provider that created the
+ * channel.
+ *
+ * @since 1.4
+ */
+
+public class IllegalSelectorException
+    extends IllegalArgumentException
+{
+
+    private static final long serialVersionUID = -8406323347253320987L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public IllegalSelectorException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/InterruptibleChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/InterruptibleChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/InterruptibleChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/InterruptibleChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+
+
+/**
+ * A channel that can be asynchronously closed and interrupted.
+ *
+ * <p> A channel that implements this interface is <i>asynchronously
+ * closeable:</i> If a thread is blocked in an I/O operation on an
+ * interruptible channel then another thread may invoke the channel's {@link
+ * #close close} method.  This will cause the blocked thread to receive an
+ * {@link AsynchronousCloseException}.
+ *
+ * <p> A channel that implements this interface is also <i>interruptible:</i>
+ * If a thread is blocked in an I/O operation on an interruptible channel then
+ * another thread may invoke the blocked thread's {@link Thread#interrupt()
+ * interrupt} method.  This will cause the channel to be closed, the blocked
+ * thread to receive a {@link ClosedByInterruptException}, and the blocked
+ * thread's interrupt status to be set.
+ *
+ * <p> If a thread's interrupt status is already set and it invokes a blocking
+ * I/O operation upon a channel then the channel will be closed and the thread
+ * will immediately receive a {@link ClosedByInterruptException}; its interrupt
+ * status will remain set.
+ *
+ * <p> A channel supports asynchronous closing and interruption if, and only
+ * if, it implements this interface.  This can be tested at runtime, if
+ * necessary, via the <tt>instanceof</tt> operator.
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public interface InterruptibleChannel
+    extends Channel
+{
+
+    /**
+     * Closes this channel.
+     *
+     * <p> Any thread currently blocked in an I/O operation upon this channel
+     * will receive an {@link AsynchronousCloseException}.
+     *
+     * <p> This method otherwise behaves exactly as specified by the {@link
+     * Channel#close Channel} interface.  </p>
+     *
+     * @throws  IOException  If an I/O error occurs
+     */
+    public void close() throws IOException;
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/NoConnectionPendingException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/NoConnectionPendingException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/NoConnectionPendingException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/NoConnectionPendingException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when the {@link SocketChannel#finishConnect
+ * finishConnect} method of a {@link SocketChannel} is invoked without first
+ * successfully invoking its {@link SocketChannel#connect connect} method.
+ *
+ * @since 1.4
+ */
+
+public class NoConnectionPendingException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = -8296561183633134743L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public NoConnectionPendingException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/NonReadableChannelException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/NonReadableChannelException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/NonReadableChannelException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/NonReadableChannelException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to read
+ * from a channel that was not originally opened for reading.
+ *
+ * @since 1.4
+ */
+
+public class NonReadableChannelException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = -3200915679294993514L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public NonReadableChannelException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/NonWritableChannelException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/NonWritableChannelException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/NonWritableChannelException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/NonWritableChannelException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to write
+ * to a channel that was not originally opened for writing.
+ *
+ * @since 1.4
+ */
+
+public class NonWritableChannelException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = -7071230488279011621L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public NonWritableChannelException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/NotYetBoundException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/NotYetBoundException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/NotYetBoundException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/NotYetBoundException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to invoke an I/O
+ * operation upon a server socket channel that is not yet bound.
+ *
+ * @since 1.4
+ */
+
+public class NotYetBoundException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = 4640999303950202242L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public NotYetBoundException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/NotYetConnectedException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/NotYetConnectedException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/NotYetConnectedException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/NotYetConnectedException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to invoke an I/O
+ * operation upon a socket channel that is not yet connected.
+ *
+ * @since 1.4
+ */
+
+public class NotYetConnectedException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = 4697316551909513464L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public NotYetConnectedException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/OverlappingFileLockException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/OverlappingFileLockException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/OverlappingFileLockException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/OverlappingFileLockException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to acquire a lock on a
+ * region of a file that overlaps a region already locked by the same Java
+ * virtual machine, or when another thread is already waiting to lock an
+ * overlapping region of the same file.
+ *
+ * @since 1.4
+ */
+
+public class OverlappingFileLockException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = 2047812138163068433L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public OverlappingFileLockException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/package.html phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/package.html
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/package.html	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/package.html	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,222 @@
+<!--
+ Copyright 2001-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+
+ This code is free software; you can redistribute it and/or modify it
+ under the terms of the GNU General Public License version 2 only, as
+ published by the Free Software Foundation.  Sun designates this
+ particular file as subject to the "Classpath" exception as provided
+ by Sun in the LICENSE file that accompanied this code.
+
+ This code is distributed in the hope that it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ version 2 for more details (a copy is included in the LICENSE file that
+ accompanied this code).
+
+ You should have received a copy of the GNU General Public License version
+ 2 along with this work; if not, write to the Free Software Foundation,
+ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+
+ Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ CA 95054 USA or visit www.sun.com if you need additional information or
+ have any questions.
+-->
+
+<!doctype html public "-//IETF//DTD HTML//EN">
+<html>
+<body bgcolor="white">
+
+Defines channels, which represent connections to entities that are capable of
+performing I/O operations, such as files and sockets; defines selectors, for
+multiplexed, non-blocking I/O operations.
+
+
+<a name="channels">
+
+<blockquote><table cellspacing=1 cellpadding=0 summary="Lists channels and their descriptions">
+  <tr><th><p align="left">Channels</p></th><th><p align="left">Description</p></th></tr>
+  <tr><td valign=top><tt><i>{@link java.nio.channels.Channel}</i></tt></td>
+      <td>A nexus for I/O operations</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;<i>{@link java.nio.channels.ReadableByteChannel}</i></tt></td>
+      <td>Can read into a buffer</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;&nbsp;&nbsp;<i>{@link java.nio.channels.ScatteringByteChannel}&nbsp;&nbsp;</i></tt></td>
+      <td>Can read into a sequence of&nbsp;buffers</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;<i>{@link java.nio.channels.WritableByteChannel}</i></tt></td>
+      <td>Can write from a buffer</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;&nbsp;&nbsp;<i>{@link java.nio.channels.GatheringByteChannel}</i></tt></td>
+      <td>Can write from a sequence of&nbsp;buffers</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;<i>{@link java.nio.channels.ByteChannel}</i></tt></td>
+      <td>Can read/write to/from a&nbsp;buffer</td></tr>
+  <tr><td valign=top><tt>{@link java.nio.channels.Channels}</tt></td>
+      <td>Utility methods for channel/stream interoperation</td></tr>
+</table></blockquote>
+
+<p> A <i>channel</i> represents an open connection to an entity such as a
+hardware device, a file, a network socket, or a program component that is
+capable of performing one or more distinct I/O operations, for example reading
+or writing.  As specified in the {@link java.nio.channels.Channel} interface,
+channels are either open or closed, and they are both <i>asynchronously
+closeable</i> and <i>interruptible</i>.
+
+<p> The {@link java.nio.channels.Channel} interface is extended by several
+other interfaces, each of which specifies a new I/O operation.
+
+<p> The {@link java.nio.channels.ReadableByteChannel} interface specifies a
+{@link java.nio.channels.ReadableByteChannel#read read} method that reads bytes
+from the channel into a buffer; similarly, the {@link
+java.nio.channels.WritableByteChannel} interface specifies a {@link
+java.nio.channels.WritableByteChannel#write write} method that writes bytes
+from a buffer to the channel.  The {@link java.nio.channels.ByteChannel}
+interface unifies these two interfaces for the common case of channels that can
+both read and write bytes.
+
+<p> The {@link java.nio.channels.ScatteringByteChannel} and {@link
+java.nio.channels.GatheringByteChannel} interfaces extend the {@link
+java.nio.channels.ReadableByteChannel} and {@link
+java.nio.channels.WritableByteChannel} interfaces, respectively, adding {@link
+java.nio.channels.ScatteringByteChannel#read read} and {@link
+java.nio.channels.GatheringByteChannel#write write} methods that take a
+sequence of buffers rather than a single buffer.
+
+<p> The {@link java.nio.channels.Channels} utility class defines static methods
+that support the interoperation of the stream classes of the <tt>{@link
+java.io}</tt> package with the channel classes of this package.  An appropriate
+channel can be constructed from an {@link java.io.InputStream} or an {@link
+java.io.OutputStream}, and conversely an {@link java.io.InputStream} or an
+{@link java.io.OutputStream} can be constructed from a channel.  A {@link
+java.io.Reader} can be constructed that uses a given charset to decode bytes
+from a given readable byte channel, and conversely a {@link java.io.Writer} can
+be constructed that uses a given charset to encode characters into bytes and
+write them to a given writable byte channel.
+
+
+<blockquote><table cellspacing=1 cellpadding=0 summary="Lists file channels and their descriptions">
+<tr><th><p align="left">File channels</p></th><th><p align="left">Description</p></th></tr>
+  <tr><td valign=top><tt>{@link java.nio.channels.FileChannel}</tt></td>
+      <td>Reads, writes, maps, and manipulates files</td></tr>
+  <tr><td valign=top><tt>{@link java.nio.channels.FileLock}</tt></td>
+      <td>A lock on a (region of a) file</td></tr>
+  <tr><td valign=top><tt>{@link java.nio.MappedByteBuffer}&nbsp;&nbsp;</tt></td>
+      <td>A direct byte buffer mapped to a region of a&nbsp;file</td></tr>
+</table></blockquote>
+
+<p> The {@link java.nio.channels.FileChannel} class supports the usual
+operations of reading bytes from, and writing bytes to, a channel connected to
+a file, as well as those of querying and modifying the current file position
+and truncating the file to a specific size.  It defines methods for acquiring
+locks on the whole file or on a specific region of a file; these methods return
+instances of the {@link java.nio.channels.FileLock} class.  Finally, it defines
+methods for forcing updates to the file to be written to the storage device that
+contains it, for efficiently transferring bytes between the file and other
+channels, and for mapping a region of the file directly into memory.  This last
+operation creates an instance of the {@link java.nio.MappedByteBuffer}
+class, which extends the {@link java.nio.ByteBuffer} class with several
+file-related operations.
+
+<p> A <tt>getChannel</tt> method has been added to each of the {@link
+java.io.FileInputStream#getChannel FileInputStream}, {@link
+java.io.FileOutputStream#getChannel FileOutputStream}, and {@link
+java.io.RandomAccessFile#getChannel RandomAccessFile} classes of the <tt>{@link
+java.io java.io}</tt> package.  Invoking this method upon an instance of one of
+these classes will return a file channel connected to the underlying file.
+
+
+<a name="multiplex">
+
+<blockquote><table cellspacing=1 cellpadding=0 summary="Lists multiplexed, non-blocking channels and their descriptions">
+  <tr><th><p align="left">Multiplexed, non-blocking I/O</p></th><th><p align="left">Description</p></th></tr>
+  <tr><td valign=top><tt>{@link java.nio.channels.SelectableChannel}</tt></td>
+      <td>A channel that can be multiplexed</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;{@link java.nio.channels.DatagramChannel}</tt></td>
+      <td>A channel for a {@link java.net.DatagramSocket java.net.DatagramSocket}</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;{@link java.nio.channels.Pipe.SinkChannel}</tt></td>
+      <td>The write end of a pipe</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;{@link java.nio.channels.Pipe.SourceChannel}</tt></td>
+      <td>The read end of a pipe</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;{@link java.nio.channels.ServerSocketChannel}&nbsp;&nbsp;</tt></td>
+      <td>A channel for a {@link java.net.ServerSocket java.net.ServerSocket}</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;{@link java.nio.channels.SocketChannel}</tt></td>
+      <td>A channel for a {@link java.net.Socket java.net.Socket}</td></tr>
+  <tr><td valign=top><tt>{@link java.nio.channels.Selector}</tt></td>
+      <td>A multiplexor of selectable channels</td></tr>
+  <tr><td valign=top><tt>{@link java.nio.channels.SelectionKey}</tt></td>
+      <td>A token representing the registration <br> of a channel
+          with&nbsp;a&nbsp;selector</td></tr>
+  <tr><td valign=top><tt>{@link java.nio.channels.Pipe}</tt></td>
+      <td>Two channels that form a unidirectional&nbsp;pipe</td></tr>
+</table></blockquote>
+
+<p> Multiplexed, non-blocking I/O, which is much more scalable than
+thread-oriented, blocking I/O, is provided by <i>selectors</i>, <i>selectable
+channels</i>, and <i>selection keys</i>.
+
+<p> A <a href="Selector.html"><i>selector</i></a> is a multiplexor of <a
+href="SelectableChannel.html"><i>selectable channels</i></a>, which in turn are
+a special type of channel that can be put into <a
+href="SelectableChannel.html#bm"><i>non-blocking mode</i></a>.  To perform
+multiplexed I/O operations, one or more selectable channels are first created,
+put into non-blocking mode, and {@link
+java.nio.channels.SelectableChannel#register </code><i>registered</i><code>}
+with a selector.  Registering a channel specifies the set of I/O operations
+that will be tested for readiness by the selector, and returns a <a
+href="SelectionKey.html"><i>selection key</i></a> that represents the
+registration.
+
+<p> Once some channels have been registered with a selector, a <a
+href="Selector.html#selop"><i>selection operation</i></a> can be performed in
+order to discover which channels, if any, have become ready to perform one or
+more of the operations in which interest was previously declared.  If a channel
+is ready then the key returned when it was registered will be added to the
+selector's <i>selected-key set</i>.  The key set, and the keys within it, can
+be examined in order to determine the operations for which each channel is
+ready.  From each key one can retrieve the corresponding channel in order to
+perform whatever I/O operations are required.
+
+<p> That a selection key indicates that its channel is ready for some operation
+is a hint, but not a guarantee, that such an operation can be performed by a
+thread without causing the thread to block.  It is imperative that code that
+performs multiplexed I/O be written so as to ignore these hints when they prove
+to be incorrect.
+
+<p> This package defines selectable-channel classes corresponding to the {@link
+java.net.DatagramSocket}, {@link java.net.ServerSocket}, and {@link
+java.net.Socket} classes defined in the <tt>{@link java.net}</tt> package.
+Minor changes to these classes have been made in order to support sockets that
+are associated with channels.  This package also defines a simple class that
+implements unidirectional pipes.  In all cases, a new selectable channel is
+created by invoking the static <tt>open</tt> method of the corresponding class.
+If a channel needs an associated socket then a socket will be created as a side
+effect of this operation.
+
+<p> The implementation of selectors, selectable channels, and selection keys
+can be replaced by "plugging in" an alternative definition or instance of the
+{@link java.nio.channels.spi.SelectorProvider} class defined in the <tt>{@link
+java.nio.channels.spi}</tt> package.  It is not expected that many developers
+will actually make use of this facility; it is provided primarily so that
+sophisticated users can take advantage of operating-system-specific
+I/O-multiplexing mechanisms when very high performance is required.
+
+<p> Much of the bookkeeping and synchronization required to implement the
+multiplexed-I/O abstractions is performed by the {@link
+java.nio.channels.spi.AbstractInterruptibleChannel}, {@link
+java.nio.channels.spi.AbstractSelectableChannel}, {@link
+java.nio.channels.spi.AbstractSelectionKey}, and {@link
+java.nio.channels.spi.AbstractSelector} classes in the <tt>{@link
+java.nio.channels.spi}</tt> package.  When defining a custom selector provider,
+only the {@link java.nio.channels.spi.AbstractSelector} and {@link
+java.nio.channels.spi.AbstractSelectionKey} classes should be subclassed
+directly; custom channel classes should extend the appropriate {@link
+java.nio.channels.SelectableChannel} subclasses defined in this package.
+
+<p> Unless otherwise noted, passing a <tt>null</tt> argument to a constructor
+or method in any class or interface in this package will cause a {@link
+java.lang.NullPointerException NullPointerException} to be thrown.
+
+
+@since 1.4
+@author Mark Reinhold
+@author JSR-51 Expert Group
+
+</body>
+</html>
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ReadableByteChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ReadableByteChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ReadableByteChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ReadableByteChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2000-2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+
+/**
+ * A channel that can read bytes.
+ *
+ * <p> Only one read operation upon a readable channel may be in progress at
+ * any given time.  If one thread initiates a read operation upon a channel
+ * then any other thread that attempts to initiate another read operation will
+ * block until the first operation is complete.  Whether or not other kinds of
+ * I/O operations may proceed concurrently with a read operation depends upon
+ * the type of the channel. </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public interface ReadableByteChannel extends Channel {
+
+    /**
+     * Reads a sequence of bytes from this channel into the given buffer.
+     *
+     * <p> An attempt is made to read up to <i>r</i> bytes from the channel,
+     * where <i>r</i> is the number of bytes remaining in the buffer, that is,
+     * <tt>dst.remaining()</tt>, at the moment this method is invoked.
+     *
+     * <p> Suppose that a byte sequence of length <i>n</i> is read, where
+     * <tt>0</tt>&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
+     * This byte sequence will be transferred into the buffer so that the first
+     * byte in the sequence is at index <i>p</i> and the last byte is at index
+     * <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>&nbsp;<tt>-</tt>&nbsp;<tt>1</tt>,
+     * where <i>p</i> is the buffer's position at the moment this method is
+     * invoked.  Upon return the buffer's position will be equal to
+     * <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>; its limit will not have changed.
+     *
+     * <p> A read operation might not fill the buffer, and in fact it might not
+     * read any bytes at all.  Whether or not it does so depends upon the
+     * nature and state of the channel.  A socket channel in non-blocking mode,
+     * for example, cannot read any more bytes than are immediately available
+     * from the socket's input buffer; similarly, a file channel cannot read
+     * any more bytes than remain in the file.  It is guaranteed, however, that
+     * if a channel is in blocking mode and there is at least one byte
+     * remaining in the buffer then this method will block until at least one
+     * byte is read.
+     *
+     * <p> This method may be invoked at any time.  If another thread has
+     * already initiated a read operation upon this channel, however, then an
+     * invocation of this method will block until the first operation is
+     * complete. </p>
+     *
+     * @param  dst
+     *         The buffer into which bytes are to be transferred
+     *
+     * @return  The number of bytes read, possibly zero, or <tt>-1</tt> if the
+     *          channel has reached end-of-stream
+     *
+     * @throws  NonReadableChannelException
+     *          If this channel was not opened for reading
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes this channel
+     *          while the read operation is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread
+     *          while the read operation is in progress, thereby
+     *          closing the channel and setting the current thread's
+     *          interrupt status
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public int read(ByteBuffer dst) throws IOException;
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ScatteringByteChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ScatteringByteChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ScatteringByteChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ScatteringByteChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,162 @@
+/*
+ * Copyright 2000-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+
+/**
+ * A channel that can read bytes into a sequence of buffers.
+ *
+ * <p> A <i>scattering</i> read operation reads, in a single invocation, a
+ * sequence of bytes into one or more of a given sequence of buffers.
+ * Scattering reads are often useful when implementing network protocols or
+ * file formats that, for example, group data into segments consisting of one
+ * or more fixed-length headers followed by a variable-length body.  Similar
+ * <i>gathering</i> write operations are defined in the {@link
+ * GatheringByteChannel} interface.  </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public interface ScatteringByteChannel
+    extends ReadableByteChannel
+{
+
+    /**
+     * Reads a sequence of bytes from this channel into a subsequence of the
+     * given buffers.
+     *
+     * <p> An invocation of this method attempts to read up to <i>r</i> bytes
+     * from this channel, where <i>r</i> is the total number of bytes remaining
+     * the specified subsequence of the given buffer array, that is,
+     *
+     * <blockquote><pre>
+     * dsts[offset].remaining()
+     *     + dsts[offset+1].remaining()
+     *     + ... + dsts[offset+length-1].remaining()</pre></blockquote>
+     *
+     * at the moment that this method is invoked.
+     *
+     * <p> Suppose that a byte sequence of length <i>n</i> is read, where
+     * <tt>0</tt>&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
+     * Up to the first <tt>dsts[offset].remaining()</tt> bytes of this sequence
+     * are transferred into buffer <tt>dsts[offset]</tt>, up to the next
+     * <tt>dsts[offset+1].remaining()</tt> bytes are transferred into buffer
+     * <tt>dsts[offset+1]</tt>, and so forth, until the entire byte sequence
+     * is transferred into the given buffers.  As many bytes as possible are
+     * transferred into each buffer, hence the final position of each updated
+     * buffer, except the last updated buffer, is guaranteed to be equal to
+     * that buffer's limit.
+     *
+     * <p> This method may be invoked at any time.  If another thread has
+     * already initiated a read operation upon this channel, however, then an
+     * invocation of this method will block until the first operation is
+     * complete. </p>
+     *
+     * @param  dsts
+     *         The buffers into which bytes are to be transferred
+     *
+     * @param  offset
+     *         The offset within the buffer array of the first buffer into
+     *         which bytes are to be transferred; must be non-negative and no
+     *         larger than <tt>dsts.length</tt>
+     *
+     * @param  length
+     *         The maximum number of buffers to be accessed; must be
+     *         non-negative and no larger than
+     *         <tt>dsts.length</tt>&nbsp;-&nbsp;<tt>offset</tt>
+     *
+     * @return The number of bytes read, possibly zero,
+     *         or <tt>-1</tt> if the channel has reached end-of-stream
+     *
+     * @throws  IndexOutOfBoundsException
+     *          If the preconditions on the <tt>offset</tt> and <tt>length</tt>
+     *          parameters do not hold
+     *
+     * @throws  NonReadableChannelException
+     *          If this channel was not opened for reading
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes this channel
+     *          while the read operation is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread
+     *          while the read operation is in progress, thereby
+     *          closing the channel and setting the current thread's
+     *          interrupt status
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public long read(ByteBuffer[] dsts, int offset, int length)
+        throws IOException;
+
+    /**
+     * Reads a sequence of bytes from this channel into the given buffers.
+     *
+     * <p> An invocation of this method of the form <tt>c.read(dsts)</tt>
+     * behaves in exactly the same manner as the invocation
+     *
+     * <blockquote><pre>
+     * c.read(dsts, 0, dsts.length);</pre></blockquote>
+     *
+     * @param  dsts
+     *         The buffers into which bytes are to be transferred
+     *
+     * @return The number of bytes read, possibly zero,
+     *         or <tt>-1</tt> if the channel has reached end-of-stream
+     *
+     * @throws  NonReadableChannelException
+     *          If this channel was not opened for reading
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes this channel
+     *          while the read operation is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread
+     *          while the read operation is in progress, thereby
+     *          closing the channel and setting the current thread's
+     *          interrupt status
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public long read(ByteBuffer[] dsts) throws IOException;
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/SelectableChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/SelectableChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/SelectableChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/SelectableChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,336 @@
+/*
+ * Copyright 2000-2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+import java.nio.channels.spi.AbstractInterruptibleChannel;
+import java.nio.channels.spi.SelectorProvider;
+
+
+/**
+ * A channel that can be multiplexed via a {@link Selector}.
+ *
+ * <p> In order to be used with a selector, an instance of this class must
+ * first be <i>registered</i> via the {@link #register(Selector,int,Object)
+ * register} method.  This method returns a new {@link SelectionKey} object
+ * that represents the channel's registration with the selector.
+ *
+ * <p> Once registered with a selector, a channel remains registered until it
+ * is <i>deregistered</i>.  This involves deallocating whatever resources were
+ * allocated to the channel by the selector.
+ *
+ * <p> A channel cannot be deregistered directly; instead, the key representing
+ * its registration must be <i>cancelled</i>.  Cancelling a key requests that
+ * the channel be deregistered during the selector's next selection operation.
+ * A key may be cancelled explicitly by invoking its {@link
+ * SelectionKey#cancel() cancel} method.  All of a channel's keys are cancelled
+ * implicitly when the channel is closed, whether by invoking its {@link
+ * Channel#close close} method or by interrupting a thread blocked in an I/O
+ * operation upon the channel.
+ *
+ * <p> If the selector itself is closed then the channel will be deregistered,
+ * and the key representing its registration will be invalidated, without
+ * further delay.
+ *
+ * <p> A channel may be registered at most once with any particular selector.
+ *
+ * <p> Whether or not a channel is registered with one or more selectors may be
+ * determined by invoking the {@link #isRegistered isRegistered} method.
+ *
+ * <p> Selectable channels are safe for use by multiple concurrent
+ * threads. </p>
+ *
+ *
+ * <a name="bm">
+ * <h4>Blocking mode</h4>
+ *
+ * A selectable channel is either in <i>blocking</i> mode or in
+ * <i>non-blocking</i> mode.  In blocking mode, every I/O operation invoked
+ * upon the channel will block until it completes.  In non-blocking mode an I/O
+ * operation will never block and may transfer fewer bytes than were requested
+ * or possibly no bytes at all.  The blocking mode of a selectable channel may
+ * be determined by invoking its {@link #isBlocking isBlocking} method.
+ *
+ * <p> Newly-created selectable channels are always in blocking mode.
+ * Non-blocking mode is most useful in conjunction with selector-based
+ * multiplexing.  A channel must be placed into non-blocking mode before being
+ * registered with a selector, and may not be returned to blocking mode until
+ * it has been deregistered.
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ *
+ * @see SelectionKey
+ * @see Selector
+ */
+
+public abstract class SelectableChannel
+    extends AbstractInterruptibleChannel
+    implements Channel
+{
+
+    /**
+     * Initializes a new instance of this class.
+     */
+    protected SelectableChannel() { }
+
+    /**
+     * Returns the provider that created this channel.
+     *
+     * @return  The provider that created this channel
+     */
+    public abstract SelectorProvider provider();
+
+    /**
+     * Returns an <a href="SelectionKey.html#opsets">operation set</a>
+     * identifying this channel's supported operations.  The bits that are set
+     * in this integer value denote exactly the operations that are valid for
+     * this channel.  This method always returns the same value for a given
+     * concrete channel class. </p>
+     *
+     * @return  The valid-operation set
+     */
+    public abstract int validOps();
+
+    // Internal state:
+    //   keySet, may be empty but is never null, typ. a tiny array
+    //   boolean isRegistered, protected by key set
+    //   regLock, lock object to prevent duplicate registrations
+    //   boolean isBlocking, protected by regLock
+
+    /**
+     * Tells whether or not this channel is currently registered with any
+     * selectors.  A newly-created channel is not registered.
+     *
+     * <p> Due to the inherent delay between key cancellation and channel
+     * deregistration, a channel may remain registered for some time after all
+     * of its keys have been cancelled.  A channel may also remain registered
+     * for some time after it is closed.  </p>
+     *
+     * @return <tt>true</tt> if, and only if, this channel is registered
+     */
+    public abstract boolean isRegistered();
+    //
+    // sync(keySet) { return isRegistered; }
+
+    /**
+     * Retrieves the key representing the channel's registration with the given
+     * selector.  </p>
+     *
+     * @return  The key returned when this channel was last registered with the
+     *          given selector, or <tt>null</tt> if this channel is not
+     *          currently registered with that selector
+     */
+    public abstract SelectionKey keyFor(Selector sel);
+    //
+    // sync(keySet) { return findKey(sel); }
+
+    /**
+     * Registers this channel with the given selector, returning a selection
+     * key.
+     *
+     * <p> If this channel is currently registered with the given selector then
+     * the selection key representing that registration is returned.  The key's
+     * interest set will have been changed to <tt>ops</tt>, as if by invoking
+     * the {@link SelectionKey#interestOps(int) interestOps(int)} method.  If
+     * the <tt>att</tt> argument is not <tt>null</tt> then the key's attachment
+     * will have been set to that value.  A {@link CancelledKeyException} will
+     * be thrown if the key has already been cancelled.
+     *
+     * <p> Otherwise this channel has not yet been registered with the given
+     * selector, so it is registered and the resulting new key is returned.
+     * The key's initial interest set will be <tt>ops</tt> and its attachment
+     * will be <tt>att</tt>.
+     *
+     * <p> This method may be invoked at any time.  If this method is invoked
+     * while another invocation of this method or of the {@link
+     * #configureBlocking(boolean) configureBlocking} method is in progress
+     * then it will first block until the other operation is complete.  This
+     * method will then synchronize on the selector's key set and therefore may
+     * block if invoked concurrently with another registration or selection
+     * operation involving the same selector. </p>
+     *
+     * <p> If this channel is closed while this operation is in progress then
+     * the key returned by this method will have been cancelled and will
+     * therefore be invalid. </p>
+     *
+     * @param  sel
+     *         The selector with which this channel is to be registered
+     *
+     * @param  ops
+     *         The interest set for the resulting key
+     *
+     * @param  att
+     *         The attachment for the resulting key; may be <tt>null</tt>
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  IllegalBlockingModeException
+     *          If this channel is in blocking mode
+     *
+     * @throws  IllegalSelectorException
+     *          If this channel was not created by the same provider
+     *          as the given selector
+     *
+     * @throws  CancelledKeyException
+     *          If this channel is currently registered with the given selector
+     *          but the corresponding key has already been cancelled
+     *
+     * @throws  IllegalArgumentException
+     *          If a bit in the <tt>ops</tt> set does not correspond to an
+     *          operation that is supported by this channel, that is, if
+     *          <tt>set & ~validOps() != 0</tt>
+     *
+     * @return  A key representing the registration of this channel with
+     *          the given selector
+     */
+    public abstract SelectionKey register(Selector sel, int ops, Object att)
+        throws ClosedChannelException;
+    //
+    // sync(regLock) {
+    //   sync(keySet) { look for selector }
+    //   if (channel found) { set interest ops -- may block in selector;
+    //                        return key; }
+    //   create new key -- may block somewhere in selector;
+    //   sync(keySet) { add key; }
+    //   attach(attachment);
+    //   return key;
+    // }
+
+    /**
+     * Registers this channel with the given selector, returning a selection
+     * key.
+     *
+     * <p> An invocation of this convenience method of the form
+     *
+     * <blockquote><tt>sc.register(sel, ops)</tt></blockquote>
+     *
+     * behaves in exactly the same way as the invocation
+     *
+     * <blockquote><tt>sc.{@link
+     * #register(java.nio.channels.Selector,int,java.lang.Object)
+     * register}(sel, ops, null)</tt></blockquote>
+     *
+     * @param  sel
+     *         The selector with which this channel is to be registered
+     *
+     * @param  ops
+     *         The interest set for the resulting key
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  IllegalBlockingModeException
+     *          If this channel is in blocking mode
+     *
+     * @throws  IllegalSelectorException
+     *          If this channel was not created by the same provider
+     *          as the given selector
+     *
+     * @throws  CancelledKeyException
+     *          If this channel is currently registered with the given selector
+     *          but the corresponding key has already been cancelled
+     *
+     * @throws  IllegalArgumentException
+     *          If a bit in <tt>ops</tt> does not correspond to an operation
+     *          that is supported by this channel, that is, if <tt>set &
+     *          ~validOps() != 0</tt>
+     *
+     * @return  A key representing the registration of this channel with
+     *          the given selector
+     */
+    public final SelectionKey register(Selector sel, int ops)
+        throws ClosedChannelException
+    {
+        return register(sel, ops, null);
+    }
+
+    /**
+     * Adjusts this channel's blocking mode.
+     *
+     * <p> If this channel is registered with one or more selectors then an
+     * attempt to place it into blocking mode will cause an {@link
+     * IllegalBlockingModeException} to be thrown.
+     *
+     * <p> This method may be invoked at any time.  The new blocking mode will
+     * only affect I/O operations that are initiated after this method returns.
+     * For some implementations this may require blocking until all pending I/O
+     * operations are complete.
+     *
+     * <p> If this method is invoked while another invocation of this method or
+     * of the {@link #register(Selector, int) register} method is in progress
+     * then it will first block until the other operation is complete. </p>
+     *
+     * @param  block  If <tt>true</tt> then this channel will be placed in
+     *                blocking mode; if <tt>false</tt> then it will be placed
+     *                non-blocking mode
+     *
+     * @return  This selectable channel
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  IllegalBlockingModeException
+     *          If <tt>block</tt> is <tt>true</tt> and this channel is
+     *          registered with one or more selectors
+     *
+     * @throws IOException
+     *         If an I/O error occurs
+     */
+    public abstract SelectableChannel configureBlocking(boolean block)
+        throws IOException;
+    //
+    // sync(regLock) {
+    //   sync(keySet) { throw IBME if block && isRegistered; }
+    //   change mode;
+    // }
+
+    /**
+     * Tells whether or not every I/O operation on this channel will block
+     * until it completes.  A newly-created channel is always in blocking mode.
+     *
+     * <p> If this channel is closed then the value returned by this method is
+     * not specified. </p>
+     *
+     * @return <tt>true</tt> if, and only if, this channel is in blocking mode
+     */
+    public abstract boolean isBlocking();
+
+    /**
+     * Retrieves the object upon which the {@link #configureBlocking
+     * configureBlocking} and {@link #register register} methods synchronize.
+     * This is often useful in the implementation of adaptors that require a
+     * specific blocking mode to be maintained for a short period of time.
+     * </p>
+     *
+     * @return  The blocking-mode lock object
+     */
+    public abstract Object blockingLock();
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/SelectionKey.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/SelectionKey.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/SelectionKey.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/SelectionKey.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,403 @@
+/*
+ * Copyright 2000-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+
+
+/**
+ * A token representing the registration of a {@link SelectableChannel} with a
+ * {@link Selector}.
+ *
+ * <p> A selection key is created each time a channel is registered with a
+ * selector.  A key remains valid until it is <i>cancelled</i> by invoking its
+ * {@link #cancel cancel} method, by closing its channel, or by closing its
+ * selector.  Cancelling a key does not immediately remove it from its
+ * selector; it is instead added to the selector's <a
+ * href="Selector.html#ks"><i>cancelled-key set</i></a> for removal during the
+ * next selection operation.  The validity of a key may be tested by invoking
+ * its {@link #isValid isValid} method.
+ *
+ * <a name="opsets">
+ *
+ * <p> A selection key contains two <i>operation sets</i> represented as
+ * integer values.  Each bit of an operation set denotes a category of
+ * selectable operations that are supported by the key's channel.
+ *
+ * <ul>
+ *
+ *   <li><p> The <i>interest set</i> determines which operation categories will
+ *   be tested for readiness the next time one of the selector's selection
+ *   methods is invoked.  The interest set is initialized with the value given
+ *   when the key is created; it may later be changed via the {@link
+ *   #interestOps(int)} method. </p></li>
+ *
+ *   <li><p> The <i>ready set</i> identifies the operation categories for which
+ *   the key's channel has been detected to be ready by the key's selector.
+ *   The ready set is initialized to zero when the key is created; it may later
+ *   be updated by the selector during a selection operation, but it cannot be
+ *   updated directly. </p></li>
+ *
+ * </ul>
+ *
+ * <p> That a selection key's ready set indicates that its channel is ready for
+ * some operation category is a hint, but not a guarantee, that an operation in
+ * such a category may be performed by a thread without causing the thread to
+ * block.  A ready set is most likely to be accurate immediately after the
+ * completion of a selection operation.  It is likely to be made inaccurate by
+ * external events and by I/O operations that are invoked upon the
+ * corresponding channel.
+ *
+ * <p> This class defines all known operation-set bits, but precisely which
+ * bits are supported by a given channel depends upon the type of the channel.
+ * Each subclass of {@link SelectableChannel} defines an {@link
+ * SelectableChannel#validOps() validOps()} method which returns a set
+ * identifying just those operations that are supported by the channel.  An
+ * attempt to set or test an operation-set bit that is not supported by a key's
+ * channel will result in an appropriate run-time exception.
+ *
+ * <p> It is often necessary to associate some application-specific data with a
+ * selection key, for example an object that represents the state of a
+ * higher-level protocol and handles readiness notifications in order to
+ * implement that protocol.  Selection keys therefore support the
+ * <i>attachment</i> of a single arbitrary object to a key.  An object can be
+ * attached via the {@link #attach attach} method and then later retrieved via
+ * the {@link #attachment() attachment} method.
+ *
+ * <p> Selection keys are safe for use by multiple concurrent threads.  The
+ * operations of reading and writing the interest set will, in general, be
+ * synchronized with certain operations of the selector.  Exactly how this
+ * synchronization is performed is implementation-dependent: In a naive
+ * implementation, reading or writing the interest set may block indefinitely
+ * if a selection operation is already in progress; in a high-performance
+ * implementation, reading or writing the interest set may block briefly, if at
+ * all.  In any case, a selection operation will always use the interest-set
+ * value that was current at the moment that the operation began.  </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ *
+ * @see SelectableChannel
+ * @see Selector
+ */
+
+public abstract class SelectionKey {
+
+    /**
+     * Constructs an instance of this class.
+     */
+    protected SelectionKey() { }
+
+
+    // -- Channel and selector operations --
+
+    /**
+     * Returns the channel for which this key was created.  This method will
+     * continue to return the channel even after the key is cancelled.  </p>
+     *
+     * @return  This key's channel
+     */
+    public abstract SelectableChannel channel();
+
+    /**
+     * Returns the selector for which this key was created.  This method will
+     * continue to return the selector even after the key is cancelled.  </p>
+     *
+     * @return  This key's selector
+     */
+    public abstract Selector selector();
+
+    /**
+     * Tells whether or not this key is valid.
+     *
+     * <p> A key is valid upon creation and remains so until it is cancelled,
+     * its channel is closed, or its selector is closed.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if, this key is valid
+     */
+    public abstract boolean isValid();
+
+    /**
+     * Requests that the registration of this key's channel with its selector
+     * be cancelled.  Upon return the key will be invalid and will have been
+     * added to its selector's cancelled-key set.  The key will be removed from
+     * all of the selector's key sets during the next selection operation.
+     *
+     * <p> If this key has already been cancelled then invoking this method has
+     * no effect.  Once cancelled, a key remains forever invalid. </p>
+     *
+     * <p> This method may be invoked at any time.  It synchronizes on the
+     * selector's cancelled-key set, and therefore may block briefly if invoked
+     * concurrently with a cancellation or selection operation involving the
+     * same selector.  </p>
+     */
+    public abstract void cancel();
+
+
+    // -- Operation-set accessors --
+
+    /**
+     * Retrieves this key's interest set.
+     *
+     * <p> It is guaranteed that the returned set will only contain operation
+     * bits that are valid for this key's channel.
+     *
+     * <p> This method may be invoked at any time.  Whether or not it blocks,
+     * and for how long, is implementation-dependent.  </p>
+     *
+     * @return  This key's interest set
+     *
+     * @throws  CancelledKeyException
+     *          If this key has been cancelled
+     */
+    public abstract int interestOps();
+
+    /**
+     * Sets this key's interest set to the given value.
+     *
+     * <p> This method may be invoked at any time.  Whether or not it blocks,
+     * and for how long, is implementation-dependent.  </p>
+     *
+     * @param  ops  The new interest set
+     *
+     * @return  This selection key
+     *
+     * @throws  IllegalArgumentException
+     *          If a bit in the set does not correspond to an operation that
+     *          is supported by this key's channel, that is, if
+     *          <tt>(ops & ~channel().validOps()) != 0</tt>
+     *
+     * @throws  CancelledKeyException
+     *          If this key has been cancelled
+     */
+    public abstract SelectionKey interestOps(int ops);
+
+    /**
+     * Retrieves this key's ready-operation set.
+     *
+     * <p> It is guaranteed that the returned set will only contain operation
+     * bits that are valid for this key's channel.  </p>
+     *
+     * @return  This key's ready-operation set
+     *
+     * @throws  CancelledKeyException
+     *          If this key has been cancelled
+     */
+    public abstract int readyOps();
+
+
+    // -- Operation bits and bit-testing convenience methods --
+
+    /**
+     * Operation-set bit for read operations.
+     *
+     * <p> Suppose that a selection key's interest set contains
+     * <tt>OP_READ</tt> at the start of a <a
+     * href="Selector.html#selop">selection operation</a>.  If the selector
+     * detects that the corresponding channel is ready for reading, has reached
+     * end-of-stream, has been remotely shut down for further reading, or has
+     * an error pending, then it will add <tt>OP_READ</tt> to the key's
+     * ready-operation set and add the key to its selected-key&nbsp;set.  </p>
+     */
+    public static final int OP_READ = 1 << 0;
+
+    /**
+     * Operation-set bit for write operations.  </p>
+     *
+     * <p> Suppose that a selection key's interest set contains
+     * <tt>OP_WRITE</tt> at the start of a <a
+     * href="Selector.html#selop">selection operation</a>.  If the selector
+     * detects that the corresponding channel is ready for writing, has been
+     * remotely shut down for further writing, or has an error pending, then it
+     * will add <tt>OP_WRITE</tt> to the key's ready set and add the key to its
+     * selected-key&nbsp;set.  </p>
+     */
+    public static final int OP_WRITE = 1 << 2;
+
+    /**
+     * Operation-set bit for socket-connect operations.  </p>
+     *
+     * <p> Suppose that a selection key's interest set contains
+     * <tt>OP_CONNECT</tt> at the start of a <a
+     * href="Selector.html#selop">selection operation</a>.  If the selector
+     * detects that the corresponding socket channel is ready to complete its
+     * connection sequence, or has an error pending, then it will add
+     * <tt>OP_CONNECT</tt> to the key's ready set and add the key to its
+     * selected-key&nbsp;set.  </p>
+     */
+    public static final int OP_CONNECT = 1 << 3;
+
+    /**
+     * Operation-set bit for socket-accept operations.  </p>
+     *
+     * <p> Suppose that a selection key's interest set contains
+     * <tt>OP_ACCEPT</tt> at the start of a <a
+     * href="Selector.html#selop">selection operation</a>.  If the selector
+     * detects that the corresponding server-socket channel is ready to accept
+     * another connection, or has an error pending, then it will add
+     * <tt>OP_ACCEPT</tt> to the key's ready set and add the key to its
+     * selected-key&nbsp;set.  </p>
+     */
+    public static final int OP_ACCEPT = 1 << 4;
+
+    /**
+     * Tests whether this key's channel is ready for reading.
+     *
+     * <p> An invocation of this method of the form <tt>k.isReadable()</tt>
+     * behaves in exactly the same way as the expression
+     *
+     * <blockquote><pre>
+     * k.readyOps()&nbsp;&amp;&nbsp;OP_READ&nbsp;!=&nbsp;0</pre></blockquote>
+     *
+     * <p> If this key's channel does not support read operations then this
+     * method always returns <tt>false</tt>.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if,
+     *          <tt>readyOps()</tt>&nbsp;<tt>&</tt>&nbsp;<tt>OP_READ</tt> is
+     *          nonzero
+     *
+     * @throws  CancelledKeyException
+     *          If this key has been cancelled
+     */
+    public final boolean isReadable() {
+        return (readyOps() & OP_READ) != 0;
+    }
+
+    /**
+     * Tests whether this key's channel is ready for writing.
+     *
+     * <p> An invocation of this method of the form <tt>k.isWritable()</tt>
+     * behaves in exactly the same way as the expression
+     *
+     * <blockquote><pre>
+     * k.readyOps()&nbsp;&amp;&nbsp;OP_WRITE&nbsp;!=&nbsp;0</pre></blockquote>
+     *
+     * <p> If this key's channel does not support write operations then this
+     * method always returns <tt>false</tt>.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if,
+     *          <tt>readyOps()</tt>&nbsp;<tt>&</tt>&nbsp;<tt>OP_WRITE</tt>
+     *          is nonzero
+     *
+     * @throws  CancelledKeyException
+     *          If this key has been cancelled
+     */
+    public final boolean isWritable() {
+        return (readyOps() & OP_WRITE) != 0;
+    }
+
+    /**
+     * Tests whether this key's channel has either finished, or failed to
+     * finish, its socket-connection operation.
+     *
+     * <p> An invocation of this method of the form <tt>k.isConnectable()</tt>
+     * behaves in exactly the same way as the expression
+     *
+     * <blockquote><pre>
+     * k.readyOps()&nbsp;&amp;&nbsp;OP_CONNECT&nbsp;!=&nbsp;0</pre></blockquote>
+     *
+     * <p> If this key's channel does not support socket-connect operations
+     * then this method always returns <tt>false</tt>.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if,
+     *          <tt>readyOps()</tt>&nbsp;<tt>&</tt>&nbsp;<tt>OP_CONNECT</tt>
+     *          is nonzero
+     *
+     * @throws  CancelledKeyException
+     *          If this key has been cancelled
+     */
+    public final boolean isConnectable() {
+        return (readyOps() & OP_CONNECT) != 0;
+    }
+
+    /**
+     * Tests whether this key's channel is ready to accept a new socket
+     * connection.
+     *
+     * <p> An invocation of this method of the form <tt>k.isAcceptable()</tt>
+     * behaves in exactly the same way as the expression
+     *
+     * <blockquote><pre>
+     * k.readyOps()&nbsp;&amp;&nbsp;OP_ACCEPT&nbsp;!=&nbsp;0</pre></blockquote>
+     *
+     * <p> If this key's channel does not support socket-accept operations then
+     * this method always returns <tt>false</tt>.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if,
+     *          <tt>readyOps()</tt>&nbsp;<tt>&</tt>&nbsp;<tt>OP_ACCEPT</tt>
+     *          is nonzero
+     *
+     * @throws  CancelledKeyException
+     *          If this key has been cancelled
+     */
+    public final boolean isAcceptable() {
+        return (readyOps() & OP_ACCEPT) != 0;
+    }
+
+
+    // -- Attachments --
+
+    private volatile Object attachment = null;
+
+    private static final Object
+        attachmentUpdater = new Object();
+
+    /**
+     * Attaches the given object to this key.
+     *
+     * <p> An attached object may later be retrieved via the {@link #attachment()
+     * attachment} method.  Only one object may be attached at a time; invoking
+     * this method causes any previous attachment to be discarded.  The current
+     * attachment may be discarded by attaching <tt>null</tt>.  </p>
+     *
+     * @param  ob
+     *         The object to be attached; may be <tt>null</tt>
+     *
+     * @return  The previously-attached object, if any,
+     *          otherwise <tt>null</tt>
+     */
+    public final Object attach(Object ob) {
+		synchronized (attachmentUpdater)
+		{
+			Object rv = attachment;
+			attachment = ob;
+			return rv;
+		}
+    }
+
+    /**
+     * Retrieves the current attachment.  </p>
+     *
+     * @return  The object currently attached to this key,
+     *          or <tt>null</tt> if there is no attachment
+     */
+    public final Object attachment() {
+        return attachment;
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/Selector.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/Selector.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/Selector.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/Selector.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,395 @@
+/*
+ * Copyright 2000-2004 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+import java.nio.channels.spi.SelectorProvider;
+import java.util.Set;
+
+
+/**
+ * A multiplexor of {@link SelectableChannel} objects.
+ *
+ * <p> A selector may be created by invoking the {@link #open open} method of
+ * this class, which will use the system's default {@link
+ * java.nio.channels.spi.SelectorProvider </code>selector provider<code>} to
+ * create a new selector.  A selector may also be created by invoking the
+ * {@link java.nio.channels.spi.SelectorProvider#openSelector openSelector}
+ * method of a custom selector provider.  A selector remains open until it is
+ * closed via its {@link #close close} method.
+ *
+ * <a name="ks">
+ *
+ * <p> A selectable channel's registration with a selector is represented by a
+ * {@link SelectionKey} object.  A selector maintains three sets of selection
+ * keys:
+ *
+ * <ul>
+ *
+ *   <li><p> The <i>key set</i> contains the keys representing the current
+ *   channel registrations of this selector.  This set is returned by the
+ *   {@link #keys() keys} method. </p></li>
+ *
+ *   <li><p> The <i>selected-key set</i> is the set of keys such that each
+ *   key's channel was detected to be ready for at least one of the operations
+ *   identified in the key's interest set during a prior selection operation.
+ *   This set is returned by the {@link #selectedKeys() selectedKeys} method.
+ *   The selected-key set is always a subset of the key set. </p></li>
+ *
+ *   <li><p> The <i>cancelled-key</i> set is the set of keys that have been
+ *   cancelled but whose channels have not yet been deregistered.  This set is
+ *   not directly accessible.  The cancelled-key set is always a subset of the
+ *   key set. </p></li>
+ *
+ * </ul>
+ *
+ * <p> All three sets are empty in a newly-created selector.
+ *
+ * <p> A key is added to a selector's key set as a side effect of registering a
+ * channel via the channel's {@link SelectableChannel#register(Selector,int)
+ * register} method.  Cancelled keys are removed from the key set during
+ * selection operations.  The key set itself is not directly modifiable.
+ *
+ * <p> A key is added to its selector's cancelled-key set when it is cancelled,
+ * whether by closing its channel or by invoking its {@link SelectionKey#cancel
+ * cancel} method.  Cancelling a key will cause its channel to be deregistered
+ * during the next selection operation, at which time the key will removed from
+ * all of the selector's key sets.
+ *
+ * <a name="sks"><p> Keys are added to the selected-key set by selection
+ * operations.  A key may be removed directly from the selected-key set by
+ * invoking the set's {@link java.util.Set#remove(java.lang.Object) remove}
+ * method or by invoking the {@link java.util.Iterator#remove() remove} method
+ * of an {@link java.util.Iterator </code>iterator<code>} obtained from the
+ * set.  Keys are never removed from the selected-key set in any other way;
+ * they are not, in particular, removed as a side effect of selection
+ * operations.  Keys may not be added directly to the selected-key set. </p>
+ *
+ *
+ * <a name="selop">
+ * <h4>Selection</h4>
+ *
+ * <p> During each selection operation, keys may be added to and removed from a
+ * selector's selected-key set and may be removed from its key and
+ * cancelled-key sets.  Selection is performed by the {@link #select()}, {@link
+ * #select(long)}, and {@link #selectNow()} methods, and involves three steps:
+ * </p>
+ *
+ * <ol>
+ *
+ *   <li><p> Each key in the cancelled-key set is removed from each key set of
+ *   which it is a member, and its channel is deregistered.  This step leaves
+ *   the cancelled-key set empty. </p></li>
+ *
+ *   <li><p> The underlying operating system is queried for an update as to the
+ *   readiness of each remaining channel to perform any of the operations
+ *   identified by its key's interest set as of the moment that the selection
+ *   operation began.  For a channel that is ready for at least one such
+ *   operation, one of the following two actions is performed: </p>
+ *
+ *   <ol type=a>
+ *
+ *     <li><p> If the channel's key is not already in the selected-key set then
+ *     it is added to that set and its ready-operation set is modified to
+ *     identify exactly those operations for which the channel is now reported
+ *     to be ready.  Any readiness information previously recorded in the ready
+ *     set is discarded.  </p></li>
+ *
+ *     <li><p> Otherwise the channel's key is already in the selected-key set,
+ *     so its ready-operation set is modified to identify any new operations
+ *     for which the channel is reported to be ready.  Any readiness
+ *     information previously recorded in the ready set is preserved; in other
+ *     words, the ready set returned by the underlying system is
+ *     bitwise-disjoined into the key's current ready set. </p></li>
+ *
+ *   </ol></li>
+ *
+ *   If all of the keys in the key set at the start of this step have empty
+ *   interest sets then neither the selected-key set nor any of the keys'
+ *   ready-operation sets will be updated.
+ *
+ *   <li><p> If any keys were added to the cancelled-key set while step (2) was
+ *   in progress then they are processed as in step (1). </p></li>
+ *
+ * </ol>
+ *
+ * <p> Whether or not a selection operation blocks to wait for one or more
+ * channels to become ready, and if so for how long, is the only essential
+ * difference between the three selection methods. </p>
+ *
+ *
+ * <h4>Concurrency</h4>
+ *
+ * <p> Selectors are themselves safe for use by multiple concurrent threads;
+ * their key sets, however, are not.
+ *
+ * <p> The selection operations synchronize on the selector itself, on the key
+ * set, and on the selected-key set, in that order.  They also synchronize on
+ * the cancelled-key set during steps (1) and (3) above.
+ *
+ * <p> Changes made to the interest sets of a selector's keys while a
+ * selection operation is in progress have no effect upon that operation; they
+ * will be seen by the next selection operation.
+ *
+ * <p> Keys may be cancelled and channels may be closed at any time.  Hence the
+ * presence of a key in one or more of a selector's key sets does not imply
+ * that the key is valid or that its channel is open.  Application code should
+ * be careful to synchronize and check these conditions as necessary if there
+ * is any possibility that another thread will cancel a key or close a channel.
+ *
+ * <p> A thread blocked in one of the {@link #select()} or {@link
+ * #select(long)} methods may be interrupted by some other thread in one of
+ * three ways:
+ *
+ * <ul>
+ *
+ *   <li><p> By invoking the selector's {@link #wakeup wakeup} method,
+ *   </p></li>
+ *
+ *   <li><p> By invoking the selector's {@link #close close} method, or
+ *   </p></li>
+ *
+ *   <li><p> By invoking the blocked thread's {@link
+ *   java.lang.Thread#interrupt() interrupt} method, in which case its
+ *   interrupt status will be set and the selector's {@link #wakeup wakeup}
+ *   method will be invoked. </p></li>
+ *
+ * </ul>
+ *
+ * <p> The {@link #close close} method synchronizes on the selector and all
+ * three key sets in the same order as in a selection operation.
+ *
+ * <a name="ksc">
+ *
+ * <p> A selector's key and selected-key sets are not, in general, safe for use
+ * by multiple concurrent threads.  If such a thread might modify one of these
+ * sets directly then access should be controlled by synchronizing on the set
+ * itself.  The iterators returned by these sets' {@link
+ * java.util.Set#iterator() iterator} methods are <i>fail-fast:</i> If the set
+ * is modified after the iterator is created, in any way except by invoking the
+ * iterator's own {@link java.util.Iterator#remove() remove} method, then a
+ * {@link java.util.ConcurrentModificationException} will be thrown. </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ *
+ * @see SelectableChannel
+ * @see SelectionKey
+ */
+
+public abstract class Selector {
+
+    /**
+     * Initializes a new instance of this class.
+     */
+    protected Selector() { }
+
+    /**
+     * Opens a selector.
+     *
+     * <p> The new selector is created by invoking the {@link
+     * java.nio.channels.spi.SelectorProvider#openSelector openSelector} method
+     * of the system-wide default {@link
+     * java.nio.channels.spi.SelectorProvider} object.  </p>
+     *
+     * @return  A new selector
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     */
+    public static Selector open() throws IOException {
+        return SelectorProvider.provider().openSelector();
+    }
+
+    /**
+     * Tells whether or not this selector is open.  </p>
+     *
+     * @return <tt>true</tt> if, and only if, this selector is open
+     */
+    public abstract boolean isOpen();
+
+    /**
+     * Returns the provider that created this channel.  </p>
+     *
+     * @return  The provider that created this channel
+     */
+    public abstract SelectorProvider provider();
+
+    /**
+     * Returns this selector's key set.
+     *
+     * <p> The key set is not directly modifiable.  A key is removed only after
+     * it has been cancelled and its channel has been deregistered.  Any
+     * attempt to modify the key set will cause an {@link
+     * UnsupportedOperationException} to be thrown.
+     *
+     * <p> The key set is <a href="#ksc">not thread-safe</a>. </p>
+     *
+     * @return  This selector's key set
+     *
+     * @throws  ClosedSelectorException
+     *          If this selector is closed
+     */
+    public abstract Set keys();
+
+    /**
+     * Returns this selector's selected-key set.
+     *
+     * <p> Keys may be removed from, but not directly added to, the
+     * selected-key set.  Any attempt to add an object to the key set will
+     * cause an {@link UnsupportedOperationException} to be thrown.
+     *
+     * <p> The selected-key set is <a href="#ksc">not thread-safe</a>. </p>
+     *
+     * @return  This selector's selected-key set
+     *
+     * @throws  ClosedSelectorException
+     *          If this selector is closed
+     */
+    public abstract Set selectedKeys();
+
+    /**
+     * Selects a set of keys whose corresponding channels are ready for I/O
+     * operations.
+     *
+     * <p> This method performs a non-blocking <a href="#selop">selection
+     * operation</a>.  If no channels have become selectable since the previous
+     * selection operation then this method immediately returns zero.
+     *
+     * <p> Invoking this method clears the effect of any previous invocations
+     * of the {@link #wakeup wakeup} method.  </p>
+     *
+     * @return  The number of keys, possibly zero, whose ready-operation sets
+     *          were updated by the selection operation
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     *
+     * @throws  ClosedSelectorException
+     *          If this selector is closed
+     */
+    public abstract int selectNow() throws IOException;
+
+    /**
+     * Selects a set of keys whose corresponding channels are ready for I/O
+     * operations.
+     *
+     * <p> This method performs a blocking <a href="#selop">selection
+     * operation</a>.  It returns only after at least one channel is selected,
+     * this selector's {@link #wakeup wakeup} method is invoked, the current
+     * thread is interrupted, or the given timeout period expires, whichever
+     * comes first.
+     *
+     * <p> This method does not offer real-time guarantees: It schedules the
+     * timeout as if by invoking the {@link Object#wait(long)} method. </p>
+     *
+     * @param  timeout  If positive, block for up to <tt>timeout</tt>
+     *                  milliseconds, more or less, while waiting for a
+     *                  channel to become ready; if zero, block indefinitely;
+     *                  must not be negative
+     *
+     * @return  The number of keys, possibly zero,
+     *          whose ready-operation sets were updated
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     *
+     * @throws  ClosedSelectorException
+     *          If this selector is closed
+     *
+     * @throws  IllegalArgumentException
+     *          If the value of the timeout argument is negative
+     */
+    public abstract int select(long timeout)
+        throws IOException;
+
+    /**
+     * Selects a set of keys whose corresponding channels are ready for I/O
+     * operations.
+     *
+     * <p> This method performs a blocking <a href="#selop">selection
+     * operation</a>.  It returns only after at least one channel is selected,
+     * this selector's {@link #wakeup wakeup} method is invoked, or the current
+     * thread is interrupted, whichever comes first.  </p>
+     *
+     * @return  The number of keys, possibly zero,
+     *          whose ready-operation sets were updated
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     *
+     * @throws  ClosedSelectorException
+     *          If this selector is closed
+     */
+    public abstract int select() throws IOException;
+
+    /**
+     * Causes the first selection operation that has not yet returned to return
+     * immediately.
+     *
+     * <p> If another thread is currently blocked in an invocation of the
+     * {@link #select()} or {@link #select(long)} methods then that invocation
+     * will return immediately.  If no selection operation is currently in
+     * progress then the next invocation of one of these methods will return
+     * immediately unless the {@link #selectNow()} method is invoked in the
+     * meantime.  In any case the value returned by that invocation may be
+     * non-zero.  Subsequent invocations of the {@link #select()} or {@link
+     * #select(long)} methods will block as usual unless this method is invoked
+     * again in the meantime.
+     *
+     * <p> Invoking this method more than once between two successive selection
+     * operations has the same effect as invoking it just once.  </p>
+     *
+     * @return  This selector
+     */
+    public abstract Selector wakeup();
+
+    /**
+     * Closes this selector.
+     *
+     * <p> If a thread is currently blocked in one of this selector's selection
+     * methods then it is interrupted as if by invoking the selector's {@link
+     * #wakeup wakeup} method.
+     *
+     * <p> Any uncancelled keys still associated with this selector are
+     * invalidated, their channels are deregistered, and any other resources
+     * associated with this selector are released.
+     *
+     * <p> If this selector is already closed then invoking this method has no
+     * effect.
+     *
+     * <p> After a selector is closed, any further attempt to use it, except by
+     * invoking this method or the {@link #wakeup wakeup} method, will cause a
+     * {@link ClosedSelectorException} to be thrown. </p>
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     */
+    public abstract void close() throws IOException;
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ServerSocketChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ServerSocketChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/ServerSocketChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/ServerSocketChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,171 @@
+/*
+ * Copyright 2000-2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.SocketAddress;
+import java.nio.channels.spi.*;
+
+
+/**
+ * A selectable channel for stream-oriented listening sockets.
+ *
+ * <p> Server-socket channels are not a complete abstraction of listening
+ * network sockets.  Binding and the manipulation of socket options must be
+ * done through an associated {@link java.net.ServerSocket} object obtained by
+ * invoking the {@link #socket() socket} method.  It is not possible to create
+ * a channel for an arbitrary, pre-existing server socket, nor is it possible
+ * to specify the {@link java.net.SocketImpl} object to be used by a server
+ * socket associated with a server-socket channel.
+ *
+ * <p> A server-socket channel is created by invoking the {@link #open() open}
+ * method of this class.  A newly-created server-socket channel is open but not
+ * yet bound.  An attempt to invoke the {@link #accept() accept} method of an
+ * unbound server-socket channel will cause a {@link NotYetBoundException} to
+ * be thrown.  A server-socket channel can be bound by invoking one of the
+ * {@link java.net.ServerSocket#bind(java.net.SocketAddress,int) bind} methods
+ * of an associated server socket.
+ *
+ * <p> Server-socket channels are safe for use by multiple concurrent threads.
+ * </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public abstract class ServerSocketChannel
+    extends AbstractSelectableChannel
+{
+
+    /**
+     * Initializes a new instance of this class.
+     */
+    protected ServerSocketChannel(SelectorProvider provider) {
+        super(provider);
+    }
+
+    /**
+     * Opens a server-socket channel.
+     *
+     * <p> The new channel is created by invoking the {@link
+     * java.nio.channels.spi.SelectorProvider#openServerSocketChannel
+     * openServerSocketChannel} method of the system-wide default {@link
+     * java.nio.channels.spi.SelectorProvider} object.
+     *
+     * <p> The new channel's socket is initially unbound; it must be bound to a
+     * specific address via one of its socket's {@link
+     * java.net.ServerSocket#bind(SocketAddress) bind} methods before
+     * connections can be accepted.  </p>
+     *
+     * @return  A new socket channel
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     */
+    public static ServerSocketChannel open() throws IOException {
+        return SelectorProvider.provider().openServerSocketChannel();
+    }
+
+    /**
+     * Returns an operation set identifying this channel's supported
+     * operations.
+     *
+     * <p> Server-socket channels only support the accepting of new
+     * connections, so this method returns {@link SelectionKey#OP_ACCEPT}.
+     * </p>
+     *
+     * @return  The valid-operation set
+     */
+    public final int validOps() {
+        return SelectionKey.OP_ACCEPT;
+    }
+
+
+    // -- ServerSocket-specific operations --
+
+    /**
+     * Retrieves a server socket associated with this channel.
+     *
+     * <p> The returned object will not declare any public methods that are not
+     * declared in the {@link java.net.ServerSocket} class.  </p>
+     *
+     * @return  A server socket associated with this channel
+     */
+    public abstract ServerSocket socket();
+
+    /**
+     * Accepts a connection made to this channel's socket.
+     *
+     * <p> If this channel is in non-blocking mode then this method will
+     * immediately return <tt>null</tt> if there are no pending connections.
+     * Otherwise it will block indefinitely until a new connection is available
+     * or an I/O error occurs.
+     *
+     * <p> The socket channel returned by this method, if any, will be in
+     * blocking mode regardless of the blocking mode of this channel.
+     *
+     * <p> This method performs exactly the same security checks as the {@link
+     * java.net.ServerSocket#accept accept} method of the {@link
+     * java.net.ServerSocket} class.  That is, if a security manager has been
+     * installed then for each new connection this method verifies that the
+     * address and port number of the connection's remote endpoint are
+     * permitted by the security manager's {@link
+     * java.lang.SecurityManager#checkAccept checkAccept} method.  </p>
+     *
+     * @return  The socket channel for the new connection,
+     *          or <tt>null</tt> if this channel is in non-blocking mode
+     *          and no connection is available to be accepted
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes this channel
+     *          while the accept operation is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread
+     *          while the accept operation is in progress, thereby
+     *          closing the channel and setting the current thread's
+     *          interrupt status
+     *
+     * @throws  NotYetBoundException
+     *          If this channel's socket has not yet been bound
+     *
+     * @throws  SecurityException
+     *          If a security manager has been installed
+     *          and it does not permit access to the remote endpoint
+     *          of the new connection
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public abstract SocketChannel accept() throws IOException;
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/SocketChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/SocketChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/SocketChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/SocketChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,387 @@
+/*
+ * Copyright 2000-2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.net.SocketAddress;
+import java.nio.ByteBuffer;
+import java.nio.channels.spi.*;
+
+
+/**
+ * A selectable channel for stream-oriented connecting sockets.
+ *
+ * <p> Socket channels are not a complete abstraction of connecting network
+ * sockets.  Binding, shutdown, and the manipulation of socket options must be
+ * done through an associated {@link java.net.Socket} object obtained by
+ * invoking the {@link #socket() socket} method.  It is not possible to create
+ * a channel for an arbitrary, pre-existing socket, nor is it possible to
+ * specify the {@link java.net.SocketImpl} object to be used by a socket
+ * associated with a socket channel.
+ *
+ * <p> A socket channel is created by invoking one of the {@link #open open}
+ * methods of this class.  A newly-created socket channel is open but not yet
+ * connected.  An attempt to invoke an I/O operation upon an unconnected
+ * channel will cause a {@link NotYetConnectedException} to be thrown.  A
+ * socket channel can be connected by invoking its {@link #connect connect}
+ * method; once connected, a socket channel remains connected until it is
+ * closed.  Whether or not a socket channel is connected may be determined by
+ * invoking its {@link #isConnected isConnected} method.
+ *
+ * <p> Socket channels support <i>non-blocking connection:</i>&nbsp;A socket
+ * channel may be created and the process of establishing the link to the
+ * remote socket may be initiated via the {@link #connect connect} method for
+ * later completion by the {@link #finishConnect finishConnect} method.
+ * Whether or not a connection operation is in progress may be determined by
+ * invoking the {@link #isConnectionPending isConnectionPending} method.
+ *
+ * <p> The input and output sides of a socket channel may independently be
+ * <i>shut down</i> without actually closing the channel.  Shutting down the
+ * input side of a channel by invoking the {@link java.net.Socket#shutdownInput
+ * shutdownInput} method of an associated socket object will cause further
+ * reads on the channel to return <tt>-1</tt>, the end-of-stream indication.
+ * Shutting down the output side of the channel by invoking the {@link
+ * java.net.Socket#shutdownOutput shutdownOutput} method of an associated
+ * socket object will cause further writes on the channel to throw a {@link
+ * ClosedChannelException}.
+ *
+ * <p> Socket channels support <i>asynchronous shutdown,</i> which is similar
+ * to the asynchronous close operation specified in the {@link Channel} class.
+ * If the input side of a socket is shut down by one thread while another
+ * thread is blocked in a read operation on the socket's channel, then the read
+ * operation in the blocked thread will complete without reading any bytes and
+ * will return <tt>-1</tt>.  If the output side of a socket is shut down by one
+ * thread while another thread is blocked in a write operation on the socket's
+ * channel, then the blocked thread will receive an {@link
+ * AsynchronousCloseException}.
+ *
+ * <p> Socket channels are safe for use by multiple concurrent threads.  They
+ * support concurrent reading and writing, though at most one thread may be
+ * reading and at most one thread may be writing at any given time.  The {@link
+ * #connect connect} and {@link #finishConnect finishConnect} methods are
+ * mutually synchronized against each other, and an attempt to initiate a read
+ * or write operation while an invocation of one of these methods is in
+ * progress will block until that invocation is complete.  </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public abstract class SocketChannel
+    extends AbstractSelectableChannel
+    implements ByteChannel, ScatteringByteChannel, GatheringByteChannel
+{
+
+    /**
+     * Initializes a new instance of this class.
+     */
+    protected SocketChannel(SelectorProvider provider) {
+        super(provider);
+    }
+
+    /**
+     * Opens a socket channel.
+     *
+     * <p> The new channel is created by invoking the {@link
+     * java.nio.channels.spi.SelectorProvider#openSocketChannel
+     * openSocketChannel} method of the system-wide default {@link
+     * java.nio.channels.spi.SelectorProvider} object.  </p>
+     *
+     * @return  A new socket channel
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     */
+    public static SocketChannel open() throws IOException {
+        return SelectorProvider.provider().openSocketChannel();
+    }
+
+    /**
+     * Opens a socket channel and connects it to a remote address.
+     *
+     * <p> This convenience method works as if by invoking the {@link #open()}
+     * method, invoking the {@link #connect(SocketAddress) connect} method upon
+     * the resulting socket channel, passing it <tt>remote</tt>, and then
+     * returning that channel.  </p>
+     *
+     * @param  remote
+     *         The remote address to which the new channel is to be connected
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes this channel
+     *          while the connect operation is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread
+     *          while the connect operation is in progress, thereby
+     *          closing the channel and setting the current thread's
+     *          interrupt status
+     *
+     * @throws  UnresolvedAddressException
+     *          If the given remote address is not fully resolved
+     *
+     * @throws  UnsupportedAddressTypeException
+     *          If the type of the given remote address is not supported
+     *
+     * @throws  SecurityException
+     *          If a security manager has been installed
+     *          and it does not permit access to the given remote endpoint
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public static SocketChannel open(SocketAddress remote)
+        throws IOException
+    {
+        SocketChannel sc = open();
+        try {
+            sc.connect(remote);
+        } finally {
+            if (!sc.isConnected()) {
+                try { sc.close(); } catch (IOException x) { }
+            }
+        }
+        assert sc.isConnected();
+        return sc;
+    }
+
+    /**
+     * Returns an operation set identifying this channel's supported
+     * operations.
+     *
+     * <p> Socket channels support connecting, reading, and writing, so this
+     * method returns <tt>(</tt>{@link SelectionKey#OP_CONNECT}
+     * <tt>|</tt>&nbsp;{@link SelectionKey#OP_READ} <tt>|</tt>&nbsp;{@link
+     * SelectionKey#OP_WRITE}<tt>)</tt>.  </p>
+     *
+     * @return  The valid-operation set
+     */
+    public final int validOps() {
+        return (SelectionKey.OP_READ
+                | SelectionKey.OP_WRITE
+                | SelectionKey.OP_CONNECT);
+    }
+
+
+    // -- Socket-specific operations --
+
+    /**
+     * Retrieves a socket associated with this channel.
+     *
+     * <p> The returned object will not declare any public methods that are not
+     * declared in the {@link java.net.Socket} class.  </p>
+     *
+     * @return  A socket associated with this channel
+     */
+    public abstract Socket socket();
+
+    /**
+     * Tells whether or not this channel's network socket is connected.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if, this channel's network socket
+     *          is connected
+     */
+    public abstract boolean isConnected();
+
+    /**
+     * Tells whether or not a connection operation is in progress on this
+     * channel.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if, a connection operation has been
+     *          initiated on this channel but not yet completed by invoking the
+     *          {@link #finishConnect finishConnect} method
+     */
+    public abstract boolean isConnectionPending();
+
+    /**
+     * Connects this channel's socket.
+     *
+     * <p> If this channel is in non-blocking mode then an invocation of this
+     * method initiates a non-blocking connection operation.  If the connection
+     * is established immediately, as can happen with a local connection, then
+     * this method returns <tt>true</tt>.  Otherwise this method returns
+     * <tt>false</tt> and the connection operation must later be completed by
+     * invoking the {@link #finishConnect finishConnect} method.
+     *
+     * <p> If this channel is in blocking mode then an invocation of this
+     * method will block until the connection is established or an I/O error
+     * occurs.
+     *
+     * <p> This method performs exactly the same security checks as the {@link
+     * java.net.Socket} class.  That is, if a security manager has been
+     * installed then this method verifies that its {@link
+     * java.lang.SecurityManager#checkConnect checkConnect} method permits
+     * connecting to the address and port number of the given remote endpoint.
+     *
+     * <p> This method may be invoked at any time.  If a read or write
+     * operation upon this channel is invoked while an invocation of this
+     * method is in progress then that operation will first block until this
+     * invocation is complete.  If a connection attempt is initiated but fails,
+     * that is, if an invocation of this method throws a checked exception,
+     * then the channel will be closed.  </p>
+     *
+     * @param  remote
+     *         The remote address to which this channel is to be connected
+     *
+     * @return  <tt>true</tt> if a connection was established,
+     *          <tt>false</tt> if this channel is in non-blocking mode
+     *          and the connection operation is in progress
+     *
+     * @throws  AlreadyConnectedException
+     *          If this channel is already connected
+     *
+     * @throws  ConnectionPendingException
+     *          If a non-blocking connection operation is already in progress
+     *          on this channel
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes this channel
+     *          while the connect operation is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread
+     *          while the connect operation is in progress, thereby
+     *          closing the channel and setting the current thread's
+     *          interrupt status
+     *
+     * @throws  UnresolvedAddressException
+     *          If the given remote address is not fully resolved
+     *
+     * @throws  UnsupportedAddressTypeException
+     *          If the type of the given remote address is not supported
+     *
+     * @throws  SecurityException
+     *          If a security manager has been installed
+     *          and it does not permit access to the given remote endpoint
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public abstract boolean connect(SocketAddress remote) throws IOException;
+
+    /**
+     * Finishes the process of connecting a socket channel.
+     *
+     * <p> A non-blocking connection operation is initiated by placing a socket
+     * channel in non-blocking mode and then invoking its {@link #connect
+     * connect} method.  Once the connection is established, or the attempt has
+     * failed, the socket channel will become connectable and this method may
+     * be invoked to complete the connection sequence.  If the connection
+     * operation failed then invoking this method will cause an appropriate
+     * {@link java.io.IOException} to be thrown.
+     *
+     * <p> If this channel is already connected then this method will not block
+     * and will immediately return <tt>true</tt>.  If this channel is in
+     * non-blocking mode then this method will return <tt>false</tt> if the
+     * connection process is not yet complete.  If this channel is in blocking
+     * mode then this method will block until the connection either completes
+     * or fails, and will always either return <tt>true</tt> or throw a checked
+     * exception describing the failure.
+     *
+     * <p> This method may be invoked at any time.  If a read or write
+     * operation upon this channel is invoked while an invocation of this
+     * method is in progress then that operation will first block until this
+     * invocation is complete.  If a connection attempt fails, that is, if an
+     * invocation of this method throws a checked exception, then the channel
+     * will be closed.  </p>
+     *
+     * @return  <tt>true</tt> if, and only if, this channel's socket is now
+     *          connected
+     *
+     * @throws  NoConnectionPendingException
+     *          If this channel is not connected and a connection operation
+     *          has not been initiated
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes this channel
+     *          while the connect operation is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread
+     *          while the connect operation is in progress, thereby
+     *          closing the channel and setting the current thread's
+     *          interrupt status
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public abstract boolean finishConnect() throws IOException;
+
+
+    // -- ByteChannel operations --
+
+    /**
+     * @throws  NotYetConnectedException
+     *          If this channel is not yet connected
+     */
+    public abstract int read(ByteBuffer dst) throws IOException;
+
+    /**
+     * @throws  NotYetConnectedException
+     *          If this channel is not yet connected
+     */
+    public abstract long read(ByteBuffer[] dsts, int offset, int length)
+        throws IOException;
+
+    /**
+     * @throws  NotYetConnectedException
+     *          If this channel is not yet connected
+     */
+    public final long read(ByteBuffer[] dsts) throws IOException {
+        return read(dsts, 0, dsts.length);
+    }
+
+    /**
+     * @throws  NotYetConnectedException
+     *          If this channel is not yet connected
+     */
+    public abstract int write(ByteBuffer src) throws IOException;
+
+    /**
+     * @throws  NotYetConnectedException
+     *          If this channel is not yet connected
+     */
+    public abstract long write(ByteBuffer[] srcs, int offset, int length)
+        throws IOException;
+
+    /**
+     * @throws  NotYetConnectedException
+     *          If this channel is not yet connected
+     */
+    public final long write(ByteBuffer[] srcs) throws IOException {
+        return write(srcs, 0, srcs.length);
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,212 @@
+/*
+ * Copyright 2000-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ */
+
+package java.nio.channels.spi;
+
+import java.io.IOException;
+import java.lang.reflect.Method;
+import java.lang.reflect.InvocationTargetException;
+import java.nio.channels.*;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import sun.nio.ch.Interruptible;
+
+
+/**
+ * Base implementation class for interruptible channels.
+ *
+ * <p> This class encapsulates the low-level machinery required to implement
+ * the asynchronous closing and interruption of channels.  A concrete channel
+ * class must invoke the {@link #begin begin} and {@link #end end} methods
+ * before and after, respectively, invoking an I/O operation that might block
+ * indefinitely.  In order to ensure that the {@link #end end} method is always
+ * invoked, these methods should be used within a
+ * <tt>try</tt>&nbsp;...&nbsp;<tt>finally</tt> block: <a name="be">
+ *
+ * <blockquote><pre>
+ * boolean completed = false;
+ * try {
+ *     begin();
+ *     completed = ...;    // Perform blocking I/O operation
+ *     return ...;         // Return result
+ * } finally {
+ *     end(completed);
+ * }</pre></blockquote>
+ *
+ * <p> The <tt>completed</tt> argument to the {@link #end end} method tells
+ * whether or not the I/O operation actually completed, that is, whether it had
+ * any effect that would be visible to the invoker.  In the case of an
+ * operation that reads bytes, for example, this argument should be
+ * <tt>true</tt> if, and only if, some bytes were actually transferred into the
+ * invoker's target buffer.
+ *
+ * <p> A concrete channel class must also implement the {@link
+ * #implCloseChannel implCloseChannel} method in such a way that if it is
+ * invoked while another thread is blocked in a native I/O operation upon the
+ * channel then that operation will immediately return, either by throwing an
+ * exception or by returning normally.  If a thread is interrupted or the
+ * channel upon which it is blocked is asynchronously closed then the channel's
+ * {@link #end end} method will throw the appropriate exception.
+ *
+ * <p> This class performs the synchronization required to implement the {@link
+ * java.nio.channels.Channel} specification.  Implementations of the {@link
+ * #implCloseChannel implCloseChannel} method need not synchronize against
+ * other threads that might be attempting to close the channel.  </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public abstract class AbstractInterruptibleChannel
+    implements Channel, InterruptibleChannel
+{
+
+    private Object closeLock = new Object();
+    private volatile boolean open = true;
+
+    /**
+     * Initializes a new instance of this class.
+     */
+    protected AbstractInterruptibleChannel() { }
+
+    /**
+     * Closes this channel.
+     *
+     * <p> If the channel has already been closed then this method returns
+     * immediately.  Otherwise it marks the channel as closed and then invokes
+     * the {@link #implCloseChannel implCloseChannel} method in order to
+     * complete the close operation.  </p>
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     */
+    public final void close() throws IOException {
+        synchronized (closeLock) {
+            if (!open)
+                return;
+            open = false;
+            implCloseChannel();
+        }
+    }
+
+    /**
+     * Closes this channel.
+     *
+     * <p> This method is invoked by the {@link #close close} method in order
+     * to perform the actual work of closing the channel.  This method is only
+     * invoked if the channel has not yet been closed, and it is never invoked
+     * more than once.
+     *
+     * <p> An implementation of this method must arrange for any other thread
+     * that is blocked in an I/O operation upon this channel to return
+     * immediately, either by throwing an exception or by returning normally.
+     * </p>
+     *
+     * @throws  IOException
+     *          If an I/O error occurs while closing the channel
+     */
+    protected abstract void implCloseChannel() throws IOException;
+
+    public final boolean isOpen() {
+        return open;
+    }
+
+
+    // -- Interruption machinery --
+
+    private Interruptible interruptor;
+    private volatile boolean interrupted = false;
+
+    /**
+     * Marks the beginning of an I/O operation that might block indefinitely.
+     *
+     * <p> This method should be invoked in tandem with the {@link #end end}
+     * method, using a <tt>try</tt>&nbsp;...&nbsp;<tt>finally</tt> block as
+     * shown <a href="#be">above</a>, in order to implement asynchronous
+     * closing and interruption for this channel.  </p>
+     */
+    protected final void begin() {
+        if (interruptor == null) {
+            interruptor = new Interruptible() {
+                    public void interrupt() {
+                        synchronized (closeLock) {
+                            if (!open)
+                                return;
+                            interrupted = true;
+                            open = false;
+                            try {
+                                AbstractInterruptibleChannel.this.implCloseChannel();
+                            } catch (IOException x) { }
+                        }
+                    }};
+        }
+        blockedOn(interruptor);
+        if (Thread.currentThread().isInterrupted())
+            interruptor.interrupt();
+    }
+
+    /**
+     * Marks the end of an I/O operation that might block indefinitely.
+     *
+     * <p> This method should be invoked in tandem with the {@link #begin
+     * begin} method, using a <tt>try</tt>&nbsp;...&nbsp;<tt>finally</tt> block
+     * as shown <a href="#be">above</a>, in order to implement asynchronous
+     * closing and interruption for this channel.  </p>
+     *
+     * @param  completed
+     *         <tt>true</tt> if, and only if, the I/O operation completed
+     *         successfully, that is, had some effect that would be visible to
+     *         the operation's invoker
+     *
+     * @throws  AsynchronousCloseException
+     *          If the channel was asynchronously closed
+     *
+     * @throws  ClosedByInterruptException
+     *          If the thread blocked in the I/O operation was interrupted
+     */
+    protected final void end(boolean completed)
+        throws AsynchronousCloseException
+    {
+        blockedOn(null);
+        if (completed) {
+            interrupted = false;
+            return;
+        }
+        if (interrupted) throw new ClosedByInterruptException();
+        if (!open) throw new AsynchronousCloseException();
+    }
+
+
+    // -- sun.misc.SharedSecrets --
+    static void blockedOn(Interruptible intr) {         // package-private
+//NARFLEX        sun.misc.SharedSecrets.getJavaLangAccess().blockedOn(Thread.currentThread(),
+//NARFLEX                                                             intr);
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/spi/AbstractSelectableChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/spi/AbstractSelectableChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/spi/AbstractSelectableChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/spi/AbstractSelectableChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,295 @@
+/*
+ * Copyright 2000-2003 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels.spi;
+
+import java.io.IOException;
+import java.nio.channels.*;
+
+
+/**
+ * Base implementation class for selectable channels.
+ *
+ * <p> This class defines methods that handle the mechanics of channel
+ * registration, deregistration, and closing.  It maintains the current
+ * blocking mode of this channel as well as its current set of selection keys.
+ * It performs all of the synchronization required to implement the {@link
+ * java.nio.channels.SelectableChannel} specification.  Implementations of the
+ * abstract protected methods defined in this class need not synchronize
+ * against other threads that might be engaged in the same operations.  </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author Mike McCloskey
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public abstract class AbstractSelectableChannel
+    extends SelectableChannel
+{
+
+    // The provider that created this channel
+    private final SelectorProvider provider;
+
+    // Keys that have been created by registering this channel with selectors.
+    // They are saved because if this channel is closed the keys must be
+    // deregistered.  Protected by keyLock.
+    //
+    private SelectionKey[] keys = null;
+    private int keyCount = 0;
+
+    // Lock for key set and count
+    private final Object keyLock = new Object();
+
+    // Lock for registration and configureBlocking operations
+    private final Object regLock = new Object();
+
+    // Blocking mode, protected by regLock
+    boolean blocking = true;
+
+    /**
+     * Initializes a new instance of this class.
+     */
+    protected AbstractSelectableChannel(SelectorProvider provider) {
+        this.provider = provider;
+    }
+
+    /**
+     * Returns the provider that created this channel.
+     *
+     * @return  The provider that created this channel
+     */
+    public final SelectorProvider provider() {
+        return provider;
+    }
+
+
+    // -- Utility methods for the key set --
+
+    private void addKey(SelectionKey k) {
+        synchronized (keyLock) {
+            int i = 0;
+            if ((keys != null) && (keyCount < keys.length)) {
+                // Find empty element of key array
+                for (i = 0; i < keys.length; i++)
+                    if (keys[i] == null)
+                        break;
+            } else if (keys == null) {
+                keys =  new SelectionKey[3];
+            } else {
+                // Grow key array
+                int n = keys.length * 2;
+                SelectionKey[] ks =  new SelectionKey[n];
+                for (i = 0; i < keys.length; i++)
+                    ks[i] = keys[i];
+                keys = ks;
+                i = keyCount;
+            }
+            keys[i] = k;
+            keyCount++;
+        }
+    }
+
+    private SelectionKey findKey(Selector sel) {
+        synchronized (keyLock) {
+            if (keys == null)
+                return null;
+            for (int i = 0; i < keys.length; i++)
+                if ((keys[i] != null) && (keys[i].selector() == sel))
+                    return keys[i];
+            return null;
+        }
+    }
+
+    void removeKey(SelectionKey k) {                    // package-private
+        synchronized (keyLock) {
+            for (int i = 0; i < keys.length; i++)
+                if (keys[i] == k) {
+                    keys[i] = null;
+                    keyCount--;
+                }
+            ((AbstractSelectionKey)k).invalidate();
+        }
+    }
+
+    private boolean haveValidKeys() {
+        synchronized (keyLock) {
+            if (keyCount == 0)
+                return false;
+            for (int i = 0; i < keys.length; i++) {
+                if ((keys[i] != null) && keys[i].isValid())
+                    return true;
+            }
+            return false;
+        }
+    }
+
+
+    // -- Registration --
+
+    public final boolean isRegistered() {
+        synchronized (keyLock) {
+            return keyCount != 0;
+        }
+    }
+
+    public final SelectionKey keyFor(Selector sel) {
+        return findKey(sel);
+    }
+
+    /**
+     * Registers this channel with the given selector, returning a selection key.
+     *
+     * <p>  This method first verifies that this channel is open and that the
+     * given initial interest set is valid.
+     *
+     * <p> If this channel is already registered with the given selector then
+     * the selection key representing that registration is returned after
+     * setting its interest set to the given value.
+     *
+     * <p> Otherwise this channel has not yet been registered with the given
+     * selector, so the {@link AbstractSelector#register register} method of
+     * the selector is invoked while holding the appropriate locks.  The
+     * resulting key is added to this channel's key set before being returned.
+     * </p>
+     */
+    public final SelectionKey register(Selector sel, int ops,
+                                       Object att)
+        throws ClosedChannelException
+    {
+        if (!isOpen())
+            throw new ClosedChannelException();
+        if ((ops & ~validOps()) != 0)
+            throw new IllegalArgumentException();
+        synchronized (regLock) {
+            if (blocking)
+                throw new IllegalBlockingModeException();
+            SelectionKey k = findKey(sel);
+            if (k != null) {
+                k.interestOps(ops);
+                k.attach(att);
+            }
+            if (k == null) {
+                // New registration
+                k = ((AbstractSelector)sel).register(this, ops, att);
+                addKey(k);
+            }
+            return k;
+        }
+    }
+
+
+    // -- Closing --
+
+    /**
+     * Closes this channel.
+     *
+     * <p> This method, which is specified in the {@link
+     * AbstractInterruptibleChannel} class and is invoked by the {@link
+     * java.nio.channels.Channel#close close} method, in turn invokes the
+     * {@link #implCloseSelectableChannel implCloseSelectableChannel} method in
+     * order to perform the actual work of closing this channel.  It then
+     * cancels all of this channel's keys.  </p>
+     */
+    protected final void implCloseChannel() throws IOException {
+        implCloseSelectableChannel();
+        synchronized (keyLock) {
+            int count = (keys == null) ? 0 : keys.length;
+            for (int i = 0; i < count; i++) {
+                SelectionKey k = keys[i];
+                if (k != null)
+                    k.cancel();
+            }
+        }
+    }
+
+    /**
+     * Closes this selectable channel.
+     *
+     * <p> This method is invoked by the {@link java.nio.channels.Channel#close
+     * close} method in order to perform the actual work of closing the
+     * channel.  This method is only invoked if the channel has not yet been
+     * closed, and it is never invoked more than once.
+     *
+     * <p> An implementation of this method must arrange for any other thread
+     * that is blocked in an I/O operation upon this channel to return
+     * immediately, either by throwing an exception or by returning normally.
+     * </p>
+     */
+    protected abstract void implCloseSelectableChannel() throws IOException;
+
+
+    // -- Blocking --
+
+    public final boolean isBlocking() {
+        synchronized (regLock) {
+            return blocking;
+        }
+    }
+
+    public final Object blockingLock() {
+        return regLock;
+    }
+
+    /**
+     * Adjusts this channel's blocking mode.
+     *
+     * <p> If the given blocking mode is different from the current blocking
+     * mode then this method invokes the {@link #implConfigureBlocking
+     * implConfigureBlocking} method, while holding the appropriate locks, in
+     * order to change the mode.  </p>
+     */
+    public final SelectableChannel configureBlocking(boolean block)
+        throws IOException
+    {
+        if (!isOpen())
+            throw new ClosedChannelException();
+        synchronized (regLock) {
+            if (blocking == block)
+                return this;
+            if (block && haveValidKeys())
+                throw new IllegalBlockingModeException();
+            implConfigureBlocking(block);
+            blocking = block;
+        }
+        return this;
+    }
+
+    /**
+     * Adjusts this channel's blocking mode.
+     *
+     * <p> This method is invoked by the {@link #configureBlocking
+     * configureBlocking} method in order to perform the actual work of
+     * changing the blocking mode.  This method is only invoked if the new mode
+     * is different from the current mode.  </p>
+     *
+     * @throws IOException
+     *         If an I/O error occurs
+     */
+    protected abstract void implConfigureBlocking(boolean block)
+        throws IOException;
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/spi/AbstractSelectionKey.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/spi/AbstractSelectionKey.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/spi/AbstractSelectionKey.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/spi/AbstractSelectionKey.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2000-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels.spi;
+
+import java.nio.channels.*;
+
+
+/**
+ * Base implementation class for selection keys.
+ *
+ * <p> This class tracks the validity of the key and implements cancellation.
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public abstract class AbstractSelectionKey
+    extends SelectionKey
+{
+
+    /**
+     * Initializes a new instance of this class.  </p>
+     */
+    protected AbstractSelectionKey() { }
+
+    private volatile boolean valid = true;
+
+    public final boolean isValid() {
+        return valid;
+    }
+
+    void invalidate() {                                 // package-private
+        valid = false;
+    }
+
+    /**
+     * Cancels this key.
+     *
+     * <p> If this key has not yet been cancelled then it is added to its
+     * selector's cancelled-key set while synchronized on that set.  </p>
+     */
+    public final void cancel() {
+        // Synchronizing "this" to prevent this key from getting canceled
+        // multiple times by different threads, which might cause race
+        // condition between selector's select() and channel's close().
+        synchronized (this) {
+            if (valid) {
+                valid = false;
+                ((AbstractSelector)selector()).cancel(this);
+            }
+        }
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/spi/AbstractSelector.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/spi/AbstractSelector.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/spi/AbstractSelector.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/spi/AbstractSelector.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,235 @@
+/*
+ * Copyright 2000-2004 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels.spi;
+
+import java.io.IOException;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.util.HashSet;
+import java.util.Set;
+import sun.nio.ch.Interruptible;
+
+
+/**
+ * Base implementation class for selectors.
+ *
+ * <p> This class encapsulates the low-level machinery required to implement
+ * the interruption of selection operations.  A concrete selector class must
+ * invoke the {@link #begin begin} and {@link #end end} methods before and
+ * after, respectively, invoking an I/O operation that might block
+ * indefinitely.  In order to ensure that the {@link #end end} method is always
+ * invoked, these methods should be used within a
+ * <tt>try</tt>&nbsp;...&nbsp;<tt>finally</tt> block: <a name="be">
+ *
+ * <blockquote><pre>
+ * try {
+ *     begin();
+ *     // Perform blocking I/O operation here
+ *     ...
+ * } finally {
+ *     end();
+ * }</pre></blockquote>
+ *
+ * <p> This class also defines methods for maintaining a selector's
+ * cancelled-key set and for removing a key from its channel's key set, and
+ * declares the abstract {@link #register register} method that is invoked by a
+ * selectable channel's {@link AbstractSelectableChannel#register register}
+ * method in order to perform the actual work of registering a channel.  </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public abstract class AbstractSelector
+    extends Selector
+{
+
+    private boolean selectorOpen = true;
+	private Object selectorOpenLock = new Object();
+
+    // The provider that created this selector
+    private final SelectorProvider provider;
+
+    /**
+     * Initializes a new instance of this class.  </p>
+     */
+    protected AbstractSelector(SelectorProvider provider) {
+        this.provider = provider;
+    }
+
+    private final Set cancelledKeys = new HashSet();
+
+    void cancel(SelectionKey k) {                       // package-private
+        synchronized (cancelledKeys) {
+            cancelledKeys.add(k);
+        }
+    }
+
+    /**
+     * Closes this selector.
+     *
+     * <p> If the selector has already been closed then this method returns
+     * immediately.  Otherwise it marks the selector as closed and then invokes
+     * the {@link #implCloseSelector implCloseSelector} method in order to
+     * complete the close operation.  </p>
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     */
+    public final void close() throws IOException {
+		boolean open;
+		synchronized (selectorOpenLock)
+		{
+			open = selectorOpen;
+			selectorOpen = false;
+		}
+        if (!open)
+            return;
+        implCloseSelector();
+    }
+
+    /**
+     * Closes this selector.
+     *
+     * <p> This method is invoked by the {@link #close close} method in order
+     * to perform the actual work of closing the selector.  This method is only
+     * invoked if the selector has not yet been closed, and it is never invoked
+     * more than once.
+     *
+     * <p> An implementation of this method must arrange for any other thread
+     * that is blocked in a selection operation upon this selector to return
+     * immediately as if by invoking the {@link
+     * java.nio.channels.Selector#wakeup wakeup} method. </p>
+     *
+     * @throws  IOException
+     *          If an I/O error occurs while closing the selector
+     */
+    protected abstract void implCloseSelector() throws IOException;
+
+    public final boolean isOpen() {
+        return selectorOpen;
+    }
+
+    /**
+     * Returns the provider that created this channel.
+     *
+     * @return  The provider that created this channel
+     */
+    public final SelectorProvider provider() {
+        return provider;
+    }
+
+    /**
+     * Retrieves this selector's cancelled-key set.
+     *
+     * <p> This set should only be used while synchronized upon it.  </p>
+     *
+     * @return  The cancelled-key set
+     */
+    protected final Set cancelledKeys() {
+        return cancelledKeys;
+    }
+
+    /**
+     * Registers the given channel with this selector.
+     *
+     * <p> This method is invoked by a channel's {@link
+     * AbstractSelectableChannel#register register} method in order to perform
+     * the actual work of registering the channel with this selector.  </p>
+     *
+     * @param  ch
+     *         The channel to be registered
+     *
+     * @param  ops
+     *         The initial interest set, which must be valid
+     *
+     * @param  att
+     *         The initial attachment for the resulting key
+     *
+     * @return  A new key representing the registration of the given channel
+     *          with this selector
+     */
+    protected abstract SelectionKey register(AbstractSelectableChannel ch,
+                                             int ops, Object att);
+
+    /**
+     * Removes the given key from its channel's key set.
+     *
+     * <p> This method must be invoked by the selector for each channel that it
+     * deregisters.  </p>
+     *
+     * @param  key
+     *         The selection key to be removed
+     */
+    protected final void deregister(AbstractSelectionKey key) {
+        ((AbstractSelectableChannel)key.channel()).removeKey(key);
+    }
+
+
+    // -- Interruption machinery --
+
+    private Interruptible interruptor = null;
+
+    /**
+     * Marks the beginning of an I/O operation that might block indefinitely.
+     *
+     * <p> This method should be invoked in tandem with the {@link #end end}
+     * method, using a <tt>try</tt>&nbsp;...&nbsp;<tt>finally</tt> block as
+     * shown <a href="#be">above</a>, in order to implement interruption for
+     * this selector.
+     *
+     * <p> Invoking this method arranges for the selector's {@link
+     * Selector#wakeup wakeup} method to be invoked if a thread's {@link
+     * Thread#interrupt interrupt} method is invoked while the thread is
+     * blocked in an I/O operation upon the selector.  </p>
+     */
+    protected final void begin() {
+        if (interruptor == null) {
+            interruptor = new Interruptible() {
+                    public void interrupt() {
+                        AbstractSelector.this.wakeup();
+                    }};
+        }
+        AbstractInterruptibleChannel.blockedOn(interruptor);
+        if (Thread.currentThread().isInterrupted())
+            interruptor.interrupt();
+    }
+
+    /**
+     * Marks the end of an I/O operation that might block indefinitely.
+     *
+     * <p> This method should be invoked in tandem with the {@link #begin begin}
+     * method, using a <tt>try</tt>&nbsp;...&nbsp;<tt>finally</tt> block as
+     * shown <a href="#be">above</a>, in order to implement interruption for
+     * this selector.  </p>
+     */
+    protected final void end() {
+        AbstractInterruptibleChannel.blockedOn(null);
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/spi/package.html phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/spi/package.html
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/spi/package.html	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/spi/package.html	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,45 @@
+<!--
+ Copyright 2000-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+
+ This code is free software; you can redistribute it and/or modify it
+ under the terms of the GNU General Public License version 2 only, as
+ published by the Free Software Foundation.  Sun designates this
+ particular file as subject to the "Classpath" exception as provided
+ by Sun in the LICENSE file that accompanied this code.
+
+ This code is distributed in the hope that it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ version 2 for more details (a copy is included in the LICENSE file that
+ accompanied this code).
+
+ You should have received a copy of the GNU General Public License version
+ 2 along with this work; if not, write to the Free Software Foundation,
+ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+
+ Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ CA 95054 USA or visit www.sun.com if you need additional information or
+ have any questions.
+-->
+
+<!doctype html public "-//IETF//DTD HTML//EN">
+<html>
+<body bgcolor="white">
+
+Service-provider classes for the <tt>{@link java.nio.channels}</tt> package.
+
+<p> Only developers who are defining new selector providers should need to make
+direct use of this package.  </p>
+
+<p> Unless otherwise noted, passing a <tt>null</tt> argument to a constructor
+or method in any class or interface in this package will cause a {@link
+java.lang.NullPointerException NullPointerException} to be thrown.
+
+
+@since 1.4
+@author Mark Reinhold
+@author JSR-51 Expert Group
+
+</body>
+</html>
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/spi/SelectorProvider.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/spi/SelectorProvider.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/spi/SelectorProvider.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/spi/SelectorProvider.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,286 @@
+/*
+ * Copyright 2000-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels.spi;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.nio.channels.*;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.Iterator;
+import java.util.ServiceLoader;
+import java.util.ServiceConfigurationError;
+import sun.security.action.GetPropertyAction;
+
+
+/**
+ * Service-provider class for selectors and selectable channels.
+ *
+ * <p> A selector provider is a concrete subclass of this class that has a
+ * zero-argument constructor and implements the abstract methods specified
+ * below.  A given invocation of the Java virtual machine maintains a single
+ * system-wide default provider instance, which is returned by the {@link
+ * #provider() provider} method.  The first invocation of that method will locate
+ * the default provider as specified below.
+ *
+ * <p> The system-wide default provider is used by the static <tt>open</tt>
+ * methods of the {@link java.nio.channels.DatagramChannel#open
+ * DatagramChannel}, {@link java.nio.channels.Pipe#open Pipe}, {@link
+ * java.nio.channels.Selector#open Selector}, {@link
+ * java.nio.channels.ServerSocketChannel#open ServerSocketChannel}, and {@link
+ * java.nio.channels.SocketChannel#open SocketChannel} classes.  It is also
+ * used by the {@link java.lang.System#inheritedChannel System.inheritedChannel()}
+ * method. A program may make use of a provider other than the default provider
+ * by instantiating that provider and then directly invoking the <tt>open</tt>
+ * methods defined in this class.
+ *
+ * <p> All of the methods in this class are safe for use by multiple concurrent
+ * threads.  </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public abstract class SelectorProvider {
+
+    private static final Object lock = new Object();
+    private static SelectorProvider provider = null;
+
+    /**
+     * Initializes a new instance of this class.  </p>
+     *
+     * @throws  SecurityException
+     *          If a security manager has been installed and it denies
+     *          {@link RuntimePermission}<tt>("selectorProvider")</tt>
+     */
+    protected SelectorProvider() {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null)
+            sm.checkPermission(new RuntimePermission("selectorProvider"));
+    }
+
+    private static boolean loadProviderFromProperty() {
+        String cn = System.getProperty("java.nio.channels.spi.SelectorProvider");
+        if (cn == null)
+            return false;
+        try {
+            Class c = Class.forName(cn, true,
+                                    ClassLoader.getSystemClassLoader());
+            provider = (SelectorProvider)c.newInstance();
+            return true;
+        } catch (ClassNotFoundException x) {
+            throw new ServiceConfigurationError(null, x);
+        } catch (IllegalAccessException x) {
+            throw new ServiceConfigurationError(null, x);
+        } catch (InstantiationException x) {
+            throw new ServiceConfigurationError(null, x);
+        } catch (SecurityException x) {
+            throw new ServiceConfigurationError(null, x);
+        }
+    }
+
+    private static boolean loadProviderAsService() {
+
+        ServiceLoader sl =
+            ServiceLoader.load(SelectorProvider.class,
+                               ClassLoader.getSystemClassLoader());
+        Iterator i = sl.iterator();
+        for (;;) {
+            try {
+                if (!i.hasNext())
+                    return false;
+                provider = (SelectorProvider)i.next();
+                return true;
+            } catch (ServiceConfigurationError sce) {
+                if (sce.getCause() instanceof SecurityException) {
+                    // Ignore the security exception, try the next provider
+                    continue;
+                }
+                throw sce;
+            }
+        }
+    }
+
+    /**
+     * Returns the system-wide default selector provider for this invocation of
+     * the Java virtual machine.
+     *
+     * <p> The first invocation of this method locates the default provider
+     * object as follows: </p>
+     *
+     * <ol>
+     *
+     *   <li><p> If the system property
+     *   <tt>java.nio.channels.spi.SelectorProvider</tt> is defined then it is
+     *   taken to be the fully-qualified name of a concrete provider class.
+     *   The class is loaded and instantiated; if this process fails then an
+     *   unspecified error is thrown.  </p></li>
+     *
+     *   <li><p> If a provider class has been installed in a jar file that is
+     *   visible to the system class loader, and that jar file contains a
+     *   provider-configuration file named
+     *   <tt>java.nio.channels.spi.SelectorProvider</tt> in the resource
+     *   directory <tt>META-INF/services</tt>, then the first class name
+     *   specified in that file is taken.  The class is loaded and
+     *   instantiated; if this process fails then an unspecified error is
+     *   thrown.  </p></li>
+     *
+     *   <li><p> Finally, if no provider has been specified by any of the above
+     *   means then the system-default provider class is instantiated and the
+     *   result is returned.  </p></li>
+     *
+     * </ol>
+     *
+     * <p> Subsequent invocations of this method return the provider that was
+     * returned by the first invocation.  </p>
+     *
+     * @return  The system-wide default selector provider
+     */
+    public static SelectorProvider provider() {
+        synchronized (lock) {
+            if (provider != null)
+                return provider;
+            return (SelectorProvider) AccessController.doPrivileged(
+                new PrivilegedAction() {
+                    public Object run() {
+                            if (loadProviderFromProperty())
+                                return provider;
+                            if (loadProviderAsService())
+                                return provider;
+                            provider = sun.nio.ch.DefaultSelectorProvider.create();
+                            return provider;
+                        }
+                    });
+        }
+    }
+
+    /**
+     * Opens a datagram channel.  </p>
+     *
+     * @return  The new channel
+     */
+//    public abstract DatagramChannel openDatagramChannel()
+  //      throws IOException;
+
+    /**
+     * Opens a pipe.  </p>
+     *
+     * @return  The new pipe
+     */
+//    public abstract Pipe openPipe()
+  //      throws IOException;
+
+    /**
+     * Opens a selector.  </p>
+     *
+     * @return  The new selector
+     */
+    public abstract AbstractSelector openSelector()
+        throws IOException;
+
+    /**
+     * Opens a server-socket channel.  </p>
+     *
+     * @return  The new channel
+     */
+    public abstract ServerSocketChannel openServerSocketChannel()
+        throws IOException;
+
+    /**
+     * Opens a socket channel. </p>
+     *
+     * @return  The new channel
+     */
+    public abstract SocketChannel openSocketChannel()
+        throws IOException;
+
+    /**
+     * Returns the channel inherited from the entity that created this
+     * Java virtual machine.
+     *
+     * <p> On many operating systems a process, such as a Java virtual
+     * machine, can be started in a manner that allows the process to
+     * inherit a channel from the entity that created the process. The
+     * manner in which this is done is system dependent, as are the
+     * possible entities to which the channel may be connected. For example,
+     * on UNIX systems, the Internet services daemon (<i>inetd</i>) is used to
+     * start programs to service requests when a request arrives on an
+     * associated network port. In this example, the process that is started,
+     * inherits a channel representing a network socket.
+     *
+     * <p> In cases where the inherited channel represents a network socket
+     * then the {@link java.nio.channels.Channel Channel} type returned
+     * by this method is determined as follows:
+     *
+     * <ul>
+     *
+     *  <li><p> If the inherited channel represents a stream-oriented connected
+     *  socket then a {@link java.nio.channels.SocketChannel SocketChannel} is
+     *  returned. The socket channel is, at least initially, in blocking
+     *  mode, bound to a socket address, and connected to a peer.
+     *  </p></li>
+     *
+     *  <li><p> If the inherited channel represents a stream-oriented listening
+     *  socket then a {@link java.nio.channels.ServerSocketChannel
+     *  ServerSocketChannel} is returned. The server-socket channel is, at
+     *  least initially, in blocking mode, and bound to a socket address.
+     *  </p></li>
+     *
+     *  <li><p> If the inherited channel is a datagram-oriented socket
+     *  then a {@link java.nio.channels.DatagramChannel DatagramChannel} is
+     *  returned. The datagram channel is, at least initially, in blocking
+     *  mode, and bound to a socket address.
+     *  </p></li>
+     *
+     * </ul>
+     *
+     * <p> In addition to the network-oriented channels described, this method
+     * may return other kinds of channels in the future.
+     *
+     * <p> The first invocation of this method creates the channel that is
+     * returned. Subsequent invocations of this method return the same
+     * channel. </p>
+     *
+     * @return  The inherited channel, if any, otherwise <tt>null</tt>.
+     *
+     * @throws  IOException
+     *          If an I/O error occurs
+     *
+     * @throws  SecurityException
+     *          If a security manager has been installed and it denies
+     *          {@link RuntimePermission}<tt>("inheritedChannel")</tt>
+     *
+     * @since 1.5
+     */
+   public Channel inheritedChannel() throws IOException {
+        return null;
+   }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/UnresolvedAddressException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/UnresolvedAddressException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/UnresolvedAddressException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/UnresolvedAddressException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to invoke a network
+ * operation upon an unresolved socket address.
+ *
+ * @since 1.4
+ */
+
+public class UnresolvedAddressException
+    extends IllegalArgumentException
+{
+
+    private static final long serialVersionUID = 6136959093620794148L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public UnresolvedAddressException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/UnsupportedAddressTypeException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/UnsupportedAddressTypeException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/UnsupportedAddressTypeException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/UnsupportedAddressTypeException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio.channels;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to bind or connect
+ * to a socket address of a type that is not supported.
+ *
+ * @since 1.4
+ */
+
+public class UnsupportedAddressTypeException
+    extends IllegalArgumentException
+{
+
+    private static final long serialVersionUID = -2964323842829700493L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public UnsupportedAddressTypeException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/WritableByteChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/WritableByteChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/channels/WritableByteChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/channels/WritableByteChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2000-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio.channels;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+
+/**
+ * A channel that can write bytes.
+ *
+ * <p> Only one write operation upon a writable channel may be in progress at
+ * any given time.  If one thread initiates a write operation upon a channel
+ * then any other thread that attempts to initiate another write operation will
+ * block until the first operation is complete.  Whether or not other kinds of
+ * I/O operations may proceed concurrently with a write operation depends upon
+ * the type of the channel. </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public interface WritableByteChannel
+    extends Channel
+{
+
+    /**
+     * Writes a sequence of bytes to this channel from the given buffer.
+     *
+     * <p> An attempt is made to write up to <i>r</i> bytes to the channel,
+     * where <i>r</i> is the number of bytes remaining in the buffer, that is,
+     * <tt>src.remaining()</tt>, at the moment this method is invoked.
+     *
+     * <p> Suppose that a byte sequence of length <i>n</i> is written, where
+     * <tt>0</tt>&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
+     * This byte sequence will be transferred from the buffer starting at index
+     * <i>p</i>, where <i>p</i> is the buffer's position at the moment this
+     * method is invoked; the index of the last byte written will be
+     * <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>&nbsp;<tt>-</tt>&nbsp;<tt>1</tt>.
+     * Upon return the buffer's position will be equal to
+     * <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>; its limit will not have changed.
+     *
+     * <p> Unless otherwise specified, a write operation will return only after
+     * writing all of the <i>r</i> requested bytes.  Some types of channels,
+     * depending upon their state, may write only some of the bytes or possibly
+     * none at all.  A socket channel in non-blocking mode, for example, cannot
+     * write any more bytes than are free in the socket's output buffer.
+     *
+     * <p> This method may be invoked at any time.  If another thread has
+     * already initiated a write operation upon this channel, however, then an
+     * invocation of this method will block until the first operation is
+     * complete. </p>
+     *
+     * @param  src
+     *         The buffer from which bytes are to be retrieved
+     *
+     * @return The number of bytes written, possibly zero
+     *
+     * @throws  NonWritableChannelException
+     *          If this channel was not opened for writing
+     *
+     * @throws  ClosedChannelException
+     *          If this channel is closed
+     *
+     * @throws  AsynchronousCloseException
+     *          If another thread closes this channel
+     *          while the write operation is in progress
+     *
+     * @throws  ClosedByInterruptException
+     *          If another thread interrupts the current thread
+     *          while the write operation is in progress, thereby
+     *          closing the channel and setting the current thread's
+     *          interrupt status
+     *
+     * @throws  IOException
+     *          If some other I/O error occurs
+     */
+    public int write(ByteBuffer src) throws IOException;
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/DirectByteBuffer.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/DirectByteBuffer.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/DirectByteBuffer.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/DirectByteBuffer.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,757 @@
+/*
+ * Copyright 2000-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio;
+
+import sun.misc.Cleaner;
+import sun.misc.Unsafe;
+import sun.nio.ch.DirectBuffer;
+import sun.nio.ch.FileChannelImpl;
+
+
+class DirectByteBuffer
+
+    extends MappedByteBuffer
+
+
+
+    implements DirectBuffer
+{
+
+
+
+    // Cached unsafe-access object
+    protected static final Unsafe unsafe = Bits.unsafe();
+
+    // Cached unaligned-access capability
+    protected static final boolean unaligned = Bits.unaligned();
+
+    // Base address, used in all indexing calculations
+    // NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
+    //    protected long address;
+
+    // If this buffer is a view of another buffer then we keep a reference to
+    // that buffer so that its memory isn't freed before we're done with it
+    protected Object viewedBuffer = null;
+
+    public Object viewedBuffer() {
+        return viewedBuffer;
+    }
+
+
+
+    private static class Deallocator
+        implements Runnable
+    {
+
+        private static Unsafe unsafe = Unsafe.getUnsafe();
+
+        private long address;
+        private int capacity;
+
+        private Deallocator(long address, int capacity) {
+            assert (address != 0);
+            this.address = address;
+            this.capacity = capacity;
+        }
+
+        public void run() {
+            if (address == 0) {
+                // Paranoia
+                return;
+            }
+            unsafe.freeMemory(address);
+            address = 0;
+            Bits.unreserveMemory(capacity);
+        }
+
+    }
+
+    private final Cleaner cleaner;
+
+    public Cleaner cleaner() { return cleaner; }
+
+
+
+
+
+
+
+
+
+
+
+    // Primary constructor
+    //
+    DirectByteBuffer(int cap) {                   // package-private
+
+        super(-1, 0, cap, cap, false);
+        Bits.reserveMemory(cap);
+        int ps = Bits.pageSize();
+        long base = 0;
+        try {
+            base = unsafe.allocateMemory(cap + ps);
+        } catch (OutOfMemoryError x) {
+            Bits.unreserveMemory(cap);
+            throw x;
+        }
+        unsafe.setMemory(base, cap + ps, (byte) 0);
+        if (base % ps != 0) {
+            // Round up to page boundary
+            address = base + ps - (base & (ps - 1));
+        } else {
+            address = base;
+        }
+        cleaner = Cleaner.create(this, new Deallocator(base, cap));
+
+
+
+    }
+
+
+
+    // Invoked only by JNI: NewDirectByteBuffer(void*, long)
+    //
+    private DirectByteBuffer(long addr, int cap) {
+        super(-1, 0, cap, cap, false);
+        address = addr;
+        cleaner = null;
+    }
+
+
+
+    // For memory-mapped buffers -- invoked by FileChannelImpl via reflection
+    //
+    protected DirectByteBuffer(int cap, long addr, Runnable unmapper) {
+
+        super(-1, 0, cap, cap, true);
+        address = addr;
+        viewedBuffer = null;
+        cleaner = Cleaner.create(this, unmapper);
+
+
+
+    }
+
+
+
+    // For duplicates and slices
+    //
+    DirectByteBuffer(DirectBuffer db,         // package-private
+                               int mark, int pos, int lim, int cap,
+                               int off)
+    {
+
+        super(mark, pos, lim, cap);
+        address = db.address() + off;
+        viewedBuffer = db;
+
+        cleaner = null;
+
+
+
+
+    }
+
+    public ByteBuffer slice() {
+        int pos = this.position();
+        int lim = this.limit();
+        assert (pos <= lim);
+        int rem = (pos <= lim ? lim - pos : 0);
+        int off = (pos << 0);
+        assert (off >= 0);
+        return new DirectByteBuffer(this, -1, 0, rem, rem, off);
+    }
+
+    public ByteBuffer duplicate() {
+        return new DirectByteBuffer(this,
+                                              this.markValue(),
+                                              this.position(),
+                                              this.limit(),
+                                              this.capacity(),
+                                              0);
+    }
+
+    public ByteBuffer asReadOnlyBuffer() {
+
+        return new DirectByteBufferR(this,
+                                           this.markValue(),
+                                           this.position(),
+                                           this.limit(),
+                                           this.capacity(),
+                                           0);
+
+
+
+    }
+
+
+
+    public long address() {
+        return address;
+    }
+
+    private long ix(int i) {
+        return address + (i << 0);
+    }
+
+    public byte get() {
+        return ((unsafe.getByte(ix(nextGetIndex()))));
+    }
+
+    public byte get(int i) {
+        return ((unsafe.getByte(ix(checkIndex(i)))));
+    }
+
+    public ByteBuffer get(byte[] dst, int offset, int length) {
+
+        if ((length << 0) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
+            checkBounds(offset, length, dst.length);
+            int pos = position();
+            int lim = limit();
+            assert (pos <= lim);
+            int rem = (pos <= lim ? lim - pos : 0);
+            if (length > rem)
+                throw new BufferUnderflowException();
+
+            if (order() != ByteOrder.nativeOrder())
+                Bits.copyToByteArray(ix(pos), dst,
+                                          offset << 0,
+                                          length << 0);
+            else
+                Bits.copyToByteArray(ix(pos), dst,
+                                     offset << 0,
+                                     length << 0);
+            position(pos + length);
+        } else {
+            super.get(dst, offset, length);
+        }
+        return this;
+
+
+
+    }
+
+
+
+    public ByteBuffer put(byte x) {
+
+        unsafe.putByte(ix(nextPutIndex()), ((x)));
+        return this;
+
+
+
+    }
+
+    public ByteBuffer put(int i, byte x) {
+
+        unsafe.putByte(ix(checkIndex(i)), ((x)));
+        return this;
+
+
+
+    }
+
+    public ByteBuffer put(ByteBuffer src) {
+
+        if (src instanceof DirectByteBuffer) {
+            if (src == this)
+                throw new IllegalArgumentException();
+            DirectByteBuffer sb = (DirectByteBuffer)src;
+
+            int spos = sb.position();
+            int slim = sb.limit();
+            assert (spos <= slim);
+            int srem = (spos <= slim ? slim - spos : 0);
+
+            int pos = position();
+            int lim = limit();
+            assert (pos <= lim);
+            int rem = (pos <= lim ? lim - pos : 0);
+
+            if (srem > rem)
+                throw new BufferOverflowException();
+            unsafe.copyMemory(sb.ix(spos), ix(pos), srem << 0);
+            sb.position(spos + srem);
+            position(pos + srem);
+        } else if (src.hb != null) {
+
+            int spos = src.position();
+            int slim = src.limit();
+            assert (spos <= slim);
+            int srem = (spos <= slim ? slim - spos : 0);
+
+            put(src.hb, src.offset + spos, srem);
+            src.position(spos + srem);
+
+        } else {
+            super.put(src);
+        }
+        return this;
+
+
+
+    }
+
+    public ByteBuffer put(byte[] src, int offset, int length) {
+
+        if ((length << 0) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
+            checkBounds(offset, length, src.length);
+            int pos = position();
+            int lim = limit();
+            assert (pos <= lim);
+            int rem = (pos <= lim ? lim - pos : 0);
+            if (length > rem)
+                throw new BufferOverflowException();
+
+            if (order() != ByteOrder.nativeOrder())
+                Bits.copyFromByteArray(src, offset << 0,
+                                            ix(pos), length << 0);
+            else
+                Bits.copyFromByteArray(src, offset << 0,
+                                       ix(pos), length << 0);
+            position(pos + length);
+        } else {
+            super.put(src, offset, length);
+        }
+        return this;
+
+
+
+    }
+
+    public ByteBuffer compact() {
+
+        int pos = position();
+        int lim = limit();
+        assert (pos <= lim);
+        int rem = (pos <= lim ? lim - pos : 0);
+
+        unsafe.copyMemory(ix(pos), ix(0), rem << 0);
+        position(rem);
+        limit(capacity());
+        return this;
+
+
+
+    }
+
+    public boolean isDirect() {
+        return true;
+    }
+
+    public boolean isReadOnly() {
+        return false;
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    byte _get(int i) {                          // package-private
+        return unsafe.getByte(address + i);
+    }
+
+    void _put(int i, byte b) {                  // package-private
+
+        unsafe.putByte(address + i, b);
+
+
+
+    }
+
+
+
+
+    private char getChar(long a) {
+        if (unaligned) {
+            char x = unsafe.getChar(a);
+            return (nativeByteOrder ? x : Bits.swap(x));
+        }
+        return Bits.getChar(a, bigEndian);
+    }
+
+    public char getChar() {
+        return getChar(ix(nextGetIndex((1 << 1))));
+    }
+
+    public char getChar(int i) {
+        return getChar(ix(checkIndex(i, (1 << 1))));
+    }
+
+
+
+    private ByteBuffer putChar(long a, char x) {
+
+        if (unaligned) {
+            char y = (x);
+            unsafe.putChar(a, (nativeByteOrder ? y : Bits.swap(y)));
+        } else {
+            Bits.putChar(a, x, bigEndian);
+        }
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putChar(char x) {
+
+        putChar(ix(nextPutIndex((1 << 1))), x);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putChar(int i, char x) {
+
+        putChar(ix(checkIndex(i, (1 << 1))), x);
+        return this;
+
+
+
+    }
+
+
+
+    private short getShort(long a) {
+        if (unaligned) {
+            short x = unsafe.getShort(a);
+            return (nativeByteOrder ? x : Bits.swap(x));
+        }
+        return Bits.getShort(a, bigEndian);
+    }
+
+    public short getShort() {
+        return getShort(ix(nextGetIndex((1 << 1))));
+    }
+
+    public short getShort(int i) {
+        return getShort(ix(checkIndex(i, (1 << 1))));
+    }
+
+
+
+    private ByteBuffer putShort(long a, short x) {
+
+        if (unaligned) {
+            short y = (x);
+            unsafe.putShort(a, (nativeByteOrder ? y : Bits.swap(y)));
+        } else {
+            Bits.putShort(a, x, bigEndian);
+        }
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putShort(short x) {
+
+        putShort(ix(nextPutIndex((1 << 1))), x);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putShort(int i, short x) {
+
+        putShort(ix(checkIndex(i, (1 << 1))), x);
+        return this;
+
+
+
+    }
+
+
+
+
+    private int getInt(long a) {
+        if (unaligned) {
+            int x = unsafe.getInt(a);
+            return (nativeByteOrder ? x : Bits.swap(x));
+        }
+        return Bits.getInt(a, bigEndian);
+    }
+
+    public int getInt() {
+        return getInt(ix(nextGetIndex((1 << 2))));
+    }
+
+    public int getInt(int i) {
+        return getInt(ix(checkIndex(i, (1 << 2))));
+    }
+
+
+
+    private ByteBuffer putInt(long a, int x) {
+
+        if (unaligned) {
+            int y = (x);
+            unsafe.putInt(a, (nativeByteOrder ? y : Bits.swap(y)));
+        } else {
+            Bits.putInt(a, x, bigEndian);
+        }
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putInt(int x) {
+
+        putInt(ix(nextPutIndex((1 << 2))), x);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putInt(int i, int x) {
+
+        putInt(ix(checkIndex(i, (1 << 2))), x);
+        return this;
+
+
+
+    }
+
+
+
+    private long getLong(long a) {
+        if (unaligned) {
+            long x = unsafe.getLong(a);
+            return (nativeByteOrder ? x : Bits.swap(x));
+        }
+        return Bits.getLong(a, bigEndian);
+    }
+
+    public long getLong() {
+        return getLong(ix(nextGetIndex((1 << 3))));
+    }
+
+    public long getLong(int i) {
+        return getLong(ix(checkIndex(i, (1 << 3))));
+    }
+
+
+
+    private ByteBuffer putLong(long a, long x) {
+
+        if (unaligned) {
+            long y = (x);
+            unsafe.putLong(a, (nativeByteOrder ? y : Bits.swap(y)));
+        } else {
+            Bits.putLong(a, x, bigEndian);
+        }
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putLong(long x) {
+
+        putLong(ix(nextPutIndex((1 << 3))), x);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putLong(int i, long x) {
+
+        putLong(ix(checkIndex(i, (1 << 3))), x);
+        return this;
+
+
+
+    }
+
+
+    private float getFloat(long a) {
+        if (unaligned) {
+            int x = unsafe.getInt(a);
+            return Float.intBitsToFloat(nativeByteOrder ? x : Bits.swap(x));
+        }
+        return Bits.getFloat(a, bigEndian);
+    }
+
+    public float getFloat() {
+        return getFloat(ix(nextGetIndex((1 << 2))));
+    }
+
+    public float getFloat(int i) {
+        return getFloat(ix(checkIndex(i, (1 << 2))));
+    }
+
+
+
+    private ByteBuffer putFloat(long a, float x) {
+
+        if (unaligned) {
+            int y = Float.floatToRawIntBits(x);
+            unsafe.putInt(a, (nativeByteOrder ? y : Bits.swap(y)));
+        } else {
+            Bits.putFloat(a, x, bigEndian);
+        }
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putFloat(float x) {
+
+        putFloat(ix(nextPutIndex((1 << 2))), x);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putFloat(int i, float x) {
+
+        putFloat(ix(checkIndex(i, (1 << 2))), x);
+        return this;
+
+
+
+    }
+
+
+    private double getDouble(long a) {
+        if (unaligned) {
+            long x = unsafe.getLong(a);
+            return Double.longBitsToDouble(nativeByteOrder ? x : Bits.swap(x));
+        }
+        return Bits.getDouble(a, bigEndian);
+    }
+
+    public double getDouble() {
+        return getDouble(ix(nextGetIndex((1 << 3))));
+    }
+
+    public double getDouble(int i) {
+        return getDouble(ix(checkIndex(i, (1 << 3))));
+    }
+
+
+
+    private ByteBuffer putDouble(long a, double x) {
+
+        if (unaligned) {
+            long y = Double.doubleToRawLongBits(x);
+            unsafe.putLong(a, (nativeByteOrder ? y : Bits.swap(y)));
+        } else {
+            Bits.putDouble(a, x, bigEndian);
+        }
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putDouble(double x) {
+
+        putDouble(ix(nextPutIndex((1 << 3))), x);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putDouble(int i, double x) {
+
+        putDouble(ix(checkIndex(i, (1 << 3))), x);
+        return this;
+
+
+
+    }
+
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/DirectByteBufferR.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/DirectByteBufferR.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/DirectByteBufferR.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/DirectByteBufferR.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,741 @@
+/*
+ * Copyright 2000-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio;
+
+import sun.misc.Cleaner;
+import sun.misc.Unsafe;
+import sun.nio.ch.DirectBuffer;
+import sun.nio.ch.FileChannelImpl;
+
+
+class DirectByteBufferR
+
+
+
+    extends DirectByteBuffer
+
+    implements DirectBuffer
+{
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    // Primary constructor
+    //
+    DirectByteBufferR(int cap) {                   // package-private
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+        super(cap);
+
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+    // For memory-mapped buffers -- invoked by FileChannelImpl via reflection
+    //
+    protected DirectByteBufferR(int cap, long addr, Runnable unmapper) {
+
+
+
+
+
+
+        super(cap, addr, unmapper);
+
+    }
+
+
+
+    // For duplicates and slices
+    //
+    DirectByteBufferR(DirectBuffer db,         // package-private
+                               int mark, int pos, int lim, int cap,
+                               int off)
+    {
+
+
+
+
+
+
+
+
+        super(db, mark, pos, lim, cap, off);
+
+    }
+
+    public ByteBuffer slice() {
+        int pos = this.position();
+        int lim = this.limit();
+        assert (pos <= lim);
+        int rem = (pos <= lim ? lim - pos : 0);
+        int off = (pos << 0);
+        assert (off >= 0);
+        return new DirectByteBufferR(this, -1, 0, rem, rem, off);
+    }
+
+    public ByteBuffer duplicate() {
+        return new DirectByteBufferR(this,
+                                              this.markValue(),
+                                              this.position(),
+                                              this.limit(),
+                                              this.capacity(),
+                                              0);
+    }
+
+    public ByteBuffer asReadOnlyBuffer() {
+
+
+
+
+
+
+
+
+        return duplicate();
+
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    public ByteBuffer put(byte x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer put(int i, byte x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer put(ByteBuffer src) {
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer put(byte[] src, int offset, int length) {
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer compact() {
+
+
+
+
+
+
+
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public boolean isDirect() {
+        return true;
+    }
+
+    public boolean isReadOnly() {
+        return true;
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    byte _get(int i) {                          // package-private
+        return unsafe.getByte(address + i);
+    }
+
+    void _put(int i, byte b) {                  // package-private
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    private ByteBuffer putChar(long a, char x) {
+
+
+
+
+
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putChar(char x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putChar(int i, char x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    private ByteBuffer putShort(long a, short x) {
+
+
+
+
+
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putShort(short x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putShort(int i, short x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    private ByteBuffer putInt(long a, int x) {
+
+
+
+
+
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putInt(int x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putInt(int i, int x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    private ByteBuffer putLong(long a, long x) {
+
+
+
+
+
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putLong(long x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putLong(int i, long x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    private ByteBuffer putFloat(long a, float x) {
+
+
+
+
+
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putFloat(float x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putFloat(int i, float x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    private ByteBuffer putDouble(long a, double x) {
+
+
+
+
+
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putDouble(double x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putDouble(int i, double x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/exceptions phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/exceptions
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/exceptions	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/exceptions	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,60 @@
+#
+# Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Sun designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Sun in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+# CA 95054 USA or visit www.sun.com if you need additional information or
+# have any questions.
+#
+
+# Generated exception classes for java.nio
+
+SINCE=1.4
+PACKAGE=java.nio
+# This year should only change if the generated source is modified.
+COPYRIGHT_YEARS=2000-2007
+
+
+SUPER=RuntimeException
+
+gen BufferOverflowException "
+ * Unchecked exception thrown when a relative <i>put</i> operation reaches
+ * the target buffer's limit." \
+ -5484897634319144535L
+
+gen BufferUnderflowException "
+ * Unchecked exception thrown when a relative <i>get</i> operation reaches
+ * the source buffer's limit." \
+ -1713313658691622206L
+
+
+SUPER=IllegalStateException
+
+gen InvalidMarkException "
+ * Unchecked exception thrown when an attempt is made to reset a buffer
+ * when its mark is not defined." \
+ 1698329710438510774L
+
+
+SUPER=UnsupportedOperationException
+
+gen ReadOnlyBufferException "
+ * Unchecked exception thrown when a content-mutation method such as
+ * <tt>put</tt> or <tt>compact</tt> is invoked upon a read-only buffer." \
+ -1210063976496234090L
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/HeapByteBuffer.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/HeapByteBuffer.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/HeapByteBuffer.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/HeapByteBuffer.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,482 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio;
+
+
+/**
+
+ * A read/write HeapByteBuffer.
+
+
+
+
+
+
+ */
+
+class HeapByteBuffer
+    extends ByteBuffer
+{
+
+    // For speed these fields are actually declared in X-Buffer;
+    // these declarations are here as documentation
+    /*
+
+    protected final byte[] hb;
+    protected final int offset;
+
+    */
+
+    HeapByteBuffer(int cap, int lim) {            // package-private
+
+        super(-1, 0, lim, cap, new byte[cap], 0);
+        /*
+        hb = new byte[cap];
+        offset = 0;
+        */
+
+
+
+
+    }
+
+    HeapByteBuffer(byte[] buf, int off, int len) { // package-private
+
+        super(-1, off, off + len, buf.length, buf, 0);
+        /*
+        hb = buf;
+        offset = 0;
+        */
+
+
+
+
+    }
+
+    protected HeapByteBuffer(byte[] buf,
+                                   int mark, int pos, int lim, int cap,
+                                   int off)
+    {
+
+        super(mark, pos, lim, cap, buf, off);
+        /*
+        hb = buf;
+        offset = off;
+        */
+
+
+
+
+    }
+
+    public ByteBuffer slice() {
+        return new HeapByteBuffer(hb,
+                                        -1,
+                                        0,
+                                        this.remaining(),
+                                        this.remaining(),
+                                        this.position() + offset);
+    }
+
+    public ByteBuffer duplicate() {
+        return new HeapByteBuffer(hb,
+                                        this.markValue(),
+                                        this.position(),
+                                        this.limit(),
+                                        this.capacity(),
+                                        offset);
+    }
+
+    public ByteBuffer asReadOnlyBuffer() {
+
+        return new HeapByteBufferR(hb,
+                                     this.markValue(),
+                                     this.position(),
+                                     this.limit(),
+                                     this.capacity(),
+                                     offset);
+
+
+
+    }
+
+
+
+    protected int ix(int i) {
+        return i + offset;
+    }
+
+    public byte get() {
+        return hb[ix(nextGetIndex())];
+    }
+
+    public byte get(int i) {
+        return hb[ix(checkIndex(i))];
+    }
+
+    public ByteBuffer get(byte[] dst, int offset, int length) {
+        checkBounds(offset, length, dst.length);
+        if (length > remaining())
+            throw new BufferUnderflowException();
+        System.arraycopy(hb, ix(position()), dst, offset, length);
+        position(position() + length);
+        return this;
+    }
+
+    public boolean isDirect() {
+        return false;
+    }
+
+
+
+    public boolean isReadOnly() {
+        return false;
+    }
+
+    public ByteBuffer put(byte x) {
+
+        hb[ix(nextPutIndex())] = x;
+        return this;
+
+
+
+    }
+
+    public ByteBuffer put(int i, byte x) {
+
+        hb[ix(checkIndex(i))] = x;
+        return this;
+
+
+
+    }
+
+    public ByteBuffer put(byte[] src, int offset, int length) {
+
+        checkBounds(offset, length, src.length);
+        if (length > remaining())
+            throw new BufferOverflowException();
+        System.arraycopy(src, offset, hb, ix(position()), length);
+        position(position() + length);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer put(ByteBuffer src) {
+
+        if (src instanceof HeapByteBuffer) {
+            if (src == this)
+                throw new IllegalArgumentException();
+            HeapByteBuffer sb = (HeapByteBuffer)src;
+            int n = sb.remaining();
+            if (n > remaining())
+                throw new BufferOverflowException();
+            System.arraycopy(sb.hb, sb.ix(sb.position()),
+                             hb, ix(position()), n);
+            sb.position(sb.position() + n);
+            position(position() + n);
+        } else if (src.isDirect()) {
+            int n = src.remaining();
+            if (n > remaining())
+                throw new BufferOverflowException();
+            src.get(hb, ix(position()), n);
+            position(position() + n);
+        } else {
+            super.put(src);
+        }
+        return this;
+
+
+
+    }
+
+    public ByteBuffer compact() {
+
+        System.arraycopy(hb, ix(position()), hb, ix(0), remaining());
+        position(remaining());
+        limit(capacity());
+        return this;
+
+
+
+    }
+
+
+
+
+
+    byte _get(int i) {                          // package-private
+        return hb[i];
+    }
+
+    void _put(int i, byte b) {                  // package-private
+
+        hb[i] = b;
+
+
+
+    }
+
+    // char
+
+
+
+    public char getChar() {
+        return Bits.getChar(this, ix(nextGetIndex(2)), bigEndian);
+    }
+
+    public char getChar(int i) {
+        return Bits.getChar(this, ix(checkIndex(i, 2)), bigEndian);
+    }
+
+
+
+    public ByteBuffer putChar(char x) {
+
+        Bits.putChar(this, ix(nextPutIndex(2)), x, bigEndian);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putChar(int i, char x) {
+
+        Bits.putChar(this, ix(checkIndex(i, 2)), x, bigEndian);
+        return this;
+
+
+
+    }
+
+
+    // short
+
+
+
+    public short getShort() {
+        return Bits.getShort(this, ix(nextGetIndex(2)), bigEndian);
+    }
+
+    public short getShort(int i) {
+        return Bits.getShort(this, ix(checkIndex(i, 2)), bigEndian);
+    }
+
+
+
+    public ByteBuffer putShort(short x) {
+
+        Bits.putShort(this, ix(nextPutIndex(2)), x, bigEndian);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putShort(int i, short x) {
+
+        Bits.putShort(this, ix(checkIndex(i, 2)), x, bigEndian);
+        return this;
+
+
+
+    }
+
+
+    // int
+
+
+
+    public int getInt() {
+        return Bits.getInt(this, ix(nextGetIndex(4)), bigEndian);
+    }
+
+    public int getInt(int i) {
+        return Bits.getInt(this, ix(checkIndex(i, 4)), bigEndian);
+    }
+
+
+
+    public ByteBuffer putInt(int x) {
+
+        Bits.putInt(this, ix(nextPutIndex(4)), x, bigEndian);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putInt(int i, int x) {
+
+        Bits.putInt(this, ix(checkIndex(i, 4)), x, bigEndian);
+        return this;
+
+
+
+    }
+
+    // long
+
+
+
+    public long getLong() {
+        return Bits.getLong(this, ix(nextGetIndex(8)), bigEndian);
+    }
+
+    public long getLong(int i) {
+        return Bits.getLong(this, ix(checkIndex(i, 8)), bigEndian);
+    }
+
+
+
+    public ByteBuffer putLong(long x) {
+
+        Bits.putLong(this, ix(nextPutIndex(8)), x, bigEndian);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putLong(int i, long x) {
+
+        Bits.putLong(this, ix(checkIndex(i, 8)), x, bigEndian);
+        return this;
+
+
+
+    }
+
+
+    // float
+
+
+
+    public float getFloat() {
+        return Bits.getFloat(this, ix(nextGetIndex(4)), bigEndian);
+    }
+
+    public float getFloat(int i) {
+        return Bits.getFloat(this, ix(checkIndex(i, 4)), bigEndian);
+    }
+
+
+
+    public ByteBuffer putFloat(float x) {
+
+        Bits.putFloat(this, ix(nextPutIndex(4)), x, bigEndian);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putFloat(int i, float x) {
+
+        Bits.putFloat(this, ix(checkIndex(i, 4)), x, bigEndian);
+        return this;
+
+
+
+    }
+
+
+
+    // double
+
+
+
+    public double getDouble() {
+        return Bits.getDouble(this, ix(nextGetIndex(8)), bigEndian);
+    }
+
+    public double getDouble(int i) {
+        return Bits.getDouble(this, ix(checkIndex(i, 8)), bigEndian);
+    }
+
+
+
+    public ByteBuffer putDouble(double x) {
+
+        Bits.putDouble(this, ix(nextPutIndex(8)), x, bigEndian);
+        return this;
+
+
+
+    }
+
+    public ByteBuffer putDouble(int i, double x) {
+
+        Bits.putDouble(this, ix(checkIndex(i, 8)), x, bigEndian);
+        return this;
+
+
+
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/HeapByteBufferR.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/HeapByteBufferR.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/HeapByteBufferR.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/HeapByteBufferR.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,476 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio;
+
+
+/**
+
+
+
+ * A read-only HeapByteBuffer.  This class extends the corresponding
+ * read/write class, overriding the mutation methods to throw a {@link
+ * ReadOnlyBufferException} and overriding the view-buffer methods to return an
+ * instance of this class rather than of the superclass.
+
+ */
+
+class HeapByteBufferR
+    extends HeapByteBuffer
+{
+
+    // For speed these fields are actually declared in X-Buffer;
+    // these declarations are here as documentation
+    /*
+
+
+
+
+    */
+
+    HeapByteBufferR(int cap, int lim) {            // package-private
+
+
+
+
+
+
+
+        super(cap, lim);
+        this.isReadOnly = true;
+
+    }
+
+    HeapByteBufferR(byte[] buf, int off, int len) { // package-private
+
+
+
+
+
+
+
+        super(buf, off, len);
+        this.isReadOnly = true;
+
+    }
+
+    protected HeapByteBufferR(byte[] buf,
+                                   int mark, int pos, int lim, int cap,
+                                   int off)
+    {
+
+
+
+
+
+
+
+        super(buf, mark, pos, lim, cap, off);
+        this.isReadOnly = true;
+
+    }
+
+    public ByteBuffer slice() {
+        return new HeapByteBufferR(hb,
+                                        -1,
+                                        0,
+                                        this.remaining(),
+                                        this.remaining(),
+                                        this.position() + offset);
+    }
+
+    public ByteBuffer duplicate() {
+        return new HeapByteBufferR(hb,
+                                        this.markValue(),
+                                        this.position(),
+                                        this.limit(),
+                                        this.capacity(),
+                                        offset);
+    }
+
+    public ByteBuffer asReadOnlyBuffer() {
+
+
+
+
+
+
+
+
+        return duplicate();
+
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    public boolean isReadOnly() {
+        return true;
+    }
+
+    public ByteBuffer put(byte x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer put(int i, byte x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer put(byte[] src, int offset, int length) {
+
+
+
+
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer put(ByteBuffer src) {
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer compact() {
+
+
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+
+
+
+
+    byte _get(int i) {                          // package-private
+        return hb[i];
+    }
+
+    void _put(int i, byte b) {                  // package-private
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    // char
+
+
+
+
+
+
+
+
+
+
+
+
+
+    public ByteBuffer putChar(char x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putChar(int i, char x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+
+    // short
+
+
+
+
+
+
+
+
+
+
+
+
+
+    public ByteBuffer putShort(short x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putShort(int i, short x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    // int
+
+
+
+
+
+
+
+
+
+
+
+
+
+    public ByteBuffer putInt(int x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putInt(int i, int x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    // long
+
+
+
+
+
+
+
+
+
+
+
+
+
+    public ByteBuffer putLong(long x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putLong(int i, long x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    // float
+
+
+
+
+
+
+
+
+
+
+
+
+
+    public ByteBuffer putFloat(float x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putFloat(int i, float x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    // double
+
+
+
+
+
+
+
+
+
+
+
+
+
+    public ByteBuffer putDouble(double x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+    public ByteBuffer putDouble(int i, double x) {
+
+
+
+
+        throw new ReadOnlyBufferException();
+
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/InvalidMarkException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/InvalidMarkException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/InvalidMarkException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/InvalidMarkException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to reset a buffer
+ * when its mark is not defined.
+ *
+ * @since 1.4
+ */
+
+public class InvalidMarkException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = 1698329710438510774L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public InvalidMarkException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/MappedByteBuffer.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/MappedByteBuffer.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/MappedByteBuffer.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/MappedByteBuffer.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2000-2003 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.nio;
+
+
+/**
+ * A direct byte buffer whose content is a memory-mapped region of a file.
+ *
+ * <p> Mapped byte buffers are created via the {@link
+ * java.nio.channels.FileChannel#map FileChannel.map} method.  This class
+ * extends the {@link ByteBuffer} class with operations that are specific to
+ * memory-mapped file regions.
+ *
+ * <p> A mapped byte buffer and the file mapping that it represents remain
+ * valid until the buffer itself is garbage-collected.
+ *
+ * <p> The content of a mapped byte buffer can change at any time, for example
+ * if the content of the corresponding region of the mapped file is changed by
+ * this program or another.  Whether or not such changes occur, and when they
+ * occur, is operating-system dependent and therefore unspecified.
+ *
+ * <a name="inaccess"><p> All or part of a mapped byte buffer may become
+ * inaccessible at any time, for example if the mapped file is truncated.  An
+ * attempt to access an inaccessible region of a mapped byte buffer will not
+ * change the buffer's content and will cause an unspecified exception to be
+ * thrown either at the time of the access or at some later time.  It is
+ * therefore strongly recommended that appropriate precautions be taken to
+ * avoid the manipulation of a mapped file by this program, or by a
+ * concurrently running program, except to read or write the file's content.
+ *
+ * <p> Mapped byte buffers otherwise behave no differently than ordinary direct
+ * byte buffers. </p>
+ *
+ *
+ * @author Mark Reinhold
+ * @author JSR-51 Expert Group
+ * @since 1.4
+ */
+
+public abstract class MappedByteBuffer
+    extends ByteBuffer
+{
+
+    // This is a little bit backwards: By rights MappedByteBuffer should be a
+    // subclass of DirectByteBuffer, but to keep the spec clear and simple, and
+    // for optimization purposes, it's easier to do it the other way around.
+    // This works because DirectByteBuffer is a package-private class.
+
+    // Volatile to make sure that the finalization thread sees the current
+    // value of this so that a region is not accidentally unmapped again later.
+    volatile boolean isAMappedBuffer;                   // package-private
+
+    // This should only be invoked by the DirectByteBuffer constructors
+    //
+    MappedByteBuffer(int mark, int pos, int lim, int cap, // package-private
+                     boolean mapped)
+    {
+        super(mark, pos, lim, cap);
+        isAMappedBuffer = mapped;
+    }
+
+    MappedByteBuffer(int mark, int pos, int lim, int cap) { // package-private
+        super(mark, pos, lim, cap);
+        isAMappedBuffer = false;
+    }
+
+    private void checkMapped() {
+        if (!isAMappedBuffer)
+            // Can only happen if a luser explicitly casts a direct byte buffer
+            throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Tells whether or not this buffer's content is resident in physical
+     * memory.
+     *
+     * <p> A return value of <tt>true</tt> implies that it is highly likely
+     * that all of the data in this buffer is resident in physical memory and
+     * may therefore be accessed without incurring any virtual-memory page
+     * faults or I/O operations.  A return value of <tt>false</tt> does not
+     * necessarily imply that the buffer's content is not resident in physical
+     * memory.
+     *
+     * <p> The returned value is a hint, rather than a guarantee, because the
+     * underlying operating system may have paged out some of the buffer's data
+     * by the time that an invocation of this method returns.  </p>
+     *
+     * @return  <tt>true</tt> if it is likely that this buffer's content
+     *          is resident in physical memory
+     */
+    public final boolean isLoaded() {
+        checkMapped();
+        if ((address == 0) || (capacity() == 0))
+            return true;
+        return isLoaded0(((DirectByteBuffer)this).address(), capacity());
+    }
+
+    /**
+     * Loads this buffer's content into physical memory.
+     *
+     * <p> This method makes a best effort to ensure that, when it returns,
+     * this buffer's content is resident in physical memory.  Invoking this
+     * method may cause some number of page faults and I/O operations to
+     * occur. </p>
+     *
+     * @return  This buffer
+     */
+    public final MappedByteBuffer load() {
+        checkMapped();
+        if ((address == 0) || (capacity() == 0))
+            return this;
+        load0(((DirectByteBuffer)this).address(), capacity(), Bits.pageSize());
+        return this;
+    }
+
+    /**
+     * Forces any changes made to this buffer's content to be written to the
+     * storage device containing the mapped file.
+     *
+     * <p> If the file mapped into this buffer resides on a local storage
+     * device then when this method returns it is guaranteed that all changes
+     * made to the buffer since it was created, or since this method was last
+     * invoked, will have been written to that device.
+     *
+     * <p> If the file does not reside on a local device then no such guarantee
+     * is made.
+     *
+     * <p> If this buffer was not mapped in read/write mode ({@link
+     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then invoking this
+     * method has no effect. </p>
+     *
+     * @return  This buffer
+     */
+    public final MappedByteBuffer force() {
+        checkMapped();
+        if ((address == 0) || (capacity() == 0))
+            return this;
+        force0(((DirectByteBuffer)this).address(), capacity());
+        return this;
+    }
+
+    private native boolean isLoaded0(long address, long length);
+    private native int load0(long address, long length, int pageSize);
+    private native void force0(long address, long length);
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/package.html phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/package.html
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/package.html	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/package.html	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,139 @@
+<!--
+ Copyright 2000-2004 Sun Microsystems, Inc.  All Rights Reserved.
+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+
+ This code is free software; you can redistribute it and/or modify it
+ under the terms of the GNU General Public License version 2 only, as
+ published by the Free Software Foundation.  Sun designates this
+ particular file as subject to the "Classpath" exception as provided
+ by Sun in the LICENSE file that accompanied this code.
+
+ This code is distributed in the hope that it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ version 2 for more details (a copy is included in the LICENSE file that
+ accompanied this code).
+
+ You should have received a copy of the GNU General Public License version
+ 2 along with this work; if not, write to the Free Software Foundation,
+ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+
+ Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ CA 95054 USA or visit www.sun.com if you need additional information or
+ have any questions.
+-->
+
+<!doctype html public "-//IETF//DTD HTML//EN">
+<html>
+<body bgcolor="white">
+
+Defines buffers, which are containers for data, and provides an overview of the
+other NIO packages.
+
+
+<p> The central abstractions of the NIO APIs are: </p>
+
+<ul>
+
+  <li><p> <a href="#buffers"><i>Buffers</i></a>, which are containers for data;
+  </p></li>
+
+  <li><p> <a href="charset/package-summary.html"><i>Charsets</i></a> and their
+  associated <i>decoders</i> and <i>encoders</i>, <br> which translate between
+  bytes and Unicode characters; </p></li>
+
+  <li><p> <a href="channels/package-summary.html"><i>Channels</i></a> of
+  various types, which represent connections <br> to entities capable of
+  performing I/O operations; and </p></li>
+
+  <li><p> <i>Selectors</i> and <i>selection keys</i>, which together with <br>
+  <i>selectable channels</i> define a <a
+  href="channels/package-summary.html#multiplex">multiplexed, non-blocking <br>
+  I/O</a>&nbsp;facility.  </p></li>
+
+</ul>
+
+<p> The <tt>java.nio</tt> package defines the buffer classes, which are used
+throughout the NIO APIs.  The charset API is defined in the {@link
+java.nio.charset} package, and the channel and selector APIs are defined in the
+{@link java.nio.channels} package.  Each of these subpackages has its own
+service-provider (SPI) subpackage, the contents of which can be used to extend
+the platform's default implementations or to construct alternative
+implementations.
+
+
+<a name="buffers">
+
+<blockquote><table cellspacing=1 cellpadding=0 summary="Description of the various buffers">
+  <tr><th><p align="left">Buffers</p></th><th><p align="left">Description</p></th></tr> 
+  <tr><td valign=top><tt>{@link java.nio.Buffer}</tt></td>
+      <td>Position, limit, and capacity;
+          <br>clear, flip, rewind, and mark/reset</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;{@link java.nio.ByteBuffer}</tt></td>
+      <td>Get/put, compact, views; allocate,&nbsp;wrap</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;&nbsp;&nbsp;{@link java.nio.MappedByteBuffer}&nbsp;&nbsp;</tt></td>
+      <td>A byte buffer mapped to a file</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;{@link java.nio.CharBuffer}</tt></td>
+      <td>Get/put, compact; allocate,&nbsp;wrap</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;{@link java.nio.DoubleBuffer}</tt></td>
+      <td>&nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;'</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;{@link java.nio.FloatBuffer}</tt></td>
+      <td>&nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;'</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;{@link java.nio.IntBuffer}</tt></td>
+      <td>&nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;'</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;{@link java.nio.LongBuffer}</tt></td>
+      <td>&nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;'</td></tr>
+  <tr><td valign=top><tt>&nbsp;&nbsp;{@link java.nio.ShortBuffer}</tt></td>
+      <td>&nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;'</td></tr>
+  <tr><td valign=top><tt>{@link java.nio.ByteOrder}</tt></td>
+      <td>Typesafe enumeration for&nbsp;byte&nbsp;orders</td></tr>
+</table></blockquote>
+
+<p> A <i>buffer</i> is a container for a fixed amount of data of a specific
+primitive type.  In addition to its content a buffer has a <i>position</i>,
+which is the index of the next element to be read or written, and a
+<i>limit</i>, which is the index of the first element that should not be read
+or written.  The base {@link java.nio.Buffer} class defines these properties as
+well as methods for <i>clearing</i>, <i>flipping</i>, and <i>rewinding</i>, for
+<i>marking</i> the current position, and for <i>resetting</i> the position to
+the previous mark.
+
+<p> There is a buffer class for each non-boolean primitive type.  Each class
+defines a family of <i>get</i> and <i>put</i> methods for moving data out of
+and in to a buffer, methods for <i>compacting</i>, <i>duplicating</i>, and
+<i>slicing</i> a buffer, and static methods for <i>allocating</i> a new buffer
+as well as for <i>wrapping</i> an existing array into a buffer.
+
+<p> Byte buffers are distinguished in that they can be used as the sources and
+targets of I/O operations.  They also support several features not found in the
+other buffer classes:
+
+<ul>
+
+  <li><p> A byte buffer can be allocated as a <a href="ByteBuffer.html#direct">
+  <i>direct</i></a> buffer, in which case the Java virtual machine will make a
+  best effort to perform native I/O operations directly upon it.  </p></li>
+
+  <li><p> A byte buffer can be created by {@link
+  java.nio.channels.FileChannel#map </code><i>mapping</i><code>} a region of a
+  file directly into memory, in which case a few additional file-related
+  operations defined in the {@link java.nio.MappedByteBuffer} class are
+  available.  </p></li>
+
+  <li><p> A byte buffer provides access to its content as either a heterogeneous
+  or homogeneous sequence of <a href="ByteBuffer.html#bin">binary data</i></a>
+  of any non-boolean primitive type, in either big-endian or little-endian <a
+  href="ByteOrder.html">byte order</a>.  </p></li>
+
+</ul>
+
+<p> Unless otherwise noted, passing a <tt>null</tt> argument to a constructor
+or method in any class or interface in this package will cause a {@link
+java.lang.NullPointerException NullPointerException} to be thrown.
+
+@since 1.4
+@author Mark Reinhold
+@author JSR-51 Expert Group
+
+</body>
+</html>
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/ReadOnlyBufferException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/ReadOnlyBufferException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/nio/ReadOnlyBufferException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/nio/ReadOnlyBufferException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package java.nio;
+
+
+/**
+ * Unchecked exception thrown when a content-mutation method such as
+ * <tt>put</tt> or <tt>compact</tt> is invoked upon a read-only buffer.
+ *
+ * @since 1.4
+ */
+
+public class ReadOnlyBufferException
+    extends UnsupportedOperationException
+{
+
+    private static final long serialVersionUID = -1210063976496234090L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public ReadOnlyBufferException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/util/ServiceConfigurationError.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/util/ServiceConfigurationError.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/util/ServiceConfigurationError.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/util/ServiceConfigurationError.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,70 @@
+/*
+ * @(#)ServiceConfigurationError.java	1.5 06/04/10
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package java.util;
+
+
+/**
+ * Error thrown when something goes wrong while loading a service provider.
+ * 
+ * <p> This error will be thrown in the following situations:
+ *
+ * <ul>
+ *
+ *   <li> The format of a provider-configuration file violates the <a
+ *   href="ServiceLoader.html#format">specification</a>; </li>
+ *
+ *   <li> An {@link java.io.IOException IOException} occurs while reading a
+ *   provider-configuration file; </li>
+ *
+ *   <li> A concrete provider class named in a provider-configuration file
+ *   cannot be found; </li>
+ *
+ *   <li> A concrete provider class is not a subclass of the service class;
+ *   </li>
+ *
+ *   <li> A concrete provider class cannot be instantiated; or
+ *
+ *   <li> Some other kind of error occurs. </li>
+ *
+ * </ul>
+ *
+ *
+ * @author Mark Reinhold
+ * @version 1.5, 06/04/10
+ * @since 1.6
+ */
+
+public class ServiceConfigurationError
+    extends Error
+{
+
+    private static final long serialVersionUID = 74132770414881L;
+
+    /**
+     * Constructs a new instance with the specified message.
+     *
+     * @param  msg  The message, or <tt>null</tt> if there is no message
+     *
+     */
+    public ServiceConfigurationError(String msg) {
+	super(msg);
+    }
+
+    /**
+     * Constructs a new instance with the specified message and cause.
+     *
+     * @param  msg  The message, or <tt>null</tt> if there is no message
+     *
+     * @param  cause  The cause, or <tt>null</tt> if the cause is nonexistent
+     *                or unknown
+     */
+    public ServiceConfigurationError(String msg, Throwable cause) {
+	super(msg, cause);
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/util/ServiceLoader.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/util/ServiceLoader.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/java/util/ServiceLoader.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/java/util/ServiceLoader.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,521 @@
+/*
+ * @(#)ServiceLoader.java	1.10 06/04/10
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package java.util;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+
+
+/**
+ * A simple service-provider loading facility.
+ *
+ * <p> A <i>service</i> is a well-known set of interfaces and (usually
+ * abstract) classes.  A <i>service provider</i> is a specific implementation
+ * of a service.  The classes in a provider typically implement the interfaces
+ * and subclass the classes defined in the service itself.  Service providers
+ * can be installed in an implementation of the Java platform in the form of
+ * extensions, that is, jar files placed into any of the usual extension
+ * directories.  Providers can also be made available by adding them to the
+ * application's class path or by some other platform-specific means.
+ *
+ * <p> For the purpose of loading, a service is represented by a single type,
+ * that is, a single interface or abstract class.  (A concrete class can be
+ * used, but this is not recommended.)  A provider of a given service contains
+ * one or more concrete classes that extend this <i>service type</i> with data
+ * and code specific to the provider.  The <i>provider class</i> is typically
+ * not the entire provider itself but rather a proxy which contains enough
+ * information to decide whether the provider is able to satisfy a particular
+ * request together with code that can create the actual provider on demand.
+ * The details of provider classes tend to be highly service-specific; no
+ * single class or interface could possibly unify them, so no such type is
+ * defined here.  The only requirement enforced by this facility is that
+ * provider classes must have a zero-argument constructor so that they can be
+ * instantiated during loading.
+ *
+ * <p><a name="format"> A service provider is identified by placing a
+ * <i>provider-configuration file</i> in the resource directory
+ * <tt>META-INF/services</tt>.  The file's name is the fully-qualified <a
+ * href="../lang/ClassLoader.html#name">binary name</a> of the service's type.
+ * The file contains a list of fully-qualified binary names of concrete
+ * provider classes, one per line.  Space and tab characters surrounding each
+ * name, as well as blank lines, are ignored.  The comment character is
+ * <tt>'#'</tt> (<tt>'&#92;u0023'</tt>, <font size="-1">NUMBER SIGN</font>); on
+ * each line all characters following the first comment character are ignored.
+ * The file must be encoded in UTF-8.
+ *
+ * <p> If a particular concrete provider class is named in more than one
+ * configuration file, or is named in the same configuration file more than
+ * once, then the duplicates are ignored.  The configuration file naming a
+ * particular provider need not be in the same jar file or other distribution
+ * unit as the provider itself.  The provider must be accessible from the same
+ * class loader that was initially queried to locate the configuration file;
+ * note that this is not necessarily the class loader from which the file was
+ * actually loaded.
+ *
+ * <p> Providers are located and instantiated lazily, that is, on demand.  A
+ * service loader maintains a cache of the providers that have been loaded so
+ * far.  Each invocation of the {@link #iterator iterator} method returns an
+ * iterator that first yields all of the elements of the cache, in
+ * instantiation order, and then lazily locates and instantiates any remaining
+ * providers, adding each one to the cache in turn.  The cache can be cleared
+ * via the {@link #reload reload} method.
+ *
+ * <p> Service loaders always execute in the security context of the caller.
+ * Trusted system code should typically invoke the methods in this class, and
+ * the methods of the iterators which they return, from within a privileged
+ * security context.
+ *
+ * <p> Instances of this class are not safe for use by multiple concurrent
+ * threads.
+ *
+ * <p> Unless otherwise specified, passing a <tt>null</tt> argument to any
+ * method in this class will cause a {@link NullPointerException} to be thrown.
+ *
+ *
+ * <p><span style="font-weight: bold; padding-right: 1em">Example</span>
+ * Suppose we have a service type <tt>com.example.CodecSet</tt> which is
+ * intended to represent sets of encoder/decoder pairs for some protocol.  In
+ * this case it is an abstract class with two abstract methods:
+ *
+ * <blockquote><pre>
+ * public abstract Encoder getEncoder(String encodingName);
+ * public abstract Decoder getDecoder(String encodingName);</pre></blockquote>
+ *
+ * Each method returns an appropriate object or <tt>null</tt> if the provider
+ * does not support the given encoding.  Typical providers support more than
+ * one encoding.
+ *
+ * <p> If <tt>com.example.impl.StandardCodecs</tt> is an implementation of the
+ * <tt>CodecSet</tt> service then its jar file also contains a file named
+ *
+ * <blockquote><pre>
+ * META-INF/services/com.example.CodecSet</pre></blockquote>
+ *
+ * <p> This file contains the single line:
+ *
+ * <blockquote><pre>
+ * com.example.impl.StandardCodecs    # Standard codecs</pre></blockquote>
+ *
+ * <p> The <tt>CodecSet</tt> class creates and saves a single service instance
+ * at initialization:
+ *
+ * <blockquote><pre>
+ * private static ServiceLoader&lt;CodecSet&gt; codecSetLoader
+ *     = ServiceLoader.load(CodecSet.class);</pre></blockquote>
+ *
+ * <p> To locate an encoder for a given encoding name it defines a static
+ * factory method which iterates through the known and available providers,
+ * returning only when it has located a suitable encoder or has run out of
+ * providers.
+ *
+ * <blockquote><pre>
+ * public static Encoder getEncoder(String encodingName) {
+ *     for (CodecSet cp : codecSetLoader) {
+ *         Encoder enc = cp.getEncoder(encodingName);
+ *         if (enc != null)
+ *             return enc;
+ *     }
+ *     return null;
+ * }</pre></blockquote>
+ *
+ * <p> A <tt>getDecoder</tt> method is defined similarly.
+ *
+ *
+ * <p><span style="font-weight: bold; padding-right: 1em">Usage Note</span> If
+ * the class path of a class loader that is used for provider loading includes
+ * remote network URLs then those URLs will be dereferenced in the process of
+ * searching for provider-configuration files.
+ *
+ * <p> This activity is normal, although it may cause puzzling entries to be
+ * created in web-server logs.  If a web server is not configured correctly,
+ * however, then this activity may cause the provider-loading algorithm to fail
+ * spuriously.
+ *
+ * <p> A web server should return an HTTP 404 (Not Found) response when a
+ * requested resource does not exist.  Sometimes, however, web servers are
+ * erroneously configured to return an HTTP 200 (OK) response along with a
+ * helpful HTML error page in such cases.  This will cause a {@link
+ * ServiceConfigurationError} to be thrown when this class attempts to parse
+ * the HTML page as a provider-configuration file.  The best solution to this
+ * problem is to fix the misconfigured web server to return the correct
+ * response code (HTTP 404) along with the HTML error page.
+ *
+ * @param  <S>
+ *         The type of the service to be loaded by this loader
+ *
+ * @author Mark Reinhold
+ * @version 1.10, 06/04/10
+ * @since 1.6
+ */
+
+public final class ServiceLoader
+    //implements Iterable
+{
+
+    private static final String PREFIX = "META-INF/services/";
+
+    // The class or interface representing the service being loaded
+    private Class service;
+
+    // The class loader used to locate, load, and instantiate providers
+    private ClassLoader loader;
+
+    // Cached providers, in instantiation order
+    private LinkedHashMap providers = new LinkedHashMap();
+
+    // The current lazy-lookup iterator
+    private LazyIterator lookupIterator;
+
+    /**
+     * Clear this loader's provider cache so that all providers will be
+     * reloaded.
+     *
+     * <p> After invoking this method, subsequent invocations of the {@link
+     * #iterator() iterator} method will lazily look up and instantiate
+     * providers from scratch, just as is done by a newly-created loader.
+     *
+     * <p> This method is intended for use in situations in which new providers
+     * can be installed into a running Java virtual machine.
+     */
+    public void reload() {
+	providers.clear();
+	lookupIterator = new LazyIterator(service, loader);
+    }
+
+    private ServiceLoader(Class svc, ClassLoader cl) {
+	service = svc;
+	loader = cl;
+	reload();
+    }
+
+    private static void fail(Class service, String msg, Throwable cause)
+	throws ServiceConfigurationError
+    {
+	throw new ServiceConfigurationError(service.getName() + ": " + msg,
+					    cause);
+    }
+
+    private static void fail(Class service, String msg)
+	throws ServiceConfigurationError
+    {
+	throw new ServiceConfigurationError(service.getName() + ": " + msg);
+    }
+
+    private static void fail(Class service, URL u, int line, String msg)
+	throws ServiceConfigurationError
+    {
+	fail(service, u + ":" + line + ": " + msg);
+    }
+
+    // Parse a single line from the given configuration file, adding the name
+    // on the line to the names list.
+    //
+    private int parseLine(Class service, URL u, BufferedReader r, int lc,
+			  List names)
+	throws IOException, ServiceConfigurationError
+    {
+	String ln = r.readLine();
+	if (ln == null) {
+	    return -1;
+	}
+	int ci = ln.indexOf('#');
+	if (ci >= 0) ln = ln.substring(0, ci);
+	ln = ln.trim();
+	int n = ln.length();
+	if (n != 0) {
+	    if ((ln.indexOf(' ') >= 0) || (ln.indexOf('\t') >= 0))
+		fail(service, u, lc, "Illegal configuration-file syntax");
+//	    int cp = ln.codePointAt(0);
+//	    if (!Character.isJavaIdentifierStart(cp))
+//		fail(service, u, lc, "Illegal provider-class name: " + ln);
+//	    for (int i = Character.charCount(cp); i < n; i += Character.charCount(cp)) {
+//		cp = ln.codePointAt(i);
+//		if (!Character.isJavaIdentifierPart(cp) && (cp != '.'))
+//		    fail(service, u, lc, "Illegal provider-class name: " + ln);
+//	    }
+	    if (!providers.containsKey(ln) && !names.contains(ln))
+		names.add(ln);
+	}
+	return lc + 1;
+    }
+
+    // Parse the content of the given URL as a provider-configuration file.
+    //
+    // @param  service
+    //         The service type for which providers are being sought;
+    //         used to construct error detail strings
+    //
+    // @param  u
+    //         The URL naming the configuration file to be parsed
+    //
+    // @return A (possibly empty) iterator that will yield the provider-class
+    //         names in the given configuration file that are not yet members
+    //         of the returned set
+    //
+    // @throws ServiceConfigurationError
+    //         If an I/O error occurs while reading from the given URL, or
+    //         if a configuration-file format error is detected
+    //
+    private Iterator parse(Class service, URL u)
+	throws ServiceConfigurationError
+    {
+	InputStream in = null;
+	BufferedReader r = null;
+	ArrayList names = new ArrayList();
+	try {
+	    in = u.openStream();
+	    r = new BufferedReader(new InputStreamReader(in, "utf-8"));
+	    int lc = 1;
+	    while ((lc = parseLine(service, u, r, lc, names)) >= 0);
+	} catch (IOException x) {
+	    fail(service, "Error reading configuration file", x);
+	} finally {
+	    try {
+		if (r != null) r.close();
+		if (in != null) in.close();
+	    } catch (IOException y) {
+		fail(service, "Error closing configuration file", y);
+	    }
+	}
+	return names.iterator();
+    }
+
+    // Private inner class implementing fully-lazy provider lookup
+    //
+    private class LazyIterator
+	implements Iterator
+    {
+
+	Class service;
+	ClassLoader loader;
+	Enumeration configs = null;
+	Iterator pending = null;
+	String nextName = null;
+
+	private LazyIterator(Class service, ClassLoader loader) {
+	    this.service = service;
+	    this.loader = loader;
+	}
+
+	public boolean hasNext() {
+	    if (nextName != null) {
+		return true;
+	    }
+	    if (configs == null) {
+		try {
+		    String fullName = PREFIX + service.getName();
+		    if (loader == null)
+			configs = ClassLoader.getSystemResources(fullName);
+		    else
+			configs = loader.getResources(fullName);
+		} catch (IOException x) {
+		    fail(service, "Error locating configuration files", x);
+		}
+	    }
+	    while ((pending == null) || !pending.hasNext()) {
+		if (!configs.hasMoreElements()) {
+		    return false;
+		}
+		pending = parse((Class)service, (java.net.URL)configs.nextElement());
+	    }
+	    nextName = (String) pending.next();
+	    return true;
+	}
+
+	public Object next() {
+	    if (!hasNext()) {
+		throw new NoSuchElementException();
+	    }
+	    String cn = nextName;
+	    nextName = null;
+	    try {
+		Object p = Class.forName(cn, true, loader)
+				   .newInstance();
+		providers.put(cn, p);
+		return p;
+	    } catch (ClassNotFoundException x) {
+		fail(service,
+		     "Provider " + cn + " not found");
+	    } catch (Throwable x) {
+		fail(service,
+		     "Provider " + cn + " could not be instantiated: " + x,
+		     x);
+	    }
+	    throw new Error();		// This cannot happen
+	}
+
+	public void remove() {
+	    throw new UnsupportedOperationException();
+	}
+
+    }
+
+    /**
+     * Lazily loads the available providers of this loader's service.
+     *
+     * <p> The iterator returned by this method first yields all of the
+     * elements of the provider cache, in instantiation order.  It then lazily
+     * loads and instantiates any remaining providers, adding each one to the
+     * cache in turn.
+     *
+     * <p> To achieve laziness the actual work of parsing the available
+     * provider-configuration files and instantiating providers must be done by
+     * the iterator itself.  Its {@link java.util.Iterator#hasNext hasNext} and
+     * {@link java.util.Iterator#next next} methods can therefore throw a
+     * {@link ServiceConfigurationError} if a provider-configuration file
+     * violates the specified format, or if it names a provider class that
+     * cannot be found and instantiated, or if the result of instantiating the
+     * class is not assignable to the service type, or if any other kind of
+     * exception or error is thrown as the next provider is located and
+     * instantiated.  To write robust code it is only necessary to catch {@link
+     * ServiceConfigurationError} when using a service iterator.
+     *
+     * <p> If such an error is thrown then subsequent invocations of the
+     * iterator will make a best effort to locate and instantiate the next
+     * available provider, but in general such recovery cannot be guaranteed.
+     *
+     * <blockquote style="font-size: smaller; line-height: 1.2"><span
+     * style="padding-right: 1em; font-weight: bold">Design Note</span>
+     * Throwing an error in these cases may seem extreme.  The rationale for
+     * this behavior is that a malformed provider-configuration file, like a
+     * malformed class file, indicates a serious problem with the way the Java
+     * virtual machine is configured or is being used.  As such it is
+     * preferable to throw an error rather than try to recover or, even worse,
+     * fail silently.</blockquote>
+     *
+     * <p> The iterator returned by this method does not support removal.
+     * Invoking its {@link java.util.Iterator#remove() remove} method will
+     * cause an {@link UnsupportedOperationException} to be thrown.
+     *
+     * @return  An iterator that lazily loads providers for this loader's
+     *          service
+     */
+    public Iterator iterator() {
+	return new Iterator() {
+
+	    Iterator knownProviders
+		= providers.entrySet().iterator();
+
+	    public boolean hasNext() {
+		if (knownProviders.hasNext())
+		    return true;
+		return lookupIterator.hasNext();
+	    }
+
+	    public Object next() {
+		if (knownProviders.hasNext())
+		    return ((java.util.Map.Entry)knownProviders.next()).getValue();
+		return lookupIterator.next();
+	    }
+
+	    public void remove() {
+		throw new UnsupportedOperationException();
+	    }
+
+	};
+    }
+
+    /**
+     * Creates a new service loader for the given service type and class
+     * loader.
+     *
+     * @param  service
+     *         The interface or abstract class representing the service
+     *
+     * @param  loader
+     *         The class loader to be used to load provider-configuration files
+     *         and provider classes, or <tt>null</tt> if the system class
+     *         loader (or, failing that, the bootstrap class loader) is to be
+     *         used
+     * 
+     * @return A new service loader
+     */
+    public static ServiceLoader load(Class service,
+					    ClassLoader loader)
+    {
+	return new ServiceLoader(service, loader);
+    }
+
+    /**
+     * Creates a new service loader for the given service type, using the
+     * current thread's {@linkplain java.lang.Thread#getContextClassLoader
+     * context class loader}.
+     *
+     * <p> An invocation of this convenience method of the form
+     *
+     * <blockquote><pre>
+     * ServiceLoader.load(<i>service</i>)</pre></blockquote>
+     *
+     * is equivalent to
+     *
+     * <blockquote><pre>
+     * ServiceLoader.load(<i>service</i>,
+     *                    Thread.currentThread().getContextClassLoader())</pre></blockquote>
+     *
+     * @param  service
+     *         The interface or abstract class representing the service
+     *
+     * @return A new service loader
+     */
+    public static ServiceLoader load(Class service) {
+	ClassLoader cl = Thread.currentThread().getContextClassLoader();
+	return ServiceLoader.load(service, cl);
+    }
+
+    /**
+     * Creates a new service loader for the given service type, using the
+     * extension class loader.
+     *
+     * <p> This convenience method simply locates the extension class loader,
+     * call it <tt><i>extClassLoader</i></tt>, and then returns
+     *
+     * <blockquote><pre>
+     * ServiceLoader.load(<i>service</i>, <i>extClassLoader</i>)</pre></blockquote>
+     *
+     * <p> If the extension class loader cannot be found then the system class
+     * loader is used; if there is no system class loader then the bootstrap
+     * class loader is used.
+     *
+     * <p> This method is intended for use when only installed providers are
+     * desired.  The resulting service will only find and load providers that
+     * have been installed into the current Java virtual machine; providers on
+     * the application's class path will be ignored.
+     *
+     * @param  service
+     *         The interface or abstract class representing the service
+     *
+     * @return A new service loader
+     */
+    public static ServiceLoader loadInstalled(Class service) {
+	ClassLoader cl = ClassLoader.getSystemClassLoader();
+	ClassLoader prev = null;
+	while (cl != null) {
+	    prev = cl;
+	    cl = cl.getParent();
+	}
+	return ServiceLoader.load(service, prev);
+    }
+
+    /**
+     * Returns a string describing this service.
+     *
+     * @return  A descriptive string
+     */
+    public String toString() {
+	return "java.util.ServiceLoader[" + service.getName() + "]";
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/misc/Cleaner.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/misc/Cleaner.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/misc/Cleaner.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/misc/Cleaner.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,138 @@
+/*
+ * @(#)Cleaner.java	1.4 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.misc;
+
+import java.lang.ref.*;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+
+
+/**
+ * General-purpose phantom-reference-based cleaners.
+ *
+ * <p> Cleaners are a lightweight and more robust alternative to finalization.
+ * They are lightweight because they are not created by the VM and thus do not
+ * require a JNI upcall to be created, and because their cleanup code is
+ * invoked directly by the reference-handler thread rather than by the
+ * finalizer thread.  They are more robust because they use phantom references,
+ * the weakest type of reference object, thereby avoiding the nasty ordering
+ * problems inherent to finalization.
+ *
+ * <p> A cleaner tracks a referent object and encapsulates a thunk of arbitrary
+ * cleanup code.  Some time after the GC detects that a cleaner's referent has
+ * become phantom-reachable, the reference-handler thread will run the cleaner.
+ * Cleaners may also be invoked directly; they are thread safe and ensure that
+ * they run their thunks at most once.
+ *
+ * <p> Cleaners are not a replacement for finalization.  They should be used
+ * only when the cleanup code is extremely simple and straightforward.
+ * Nontrivial cleaners are inadvisable since they risk blocking the
+ * reference-handler thread and delaying further cleanup and finalization.
+ *
+ *
+ * @author Mark Reinhold
+ * @version 1.4, 05/11/17
+ */
+
+public class Cleaner
+    extends PhantomReference
+{
+
+    // Dummy reference queue, needed because the PhantomReference constructor
+    // insists that we pass a queue.  Nothing will ever be placed on this queue
+    // since the reference handler invokes cleaners explicitly.
+    //
+    private static final ReferenceQueue dummyQueue = new ReferenceQueue();
+
+    // Doubly-linked list of live cleaners, which prevents the cleaners
+    // themselves from being GC'd before their referents
+    //
+    static private Cleaner first = null;
+
+    private Cleaner
+	next = null,
+	prev = null;
+
+    private static synchronized Cleaner add(Cleaner cl) {
+	if (first != null) {
+	    cl.next = first;
+	    first.prev = cl;
+	}
+	first = cl;
+	return cl;
+    }
+
+    private static synchronized boolean remove(Cleaner cl) {
+
+	// If already removed, do nothing
+	if (cl.next == cl)
+	    return false;
+
+	// Update list
+	if (first == cl) {
+	    if (cl.next != null)
+		first = cl.next;
+	    else
+		first = cl.prev;
+	}
+	if (cl.next != null)
+	    cl.next.prev = cl.prev;
+	if (cl.prev != null)
+	    cl.prev.next = cl.next;
+
+	// Indicate removal by pointing the cleaner to itself
+	cl.next = cl;
+	cl.prev = cl;
+	return true;
+
+    }
+
+    private final Runnable thunk;
+
+    private Cleaner(Object referent, Runnable thunk) {
+	super(referent, dummyQueue);
+	this.thunk = thunk;
+    }
+
+    /**
+     * Creates a new cleaner.
+     *
+     * @param  thunk
+     *         The cleanup code to be run when the cleaner is invoked.  The
+     *         cleanup code is run directly from the reference-handler thread,
+     *         so it should be as simple and straightforward as possible.
+     *
+     * @return  The new cleaner
+     */
+    public static Cleaner create(Object ob, Runnable thunk) {
+	if (thunk == null)
+	    return null;
+	return add(new Cleaner(ob, thunk));
+    }
+
+    /**
+     * Runs this cleaner, if it has not been run before.
+     */
+    public void clean() {
+	if (!remove(this))
+	    return;
+	try {
+	    thunk.run();
+	} catch (final Throwable x) {
+	    AccessController.doPrivileged(new PrivilegedAction() {
+		    public Object run() {
+			if (System.err != null)
+			    new Error("Cleaner terminated abnormally", x)
+				.printStackTrace();
+			System.exit(1);
+			return null;
+		    }});
+	}
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/misc/Unsafe.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/misc/Unsafe.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/misc/Unsafe.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/misc/Unsafe.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,165 @@
+/*
+ * @(#)Unsafe.java	1.20 05/12/08
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.misc;
+
+import java.security.*;
+import java.lang.reflect.*;
+
+
+/**
+ * A collection of methods for performing low-level, unsafe operations.
+ * Although the class and all methods are public, use of this class is
+ * limited because only trusted code can obtain instances of it.
+ *
+ * @author John R. Rose
+ * @version  1.20, 05/12/08
+ * @see #getUnsafe
+ */
+
+public final class Unsafe {
+
+    private static native void registerNatives();
+    static {
+        registerNatives();
+    }
+
+    private Unsafe() {}
+
+    private static final Unsafe theUnsafe = new Unsafe();
+
+    /**
+     * Provides the caller with the capability of performing unsafe
+     * operations.
+     * 
+     * <p> The returned <code>Unsafe</code> object should be carefully guarded
+     * by the caller, since it can be used to read and write data at arbitrary
+     * memory addresses.  It must never be passed to untrusted code.
+     * 
+     * <p> Most methods in this class are very low-level, and correspond to a
+     * small number of hardware instructions (on typical machines).  Compilers
+     * are encouraged to optimize these methods accordingly.
+     * 
+     * <p> Here is a suggested idiom for using unsafe operations:
+     * 
+     * <blockquote><pre>
+     * class MyTrustedClass {
+     *   private static final Unsafe unsafe = Unsafe.getUnsafe();
+     *   ...
+     *   private long myCountAddress = ...;
+     *   public int getCount() { return unsafe.getByte(myCountAddress); }
+     * }
+     * </pre></blockquote>
+     *
+     * (It may assist compilers to make the local variable be
+     * <code>final</code>.)
+     *
+     * @exception  SecurityException  if a security manager exists and its  
+     *             <code>checkPropertiesAccess</code> method doesn't allow
+     *             access to the system properties.
+     */
+    public static Unsafe getUnsafe() {
+//	Class cc = sun.reflect.Reflection.getCallerClass(2);
+//	if (cc.getClassLoader() != null)
+//	    throw new SecurityException("Unsafe");
+	return theUnsafe;
+    }
+
+    // These work on values in the C heap.
+
+    /**
+     * Fetches a value from a given memory address.  If the address is zero, or
+     * does not point into a block obtained from {@link #allocateMemory}, the
+     * results are undefined.
+     * 
+     * @see #allocateMemory
+     */
+    public native byte    getByte(long address);
+
+    /**
+     * Stores a value into a given memory address.  If the address is zero, or
+     * does not point into a block obtained from {@link #allocateMemory}, the
+     * results are undefined.
+     * 
+     * @see #getByte(long)
+     */
+    public native void    putByte(long address, byte x);
+
+    /** @see #getByte(long) */
+    public native short   getShort(long address);
+    /** @see #putByte(long, byte) */
+    public native void    putShort(long address, short x);
+    /** @see #getByte(long) */
+    public native char    getChar(long address);
+    /** @see #putByte(long, byte) */
+    public native void    putChar(long address, char x);
+    /** @see #getByte(long) */
+    public native int     getInt(long address);
+    /** @see #putByte(long, byte) */
+    public native void    putInt(long address, int x);
+    /** @see #getByte(long) */
+    public native long    getLong(long address);
+    /** @see #putByte(long, byte) */
+    public native void    putLong(long address, long x);
+    /// wrappers for malloc, realloc, free:
+
+    /**
+     * Allocates a new block of native memory, of the given size in bytes.  The
+     * contents of the memory are uninitialized; they will generally be
+     * garbage.  The resulting native pointer will never be zero, and will be
+     * aligned for all value types.  Dispose of this memory by calling {@link
+     * #freeMemory}, or resize it with {@link #reallocateMemory}.
+     * 
+     * @throws IllegalArgumentException if the size is negative or too large
+     *         for the native size_t type
+     * 
+     * @throws OutOfMemoryError if the allocation is refused by the system
+     * 
+     * @see #getByte(long)
+     * @see #putByte(long, byte)
+     */
+    public native long allocateMemory(long bytes);
+
+
+    /**
+     * Sets all bytes in a given block of memory to a fixed value
+     * (usually zero).
+     */
+    public native void setMemory(long address, long bytes, byte value);
+
+    /**
+     * Sets all bytes in a given block of memory to a copy of another
+     * block.
+     */
+    public native void copyMemory(long srcAddress, long destAddress,
+				  long bytes);
+
+    /**
+     * Disposes of a block of native memory, as obtained from {@link
+     * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
+     * this method may be null, in which case no action is taken.
+     *
+     * @see #allocateMemory
+     */
+    public native void freeMemory(long address);
+
+    /**
+     * Report the size in bytes of a native pointer, as stored via {@link
+     * #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
+     * other primitive types (as stored in native memory blocks) is determined
+     * fully by their information content.
+     */
+    public native int addressSize();
+
+    /**
+     * Report the size in bytes of a native memory page (whatever that is).
+     * This value will always be a power of two.
+     */
+    public native int pageSize();
+
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/misc/VM.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/misc/VM.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/misc/VM.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/misc/VM.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,335 @@
+/*
+ * @(#)VM.java	1.34 05/11/21
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.misc;
+
+import java.util.Properties;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+public class VM {
+
+    /* The following methods used to be native methods that instruct
+     * the VM to selectively suspend certain threads in low-memory
+     * situations. They are inherently dangerous and not implementable
+     * on native threads. We removed them in JDK 1.2. The skeletons
+     * remain so that existing applications that use these methods
+     * will still work.
+     */
+    private static boolean suspended = false;
+
+    /** @deprecated */
+    ////@Deprecated
+    public static boolean threadsSuspended() {
+        return suspended;
+    }
+
+    public static boolean allowThreadSuspension(ThreadGroup g, boolean b) {
+	return true;//g.allowThreadSuspension(b);
+    }
+
+    /** @deprecated */
+    //@Deprecated
+    public static boolean suspendThreads() {
+        suspended = true;
+	return true;
+    }
+
+    // Causes any suspended threadgroups to be resumed.
+    /** @deprecated */
+    //@Deprecated
+    public static void unsuspendThreads() {
+        suspended = false;
+    }
+
+    // Causes threadgroups no longer marked suspendable to be resumed.
+    /** @deprecated */
+    //@Deprecated
+    public static void unsuspendSomeThreads() {
+    }
+
+    /* Deprecated fields and methods -- Memory advice not supported in 1.2 */
+
+    /** @deprecated */
+    //@Deprecated
+    public static final int STATE_GREEN = 1;
+
+    /** @deprecated */
+    //@Deprecated
+    public static final int STATE_YELLOW = 2;
+
+    /** @deprecated */
+    //@Deprecated
+    public static final int STATE_RED = 3;
+
+    /** @deprecated */
+    //@Deprecated
+    public static final int getState() {
+	return STATE_GREEN;
+    }
+
+    /** @deprecated */
+    //@Deprecated
+//    public static void registerVMNotification(VMNotification n) { }
+
+    /** @deprecated */
+    //@Deprecated
+    public static void asChange(int as_old, int as_new) { }
+
+    /** @deprecated */
+    //@Deprecated
+    public static void asChange_otherthread(int as_old, int as_new) { }
+
+    /*
+     * Not supported in 1.2 because these will have to be exported as
+     * JVM functions, and we are not sure we want do that. Leaving
+     * here so it can be easily resurrected -- just remove the //
+     * comments.
+     */
+
+    /**
+     * Resume Java profiling.  All profiling data is added to any
+     * earlier profiling, unless <code>resetJavaProfiler</code> is
+     * called in between.  If profiling was not started from the
+     * command line, <code>resumeJavaProfiler</code> will start it.
+     * <p>
+     *
+     * NOTE: Profiling must be enabled from the command line for a
+     * java.prof report to be automatically generated on exit; if not,
+     * writeJavaProfilerReport must be invoked to write a report.
+     *
+     * @see 	resetJavaProfiler
+     * @see 	writeJavaProfilerReport
+     */
+
+    // public native static void resumeJavaProfiler();
+
+    /**
+     * Suspend Java profiling.
+     */
+    // public native static void suspendJavaProfiler();
+
+    /**
+     * Initialize Java profiling.  Any accumulated profiling
+     * information is discarded.
+     */
+    // public native static void resetJavaProfiler();
+
+    /**
+     * Write the current profiling contents to the file "java.prof".
+     * If the file already exists, it will be overwritten.
+     */
+    // public native static void writeJavaProfilerReport();
+
+
+    private static volatile boolean booted = false;
+
+    // Invoked by by System.initializeSystemClass just before returning.
+    // Subsystems that are invoked during initialization can check this
+    // property in order to avoid doing things that should wait until the
+    // application class loader has been set up.
+    //
+    public static void booted() {
+	booted = true;
+    }
+
+    public static boolean isBooted() {
+	return booted;
+    }
+
+    // A user-settable upper limit on the maximum amount of allocatable direct
+    // buffer memory.  This value may be changed during VM initialization if
+    // "java" is launched with "-XX:MaxDirectMemorySize=<size>".
+    //
+    // The initial value of this field is arbitrary; during JRE initialization
+    // it will be reset to the value specified on the command line, if any,
+    // otherwise to Runtime.getRuntime.maxDirectMemory().
+    //
+    private static long directMemory = 64 * 1024 * 1024;
+
+    // If this method is invoked during VM initialization, it initializes the
+    // maximum amount of allocatable direct buffer memory (in bytes) from the
+    // system property sun.nio.MaxDirectMemorySize.  The system property will
+    // be removed when it is accessed.
+    //
+    // If this method is invoked after the VM is booted, it returns the
+    // maximum amount of allocatable direct buffer memory.
+    //
+    public static long maxDirectMemory() {
+	if (booted)
+	    return directMemory;
+
+	Properties p = System.getProperties();
+	String s = (String)p.remove("sun.nio.MaxDirectMemorySize");
+	System.setProperties(p);
+
+	if (s != null) {
+	    if (s.equals("-1")) {
+		// -XX:MaxDirectMemorySize not given, take default
+		directMemory = Runtime.getRuntime().maxMemory();
+	    } else {
+		long l = Long.parseLong(s);
+		if (l > -1)
+		    directMemory = l;
+	    }
+	}
+
+	return directMemory;
+    }
+
+    // A user-settable boolean to determine whether ClassLoader.loadClass should
+    // accept array syntax.  This value may be changed during VM initialization 
+    // via the system property "sun.lang.ClassLoader.allowArraySyntax". 
+    //
+    // The default for 1.5 is "true", array syntax is allowed.  In 1.6, the
+    // default will be "false".  The presence of this system property to
+    // control array syntax allows applications the ability to preview this new
+    // behaviour.
+    // 
+    private static boolean defaultAllowArraySyntax = false;
+    private static boolean allowArraySyntax = defaultAllowArraySyntax;
+
+    // If this method is invoked during VM initialization, it initializes the
+    // allowArraySyntax boolean based on the value of the system property
+    // "sun.lang.ClassLoader.allowArraySyntax".  If the system property is not
+    // provided, the default for 1.5 is "true".  In 1.6, the default will be
+    // "false".  If the system property is provided, then the value of
+    // allowArraySyntax will be equal to "true" if Boolean.parseBoolean() 
+    // returns "true".   Otherwise, the field will be set to "false".
+    //
+    // If this method is invoked after the VM is booted, it returns the
+    // allowArraySyntax boolean set during initialization.
+    //    
+    public static boolean allowArraySyntax() {
+	if (!booted) {
+	    String s
+		= (String) System.getProperty("sun.lang.ClassLoader.allowArraySyntax");
+	    allowArraySyntax = (s == null 
+				? defaultAllowArraySyntax
+				: new Boolean(s).booleanValue());
+	}
+	return allowArraySyntax;
+    }
+    
+    // Initialize any miscellenous operating system settings that need to be
+    // set for the class libraries. 
+    //
+    public static void initializeOSEnvironment() {
+        if (!booted) {
+//NARFLEX            OSEnvironment.initialize();
+        }
+    }
+
+    /* Current count of objects pending for finalization */
+    private static volatile int finalRefCount = 0;
+
+    /* Peak count of objects pending for finalization */
+    private static volatile int peakFinalRefCount = 0;
+
+    /*
+     * Gets the number of objects pending for finalization.
+     *
+     * @return the number of objects pending for finalization.
+     */
+    public static int getFinalRefCount() {
+        return finalRefCount;
+    }
+
+    /*
+     * Gets the peak number of objects pending for finalization.
+     *
+     * @return the peak number of objects pending for finalization.
+     */
+    public static int getPeakFinalRefCount() {
+        return peakFinalRefCount;
+    }
+
+    /*
+     * Add <tt>n</tt> to the objects pending for finalization count.
+     * 
+     * @param n an integer value to be added to the objects pending
+     * for finalization count
+     */
+    public static void addFinalRefCount(int n) {
+        // The caller must hold lock to synchronize the update. 
+
+        finalRefCount += n;
+        if (finalRefCount > peakFinalRefCount) {
+            peakFinalRefCount = finalRefCount;
+        }
+    }
+
+
+/*    public static Thread.State toThreadState(int threadStatus) {
+        // Initialize the threadStateMap
+        initThreadStateMap();
+
+        Thread.State s = (Thread.State)threadStateMap.get(new Integer(threadStatus));
+        if (s == null) {
+            // default to RUNNABLE if the threadStatus value is unknown
+            s = Thread.State.RUNNABLE;
+        }
+        return s;
+    }
+
+    // a map of threadStatus values to the corresponding Thread.State
+    private static Map threadStateMap = null;
+    private static Map threadStateNames = null;
+
+    private synchronized static void initThreadStateMap() {
+        if (threadStateMap != null) {
+            return;
+        }
+
+        final Thread.State[] ts = Thread.State.values();
+
+        final int[][] vmThreadStateValues = new int[ts.length][];
+        final String[][] vmThreadStateNames = new String[ts.length][];
+        getThreadStateValues(vmThreadStateValues, vmThreadStateNames);
+
+        threadStateMap = new HashMap();
+        threadStateNames = new HashMap();
+        for (int i = 0; i < ts.length; i++) {
+            String state = ts[i].name();
+            int[] values = null;
+            String[] names = null;
+            for (int j = 0; j < ts.length; j++) {
+                if (vmThreadStateNames[j][0].startsWith(state)) {
+                    values = vmThreadStateValues[j];
+                    names = vmThreadStateNames[j];
+                }
+            }
+            if (values == null) {
+                throw new InternalError("No VM thread state mapped to " +
+                    state);
+            }
+            if (values.length != names.length) {
+                throw new InternalError("VM thread state values and names " +
+                    " mapped to " + state + ": length not matched" );
+            }
+            for (int k = 0; k < values.length; k++) {
+                threadStateMap.put(new Integer(values[k]), ts[i]);
+                threadStateNames.put(new Integer(values[k]), names[k]);
+            }
+        }
+    }
+    // Fill in vmThreadStateValues with int arrays, each of which contains
+    // the threadStatus values mapping to the Thread.State enum constant.
+    // Fill in vmThreadStateNames with String arrays, each of which contains
+    // the name of each threadStatus value of the format:
+    //    <Thread.State.name()>[.<Substate name>]
+    // e.g. WAITING.OBJECT_WAIT
+    //
+    private native static void getThreadStateValues(int[][] vmThreadStateValues,
+                                                    String[][] vmThreadStateNames);
+*/
+    static {
+//        initialize();
+    }
+//    private native static void initialize();
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ByteBuffered.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ByteBuffered.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ByteBuffered.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ByteBuffered.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2003-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio;
+
+import java.nio.ByteBuffer;
+import java.io.IOException;
+
+/** This is an interface to adapt existing APIs to use {@link java.nio.ByteBuffer
+ *  <tt>ByteBuffers</tt>} as the underlying
+ *  data format.  Only the initial producer and final consumer have to be changed.<p>
+ *
+ *  For example, the Zip/Jar code supports {@link java.io.InputStream <tt>InputStreams</tt>}.
+ *  To make the Zip code use {@link java.nio.MappedByteBuffer <tt>MappedByteBuffers</tt>} as
+ *  the underlying data structure, it can create a class of InputStream that wraps the ByteBuffer,
+ *  and implements the ByteBuffered interface. A co-operating class several layers
+ *  away can ask the InputStream if it is an instance of ByteBuffered, then
+ *  call the {@link #getByteBuffer()} method.
+ */
+public interface ByteBuffered {
+
+     /**
+     * Returns the <tt>ByteBuffer</tt> behind this object, if this particular
+     * instance has one. An implementation of <tt>getByteBuffer()</tt> is allowed
+     * to return <tt>null</tt> for any reason.
+     *
+     * @return  The <tt>ByteBuffer</tt>, if this particular instance has one,
+     *          or <tt>null</tt> otherwise.
+     *
+     * @throws  IOException
+     *          If the ByteBuffer is no longer valid.
+     *
+     * @since  1.5
+     */
+    public ByteBuffer getByteBuffer() throws IOException;
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/AbstractPollArrayWrapper.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/AbstractPollArrayWrapper.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/AbstractPollArrayWrapper.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/AbstractPollArrayWrapper.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import sun.misc.*;
+
+
+/**
+ * Manipulates a native array of pollfd structs.
+ *
+ * @author Mike McCloskey
+ * @since 1.4
+ */
+
+abstract class AbstractPollArrayWrapper {
+
+    // Event masks
+    static final short POLLIN       = 0x0001;
+    static final short POLLOUT      = 0x0004;
+    static final short POLLERR      = 0x0008;
+    static final short POLLHUP      = 0x0010;
+    static final short POLLNVAL     = 0x0020;
+    static final short POLLREMOVE   = 0x0800;
+
+    // Miscellaneous constants
+    static final short SIZE_POLLFD   = 8;
+    static final short FD_OFFSET     = 0;
+    static final short EVENT_OFFSET  = 4;
+    static final short REVENT_OFFSET = 6;
+
+    // The poll fd array
+    protected AllocatedNativeObject pollArray;
+
+    // Number of valid entries in the pollArray
+    protected int totalChannels = 0;
+
+    // Base address of the native pollArray
+    protected long pollArrayAddress;
+
+    // Access methods for fd structures
+    int getEventOps(int i) {
+        int offset = SIZE_POLLFD * i + EVENT_OFFSET;
+        return pollArray.getShort(offset);
+    }
+
+    int getReventOps(int i) {
+        int offset = SIZE_POLLFD * i + REVENT_OFFSET;
+        return pollArray.getShort(offset);
+    }
+
+    int getDescriptor(int i) {
+        int offset = SIZE_POLLFD * i + FD_OFFSET;
+        return pollArray.getInt(offset);
+    }
+
+    void putEventOps(int i, int event) {
+        int offset = SIZE_POLLFD * i + EVENT_OFFSET;
+        pollArray.putShort(offset, (short)event);
+    }
+
+    void putReventOps(int i, int revent) {
+        int offset = SIZE_POLLFD * i + REVENT_OFFSET;
+        pollArray.putShort(offset, (short)revent);
+    }
+
+    void putDescriptor(int i, int fd) {
+        int offset = SIZE_POLLFD * i + FD_OFFSET;
+        pollArray.putInt(offset, fd);
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/AbstractPollSelectorImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/AbstractPollSelectorImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/AbstractPollSelectorImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/AbstractPollSelectorImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,187 @@
+/*
+ * Copyright 2001-2004 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.util.*;
+import sun.misc.*;
+
+
+/**
+ * An abstract selector impl.
+ */
+
+abstract class AbstractPollSelectorImpl
+    extends SelectorImpl
+{
+
+    // The poll fd array
+    PollArrayWrapper pollWrapper;
+
+    // Initial capacity of the pollfd array
+    protected final int INIT_CAP = 10;
+
+    // The list of SelectableChannels serviced by this Selector
+    protected SelectionKeyImpl[] channelArray;
+
+    // In some impls the first entry of channelArray is bogus
+    protected int channelOffset = 0;
+
+    // The number of valid channels in this Selector's poll array
+    protected int totalChannels;
+
+    // True if this Selector has been closed
+    private boolean closed = false;
+
+    AbstractPollSelectorImpl(SelectorProvider sp, int channels, int offset) {
+        super(sp);
+        this.totalChannels = channels;
+        this.channelOffset = offset;
+    }
+
+    void putEventOps(SelectionKeyImpl sk, int ops) {
+        pollWrapper.putEventOps(sk.getIndex(), ops);
+    }
+
+    public Selector wakeup() {
+        pollWrapper.interrupt();
+        return this;
+    }
+
+    protected abstract int doSelect(long timeout) throws IOException;
+
+    protected void implClose() throws IOException {
+        if (!closed) {
+            closed = true;
+            // Deregister channels
+            for(int i=channelOffset; i<totalChannels; i++) {
+                SelectionKeyImpl ski = channelArray[i];
+                assert(ski.getIndex() != -1);
+                ski.setIndex(-1);
+                deregister(ski);
+                SelectableChannel selch = channelArray[i].channel();
+                if (!selch.isOpen() && !selch.isRegistered())
+                    ((SelChImpl)selch).kill();
+            }
+            implCloseInterrupt();
+            pollWrapper.free();
+            pollWrapper = null;
+            selectedKeys = null;
+            channelArray = null;
+            totalChannels = 0;
+        }
+    }
+
+    protected abstract void implCloseInterrupt() throws IOException;
+
+    /**
+     * Copy the information in the pollfd structs into the opss
+     * of the corresponding Channels. Add the ready keys to the
+     * ready queue.
+     */
+    protected int updateSelectedKeys() {
+        int numKeysUpdated = 0;
+        // Skip zeroth entry; it is for interrupts only
+        for (int i=channelOffset; i<totalChannels; i++) {
+            int rOps = pollWrapper.getReventOps(i);
+            if (rOps != 0) {
+                SelectionKeyImpl sk = channelArray[i];
+                pollWrapper.putReventOps(i, 0);
+                if (selectedKeys.contains(sk)) {
+                    if (sk.channel.translateAndSetReadyOps(rOps, sk)) {
+                        numKeysUpdated++;
+                    }
+                } else {
+                    sk.channel.translateAndSetReadyOps(rOps, sk);
+                    if ((sk.nioReadyOps() & sk.nioInterestOps()) != 0) {
+                        selectedKeys.add(sk);
+                        numKeysUpdated++;
+                    }
+                }
+            }
+        }
+        return numKeysUpdated;
+    }
+
+    protected void implRegister(SelectionKeyImpl ski) {
+        // Check to see if the array is large enough
+        if (channelArray.length == totalChannels) {
+            // Make a larger array
+            int newSize = pollWrapper.totalChannels * 2;
+            SelectionKeyImpl temp[] = new SelectionKeyImpl[newSize];
+            // Copy over
+            for (int i=channelOffset; i<totalChannels; i++)
+                temp[i] = channelArray[i];
+            channelArray = temp;
+            // Grow the NativeObject poll array
+            pollWrapper.grow(newSize);
+        }
+        channelArray[totalChannels] = ski;
+        ski.setIndex(totalChannels);
+        pollWrapper.addEntry(ski.channel);
+        totalChannels++;
+        keys.add(ski);
+    }
+
+    protected void implDereg(SelectionKeyImpl ski) throws IOException {
+        // Algorithm: Copy the sc from the end of the list and put it into
+        // the location of the sc to be removed (since order doesn't
+        // matter). Decrement the sc count. Update the index of the sc
+        // that is moved.
+        int i = ski.getIndex();
+        assert (i >= 0);
+        if (i != totalChannels - 1) {
+            // Copy end one over it
+            SelectionKeyImpl endChannel = channelArray[totalChannels-1];
+            channelArray[i] = endChannel;
+            endChannel.setIndex(i);
+            pollWrapper.release(i);
+            PollArrayWrapper.replaceEntry(pollWrapper, totalChannels - 1,
+                                          pollWrapper, i);
+        } else {
+            pollWrapper.release(i);
+        }
+        // Destroy the last one
+        channelArray[totalChannels-1] = null;
+        totalChannels--;
+        pollWrapper.totalChannels--;
+        ski.setIndex(-1);
+        // Remove the key from keys and selectedKeys
+        keys.remove(ski);
+        selectedKeys.remove(ski);
+        deregister((AbstractSelectionKey)ski);
+        SelectableChannel selch = ski.channel();
+        if (!selch.isOpen() && !selch.isRegistered())
+            ((SelChImpl)selch).kill();
+    }
+
+    static {
+        Util.load();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/AllocatedNativeObject.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/AllocatedNativeObject.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/AllocatedNativeObject.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/AllocatedNativeObject.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2000-2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ */
+
+package sun.nio.ch;                                     // Formerly in sun.misc
+
+
+// ## In the fullness of time, this class will be eliminated
+
+class AllocatedNativeObject                             // package-private
+    extends NativeObject
+{
+
+    /**
+     * Allocates a memory area of at least <tt>size</tt> bytes outside of the
+     * Java heap and creates a native object for that area.
+     *
+     * @param  size
+     *         Number of bytes to allocate
+     *
+     * @param  pageAligned
+     *         If <tt>true</tt> then the area will be aligned on a hardware
+     *         page boundary
+     *
+     * @throws OutOfMemoryError
+     *         If the request cannot be satisfied
+     */
+    AllocatedNativeObject(int size, boolean pageAligned) {
+        super(size, pageAligned);
+    }
+
+    /**
+     * Frees the native memory area associated with this object.
+     */
+    synchronized void free() {
+        if (allocationAddress != 0) {
+            unsafe.freeMemory(allocationAddress);
+            allocationAddress = 0;
+        }
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/AlreadyBoundException.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/AlreadyBoundException.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/AlreadyBoundException.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/AlreadyBoundException.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+// -- This file was mechanically generated: Do not edit! -- //
+
+package sun.nio.ch;
+
+
+/**
+ * Unchecked exception thrown when an attempt is made to bind a {@link
+ * SocketChannel} that is already bound.
+ *
+ * @since 1.4
+ */
+
+public class AlreadyBoundException
+    extends IllegalStateException
+{
+
+    private static final long serialVersionUID = 9002280723481772026L;
+
+    /**
+     * Constructs an instance of this class.
+     */
+    public AlreadyBoundException() { }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/ChannelInputStream.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/ChannelInputStream.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/ChannelInputStream.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/ChannelInputStream.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2001-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+import java.nio.*;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+
+/**
+ * This class is defined here rather than in java.nio.channels.Channels
+ * so that code can be shared with SocketAdaptor.
+ *
+ * @author Mike McCloskey
+ * @author Mark Reinhold
+ * @since 1.4
+ */
+
+public class ChannelInputStream
+    extends InputStream
+{
+
+    public static int read(ReadableByteChannel ch, ByteBuffer bb,
+                           boolean block)
+        throws IOException
+    {
+        if (ch instanceof SelectableChannel) {
+            SelectableChannel sc = (SelectableChannel)ch;
+            synchronized (sc.blockingLock()) {
+                boolean bm = sc.isBlocking();
+                if (!bm)
+                    throw new IllegalBlockingModeException();
+                if (bm != block)
+                    sc.configureBlocking(block);
+                int n = ch.read(bb);
+                if (bm != block)
+                    sc.configureBlocking(bm);
+                return n;
+            }
+        } else {
+            return ch.read(bb);
+        }
+    }
+
+    protected final ReadableByteChannel ch;
+    private ByteBuffer bb = null;
+    private byte[] bs = null;           // Invoker's previous array
+    private byte[] b1 = null;
+
+    public ChannelInputStream(ReadableByteChannel ch) {
+        this.ch = ch;
+    }
+
+    public synchronized int read() throws IOException {
+        if (b1 == null)
+            b1 = new byte[1];
+        int n = this.read(b1);
+        if (n == 1)
+            return b1[0] & 0xff;
+        return -1;
+    }
+
+    public synchronized int read(byte[] bs, int off, int len)
+        throws IOException
+    {
+        if ((off < 0) || (off > bs.length) || (len < 0) ||
+            ((off + len) > bs.length) || ((off + len) < 0)) {
+            throw new IndexOutOfBoundsException();
+        } else if (len == 0)
+            return 0;
+
+        ByteBuffer bb = ((this.bs == bs)
+                         ? this.bb
+                         : ByteBuffer.wrap(bs));
+        bb.limit(Math.min(off + len, bb.capacity()));
+        bb.position(off);
+        this.bb = bb;
+        this.bs = bs;
+        return read(bb);
+    }
+
+    protected int read(ByteBuffer bb)
+        throws IOException
+    {
+        return ChannelInputStream.read(ch, bb, true);
+    }
+
+    public void close() throws IOException {
+        ch.close();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/DefaultSelectorProvider.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/DefaultSelectorProvider.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/DefaultSelectorProvider.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/DefaultSelectorProvider.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,57 @@
+/*
+ * @(#)DefaultSelectorProvider.java	1.8 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.nio.ch;
+
+import java.nio.channels.spi.SelectorProvider;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import sun.security.action.GetPropertyAction;
+
+/**
+ * Creates this platform's default SelectorProvider
+ */
+
+public class DefaultSelectorProvider {
+
+    /**
+     * Prevent instantiation.
+     */
+    private DefaultSelectorProvider() { }
+
+    /**
+     * Returns the default SelectorProvider.
+     */
+    public static SelectorProvider create() {
+	PrivilegedAction pa = new GetPropertyAction("os.name");
+	String osname = (String) AccessController.doPrivileged(pa);
+//        if ("SunOS".equals(osname)) {
+  //          return new sun.nio.ch.DevPollSelectorProvider();
+    //    }
+
+        // use EPollSelectorProvider for Linux kernels >= 2.6
+    //    if ("Linux".equals(osname)) {
+//            pa = new GetPropertyAction("os.version");
+  //          String osversion = (String) AccessController.doPrivileged(pa);
+    //        String[] vers = osversion.split("\\.", 0);
+      //      if (vers.length >= 2) {
+        //        try {
+          //          int major = Integer.parseInt(vers[0]);
+            //        int minor = Integer.parseInt(vers[1]);
+              //      if (major > 2 || (major == 2 && minor >= 6)) {
+                        return new sun.nio.ch.EPollSelectorProvider();
+//                    }
+  //              } catch (NumberFormatException x) {
+                    // format not recognized
+    //            }
+      //      }
+//        }
+
+  //      return new sun.nio.ch.PollSelectorProvider();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/DirectBuffer.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/DirectBuffer.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/DirectBuffer.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/DirectBuffer.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2000-2003 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import sun.misc.Cleaner;
+
+
+public interface DirectBuffer {
+
+    public long address();
+
+    public Object viewedBuffer();
+
+    public Cleaner cleaner();
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/EPollArrayWrapper.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/EPollArrayWrapper.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/EPollArrayWrapper.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/EPollArrayWrapper.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,241 @@
+/*
+ * @(#)EPollArrayWrapper.java	1.2 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.util.LinkedList;
+
+
+/**
+ * Manipulates a native array of epoll_event structs on Linux:
+ *
+ * typedef union epoll_data {
+ *     void *ptr;
+ *     int fd;
+ *     __uint32_t u32;
+ *     __uint64_t u64;
+ *  } epoll_data_t;
+ *
+ * struct epoll_event {
+ *     __uint32_t events;  
+ *     epoll_data_t data; 
+ * }; 
+ *
+ * The system call to wait for I/O events is epoll_wait(2). It populates an
+ * array of epoll_event structures that are passed to the call. The data
+ * member of the epoll_event structure contains the same data as was set
+ * when the file descriptor was registered to epoll via epoll_ctl(2). In
+ * this implementation we set data.fd to be the file descriptor that we
+ * register. That way, we have the file descriptor available when we
+ * process the events.
+ */
+
+class EPollArrayWrapper {
+    // EPOLL_EVENTS
+    static final int EPOLLIN      = 0x001;
+
+    // opcodes
+    static final int EPOLL_CTL_ADD	= 1;
+    static final int EPOLL_CTL_DEL      = 2;
+    static final int EPOLL_CTL_MOD      = 3;
+
+    // Miscellaneous constants
+    static final short SIZE_EPOLLEVENT  = 12;
+    static final short EVENT_OFFSET     = 0;
+    static final short DATA_OFFSET      = 4;
+    static final short FD_OFFSET        = 4;
+    static final int   NUM_EPOLLEVENTS  = Math.min(fdLimit(), 8192);
+
+    // Base address of the native pollArray
+    private long pollArrayAddress;
+
+    EPollArrayWrapper() {
+        // creates the epoll file descriptor
+        epfd = epollCreate();
+
+        // the epoll_event array passed to epoll_wait
+        int allocationSize = NUM_EPOLLEVENTS * SIZE_EPOLLEVENT;
+        pollArray = new AllocatedNativeObject(allocationSize, true);
+        pollArrayAddress = pollArray.address();
+
+        for (int i=0; i<NUM_EPOLLEVENTS; i++) {
+            putEventOps(i, 0);
+            putData(i, 0L);
+        }
+    }
+
+    // Used to update file description registrations
+    private static class Updator {
+        int opcode;
+        int fd;
+        int events;
+        Updator(int opcode, int fd, int events) {
+            this.opcode = opcode;
+            this.fd = fd;
+            this.events = events;
+        }
+    }
+
+    private LinkedList updateList = new LinkedList();
+
+    // The epoll_event array for results from epoll_wait
+    private AllocatedNativeObject pollArray;
+
+    // The fd of the epoll driver
+    int epfd;
+
+    // The fd of the interrupt line going out
+    int outgoingInterruptFD;
+
+    // The fd of the interrupt line coming in
+    int incomingInterruptFD;
+
+    // The index of the interrupt FD
+    int interruptedIndex;
+
+    // Number of updated pollfd entries
+    int updated;
+
+    void initInterrupt(int fd0, int fd1) {
+        outgoingInterruptFD = fd1;
+        incomingInterruptFD = fd0;
+        epollCtl(epfd, EPOLL_CTL_ADD, fd0, EPOLLIN);
+    }
+
+    void putEventOps(int i, int event) {
+        int offset = SIZE_EPOLLEVENT * i + EVENT_OFFSET;
+        pollArray.putInt(offset, event);
+    }
+
+    void putData(int i, long value) {
+        int offset = SIZE_EPOLLEVENT * i + DATA_OFFSET;
+        pollArray.putLong(offset, value);
+    }
+
+    void putDescriptor(int i, int fd) {
+        int offset = SIZE_EPOLLEVENT * i + FD_OFFSET;
+        pollArray.putInt(offset, fd);
+    }
+
+    int getEventOps(int i) {
+        int offset = SIZE_EPOLLEVENT * i + EVENT_OFFSET;
+        return pollArray.getInt(offset);
+    }
+
+    int getDescriptor(int i) {
+        int offset = SIZE_EPOLLEVENT * i + FD_OFFSET;
+        return pollArray.getInt(offset);
+    }
+
+    /**
+     * Update the events for a given file descriptor.
+     */
+    void setInterest(int fd, int mask) {
+        synchronized (updateList) {
+            /*
+             * When a channel is registered we put an CTL_ADD opcode into
+             * the update list. To avoid a subsequent CTL_MOD we update the
+             * pending CTL_ADD to avoid a call second to epoll_ctl.
+             */
+            if (updateList.size() > 0) {
+                Updator last = (Updator)updateList.getLast();
+                if (last.fd == fd && last.opcode == EPOLL_CTL_ADD) {
+                    last.events = mask;
+                    return;
+                }
+            }
+            updateList.add(new Updator(EPOLL_CTL_MOD, fd, mask));
+        }
+    }
+
+    /**
+     * Add a new file descriptor to epoll
+     */
+    void add(int fd) {
+	synchronized (updateList) {
+             updateList.add(new Updator(EPOLL_CTL_ADD, fd, 0));
+        }
+    }
+
+    /**
+     * Remove a file descriptor from epoll
+     */
+    void release(int fd) {
+        synchronized (updateList) {
+            updateList.add(new Updator(EPOLL_CTL_DEL, fd, 0));
+        }
+    }
+
+    /**
+     * Close epoll file descriptor and free poll array
+     */
+    void closeEPollFD() throws IOException {
+        FileDispatcher.closeIntFD(epfd);
+        pollArray.free();
+    }
+
+    int poll(long timeout) throws IOException {
+        updateRegistrations();
+        updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);
+        for (int i=0; i<updated; i++) {
+            if (getDescriptor(i) == incomingInterruptFD) {
+                interruptedIndex = i;
+                interrupted = true;
+                break;
+            }
+        }
+        return updated;
+    }
+
+    /**
+     * Update the pending registrations. 
+     */
+    void updateRegistrations() {
+        synchronized (updateList) {
+            Updator u = null;
+			while (true)
+			{
+				if (updateList.isEmpty())
+					break;
+				u = (Updator) updateList.remove(0);
+                epollCtl(epfd, u.opcode, u.fd, u.events);
+            }
+        }
+    }
+
+    // interrupt support
+    boolean interrupted = false;
+
+    public void interrupt() {
+        interrupt(outgoingInterruptFD);
+    }
+
+    public int interruptedIndex() {
+        return interruptedIndex;
+    }
+
+    boolean interrupted() { 
+        return interrupted;
+    }
+
+    void clearInterrupted() {
+        interrupted = false;
+    }
+
+    static {
+        init();
+    }    
+
+    private native int epollCreate();
+    private native void epollCtl(int epfd, int opcode, int fd, int events);
+    private native int epollWait(long pollAddress, int numfds, long timeout,
+                                 int epfd) throws IOException;
+    private static native int fdLimit();
+    private static native void interrupt(int fd);
+    private static native void init();
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/EPollSelectorImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/EPollSelectorImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/EPollSelectorImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/EPollSelectorImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,181 @@
+/*
+ * @(#)EPollSelectorImpl.java	1.2 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.util.*;
+import sun.misc.*;
+
+
+/**
+ * An implementation of Selector for Linux 2.6+ kernels that uses 
+ * the epoll event notification facility.
+ */
+class EPollSelectorImpl
+    extends SelectorImpl
+{
+
+    // File descriptors used for interrupt
+    protected int fd0;
+    protected int fd1;
+
+    // The poll object
+    EPollArrayWrapper pollWrapper;
+
+    // Maps from file descriptors to keys
+    private HashMap fdToKey;
+
+    // True if this Selector has been closed
+    private boolean closed = false;
+
+    // Lock for interrupt triggering and clearing
+    private Object interruptLock = new Object();
+    private boolean interruptTriggered = false;
+
+    /**
+     * Package private constructor called by factory method in
+     * the abstract superclass Selector.
+     */
+    EPollSelectorImpl(SelectorProvider sp) {
+	super(sp);
+        int[] fdes = new int[2];
+        IOUtil.initPipe(fdes, false);
+        fd0 = fdes[0];
+        fd1 = fdes[1];
+        pollWrapper = new EPollArrayWrapper();
+        pollWrapper.initInterrupt(fd0, fd1);
+        fdToKey = new HashMap();
+    }
+
+    protected int doSelect(long timeout)
+        throws IOException
+    {
+        if (closed)
+            throw new ClosedSelectorException();
+        processDeregisterQueue();
+        try {
+            begin();
+            pollWrapper.poll(timeout);
+        } finally {
+            end();
+        }
+        processDeregisterQueue();
+        int numKeysUpdated = updateSelectedKeys();
+        if (pollWrapper.interrupted()) {
+            // Clear the wakeup pipe
+            pollWrapper.putEventOps(pollWrapper.interruptedIndex(), 0);
+            synchronized (interruptLock) {
+                pollWrapper.clearInterrupted();
+                IOUtil.drain(fd0);
+                interruptTriggered = false;
+            }
+        }
+        return numKeysUpdated;
+    }
+
+    /**
+     * Update the keys whose fd's have been selected by the epoll.
+     * Add the ready keys to the ready queue.
+     */
+    private int updateSelectedKeys() {
+        int entries = pollWrapper.updated;
+        int numKeysUpdated = 0;
+        for (int i=0; i<entries; i++) {
+            int nextFD = pollWrapper.getDescriptor(i);
+            SelectionKeyImpl ski = (SelectionKeyImpl) fdToKey.get(
+                new Integer(nextFD));
+            // ski is null in the case of an interrupt
+            if (ski != null) {
+                int rOps = pollWrapper.getEventOps(i);
+                if (selectedKeys.contains(ski)) {
+                    if (ski.channel.translateAndSetReadyOps(rOps, ski)) {
+                        numKeysUpdated++;
+                    }    
+                } else {
+                    ski.channel.translateAndSetReadyOps(rOps, ski);
+                    if ((ski.nioReadyOps() & ski.nioInterestOps()) != 0) {
+                        selectedKeys.add(ski);
+                        numKeysUpdated++;
+                    }
+                }
+            }
+        }
+        return numKeysUpdated;
+    }
+
+    protected void implClose() throws IOException {
+        if (!closed) {
+            closed = true;
+            FileDispatcher.closeIntFD(fd0);
+            FileDispatcher.closeIntFD(fd1);
+            if (pollWrapper != null) {
+
+                pollWrapper.release(fd0);
+                pollWrapper.closeEPollFD();
+                pollWrapper = null;
+                selectedKeys = null;
+
+                // Deregister channels
+		Iterator i = keys.iterator();
+		while (i.hasNext()) {
+		    SelectionKeyImpl ski = (SelectionKeyImpl)i.next();
+		    deregister(ski);
+		    SelectableChannel selch = ski.channel();
+		    if (!selch.isOpen() && !selch.isRegistered())
+			((SelChImpl)selch).kill();
+		    i.remove();
+		}
+            }
+            fd0 = -1;
+            fd1 = -1;
+        }
+    }
+
+    protected void implRegister(SelectionKeyImpl ski) {
+        int fd = IOUtil.fdVal(ski.channel.getFD());
+        fdToKey.put(new Integer(fd), ski);
+        pollWrapper.add(fd);
+        keys.add(ski);
+    }
+
+    protected void implDereg(SelectionKeyImpl ski) throws IOException {
+        assert (ski.getIndex() >= 0);
+        int fd = ski.channel.getFDVal();
+        fdToKey.remove(new Integer(fd));
+        pollWrapper.release(fd);
+        ski.setIndex(-1);
+        keys.remove(ski);
+        selectedKeys.remove(ski);
+	deregister((AbstractSelectionKey)ski);
+	SelectableChannel selch = ski.channel();
+	if (!selch.isOpen() && !selch.isRegistered())
+	    ((SelChImpl)selch).kill();
+    }
+
+    void putEventOps(SelectionKeyImpl sk, int ops) {
+        int fd = IOUtil.fdVal(sk.channel.getFD());
+        pollWrapper.setInterest(fd, ops);
+    }
+
+    public Selector wakeup() {
+        synchronized (interruptLock) {
+            if (!interruptTriggered) {
+                pollWrapper.interrupt();
+                interruptTriggered = true;
+            }
+        }
+	return this;
+    }
+
+    static {
+        Util.load();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/EPollSelectorProvider.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/EPollSelectorProvider.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/EPollSelectorProvider.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/EPollSelectorProvider.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,24 @@
+/*
+ * @(#)EPollSelectorProvider.java	1.2 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+public class EPollSelectorProvider
+    extends SelectorProviderImpl
+{
+    public AbstractSelector openSelector() throws IOException {
+	return new EPollSelectorImpl(this);
+    }
+
+    public Channel inheritedChannel() throws IOException {
+	return InheritedChannel.getChannel();
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/exceptions phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/exceptions
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/exceptions	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/exceptions	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,39 @@
+#
+# Copyright 2000-2007 Sun Microsystems, Inc.  All Rights Reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Sun designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Sun in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+# CA 95054 USA or visit www.sun.com if you need additional information or
+# have any questions.
+#
+
+# Generated exception classes for sun.nio.ch
+
+SINCE=1.4
+PACKAGE=sun.nio.ch
+# This year should only change if the generated source is modified.
+COPYRIGHT_YEARS=2000-2007
+
+
+SUPER=IllegalStateException
+
+gen AlreadyBoundException "
+ * Unchecked exception thrown when an attempt is made to bind a {@link
+ * SocketChannel} that is already bound." \
+ 9002280723481772026L
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/FileChannelImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/FileChannelImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/FileChannelImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/FileChannelImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,828 @@
+/*
+ * Copyright 2000-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.FileDescriptor;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.RandomAccessFile;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.MappedByteBuffer;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Iterator;
+import java.lang.ref.WeakReference;
+import java.lang.ref.ReferenceQueue;
+import java.lang.reflect.Field;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import sun.misc.Cleaner;
+import sun.security.action.GetPropertyAction;
+
+
+public class FileChannelImpl
+    extends FileChannel
+{
+
+    // Used to make native read and write calls
+    private static final NativeDispatcher nd;
+
+    // Memory allocation size for mapping buffers
+    private static final long allocationGranularity;
+
+    // Cached field for MappedByteBuffer.isAMappedBuffer
+    private static final Field isAMappedBufferField;
+
+    // File descriptor
+    private final FileDescriptor fd;
+
+    // File access mode (immutable)
+    private final boolean writable;
+    private final boolean readable;
+
+    // Required to prevent finalization of creating stream (immutable)
+    private final Object parent;
+
+    // Thread-safe set of IDs of native threads, for signalling
+    private final NativeThreadSet threads = new NativeThreadSet(2);
+
+    // Lock for operations involving position and size
+    private final Object positionLock = new Object();
+
+    private FileChannelImpl(FileDescriptor fd, boolean readable,
+                            boolean writable, Object parent)
+    {
+        this.fd = fd;
+        this.readable = readable;
+        this.writable = writable;
+        this.parent = parent;
+    }
+
+    // Invoked by getChannel() methods
+    // of java.io.File{Input,Output}Stream and RandomAccessFile
+    //
+    public static FileChannel open(FileDescriptor fd,
+                                   boolean readable, boolean writable,
+                                   Object parent)
+    {
+        return new FileChannelImpl(fd, readable, writable, parent);
+    }
+
+    private void ensureOpen() throws IOException {
+        if (!isOpen())
+            throw new ClosedChannelException();
+    }
+
+
+    // -- Standard channel operations --
+
+    protected void implCloseChannel() throws IOException {
+
+        nd.preClose(fd);
+        threads.signal();
+
+        if (parent != null) {
+
+            // Close the fd via the parent stream's close method.  The parent
+            // will reinvoke our close method, which is defined in the
+            // superclass AbstractInterruptibleChannel, but the isOpen logic in
+            // that method will prevent this method from being reinvoked.
+            //
+            ((java.io.Closeable)parent).close();
+        } else {
+            nd.close(fd);
+        }
+
+    }
+
+    public int read(ByteBuffer dst) throws IOException {
+        ensureOpen();
+        if (!readable)
+            throw new NonReadableChannelException();
+        synchronized (positionLock) {
+            int n = 0;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                ti = threads.add();
+                do {
+                    n = IOUtil.read(fd, dst, -1, nd, positionLock);
+                } while ((n == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(n);
+            } finally {
+                threads.remove(ti);
+                end(n > 0);
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    private long read0(ByteBuffer[] dsts) throws IOException {
+        ensureOpen();
+        if (!readable)
+            throw new NonReadableChannelException();
+        synchronized (positionLock) {
+            long n = 0;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                ti = threads.add();
+                do {
+                    n = IOUtil.read(fd, dsts, nd);
+                } while ((n == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(n);
+            } finally {
+                threads.remove(ti);
+                end(n > 0);
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    public long read(ByteBuffer[] dsts, int offset, int length)
+        throws IOException
+    {
+        if ((offset < 0) || (length < 0) || (offset > dsts.length - length))
+           throw new IndexOutOfBoundsException();
+        // ## Fix IOUtil.write so that we can avoid this array copy
+        return read0(Util.subsequence(dsts, offset, length));
+    }
+
+    public int write(ByteBuffer src) throws IOException {
+        ensureOpen();
+        if (!writable)
+            throw new NonWritableChannelException();
+        synchronized (positionLock) {
+            int n = 0;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                ti = threads.add();
+                do {
+                    n = IOUtil.write(fd, src, -1, nd, positionLock);
+                } while ((n == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(n);
+            } finally {
+                threads.remove(ti);
+                end(n > 0);
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    private long write0(ByteBuffer[] srcs) throws IOException {
+        ensureOpen();
+        if (!writable)
+            throw new NonWritableChannelException();
+        synchronized (positionLock) {
+            long n = 0;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                ti = threads.add();
+                do {
+                    n = IOUtil.write(fd, srcs, nd);
+                } while ((n == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(n);
+            } finally {
+                threads.remove(ti);
+                end(n > 0);
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    public long write(ByteBuffer[] srcs, int offset, int length)
+        throws IOException
+    {
+        if ((offset < 0) || (length < 0) || (offset > srcs.length - length))
+           throw new IndexOutOfBoundsException();
+        // ## Fix IOUtil.write so that we can avoid this array copy
+        return write0(Util.subsequence(srcs, offset, length));
+    }
+
+
+    // -- Other operations --
+
+    public long position() throws IOException {
+        ensureOpen();
+        synchronized (positionLock) {
+            long p = -1;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                ti = threads.add();
+                do {
+                    p = position0(fd, -1);
+                } while ((p == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(p);
+            } finally {
+                threads.remove(ti);
+                end(p > -1);
+                assert IOStatus.check(p);
+            }
+        }
+    }
+
+    public FileChannel position(long newPosition) throws IOException {
+        ensureOpen();
+        if (newPosition < 0)
+            throw new IllegalArgumentException();
+        synchronized (positionLock) {
+            long p = -1;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return null;
+                ti = threads.add();
+                do {
+                    p  = position0(fd, newPosition);
+                } while ((p == IOStatus.INTERRUPTED) && isOpen());
+                return this;
+            } finally {
+                threads.remove(ti);
+                end(p > -1);
+                assert IOStatus.check(p);
+            }
+        }
+    }
+
+    public long size() throws IOException {
+        ensureOpen();
+        synchronized (positionLock) {
+            long s = -1;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return -1;
+                ti = threads.add();
+                do {
+                    s = size0(fd);
+                } while ((s == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(s);
+            } finally {
+                threads.remove(ti);
+                end(s > -1);
+                assert IOStatus.check(s);
+            }
+        }
+    }
+
+    public FileChannel truncate(long size) throws IOException {
+        ensureOpen();
+        if (size < 0)
+            throw new IllegalArgumentException();
+        if (size > size())
+            return this;
+        if (!writable)
+            throw new NonWritableChannelException();
+        synchronized (positionLock) {
+            int rv = -1;
+            long p = -1;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return null;
+                ti = threads.add();
+
+                // get current position
+                do {
+                    p = position0(fd, -1);
+                } while ((p == IOStatus.INTERRUPTED) && isOpen());
+                if (!isOpen())
+                    return null;
+                assert p >= 0;
+
+                // truncate file
+                do {
+                    rv = truncate0(fd, size);
+                } while ((rv == IOStatus.INTERRUPTED) && isOpen());
+                if (!isOpen())
+                    return null;
+
+                // set position to size if greater than size
+                if (p > size)
+                    p = size;
+                do {
+                    rv = (int)position0(fd, p);
+                } while ((rv == IOStatus.INTERRUPTED) && isOpen());
+                return this;
+            } finally {
+                threads.remove(ti);
+                end(rv > -1);
+                assert IOStatus.check(rv);
+            }
+        }
+    }
+
+    public void force(boolean metaData) throws IOException {
+        ensureOpen();
+        int rv = -1;
+        int ti = -1;
+        try {
+            begin();
+            if (!isOpen())
+                return;
+            ti = threads.add();
+            do {
+                rv = force0(fd, metaData);
+            } while ((rv == IOStatus.INTERRUPTED) && isOpen());
+        } finally {
+            threads.remove(ti);
+            end(rv > -1);
+            assert IOStatus.check(rv);
+        }
+    }
+
+    // Assume at first that the underlying kernel supports sendfile();
+    // set this to false if we find out later that it doesn't
+    //
+    private static volatile boolean transferSupported = true;
+
+    // Assume that the underlying kernel sendfile() will work if the target
+    // fd is a pipe; set this to false if we find out later that it doesn't
+    //
+    private static volatile boolean pipeSupported = true;
+
+    // Assume that the underlying kernel sendfile() will work if the target
+    // fd is a file; set this to false if we find out later that it doesn't
+    //
+    private static volatile boolean fileSupported = true;
+
+    private long transferToDirectly(long position, int icount,
+                                    WritableByteChannel target)
+        throws IOException
+    {
+        if (!transferSupported)
+            return IOStatus.UNSUPPORTED;
+
+        FileDescriptor targetFD = null;
+        if (target instanceof FileChannelImpl) {
+            if (!fileSupported)
+                return IOStatus.UNSUPPORTED_CASE;
+            targetFD = ((FileChannelImpl)target).fd;
+        } else if (target instanceof SelChImpl) {
+            // Direct transfer to pipe causes EINVAL on some configurations
+//            if ((target instanceof SinkChannelImpl) && !pipeSupported)
+  //              return IOStatus.UNSUPPORTED_CASE;
+            targetFD = ((SelChImpl)target).getFD();
+        }
+        if (targetFD == null)
+            return IOStatus.UNSUPPORTED;
+        int thisFDVal = IOUtil.fdVal(fd);
+        int targetFDVal = IOUtil.fdVal(targetFD);
+        if (thisFDVal == targetFDVal) // Not supported on some configurations
+            return IOStatus.UNSUPPORTED;
+
+        long n = -1;
+        int ti = -1;
+        try {
+            begin();
+            if (!isOpen())
+                return -1;
+            ti = threads.add();
+            do {
+                n = transferTo0(thisFDVal, position, icount, targetFDVal);
+            } while ((n == IOStatus.INTERRUPTED) && isOpen());
+            if (n == IOStatus.UNSUPPORTED_CASE) {
+//                if (target instanceof SinkChannelImpl)
+  //                  pipeSupported = false;
+                if (target instanceof FileChannelImpl)
+                    fileSupported = false;
+                return IOStatus.UNSUPPORTED_CASE;
+            }
+            if (n == IOStatus.UNSUPPORTED) {
+                // Don't bother trying again
+                transferSupported = false;
+                return IOStatus.UNSUPPORTED;
+            }
+            return IOStatus.normalize(n);
+        } finally {
+            threads.remove(ti);
+            end (n > -1);
+        }
+    }
+
+    private long transferToTrustedChannel(long position, int icount,
+                                          WritableByteChannel target)
+        throws IOException
+    {
+        if (  !((target instanceof FileChannelImpl)
+                || (target instanceof SelChImpl)))
+            return IOStatus.UNSUPPORTED;
+
+        // Trusted target: Use a mapped buffer
+        MappedByteBuffer dbb = null;
+        try {
+            dbb = map(MapMode.READ_ONLY, position, icount);
+            // ## Bug: Closing this channel will not terminate the write
+            return target.write(dbb);
+        } finally {
+            if (dbb != null)
+                unmap(dbb);
+        }
+    }
+
+    private long transferToArbitraryChannel(long position, int icount,
+                                            WritableByteChannel target)
+        throws IOException
+    {
+        // Untrusted target: Use a newly-erased buffer
+        int c = Math.min(icount, TRANSFER_SIZE);
+        ByteBuffer bb = Util.getTemporaryDirectBuffer(c);
+        long tw = 0;                    // Total bytes written
+        long pos = position;
+        try {
+            Util.erase(bb);
+            while (tw < icount) {
+                bb.limit(Math.min((int)(icount - tw), TRANSFER_SIZE));
+                int nr = read(bb, pos);
+                if (nr <= 0)
+                    break;
+                bb.flip();
+                // ## Bug: Will block writing target if this channel
+                // ##      is asynchronously closed
+                int nw = target.write(bb);
+                tw += nw;
+                if (nw != nr)
+                    break;
+                pos += nw;
+                bb.clear();
+            }
+            return tw;
+        } catch (IOException x) {
+            if (tw > 0)
+                return tw;
+            throw x;
+        } finally {
+            Util.releaseTemporaryDirectBuffer(bb);
+        }
+    }
+
+    public long transferTo(long position, long count,
+                           WritableByteChannel target)
+        throws IOException
+    {
+        ensureOpen();
+        if (!target.isOpen())
+            throw new ClosedChannelException();
+        if (!readable)
+            throw new NonReadableChannelException();
+        if (target instanceof FileChannelImpl &&
+            !((FileChannelImpl)target).writable)
+            throw new NonWritableChannelException();
+        if ((position < 0) || (count < 0))
+            throw new IllegalArgumentException();
+        long sz = size();
+        if (position > sz)
+            return 0;
+        int icount = (int)Math.min(count, Integer.MAX_VALUE);
+        if ((sz - position) < icount)
+            icount = (int)(sz - position);
+
+        long n;
+
+        // Attempt a direct transfer, if the kernel supports it
+        if ((n = transferToDirectly(position, icount, target)) >= 0)
+            return n;
+
+        // Attempt a mapped transfer, but only to trusted channel types
+        if ((n = transferToTrustedChannel(position, icount, target)) >= 0)
+            return n;
+
+        // Slow path for untrusted targets
+        return transferToArbitraryChannel(position, icount, target);
+    }
+
+    private long transferFromFileChannel(FileChannelImpl src,
+                                         long position, long count)
+        throws IOException
+    {
+        // Note we could loop here to accumulate more at once
+        synchronized (src.positionLock) {
+            long p = src.position();
+            int icount = (int)Math.min(Math.min(count, Integer.MAX_VALUE),
+                                       src.size() - p);
+            // ## Bug: Closing this channel will not terminate the write
+            MappedByteBuffer bb = src.map(MapMode.READ_ONLY, p, icount);
+            try {
+                long n = write(bb, position);
+                src.position(p + n);
+                return n;
+            } finally {
+                unmap(bb);
+            }
+        }
+    }
+
+    private static final int TRANSFER_SIZE = 8192;
+
+    private long transferFromArbitraryChannel(ReadableByteChannel src,
+                                              long position, long count)
+        throws IOException
+    {
+        // Untrusted target: Use a newly-erased buffer
+        int c = (int)Math.min(count, TRANSFER_SIZE);
+        ByteBuffer bb = Util.getTemporaryDirectBuffer(c);
+        long tw = 0;                    // Total bytes written
+        long pos = position;
+        try {
+            Util.erase(bb);
+            while (tw < count) {
+                bb.limit((int)Math.min((count - tw), (long)TRANSFER_SIZE));
+                // ## Bug: Will block reading src if this channel
+                // ##      is asynchronously closed
+                int nr = src.read(bb);
+                if (nr <= 0)
+                    break;
+                bb.flip();
+                int nw = write(bb, pos);
+                tw += nw;
+                if (nw != nr)
+                    break;
+                pos += nw;
+                bb.clear();
+            }
+            return tw;
+        } catch (IOException x) {
+            if (tw > 0)
+                return tw;
+            throw x;
+        } finally {
+            Util.releaseTemporaryDirectBuffer(bb);
+        }
+    }
+
+    public long transferFrom(ReadableByteChannel src,
+                             long position, long count)
+        throws IOException
+    {
+        ensureOpen();
+        if (!src.isOpen())
+            throw new ClosedChannelException();
+        if (!writable)
+            throw new NonWritableChannelException();
+        if ((position < 0) || (count < 0))
+            throw new IllegalArgumentException();
+        if (position > size())
+            return 0;
+        if (src instanceof FileChannelImpl)
+           return transferFromFileChannel((FileChannelImpl)src,
+                                          position, count);
+
+        return transferFromArbitraryChannel(src, position, count);
+    }
+
+    public int read(ByteBuffer dst, long position) throws IOException {
+        if (dst == null)
+            throw new NullPointerException();
+        if (position < 0)
+            throw new IllegalArgumentException("Negative position");
+        if (!readable)
+            throw new NonReadableChannelException();
+        ensureOpen();
+        int n = 0;
+        int ti = -1;
+        try {
+            begin();
+            if (!isOpen())
+                return -1;
+            ti = threads.add();
+            do {
+                n = IOUtil.read(fd, dst, position, nd, positionLock);
+            } while ((n == IOStatus.INTERRUPTED) && isOpen());
+            return IOStatus.normalize(n);
+        } finally {
+            threads.remove(ti);
+            end(n > 0);
+            assert IOStatus.check(n);
+        }
+    }
+
+    public int write(ByteBuffer src, long position) throws IOException {
+        if (src == null)
+            throw new NullPointerException();
+        if (position < 0)
+            throw new IllegalArgumentException("Negative position");
+        if (!writable)
+            throw new NonWritableChannelException();
+        ensureOpen();
+        int n = 0;
+        int ti = -1;
+        try {
+            begin();
+            if (!isOpen())
+                return -1;
+            ti = threads.add();
+            do {
+                n = IOUtil.write(fd, src, position, nd, positionLock);
+            } while ((n == IOStatus.INTERRUPTED) && isOpen());
+            return IOStatus.normalize(n);
+        } finally {
+            threads.remove(ti);
+            end(n > 0);
+            assert IOStatus.check(n);
+        }
+    }
+
+
+    // -- Memory-mapped buffers --
+
+    private static class Unmapper
+        implements Runnable
+    {
+
+        private long address;
+        private long size;
+
+        private Unmapper(long address, long size) {
+            assert (address != 0);
+            this.address = address;
+            this.size = size;
+        }
+
+        public void run() {
+            if (address == 0)
+                return;
+            unmap0(address, size);
+            address = 0;
+        }
+
+    }
+
+    private static void unmap(MappedByteBuffer bb) {
+        Cleaner cl = ((DirectBuffer)bb).cleaner();
+        if (cl != null)
+            cl.clean();
+    }
+
+    private static final int MAP_RO = 0;
+    private static final int MAP_RW = 1;
+    private static final int MAP_PV = 2;
+
+    public MappedByteBuffer map(MapMode mode, long position, long size)
+        throws IOException
+    {
+        ensureOpen();
+        if (position < 0L)
+            throw new IllegalArgumentException("Negative position");
+        if (size < 0L)
+            throw new IllegalArgumentException("Negative size");
+        if (position + size < 0)
+            throw new IllegalArgumentException("Position + size overflow");
+        if (size > Integer.MAX_VALUE)
+            throw new IllegalArgumentException("Size exceeds Integer.MAX_VALUE");
+        int imode = -1;
+        if (mode == MapMode.READ_ONLY)
+            imode = MAP_RO;
+        else if (mode == MapMode.READ_WRITE)
+            imode = MAP_RW;
+        else if (mode == MapMode.PRIVATE)
+            imode = MAP_PV;
+        assert (imode >= 0);
+        if ((mode != MapMode.READ_ONLY) && !writable)
+            throw new NonWritableChannelException();
+        if (!readable)
+            throw new NonReadableChannelException();
+
+        long addr = -1;
+        int ti = -1;
+        try {
+            begin();
+            if (!isOpen())
+                return null;
+            ti = threads.add();
+            if (size() < position + size) { // Extend file size
+                if (!writable) {
+                    throw new IOException("Channel not open for writing " +
+                        "- cannot extend file to required size");
+                }
+                int rv;
+                do {
+                    rv = truncate0(fd, position + size);
+                } while ((rv == IOStatus.INTERRUPTED) && isOpen());
+            }
+            if (size == 0) {
+                addr = 0;
+                if ((!writable) || (imode == MAP_RO))
+                    return Util.newMappedByteBufferR(0, 0, null);
+                else
+                    return Util.newMappedByteBuffer(0, 0, null);
+            }
+
+            int pagePosition = (int)(position % allocationGranularity);
+            long mapPosition = position - pagePosition;
+            long mapSize = size + pagePosition;
+            try {
+                // If no exception was thrown from map0, the address is valid
+                addr = map0(imode, mapPosition, mapSize);
+            } catch (OutOfMemoryError x) {
+                // An OutOfMemoryError may indicate that we've exhausted memory
+                // so force gc and re-attempt map
+                System.gc();
+                try {
+                    Thread.sleep(100);
+                } catch (InterruptedException y) {
+                    Thread.currentThread().interrupt();
+                }
+                try {
+                    addr = map0(imode, mapPosition, mapSize);
+                } catch (OutOfMemoryError y) {
+                    // After a second OOME, fail
+                    throw new IOException("Map failed:" + y);
+                }
+            }
+
+            assert (IOStatus.checkAll(addr));
+            assert (addr % allocationGranularity == 0);
+            int isize = (int)size;
+            Unmapper um = new Unmapper(addr, size + pagePosition);
+            if ((!writable) || (imode == MAP_RO))
+                return Util.newMappedByteBufferR(isize, addr + pagePosition, um);
+            else
+                return Util.newMappedByteBuffer(isize, addr + pagePosition, um);
+        } finally {
+            threads.remove(ti);
+            end(IOStatus.checkAll(addr));
+        }
+    }
+
+
+
+    // -- Native methods --
+
+    // Creates a new mapping
+    private native long map0(int prot, long position, long length)
+        throws IOException;
+
+    // Removes an existing mapping
+    private static native int unmap0(long address, long length);
+
+    // Forces output to device
+    private native int force0(FileDescriptor fd, boolean metaData);
+
+    // Truncates a file
+    private native int truncate0(FileDescriptor fd, long size);
+
+    // Transfers from src to dst, or returns -2 if kernel can't do that
+    private native long transferTo0(int src, long position, long count, int dst);
+
+    // Sets or reports this file's position
+    // If offset is -1, the current position is returned
+    // otherwise the position is set to offset
+    private native long position0(FileDescriptor fd, long offset);
+
+    // Reports this file's size
+    private native long size0(FileDescriptor fd);
+
+    // Caches fieldIDs
+    private static native long initIDs();
+
+    static {
+        Util.load();
+        allocationGranularity = initIDs();
+        nd = new FileDispatcher();
+        isAMappedBufferField = Reflect.lookupField("java.nio.MappedByteBuffer",
+                                          "isAMappedBuffer");
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/FileDispatcher.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/FileDispatcher.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/FileDispatcher.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/FileDispatcher.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,90 @@
+/*
+ * @(#)FileDispatcher.java	1.14 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+
+/**
+ * Allows different platforms to call different native methods
+ * for read and write operations.
+ */
+
+class FileDispatcher extends NativeDispatcher
+{
+
+    static {
+        Util.load();
+	init();
+    }
+
+    int read(FileDescriptor fd, long address, int len) throws IOException {
+        return read0(fd, address, len);
+    }
+
+    int pread(FileDescriptor fd, long address, int len,
+                             long position, Object lock) throws IOException {
+        return pread0(fd, address, len, position);
+    }
+
+    long readv(FileDescriptor fd, long address, int len) throws IOException {
+        return readv0(fd, address, len);
+    }
+
+    int write(FileDescriptor fd, long address, int len) throws IOException {
+        return write0(fd, address, len);
+    }
+
+    int pwrite(FileDescriptor fd, long address, int len,
+                             long position, Object lock) throws IOException
+    {
+        return pwrite0(fd, address, len, position);
+    }
+
+    long writev(FileDescriptor fd, long address, int len)
+	throws IOException
+    {
+        return writev0(fd, address, len);
+    }
+
+    void close(FileDescriptor fd) throws IOException {
+        close0(fd);
+    }
+
+    void preClose(FileDescriptor fd) throws IOException {
+	preClose0(fd);
+    }
+
+    // -- Native methods --
+
+    static native int read0(FileDescriptor fd, long address, int len)
+	throws IOException;
+
+    static native int pread0(FileDescriptor fd, long address, int len,
+                             long position) throws IOException;
+
+    static native long readv0(FileDescriptor fd, long address, int len)
+	throws IOException;
+
+    static native int write0(FileDescriptor fd, long address, int len)
+	throws IOException;
+
+    static native int pwrite0(FileDescriptor fd, long address, int len,
+                             long position) throws IOException;
+
+    static native long writev0(FileDescriptor fd, long address, int len)
+	throws IOException;
+
+    static native void close0(FileDescriptor fd) throws IOException;
+
+    static native void preClose0(FileDescriptor fd) throws IOException;
+
+    static native void closeIntFD(int fd) throws IOException;
+
+    static native void init();
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/FileKey.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/FileKey.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/FileKey.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/FileKey.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2005 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.nio.ch;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+
+/*
+ * Represents a key to a specific file on Solaris or Linux
+ */
+public class FileKey {
+
+    private long st_dev;    // ID of device
+    private long st_ino;    // Inode number 
+    
+    private FileKey() { }    
+
+    public static FileKey create(FileDescriptor fd) {
+        FileKey fk = new FileKey();
+        try {
+            fk.init(fd);
+        } catch (IOException ioe) {
+            throw new Error(ioe);
+        }
+        return fk;
+    }
+
+    public int hashCode() {
+        return (int)(st_dev ^ (st_dev >>> 32)) +
+               (int)(st_ino ^ (st_ino >>> 32));
+    }
+
+    public boolean equals(Object obj) {
+        if (obj == this)
+            return true;
+        if (!(obj instanceof FileKey)) 
+            return false;
+        FileKey other = (FileKey)obj;
+        if ((this.st_dev != other.st_dev) ||
+            (this.st_ino != other.st_ino)) {
+            return false;
+        }
+        return true;
+    }
+     
+    private native void init(FileDescriptor fd) throws IOException;
+    private static native void initIDs();
+    
+    static {
+        initIDs();
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/InheritedChannel.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/InheritedChannel.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/InheritedChannel.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/InheritedChannel.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,222 @@
+/* 
+ * @(#)InheritedChannel.java	1.7 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.nio.ch;
+
+import java.lang.reflect.Constructor;
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.channels.Channel;
+import java.nio.channels.SocketChannel;
+import java.nio.channels.ServerSocketChannel;
+//import java.nio.channels.DatagramChannel;
+import java.nio.channels.spi.SelectorProvider;
+
+class InheritedChannel {
+
+    // the "types" of socket returned by soType0
+    private static final int UNKNOWN 		= -1;
+    private static final int SOCK_STREAM 	= 1;
+    private static final int SOCK_DGRAM 	= 2;
+    
+    // oflag values when opening a file
+    private static final int O_RDONLY		= 0;
+    private static final int O_WRONLY		= 1;
+    private static final int O_RDWR		= 2;
+
+    /*
+     * In order to "detach" the standard streams we dup them to /dev/null.
+     * In order to reduce the possibility of an error at close time we
+     * open /dev/null early - that way we know we won't run out of file 
+     * descriptors at close time. This makes the close operation a 
+     * simple dup2 operation for each of the standard streams.
+     */
+    private static int devnull = -1;
+
+    private static void detachIOStreams() {
+	try {
+	    dup2(devnull, 0);
+	    dup2(devnull, 1);
+	    dup2(devnull, 2);
+	} catch (IOException ioe) {
+	    // this shouldn't happen
+	    throw new InternalError();
+	}
+    }
+
+    /*
+     * Override the implCloseSelectableChannel for each channel type - this     
+     * allows us to "detach" the standard streams after closing and ensures
+     * that the underlying socket really closes.
+     */
+    public static class InheritedSocketChannelImpl extends SocketChannelImpl {
+
+	InheritedSocketChannelImpl(SelectorProvider sp,
+                                   FileDescriptor fd, 
+				   InetSocketAddress remote)
+	    throws IOException 
+ 	{
+	    super(sp, fd, remote);
+	}
+
+	protected void implCloseSelectableChannel() throws IOException {
+	    super.implCloseSelectableChannel();
+	    detachIOStreams();
+	}
+    }
+
+    public static class InheritedServerSocketChannelImpl extends 
+	ServerSocketChannelImpl {
+
+        InheritedServerSocketChannelImpl(SelectorProvider sp, 
+					 FileDescriptor fd)
+	    throws IOException
+        {
+	    super(sp, fd);
+        }
+
+	protected void implCloseSelectableChannel() throws IOException {
+	    super.implCloseSelectableChannel();
+	    detachIOStreams();
+	}
+
+    }
+
+/*    public static class InheritedDatagramChannelImpl extends
+	DatagramChannelImpl {
+
+	InheritedDatagramChannelImpl(SelectorProvider sp, 
+                                     FileDescriptor fd)
+            throws IOException
+        {
+            super(sp, fd);
+        }
+
+	protected void implCloseSelectableChannel() throws IOException {
+	    super.implCloseSelectableChannel();
+	    detachIOStreams();
+	}
+    }
+*/
+    /* 
+     * If there's a SecurityManager then check for the appropriate
+     * RuntimePermission.
+     */
+    private static void checkAccess(Channel c) {
+        SecurityManager sm = System.getSecurityManager();
+	if (sm != null) {
+	    sm.checkPermission(
+		new RuntimePermission("inheritedChannel")
+            );
+	}
+    }
+
+
+    /*
+     * If standard inherited channel is connected to a socket then return a Channel
+     * of the appropriate type based standard input.
+     */
+    private static Channel createChannel() throws IOException {
+
+	// dup the file descriptor - we do this so that for two reasons :-
+	// 1. Avoids any timing issues with FileDescriptor.in being closed
+	//    or redirected while we create the channel.
+	// 2. Allows streams based on file descriptor 0 to co-exist with
+	//    the channel (closing one doesn't impact the other)
+
+	int fdVal = dup(0);
+
+	// Examine the file descriptor - if it's not a socket then we don't
+	// create a channel so we release the file descriptor.
+
+	int st;
+	st = soType0(fdVal);
+	if (st != SOCK_STREAM && st != SOCK_DGRAM) {
+	    close0(fdVal);
+	    return null;
+	}
+
+
+	// Next we create a FileDescriptor for the dup'ed file descriptor
+	// Have to use reflection and also make assumption on how FD
+	// is implemented.
+
+	Class paramTypes[] = { int.class };
+	Constructor ctr = Reflect.lookupConstructor("java.io.FileDescriptor",
+						    paramTypes);
+	Object args[] = { new Integer(fdVal) };
+	FileDescriptor fd = (FileDescriptor)Reflect.invoke(ctr, args);
+
+
+	// Now create the channel. If the socket is a streams socket then
+	// we see if tthere is a peer (ie: connected). If so, then we
+	// create a SocketChannel, otherwise a ServerSocketChannel.
+	// If the socket is a datagram socket then create a DatagramChannel
+
+	SelectorProvider provider = SelectorProvider.provider();
+	assert provider instanceof sun.nio.ch.SelectorProviderImpl;
+
+	Channel c;
+	if (st == SOCK_STREAM) {
+	    InetAddress ia = peerAddress0(fdVal);
+	    if (ia == null) {
+	       c = new InheritedServerSocketChannelImpl(provider, fd);
+	    } else {
+	       int port = peerPort0(fdVal);
+	       assert port > 0;
+	       InetSocketAddress isa = new InetSocketAddress(ia, port);
+	       c = new InheritedSocketChannelImpl(provider, fd, isa);
+	    }
+	} else {
+	    c = null;//new InheritedDatagramChannelImpl(provider, fd);
+	}
+	return c;
+    }
+
+    private static boolean haveChannel = false;
+    private static Channel channel = null;
+
+    /*
+     * Returns a Channel representing the inherited channel if the 
+     * inherited channel is a stream connected to a network socket.
+     */
+    public static synchronized Channel getChannel() throws IOException { 
+	if (devnull < 0) {
+	    devnull = open0("/dev/null", O_RDWR);
+	}
+
+	// If we don't have the channel try to create it
+	if (!haveChannel) {
+	    channel = createChannel();
+	    haveChannel = true;
+	}
+
+	// if there is a channel then do the security check before
+	// returning it.
+	if (channel != null) {
+	    checkAccess(channel);
+	}
+	return channel;
+    }
+
+
+    // -- Native methods --
+
+    private static native int dup(int fd) throws IOException;
+    private static native void dup2(int fd, int fd2) throws IOException;
+    private static native int open0(String path, int oflag) throws IOException;
+    private static native void close0(int fd) throws IOException;
+    private static native int soType0(int fd);
+    private static native InetAddress peerAddress0(int fd);
+    private static native int peerPort0(int fd);
+
+    static {
+        Util.load();
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/Interruptible.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/Interruptible.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/Interruptible.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/Interruptible.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2000 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ */
+
+package sun.nio.ch;
+
+
+public interface Interruptible {
+
+    public void interrupt();
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/IOStatus.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/IOStatus.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/IOStatus.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/IOStatus.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2002-2003 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+
+// Constants for reporting I/O status
+
+final class IOStatus {
+
+    private IOStatus() { }
+
+    static final int EOF = -1;              // End of file
+    static final int UNAVAILABLE = -2;      // Nothing available (non-blocking)
+    static final int INTERRUPTED = -3;      // System call interrupted
+    static final int UNSUPPORTED = -4;      // Operation not supported
+    static final int THROWN = -5;           // Exception thrown in JNI code
+    static final int UNSUPPORTED_CASE = -6; // This case not supported
+
+    // The following two methods are for use in try/finally blocks where a
+    // status value needs to be normalized before being returned to the invoker
+    // but also checked for illegal negative values before the return
+    // completes, like so:
+    //
+    //     int n = 0;
+    //     try {
+    //         begin();
+    //         n = op(fd, buf, ...);
+    //         return IOStatus.normalize(n);    // Converts UNAVAILABLE to zero
+    //     } finally {
+    //         end(n > 0);
+    //         assert IOStatus.check(n);        // Checks other negative values
+    //     }
+    //
+
+    static int normalize(int n) {
+        if (n == UNAVAILABLE)
+            return 0;
+        return n;
+    }
+
+    static boolean check(int n) {
+        return (n >= UNAVAILABLE);
+    }
+
+    static long normalize(long n) {
+        if (n == UNAVAILABLE)
+            return 0;
+        return n;
+    }
+
+    static boolean check(long n) {
+        return (n >= UNAVAILABLE);
+    }
+
+    // Return true iff n is not one of the IOStatus values
+    static boolean checkAll(long n) {
+        return ((n > EOF) || (n < UNSUPPORTED_CASE));
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/IOUtil.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/IOUtil.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/IOUtil.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/IOUtil.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,363 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.net.*;
+import java.nio.ByteBuffer;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+
+/**
+ * File-descriptor based I/O utilities that are shared by NIO classes.
+ */
+
+class IOUtil {
+
+    private IOUtil() { }                // No instantiation
+
+    /*
+     * Returns the index of first buffer in bufs with remaining,
+     * or -1 if there is nothing left
+     */
+    private static int remaining(ByteBuffer[] bufs) {
+        int numBufs = bufs.length;
+        boolean remaining = false;
+        for (int i=0; i<numBufs; i++) {
+            if (bufs[i].hasRemaining()) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    /*
+     * Returns a new ByteBuffer array with only unfinished buffers in it
+     */
+    private static ByteBuffer[] skipBufs(ByteBuffer[] bufs,
+                                         int nextWithRemaining)
+    {
+        int newSize = bufs.length - nextWithRemaining;
+        ByteBuffer[] temp = new ByteBuffer[newSize];
+        for (int i=0; i<newSize; i++) {
+            temp[i] = bufs[i + nextWithRemaining];
+        }
+        return temp;
+    }
+
+    static int write(FileDescriptor fd, ByteBuffer src, long position,
+                     NativeDispatcher nd, Object lock)
+        throws IOException
+    {
+        if (src instanceof DirectBuffer)
+            return writeFromNativeBuffer(fd, src, position, nd, lock);
+
+        // Substitute a native buffer
+        int pos = src.position();
+        int lim = src.limit();
+        assert (pos <= lim);
+        int rem = (pos <= lim ? lim - pos : 0);
+        ByteBuffer bb = null;
+        try {
+            bb = Util.getTemporaryDirectBuffer(rem);
+            bb.put(src);
+            bb.flip();
+            // Do not update src until we see how many bytes were written
+            src.position(pos);
+
+            int n = writeFromNativeBuffer(fd, bb, position, nd, lock);
+            if (n > 0) {
+                // now update src
+                src.position(pos + n);
+            }
+            return n;
+        } finally {
+            Util.releaseTemporaryDirectBuffer(bb);
+        }
+    }
+
+    private static int writeFromNativeBuffer(FileDescriptor fd, ByteBuffer bb,
+                                           long position, NativeDispatcher nd,
+                                             Object lock)
+        throws IOException
+    {
+        int pos = bb.position();
+        int lim = bb.limit();
+        assert (pos <= lim);
+        int rem = (pos <= lim ? lim - pos : 0);
+
+        int written = 0;
+        if (rem == 0)
+            return 0;
+        if (position != -1) {
+            written = nd.pwrite(fd,
+                                ((DirectBuffer)bb).address() + pos,
+                                rem, position, lock);
+        } else {
+            written = nd.write(fd, ((DirectBuffer)bb).address() + pos, rem);
+        }
+        if (written > 0)
+            bb.position(pos + written);
+        return written;
+    }
+
+    static long write(FileDescriptor fd, ByteBuffer[] bufs, NativeDispatcher nd)
+        throws IOException
+    {
+        int nextWithRemaining = remaining(bufs);
+        // if all bufs are empty we should return immediately
+        if (nextWithRemaining < 0)
+            return 0;
+        // If some bufs are empty we should skip them
+        if (nextWithRemaining > 0)
+            bufs = skipBufs(bufs, nextWithRemaining);
+
+        int numBufs = bufs.length;
+        int bytesReadyToWrite = 0;
+
+        // Create shadow to ensure DirectByteBuffers are used
+        ByteBuffer[] shadow = new ByteBuffer[numBufs];
+        for (int i=0; i<numBufs; i++) {
+            if (!(bufs[i] instanceof DirectBuffer)) {
+                int pos = bufs[i].position();
+                int lim = bufs[i].limit();
+                assert (pos <= lim);
+                int rem = (pos <= lim ? lim - pos : 0);
+
+                ByteBuffer bb = ByteBuffer.allocateDirect(rem);
+                shadow[i] = bb;
+                // Leave slow buffer position untouched; it will be updated
+                // after we see how many bytes were really written out
+                bb.put(bufs[i]);
+                bufs[i].position(pos);
+                bb.flip();
+            } else {
+                shadow[i] = bufs[i];
+            }
+        }
+
+        IOVecWrapper vec = null;
+        long bytesWritten = 0;
+        try {
+            // Create a native iovec array
+            vec= new IOVecWrapper(numBufs);
+
+            // Fill in the iovec array with appropriate data
+            for (int i=0; i<numBufs; i++) {
+                ByteBuffer nextBuffer = shadow[i];
+                // put in the buffer addresses
+                long pos = nextBuffer.position();
+                long len = nextBuffer.limit() - pos;
+                bytesReadyToWrite += len;
+                vec.putBase(i, ((DirectBuffer)nextBuffer).address() + pos);
+                vec.putLen(i, len);
+            }
+
+            // Invoke native call to fill the buffers
+            bytesWritten = nd.writev(fd, vec.address, numBufs);
+        } finally {
+            vec.free();
+        }
+        long returnVal = bytesWritten;
+
+        // Notify the buffers how many bytes were taken
+        for (int i=0; i<numBufs; i++) {
+            ByteBuffer nextBuffer = bufs[i];
+            int pos = nextBuffer.position();
+            int lim = nextBuffer.limit();
+            assert (pos <= lim);
+            int len = (pos <= lim ? lim - pos : lim);
+            if (bytesWritten >= len) {
+                bytesWritten -= len;
+                int newPosition = pos + len;
+                nextBuffer.position(newPosition);
+            } else { // Buffers not completely filled
+                if (bytesWritten > 0) {
+                    assert(pos + bytesWritten < (long)Integer.MAX_VALUE);
+                    int newPosition = (int)(pos + bytesWritten);
+                    nextBuffer.position(newPosition);
+                }
+                break;
+            }
+        }
+        return returnVal;
+    }
+
+    static int read(FileDescriptor fd, ByteBuffer dst, long position,
+                    NativeDispatcher nd, Object lock)
+        throws IOException
+    {
+        if (dst.isReadOnly())
+            throw new IllegalArgumentException("Read-only buffer");
+        if (dst instanceof DirectBuffer)
+            return readIntoNativeBuffer(fd, dst, position, nd, lock);
+
+        // Substitute a native buffer
+        ByteBuffer bb = null;
+        try {
+            bb = Util.getTemporaryDirectBuffer(dst.remaining());
+            int n = readIntoNativeBuffer(fd, bb, position, nd, lock);
+            bb.flip();
+            if (n > 0)
+                dst.put(bb);
+            return n;
+        } finally {
+            Util.releaseTemporaryDirectBuffer(bb);
+        }
+    }
+
+    private static int readIntoNativeBuffer(FileDescriptor fd, ByteBuffer bb,
+                                            long position, NativeDispatcher nd,
+                                            Object lock)
+        throws IOException
+    {
+        int pos = bb.position();
+        int lim = bb.limit();
+        assert (pos <= lim);
+        int rem = (pos <= lim ? lim - pos : 0);
+
+        if (rem == 0)
+            return 0;
+        int n = 0;
+        if (position != -1) {
+            n = nd.pread(fd, ((DirectBuffer)bb).address() + pos,
+                         rem, position, lock);
+        } else {
+            n = nd.read(fd, ((DirectBuffer)bb).address() + pos, rem);
+        }
+        if (n > 0)
+            bb.position(pos + n);
+        return n;
+    }
+
+    static long read(FileDescriptor fd, ByteBuffer[] bufs, NativeDispatcher nd)
+        throws IOException
+    {
+        int nextWithRemaining = remaining(bufs);
+        // if all bufs are empty we should return immediately
+        if (nextWithRemaining < 0)
+            return 0;
+        // If some bufs are empty we should skip them
+        if (nextWithRemaining > 0)
+            bufs = skipBufs(bufs, nextWithRemaining);
+
+        int numBufs = bufs.length;
+
+        // Read into the shadow to ensure DirectByteBuffers are used
+        ByteBuffer[] shadow = new ByteBuffer[numBufs];
+        for (int i=0; i<numBufs; i++) {
+            if (bufs[i].isReadOnly())
+                throw new IllegalArgumentException("Read-only buffer");
+            if (!(bufs[i] instanceof DirectBuffer)) {
+                shadow[i] = ByteBuffer.allocateDirect(bufs[i].remaining());
+            } else {
+                shadow[i] = bufs[i];
+            }
+        }
+
+        IOVecWrapper vec = null;
+        long bytesRead = 0;
+        try {
+            // Create a native iovec array
+            vec = new IOVecWrapper(numBufs);
+
+            // Fill in the iovec array with appropriate data
+            for (int i=0; i<numBufs; i++) {
+                ByteBuffer nextBuffer = shadow[i];
+                // put in the buffer addresses
+                long pos = nextBuffer.position();
+                long len = nextBuffer.remaining();
+                vec.putBase(i, ((DirectBuffer)nextBuffer).address() + pos);
+                vec.putLen(i, len);
+            }
+
+            // Invoke native call to fill the buffers
+            bytesRead = nd.readv(fd, vec.address, numBufs);
+        } finally {
+            vec.free();
+        }
+        long returnVal = bytesRead;
+
+        // Notify the buffers how many bytes were read
+        for (int i=0; i<numBufs; i++) {
+            ByteBuffer nextBuffer = shadow[i];
+            // Note: should this have been cached from above?
+            int pos = nextBuffer.position();
+            int len = nextBuffer.remaining();
+            if (bytesRead >= len) {
+                bytesRead -= len;
+                int newPosition = pos + len;
+                nextBuffer.position(newPosition);
+            } else { // Buffers not completely filled
+                if (bytesRead > 0) {
+                    assert(pos + bytesRead < (long)Integer.MAX_VALUE);
+                    int newPosition = (int)(pos + bytesRead);
+                    nextBuffer.position(newPosition);
+                }
+                break;
+            }
+        }
+
+        // Put results from shadow into the slow buffers
+        for (int i=0; i<numBufs; i++) {
+            if (!(bufs[i] instanceof DirectBuffer)) {
+                shadow[i].flip();
+                bufs[i].put(shadow[i]);
+            }
+        }
+
+        return returnVal;
+    }
+
+    static FileDescriptor newFD(int i) {
+        FileDescriptor fd = new FileDescriptor();
+        setfdVal(fd, i);
+        return fd;
+    }
+
+    static native boolean randomBytes(byte[] someBytes);
+
+    static native void initPipe(int[] fda, boolean blocking);
+
+    static native boolean drain(int fd) throws IOException;
+
+    static native void configureBlocking(FileDescriptor fd, boolean blocking)
+        throws IOException;
+
+    static native int fdVal(FileDescriptor fd);
+
+    static native void setfdVal(FileDescriptor fd, int value);
+
+    static native void initIDs();
+
+    static {
+        // Note that IOUtil.initIDs is called from within Util.load.
+        Util.load();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/IOVecWrapper.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/IOVecWrapper.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/IOVecWrapper.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/IOVecWrapper.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import sun.misc.*;
+
+
+/**
+ * Manipulates a native array of iovec structs on Solaris:
+ *
+ * typedef struct iovec {
+ *    caddr_t  iov_base;
+      int      iov_len;
+ * } iovec_t;
+ *
+ * @author Mike McCloskey
+ * @since 1.4
+ */
+
+class IOVecWrapper {
+
+    // Miscellaneous constants
+    static int BASE_OFFSET = 0;
+    static int LEN_OFFSET;
+    static int SIZE_IOVEC;
+
+    // The iovec array
+    private AllocatedNativeObject vecArray;
+
+    // Base address of this array
+    long address;
+
+    // Address size in bytes
+    static int addressSize;
+
+    IOVecWrapper(int newSize) {
+        newSize = (newSize + 1) * SIZE_IOVEC;
+        vecArray = new AllocatedNativeObject(newSize, false);
+        address = vecArray.address();
+    }
+
+    void putBase(int i, long base) {
+        int offset = SIZE_IOVEC * i + BASE_OFFSET;
+        if (addressSize == 4)
+            vecArray.putInt(offset, (int)base);
+        else
+            vecArray.putLong(offset, base);
+    }
+
+    void putLen(int i, long len) {
+        int offset = SIZE_IOVEC * i + LEN_OFFSET;
+        if (addressSize == 4)
+            vecArray.putInt(offset, (int)len);
+        else
+            vecArray.putLong(offset, len);
+    }
+
+    void free() {
+        vecArray.free();
+    }
+
+    static {
+        addressSize = Util.unsafe().addressSize();
+        LEN_OFFSET = addressSize;
+        SIZE_IOVEC = (short) (addressSize * 2);
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/NativeDispatcher.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/NativeDispatcher.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/NativeDispatcher.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/NativeDispatcher.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+
+/**
+ * Allows different platforms to call different native methods
+ * for read and write operations.
+ */
+
+abstract class NativeDispatcher
+{
+
+    abstract int read(FileDescriptor fd, long address, int len)
+        throws IOException;
+
+    int pread(FileDescriptor fd, long address, int len,
+                             long position, Object lock) throws IOException
+    {
+        throw new IOException("Operation Unsupported");
+    }
+
+    abstract long readv(FileDescriptor fd, long address, int len)
+        throws IOException;
+
+    abstract int write(FileDescriptor fd, long address, int len)
+        throws IOException;
+
+    int pwrite(FileDescriptor fd, long address, int len,
+                             long position, Object lock) throws IOException
+    {
+        throw new IOException("Operation Unsupported");
+    }
+
+    abstract long writev(FileDescriptor fd, long address, int len)
+        throws IOException;
+
+    abstract void close(FileDescriptor fd) throws IOException;
+
+    // Prepare the given fd for closing by duping it to a known internal fd
+    // that's already closed.  This is necessary on some operating systems
+    // (Solaris and Linux) to prevent fd recycling.
+    //
+    void preClose(FileDescriptor fd) throws IOException {
+        // Do nothing by default; this is only needed on Unix
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/NativeObject.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/NativeObject.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/NativeObject.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/NativeObject.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,351 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ */
+
+package sun.nio.ch;                                     // Formerly in sun.misc
+
+import java.nio.ByteOrder;
+import sun.misc.Unsafe;
+
+
+// ## In the fullness of time, this class will be eliminated
+
+/**
+ * Proxies for objects that reside in native memory.
+ */
+
+class NativeObject {                                    // package-private
+
+    protected static final Unsafe unsafe = Unsafe.getUnsafe();
+
+    // Native allocation address;
+    // may be smaller than the base address due to page-size rounding
+    //
+    protected long allocationAddress;
+
+    // Native base address
+    //
+    private final long address;
+
+    /**
+     * Creates a new native object that is based at the given native address.
+     */
+    NativeObject(long address) {
+        this.allocationAddress = address;
+        this.address = address;
+    }
+
+    /**
+     * Creates a new native object allocated at the given native address but
+     * whose base is at the additional offset.
+     */
+    NativeObject(long address, long offset) {
+        this.allocationAddress = address;
+        this.address = address + offset;
+    }
+
+    // Invoked only by AllocatedNativeObject
+    //
+    protected NativeObject(int size, boolean pageAligned) {
+        if (!pageAligned) {
+            this.allocationAddress = unsafe.allocateMemory(size);
+            this.address = this.allocationAddress;
+        } else {
+            int ps = pageSize();
+            long a = unsafe.allocateMemory(size + ps);
+            this.allocationAddress = a;
+            this.address = a + ps - (a & (ps - 1));
+        }
+    }
+
+    /**
+     * Returns the native base address of this native object.
+     *
+     * @return The native base address
+     */
+    long address() {
+        return address;
+    }
+
+    long allocationAddress() {
+        return allocationAddress;
+    }
+
+    /**
+     * Creates a new native object starting at the given offset from the base
+     * of this native object.
+     *
+     * @param  offset
+     *         The offset from the base of this native object that is to be
+     *         the base of the new native object
+     *
+     * @return The newly created native object
+     */
+    NativeObject subObject(int offset) {
+        return new NativeObject(offset + address);
+    }
+
+    /**
+     * Reads an address from this native object at the given offset and
+     * constructs a native object using that address.
+     *
+     * @param  offset
+     *         The offset of the address to be read.  Note that the size of an
+     *         address is implementation-dependent.
+     *
+     * @return The native object created using the address read from the
+     *         given offset
+     */
+    NativeObject getObject(int offset) {
+        long newAddress = 0L;
+        switch (addressSize()) {
+            case 8:
+                newAddress = unsafe.getLong(offset + address);
+                break;
+            case 4:
+                newAddress = unsafe.getInt(offset + address) & 0x00000000FFFFFFFF;
+                break;
+            default:
+                throw new InternalError("Address size not supported");
+        }
+
+        return new NativeObject(newAddress);
+    }
+
+    /**
+     * Writes the base address of the given native object at the given offset
+     * of this native object.
+     *
+     * @param  offset
+     *         The offset at which the address is to be written.  Note that the
+     *         size of an address is implementation-dependent.
+     *
+     * @param  ob
+     *         The native object whose address is to be written
+     */
+    void putObject(int offset, NativeObject ob) {
+        switch (addressSize()) {
+            case 8:
+                putLong(offset, ob.address);
+                break;
+            case 4:
+                putInt(offset, (int)(ob.address & 0x00000000FFFFFFFF));
+                break;
+            default:
+                throw new InternalError("Address size not supported");
+        }
+    }
+
+
+    /* -- Value accessors: No range checking! -- */
+
+    /**
+     * Reads a byte starting at the given offset from base of this native
+     * object.
+     *
+     * @param  offset
+     *         The offset at which to read the byte
+     *
+     * @return The byte value read
+     */
+    final byte getByte(int offset) {
+        return unsafe.getByte(offset + address);
+    }
+
+    /**
+     * Writes a byte at the specified offset from this native object's
+     * base address.
+     *
+     * @param  offset
+     *         The offset at which to write the byte
+     *
+     * @param  value
+     *         The byte value to be written
+     */
+    final void putByte(int offset, byte value) {
+        unsafe.putByte(offset + address,  value);
+    }
+
+    /**
+     * Reads a short starting at the given offset from base of this native
+     * object.
+     *
+     * @param  offset
+     *         The offset at which to read the short
+     *
+     * @return The short value read
+     */
+    final short getShort(int offset) {
+        return unsafe.getShort(offset + address);
+    }
+
+    /**
+     * Writes a short at the specified offset from this native object's
+     * base address.
+     *
+     * @param  offset
+     *         The offset at which to write the short
+     *
+     * @param  value
+     *         The short value to be written
+     */
+    final void putShort(int offset, short value) {
+        unsafe.putShort(offset + address,  value);
+    }
+
+    /**
+     * Reads a char starting at the given offset from base of this native
+     * object.
+     *
+     * @param  offset
+     *         The offset at which to read the char
+     *
+     * @return The char value read
+     */
+    final char getChar(int offset) {
+        return unsafe.getChar(offset + address);
+    }
+
+    /**
+     * Writes a char at the specified offset from this native object's
+     * base address.
+     *
+     * @param  offset
+     *         The offset at which to write the char
+     *
+     * @param  value
+     *         The char value to be written
+     */
+    final void putChar(int offset, char value) {
+        unsafe.putChar(offset + address,  value);
+    }
+
+    /**
+     * Reads an int starting at the given offset from base of this native
+     * object.
+     *
+     * @param  offset
+     *         The offset at which to read the int
+     *
+     * @return The int value read
+     */
+    final int getInt(int offset) {
+        return unsafe.getInt(offset + address);
+    }
+
+    /**
+     * Writes an int at the specified offset from this native object's
+     * base address.
+     *
+     * @param  offset
+     *         The offset at which to write the int
+     *
+     * @param  value
+     *         The int value to be written
+     */
+    final void putInt(int offset, int value) {
+        unsafe.putInt(offset + address, value);
+    }
+
+    /**
+     * Reads a long starting at the given offset from base of this native
+     * object.
+     *
+     * @param  offset
+     *         The offset at which to read the long
+     *
+     * @return The long value read
+     */
+    final long getLong(int offset) {
+        return unsafe.getLong(offset + address);
+    }
+
+    /**
+     * Writes a long at the specified offset from this native object's
+     * base address.
+     *
+     * @param  offset
+     *         The offset at which to write the long
+     *
+     * @param  value
+     *         The long value to be written
+     */
+    final void putLong(int offset, long value) {
+        unsafe.putLong(offset + address, value);
+    }
+
+    /**
+     * Returns the native architecture's address size in bytes.
+     *
+     * @return The address size of the native architecture
+     */
+    static int addressSize() {
+        return unsafe.addressSize();
+    }
+
+    // Cache for byte order
+    private static ByteOrder byteOrder = null;
+
+    /**
+     * Returns the byte order of the underlying hardware.
+     *
+     * @return  An instance of {@link java.nio.ByteOrder}
+     */
+    static ByteOrder byteOrder() {
+        if (byteOrder != null)
+            return byteOrder;
+        long a = unsafe.allocateMemory(8);
+        try {
+            unsafe.putLong(a, 0x0102030405060708L);
+            byte b = unsafe.getByte(a);
+            switch (b) {
+            case 0x01: byteOrder = ByteOrder.BIG_ENDIAN;     break;
+            case 0x08: byteOrder = ByteOrder.LITTLE_ENDIAN;  break;
+            default:
+                assert false;
+            }
+        } finally {
+            unsafe.freeMemory(a);
+        }
+        return byteOrder;
+    }
+
+    // Cache for page size
+    private static int pageSize = -1;
+
+    /**
+     * Returns the page size of the underlying hardware.
+     *
+     * @return  The page size, in bytes
+     */
+    static int pageSize() {
+        if (pageSize == -1)
+            pageSize = unsafe.pageSize();
+        return pageSize;
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/NativeThread.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/NativeThread.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/NativeThread.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/NativeThread.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,43 @@
+/*
+ * @(#)NativeThread.java	1.4 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.nio.ch;
+
+
+// Signalling operations on native threads
+//
+// On some operating systems (e.g., Linux), closing a channel while another
+// thread is blocked in an I/O operation upon that channel does not cause that
+// thread to be released.  This class provides access to the native threads
+// upon which Java threads are built, and defines a simple signal mechanism
+// that can be used to release a native thread from a blocking I/O operation.
+// On systems that do not require this type of signalling, the current() method
+// always returns zero and the signal(long) method has no effect.
+
+
+class NativeThread {
+
+    // Returns an opaque token representing the native thread underlying the
+    // invoking Java thread.  On systems that do not require signalling, this
+    // method always returns zero.
+    //
+    static native long current();
+
+    // Signals the given native thread so as to release it from a blocking I/O
+    // operation.  On systems that do not require signalling, this method has
+    // no effect.
+    //
+    static native void signal(long nt);
+
+    static native void init();
+
+    static {
+	Util.load();
+	init();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/NativeThreadSet.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/NativeThreadSet.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/NativeThreadSet.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/NativeThreadSet.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2002-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+
+// Special-purpose data structure for sets of native threads
+
+
+class NativeThreadSet {
+
+    private long[] elts;
+    private int used = 0;
+
+    NativeThreadSet(int n) {
+        elts = new long[n];
+    }
+
+    // Adds the current native thread to this set, returning its index so that
+    // it can efficiently be removed later.
+    //
+    int add() {
+        long th = NativeThread.current();
+        if (th == -1)
+            return -1;
+        synchronized (this) {
+            int start = 0;
+            if (used >= elts.length) {
+                int on = elts.length;
+                int nn = on * 2;
+                long[] nelts = new long[nn];
+                System.arraycopy(elts, 0, nelts, 0, on);
+                elts = nelts;
+                start = on;
+            }
+            for (int i = start; i < elts.length; i++) {
+                if (elts[i] == 0) {
+                    elts[i] = th;
+                    used++;
+                    return i;
+                }
+            }
+            assert false;
+            return -1;
+        }
+    }
+
+    // Removes the thread at the given index.
+    //
+    void remove(int i) {
+        if (i < 0)
+            return;
+        synchronized (this) {
+            elts[i] = 0;
+            used--;
+        }
+    }
+
+    // Signals all threads in this set.
+    //
+    void signal() {
+        synchronized (this) {
+            int u = used;
+            int n = elts.length;
+            for (int i = 0; i < n; i++) {
+                long th = elts[i];
+                if (th == 0)
+                    continue;
+                NativeThread.signal(th);
+                if (--u == 0)
+                    break;
+            }
+        }
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/Net.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/Net.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/Net.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/Net.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,182 @@
+/*
+ * Copyright 2000-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+import java.lang.reflect.*;
+import java.net.*;
+import java.nio.channels.*;
+
+
+class Net {                                             // package-private
+
+    private Net() { }
+
+
+    // -- Miscellaneous utilities --
+
+    static InetSocketAddress checkAddress(SocketAddress sa) {
+        if (sa == null)
+            throw new IllegalArgumentException();
+        if (!(sa instanceof InetSocketAddress))
+            throw new UnsupportedAddressTypeException(); // ## needs arg
+        InetSocketAddress isa = (InetSocketAddress)sa;
+        if (isa.isUnresolved())
+            throw new UnresolvedAddressException(); // ## needs arg
+        return isa;
+    }
+
+    static InetSocketAddress asInetSocketAddress(SocketAddress sa) {
+        if (!(sa instanceof InetSocketAddress))
+            throw new UnsupportedAddressTypeException();
+        return (InetSocketAddress)sa;
+    }
+
+    static void translateToSocketException(Exception x)
+        throws SocketException
+    {
+        if (x instanceof SocketException)
+            throw (SocketException)x;
+        Exception nx = x;
+        if (x instanceof ClosedChannelException)
+            nx = new SocketException("Socket is closed");
+        else if (x instanceof AlreadyBoundException)
+            nx = new SocketException("Already bound");
+        else if (x instanceof NotYetBoundException)
+            nx = new SocketException("Socket is not bound yet");
+        else if (x instanceof UnsupportedAddressTypeException)
+            nx = new SocketException("Unsupported address type");
+        else if (x instanceof UnresolvedAddressException) {
+            nx = new SocketException("Unresolved address");
+        }
+        if (nx != x)
+            nx.initCause(x);
+
+        if (nx instanceof SocketException)
+            throw (SocketException)nx;
+        else if (nx instanceof RuntimeException)
+            throw (RuntimeException)nx;
+        else
+            throw new Error("Untranslated exception", nx);
+    }
+
+    static void translateException(Exception x,
+                                   boolean unknownHostForUnresolved)
+        throws IOException
+    {
+        if (x instanceof IOException)
+            throw (IOException)x;
+        // Throw UnknownHostException from here since it cannot
+        // be thrown as a SocketException
+        if (unknownHostForUnresolved &&
+            (x instanceof UnresolvedAddressException))
+        {
+             throw new UnknownHostException();
+        }
+        translateToSocketException(x);
+    }
+
+    static void translateException(Exception x)
+        throws IOException
+    {
+        translateException(x, false);
+    }
+
+
+    // -- Socket operations --
+
+    static FileDescriptor socket(boolean stream) {
+        return IOUtil.newFD(socket0(stream, false));
+    }
+
+    static FileDescriptor serverSocket(boolean stream) {
+        return IOUtil.newFD(socket0(stream, true));
+    }
+
+    // Due to oddities SO_REUSEADDR on windows reuse is ignored
+    private static native int socket0(boolean stream, boolean reuse);
+
+    static native void bind(FileDescriptor fd, InetAddress addr, int port)
+        throws IOException;
+
+    static native int connect(FileDescriptor fd,
+                              InetAddress remote,
+                              int remotePort,
+                              int trafficClass)
+        throws IOException;
+
+
+    private static native int localPort(FileDescriptor fd)
+        throws IOException;
+
+    private static native InetAddress localInetAddress(FileDescriptor fd)
+        throws IOException;
+
+    static InetSocketAddress localAddress(FileDescriptor fd) {
+        try {
+            return new InetSocketAddress(localInetAddress(fd),
+                                         localPort(fd));
+        } catch (IOException x) {
+            throw new Error(x);         // Can't happen
+        }
+    }
+
+    static int localPortNumber(FileDescriptor fd) {
+        try {
+            return localPort(fd);
+        } catch (IOException x) {
+            throw new Error(x);         // Can't happen
+        }
+    }
+
+    private static native int getIntOption0(FileDescriptor fd, int opt)
+        throws IOException;
+
+    static int getIntOption(FileDescriptor fd, int opt)
+        throws IOException
+    {
+        return getIntOption0(fd, opt);
+    }
+
+
+    private static native void setIntOption0(FileDescriptor fd,
+                                             int opt, int arg)
+        throws IOException;
+
+    static void setIntOption(FileDescriptor fd, int opt, int arg)
+        throws IOException
+    {
+        setIntOption0(fd, opt, arg);
+    }
+
+    private static native void initIDs();
+
+    static {
+        Util.load();
+        initIDs();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/OptionAdaptor.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/OptionAdaptor.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/OptionAdaptor.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/OptionAdaptor.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,225 @@
+/*
+ * Copyright 2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+import java.net.*;
+import java.nio.*;
+import java.nio.channels.*;
+
+
+// Adaptor class for java.net-style options
+//
+// The option get/set methods in the socket, server-socket, and datagram-socket
+// adaptors delegate to an instance of this class.
+//
+
+class OptionAdaptor {                                   // package-private
+
+    private final SocketOpts.IP opts;
+
+    OptionAdaptor(SocketChannelImpl sc) {
+        opts = (SocketOpts.IP)sc.options();
+    }
+
+    OptionAdaptor(ServerSocketChannelImpl ssc) {
+        opts = (SocketOpts.IP)ssc.options();
+    }
+
+    private SocketOpts.IP opts() {
+        return opts;
+    }
+
+    private SocketOpts.IP.TCP tcpOpts() {
+        return (SocketOpts.IP.TCP)opts;
+    }
+
+    public void setTcpNoDelay(boolean on) throws SocketException {
+        try {
+            tcpOpts().noDelay(on);
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+        }
+    }
+
+    public boolean getTcpNoDelay() throws SocketException {
+        try {
+            return tcpOpts().noDelay();
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+            return false;               // Never happens
+        }
+    }
+
+    public void setSoLinger(boolean on, int linger) throws SocketException {
+        try {
+            if (linger > 65535)
+                linger = 65535;
+            opts().linger(on ? linger : -1);
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+        }
+    }
+
+    public int getSoLinger() throws SocketException {
+        try {
+            return opts().linger();
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+            return 0;                   // Never happens
+        }
+    }
+
+    public void setOOBInline(boolean on) throws SocketException {
+        try {
+            opts().outOfBandInline(on);
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+        }
+    }
+
+    public boolean getOOBInline() throws SocketException {
+        try {
+            return opts().outOfBandInline();
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+            return false;               // Never happens
+        }
+    }
+
+    public void setSendBufferSize(int size)
+        throws SocketException
+    {
+        try {
+            opts().sendBufferSize(size);
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+        }
+    }
+
+    public int getSendBufferSize() throws SocketException {
+        try {
+            return opts().sendBufferSize();
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+            return 0;                   // Never happens
+        }
+    }
+
+    public void setReceiveBufferSize(int size)
+        throws SocketException
+    {
+        try {
+            opts().receiveBufferSize(size);
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+        }
+    }
+
+    public int getReceiveBufferSize() throws SocketException {
+        try {
+            return opts().receiveBufferSize();
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+            return 0;                   // Never happens
+        }
+    }
+
+    public void setKeepAlive(boolean on) throws SocketException {
+        try {
+            opts().keepAlive(on);
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+        }
+    }
+
+    public boolean getKeepAlive() throws SocketException {
+        try {
+            return opts().keepAlive();
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+            return false;               // Never happens
+        }
+    }
+
+    public void setTrafficClass(int tc) throws SocketException {
+        if (tc < 0 || tc > 255)
+            throw new IllegalArgumentException("tc is not in range 0 -- 255");
+        try {
+            opts().typeOfService(tc);
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+        }
+    }
+
+    public int getTrafficClass() throws SocketException {
+        try {
+            return opts().typeOfService();
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+            return 0;                   // Never happens
+        }
+    }
+
+    public void setReuseAddress(boolean on)
+        throws SocketException
+    {
+        try {
+            opts().reuseAddress(on);
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+        }
+    }
+
+    public boolean getReuseAddress() throws SocketException {
+        try {
+            return opts().reuseAddress();
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+            return false;               // Never happens
+        }
+    }
+
+    public void setBroadcast(boolean on)
+        throws SocketException
+    {
+        try {
+            opts().broadcast(on);
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+        }
+    }
+
+    public boolean getBroadcast() throws SocketException {
+        try {
+            return opts().broadcast();
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+            return false;               // Never happens
+        }
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/PollArrayWrapper.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/PollArrayWrapper.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/PollArrayWrapper.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/PollArrayWrapper.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,112 @@
+/*
+ * @(#)PollArrayWrapper.java	1.13 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.nio.ch;
+
+import sun.misc.*;
+
+
+/**
+ * Manipulates a native array of pollfd structs on Solaris:
+ *
+ * typedef struct pollfd {
+ *    int fd;
+ *    short events;
+ *    short revents;
+ * } pollfd_t;
+ *
+ * @author Mike McCloskey
+ * @version 1.13, 05/11/17
+ * @since 1.4
+ */
+
+class PollArrayWrapper extends AbstractPollArrayWrapper {
+
+    static final short POLLCONN = POLLOUT;
+
+    // File descriptor to write for interrupt
+    int interruptFD;
+
+    PollArrayWrapper(int newSize) {
+        newSize = (newSize + 1) * SIZE_POLLFD;
+        pollArray = new AllocatedNativeObject(newSize, false);
+        pollArrayAddress = pollArray.address();
+        totalChannels = 1;
+    }
+
+    void initInterrupt(int fd0, int fd1) {
+        interruptFD = fd1;
+        putDescriptor(0, fd0);
+        putEventOps(0, POLLIN);
+        putReventOps(0, 0);
+    }
+
+    void release(int i) {
+        return;
+    }
+
+    void free() {
+        pollArray.free();
+    }
+
+    /**
+     * Prepare another pollfd struct for use.
+     */
+    void addEntry(SelChImpl sc) {
+        putDescriptor(totalChannels, IOUtil.fdVal(sc.getFD()));
+        putEventOps(totalChannels, 0);
+        putReventOps(totalChannels, 0);
+        totalChannels++;
+    }
+
+    /**
+     * Writes the pollfd entry from the source wrapper at the source index
+     * over the entry in the target wrapper at the target index. The source
+     * array remains unchanged unless the source array and the target are
+     * the same array.
+     */
+    static void replaceEntry(PollArrayWrapper source, int sindex,
+                      PollArrayWrapper target, int tindex) {
+        target.putDescriptor(tindex, source.getDescriptor(sindex));
+        target.putEventOps(tindex, source.getEventOps(sindex));
+        target.putReventOps(tindex, source.getReventOps(sindex));
+    }
+
+    /**
+     * Grows the pollfd array to a size that will accommodate newSize
+     * pollfd entries. This method does no checking of the newSize
+     * to determine if it is in fact bigger than the old size: it
+     * always reallocates an array of the new size.
+     */
+    void grow(int newSize) {
+        // create new array
+        PollArrayWrapper temp = new PollArrayWrapper(newSize);
+
+        // Copy over existing entries
+        for (int i=0; i<totalChannels; i++)
+            replaceEntry(this, i, temp, i);
+
+        // Swap new array into pollArray field
+        pollArray.free();
+        pollArray = temp.pollArray;
+        pollArrayAddress = pollArray.address();
+    }
+
+    int poll(int numfds, int offset, long timeout) {
+        return poll0(pollArrayAddress + (offset * SIZE_POLLFD),
+                     numfds, timeout);
+    }
+
+    public void interrupt() {
+        interrupt(interruptFD);
+    }
+
+    private native int poll0(long pollAddress, int numfds, long timeout);
+
+    private static native void interrupt(int fd);
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/Reflect.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/Reflect.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/Reflect.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/Reflect.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2000-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+import java.lang.reflect.*;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+
+
+class Reflect {                                 // package-private
+
+    private Reflect() { }
+
+    private static class ReflectionError extends Error {
+        private static final long serialVersionUID = -8659519328078164097L;
+        ReflectionError(Throwable x) {
+            super(x);
+        }
+    }
+
+    private static void setAccessible(final AccessibleObject ao) {
+        AccessController.doPrivileged(new PrivilegedAction() {
+                public Object run() {
+                    ao.setAccessible(true);
+                    return null;
+                }});
+    }
+
+    static Constructor lookupConstructor(String className,
+                                         Class[] paramTypes)
+    {
+        try {
+            Class cl = Class.forName(className);
+            Constructor c = cl.getDeclaredConstructor(paramTypes);
+            setAccessible(c);
+            return c;
+        } catch (ClassNotFoundException x) {
+            throw new ReflectionError(x);
+        } catch (NoSuchMethodException x) {
+            throw new ReflectionError(x);
+        }
+    }
+
+    static Object invoke(Constructor c, Object[] args) {
+        try {
+            return c.newInstance(args);
+        } catch (InstantiationException x) {
+            throw new ReflectionError(x);
+        } catch (IllegalAccessException x) {
+            throw new ReflectionError(x);
+        } catch (InvocationTargetException x) {
+            throw new ReflectionError(x);
+        }
+    }
+
+    static Method lookupMethod(String className,
+                               String methodName,
+                               Class[] paramTypes)
+    {
+        try {
+            Class cl = Class.forName(className);
+            Method m = cl.getDeclaredMethod(methodName, paramTypes);
+            setAccessible(m);
+            return m;
+        } catch (ClassNotFoundException x) {
+            throw new ReflectionError(x);
+        } catch (NoSuchMethodException x) {
+            throw new ReflectionError(x);
+        }
+    }
+
+    static Object invoke(Method m, Object ob, Object[] args) {
+        try {
+            return m.invoke(ob, args);
+        } catch (IllegalAccessException x) {
+            throw new ReflectionError(x);
+        } catch (InvocationTargetException x) {
+            throw new ReflectionError(x);
+        }
+    }
+
+    static Object invokeIO(Method m, Object ob, Object[] args)
+        throws IOException
+    {
+        try {
+            return m.invoke(ob, args);
+        } catch (IllegalAccessException x) {
+            throw new ReflectionError(x);
+        } catch (InvocationTargetException x) {
+            if (IOException.class.isInstance(x.getCause()))
+                throw (IOException)x.getCause();
+            throw new ReflectionError(x);
+        }
+    }
+
+    static Field lookupField(String className, String fieldName) {
+        try {
+            Class cl = Class.forName(className);
+            Field f = cl.getDeclaredField(fieldName);
+            setAccessible(f);
+            return f;
+        } catch (ClassNotFoundException x) {
+            throw new ReflectionError(x);
+        } catch (NoSuchFieldException x) {
+            throw new ReflectionError(x);
+        }
+    }
+
+    static Object get(Object ob, Field f) {
+        try {
+            return f.get(ob);
+        } catch (IllegalAccessException x) {
+            throw new ReflectionError(x);
+        }
+    }
+
+    static Object get(Field f) {
+        return get(null, f);
+    }
+
+    static void set(Object ob, Field f, Object val) {
+        try {
+            f.set(ob, val);
+        } catch (IllegalAccessException x) {
+            throw new ReflectionError(x);
+        }
+    }
+
+    static void setInt(Object ob, Field f, int val) {
+        try {
+            f.setInt(ob, val);
+        } catch (IllegalAccessException x) {
+            throw new ReflectionError(x);
+        }
+    }
+
+    static void setBoolean(Object ob, Field f, boolean val) {
+        try {
+            f.setBoolean(ob, val);
+        } catch (IllegalAccessException x) {
+            throw new ReflectionError(x);
+        }
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SelChImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SelChImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SelChImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SelChImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2000-2002 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+
+
+/**
+ * An interface that allows translation (and more!).
+ *
+ * @since 1.4
+ */
+
+interface SelChImpl {
+
+    FileDescriptor getFD();
+
+    int getFDVal();
+
+    /**
+     * Adds the specified ops if present in interestOps. The specified
+     * ops are turned on without affecting the other ops.
+     *
+     * @return  true iff the new value of sk.readyOps() set by this method
+     *          contains at least one bit that the previous value did not
+     *          contain
+     */
+    public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl sk);
+
+    /**
+     * Sets the specified ops if present in interestOps. The specified
+     * ops are turned on, and all other ops are turned off.
+     *
+     * @return  true iff the new value of sk.readyOps() set by this method
+     *          contains at least one bit that the previous value did not
+     *          contain
+     */
+    public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl sk);
+
+    void translateAndSetInterestOps(int ops, SelectionKeyImpl sk);
+
+    int validOps();
+
+    void kill() throws IOException;
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SelectionKeyImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SelectionKeyImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SelectionKeyImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SelectionKeyImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2000-2004 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+
+/**
+ * An implementation of SelectionKey for Solaris.
+ */
+
+class SelectionKeyImpl
+    extends AbstractSelectionKey
+{
+
+    final SelChImpl channel;                            // package-private
+    final SelectorImpl selector;                        // package-private
+
+    // Index for a pollfd array in Selector that this key is registered with
+    private int index;
+
+    private volatile int interestOps;
+    private int readyOps;
+
+    SelectionKeyImpl(SelChImpl ch, SelectorImpl sel) {
+        channel = ch;
+        selector = sel;
+    }
+
+    public SelectableChannel channel() {
+        return (SelectableChannel)channel;
+    }
+
+    public Selector selector() {
+        return selector;
+    }
+
+    int getIndex() {                                    // package-private
+        return index;
+    }
+
+    void setIndex(int i) {                              // package-private
+        index = i;
+    }
+
+    private void ensureValid() {
+        if (!isValid())
+            throw new CancelledKeyException();
+    }
+
+    public int interestOps() {
+        ensureValid();
+        return interestOps;
+    }
+
+    public SelectionKey interestOps(int ops) {
+        ensureValid();
+        return nioInterestOps(ops);
+    }
+
+    public int readyOps() {
+        ensureValid();
+        return readyOps;
+    }
+
+    // The nio versions of these operations do not care if a key
+    // has been invalidated. They are for internal use by nio code.
+
+    void nioReadyOps(int ops) {                 // package-private
+        readyOps = ops;
+    }
+
+    int nioReadyOps() {                         // package-private
+        return readyOps;
+    }
+
+    SelectionKey nioInterestOps(int ops) {      // package-private
+        if ((ops & ~channel().validOps()) != 0)
+            throw new IllegalArgumentException();
+        channel.translateAndSetInterestOps(ops, this);
+        interestOps = ops;
+        return this;
+    }
+
+    int nioInterestOps() {                       // package-private
+        return interestOps;
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SelectorImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SelectorImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SelectorImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SelectorImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,168 @@
+/*
+ * Copyright 2000-2004 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.net.SocketException;
+import java.util.*;
+import sun.misc.*;
+
+
+/**
+ * Base Selector implementation class.
+ */
+
+abstract class SelectorImpl
+    extends AbstractSelector
+{
+
+    // The set of keys with data ready for an operation
+    protected Set selectedKeys;
+
+    // The set of keys registered with this Selector
+    protected HashSet keys;
+
+    // Public views of the key sets
+    private Set publicKeys;             // Immutable
+    private Set publicSelectedKeys;     // Removal allowed, but not addition
+
+    protected SelectorImpl(SelectorProvider sp) {
+        super(sp);
+        keys = new HashSet();
+        selectedKeys = new HashSet();
+        if (Util.atBugLevel("1.4")) {
+            publicKeys = keys;
+            publicSelectedKeys = selectedKeys;
+        } else {
+            publicKeys = Collections.unmodifiableSet(keys);
+            publicSelectedKeys = Util.ungrowableSet(selectedKeys);
+        }
+    }
+
+    public Set keys() {
+        if (!isOpen() && !Util.atBugLevel("1.4"))
+            throw new ClosedSelectorException();
+        return publicKeys;
+    }
+
+    public Set selectedKeys() {
+        if (!isOpen() && !Util.atBugLevel("1.4"))
+            throw new ClosedSelectorException();
+        return publicSelectedKeys;
+    }
+
+    protected abstract int doSelect(long timeout) throws IOException;
+
+    private int lockAndDoSelect(long timeout) throws IOException {
+        synchronized (this) {
+            if (!isOpen())
+                throw new ClosedSelectorException();
+            synchronized (publicKeys) {
+                synchronized (publicSelectedKeys) {
+                    return doSelect(timeout);
+                }
+            }
+        }
+    }
+
+    public int select(long timeout)
+        throws IOException
+    {
+        if (timeout < 0)
+            throw new IllegalArgumentException("Negative timeout");
+        return lockAndDoSelect((timeout == 0) ? -1 : timeout);
+    }
+
+    public int select() throws IOException {
+        return select(0);
+    }
+
+    public int selectNow() throws IOException {
+        return lockAndDoSelect(0);
+    }
+
+    public void implCloseSelector() throws IOException {
+        wakeup();
+        synchronized (this) {
+            synchronized (publicKeys) {
+                synchronized (publicSelectedKeys) {
+                    implClose();
+                }
+            }
+        }
+    }
+
+    protected abstract void implClose() throws IOException;
+
+    void putEventOps(SelectionKeyImpl sk, int ops) { }
+
+    protected final SelectionKey register(AbstractSelectableChannel ch,
+                                          int ops,
+                                          Object attachment)
+    {
+        if (!(ch instanceof SelChImpl))
+            throw new IllegalSelectorException();
+        SelectionKeyImpl k = new SelectionKeyImpl((SelChImpl)ch, this);
+        k.attach(attachment);
+        synchronized (publicKeys) {
+            implRegister(k);
+        }
+        k.interestOps(ops);
+        return k;
+    }
+
+    protected abstract void implRegister(SelectionKeyImpl ski);
+
+    void processDeregisterQueue() throws IOException {
+        // Precondition: Synchronized on this, keys, and selectedKeys
+        Set cks = cancelledKeys();
+        synchronized (cks) {
+            if (!cks.isEmpty()) {
+                Iterator i = cks.iterator();
+                while (i.hasNext()) {
+                    SelectionKeyImpl ski = (SelectionKeyImpl)i.next();
+                    try {
+                        implDereg(ski);
+                    } catch (SocketException se) {
+                        IOException ioe = new IOException(
+                            "Error deregistering key");
+                        ioe.initCause(se);
+                        throw ioe;
+                    } finally {
+                        i.remove();
+                    }
+                }
+            }
+        }
+    }
+
+    protected abstract void implDereg(SelectionKeyImpl ski) throws IOException;
+
+    abstract public Selector wakeup();
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SelectorProviderImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SelectorProviderImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SelectorProviderImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SelectorProviderImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2000-2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+
+public abstract class SelectorProviderImpl
+    extends SelectorProvider
+{
+
+//    public DatagramChannel openDatagramChannel() throws IOException {
+  //      return new DatagramChannelImpl(this);
+    //}
+
+//    public Pipe openPipe() throws IOException {
+  //      return new PipeImpl(this);
+    //}
+
+    public abstract AbstractSelector openSelector() throws IOException;
+
+    public ServerSocketChannel openServerSocketChannel() throws IOException {
+        return new ServerSocketChannelImpl(this);
+    }
+
+    public SocketChannel openSocketChannel() throws IOException {
+        return new SocketChannelImpl(this);
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/ServerSocketAdaptor.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/ServerSocketAdaptor.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/ServerSocketAdaptor.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/ServerSocketAdaptor.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,207 @@
+/*
+ * Copyright 2000-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+import java.net.*;
+import java.nio.channels.*;
+
+
+// Make a server-socket channel look like a server socket.
+//
+// The methods in this class are defined in exactly the same order as in
+// java.net.ServerSocket so as to simplify tracking future changes to that
+// class.
+//
+
+public class ServerSocketAdaptor                        // package-private
+    extends ServerSocket
+{
+
+    // The channel being adapted
+    private final ServerSocketChannelImpl ssc;
+
+    // Option adaptor object, created on demand
+    private volatile OptionAdaptor opts = null;
+
+    // Timeout "option" value for accepts
+    private volatile int timeout = 0;
+
+    public static ServerSocket create(ServerSocketChannelImpl ssc) {
+        try {
+            return new ServerSocketAdaptor(ssc);
+        } catch (IOException x) {
+            throw new Error(x);
+        }
+    }
+
+    // ## super will create a useless impl
+    private ServerSocketAdaptor(ServerSocketChannelImpl ssc)
+        throws IOException
+    {
+        this.ssc = ssc;
+    }
+
+
+    public void bind(SocketAddress local) throws IOException {
+        bind(local, 50);
+    }
+
+    public void bind(SocketAddress local, int backlog) throws IOException {
+        if (local == null)
+            local = new InetSocketAddress(0);
+        try {
+            ssc.bind(local, backlog);
+        } catch (Exception x) {
+            Net.translateException(x);
+        }
+    }
+
+    public InetAddress getInetAddress() {
+        if (!ssc.isBound())
+            return null;
+        return Net.asInetSocketAddress(ssc.localAddress()).getAddress();
+    }
+
+    public int getLocalPort() {
+        if (!ssc.isBound())
+            return -1;
+        return Net.asInetSocketAddress(ssc.localAddress()).getPort();
+    }
+
+
+    public Socket accept() throws IOException {
+        synchronized (ssc.blockingLock()) {
+            if (!ssc.isBound())
+                throw new IllegalBlockingModeException();
+            try {
+                if (timeout == 0) {
+                    SocketChannel sc = ssc.accept();
+                    if (sc == null && !ssc.isBlocking())
+                        throw new IllegalBlockingModeException();
+                    return sc.socket();
+                }
+
+                // Implement timeout with a selector
+                SelectionKey sk = null;
+                Selector sel = null;
+                ssc.configureBlocking(false);
+                try {
+                    SocketChannel sc;
+                    if ((sc = ssc.accept()) != null)
+                        return sc.socket();
+                    sel = Util.getTemporarySelector(ssc);
+                    sk = ssc.register(sel, SelectionKey.OP_ACCEPT);
+                    long to = timeout;
+                    for (;;) {
+                        if (!ssc.isOpen())
+                            throw new ClosedChannelException();
+                        long st = System.currentTimeMillis();
+                        int ns = sel.select(to);
+                        if (ns > 0 &&
+                            sk.isAcceptable() && ((sc = ssc.accept()) != null))
+                            return sc.socket();
+                        sel.selectedKeys().remove(sk);
+                        to -= System.currentTimeMillis() - st;
+                        if (to <= 0)
+                            throw new SocketTimeoutException();
+                    }
+                } finally {
+                    if (sk != null)
+                        sk.cancel();
+                    if (ssc.isOpen())
+                        ssc.configureBlocking(true);
+                    if (sel != null)
+                        Util.releaseTemporarySelector(sel);
+                }
+
+            } catch (Exception x) {
+                Net.translateException(x);
+                assert false;
+                return null;            // Never happens
+            }
+        }
+    }
+
+    public void close() throws IOException {
+        try {
+            ssc.close();
+        } catch (Exception x) {
+            Net.translateException(x);
+        }
+    }
+
+    public ServerSocketChannel getChannel() {
+        return ssc;
+    }
+
+    public boolean isBound() {
+        return ssc.isBound();
+    }
+
+    public boolean isClosed() {
+        return !ssc.isOpen();
+    }
+
+    public void setSoTimeout(int timeout) throws SocketException {
+        this.timeout = timeout;
+    }
+
+    public int getSoTimeout() throws SocketException {
+        return timeout;
+    }
+
+    private OptionAdaptor opts() {
+        if (opts == null)
+            opts = new OptionAdaptor(ssc);
+        return opts;
+    }
+
+    public void setReuseAddress(boolean on) throws SocketException {
+        opts().setReuseAddress(on);
+    }
+
+    public boolean getReuseAddress() throws SocketException {
+        return opts().getReuseAddress();
+    }
+
+    public String toString() {
+        if (!isBound())
+            return "ServerSocket[unbound]";
+        return "ServerSocket[addr=" + getInetAddress() +
+            //          ",port=" + getPort() +
+                ",localport=" + getLocalPort()  + "]";
+    }
+
+    public void setReceiveBufferSize(int size) throws SocketException {
+        opts().setReceiveBufferSize(size);
+    }
+
+    public int getReceiveBufferSize() throws SocketException {
+        return opts().getReceiveBufferSize();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/ServerSocketChannelImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/ServerSocketChannelImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/ServerSocketChannelImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/ServerSocketChannelImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,343 @@
+/*
+ * Copyright 2000-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.lang.reflect.*;
+import java.net.*;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.HashSet;
+import java.util.Iterator;
+
+
+/**
+ * An implementation of ServerSocketChannels
+ */
+
+class ServerSocketChannelImpl
+    extends ServerSocketChannel
+    implements SelChImpl
+{
+
+    // Used to make native close and configure calls
+    private static NativeDispatcher nd;
+
+    // Our file descriptor
+    private final FileDescriptor fd;
+
+    // fd value needed for dev/poll. This value will remain valid
+    // even after the value in the file descriptor object has been set to -1
+    private int fdVal;
+
+    // ID of native thread currently blocked in this channel, for signalling
+    private volatile long thread = 0;
+
+    // Lock held by thread currently blocked in this channel
+    private final Object lock = new Object();
+
+    // Lock held by any thread that modifies the state fields declared below
+    // DO NOT invoke a blocking I/O operation while holding this lock!
+    private final Object stateLock = new Object();
+
+    // -- The following fields are protected by stateLock
+
+    // Channel state, increases monotonically
+    private static final int ST_UNINITIALIZED = -1;
+    private static final int ST_INUSE = 0;
+    private static final int ST_KILLED = 1;
+    private int state = ST_UNINITIALIZED;
+
+    // Binding
+    private SocketAddress localAddress = null; // null => unbound
+
+    // Options, created on demand
+    private SocketOpts.IP.TCP options = null;
+
+    // Our socket adaptor, if any
+    ServerSocket socket;
+
+    // -- End of fields protected by stateLock
+
+
+    public ServerSocketChannelImpl(SelectorProvider sp) throws IOException {
+        super(sp);
+        this.fd =  Net.serverSocket(true);
+        this.fdVal = IOUtil.fdVal(fd);
+        this.state = ST_INUSE;
+    }
+
+    public ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd)
+        throws IOException
+    {
+        super(sp);
+        this.fd =  fd;
+        this.fdVal = IOUtil.fdVal(fd);
+        this.state = ST_INUSE;
+        localAddress = Net.localAddress(fd);
+    }
+
+
+    public ServerSocket socket() {
+        synchronized (stateLock) {
+            if (socket == null)
+                socket = ServerSocketAdaptor.create(this);
+            return socket;
+        }
+    }
+
+    public boolean isBound() {
+        synchronized (stateLock) {
+            return localAddress != null;
+        }
+    }
+
+    public SocketAddress localAddress() {
+        synchronized (stateLock) {
+            return localAddress;
+        }
+    }
+
+    public void bind(SocketAddress local, int backlog) throws IOException {
+        synchronized (lock) {
+            if (!isOpen())
+                throw new ClosedChannelException();
+            if (isBound())
+                throw new AlreadyBoundException();
+            InetSocketAddress isa = Net.checkAddress(local);
+            SecurityManager sm = System.getSecurityManager();
+            if (sm != null)
+                sm.checkListen(isa.getPort());
+            Net.bind(fd, isa.getAddress(), isa.getPort());
+            listen(fd, backlog < 1 ? 50 : backlog);
+            synchronized (stateLock) {
+                localAddress = Net.localAddress(fd);
+            }
+        }
+    }
+
+    public SocketChannel accept() throws IOException {
+        synchronized (lock) {
+            if (!isOpen())
+                throw new ClosedChannelException();
+            if (!isBound())
+                throw new NotYetBoundException();
+            SocketChannel sc = null;
+
+            int n = 0;
+            FileDescriptor newfd = new FileDescriptor();
+            InetSocketAddress[] isaa = new InetSocketAddress[1];
+
+            try {
+                begin();
+                if (!isOpen())
+                    return null;
+                thread = NativeThread.current();
+                for (;;) {
+                    n = accept0(this.fd, newfd, isaa);
+                    if ((n == IOStatus.INTERRUPTED) && isOpen())
+                        continue;
+                    break;
+                }
+            } finally {
+                thread = 0;
+                end(n > 0);
+                assert IOStatus.check(n);
+            }
+
+            if (n < 1)
+                return null;
+
+            IOUtil.configureBlocking(newfd, true);
+            InetSocketAddress isa = isaa[0];
+            sc = new SocketChannelImpl(provider(), newfd, isa);
+            SecurityManager sm = System.getSecurityManager();
+            if (sm != null) {
+                try {
+                    sm.checkAccept(isa.getAddress().getHostAddress(),
+                                   isa.getPort());
+                } catch (SecurityException x) {
+                    sc.close();
+                    throw x;
+                }
+            }
+            return sc;
+
+        }
+    }
+
+    protected void implConfigureBlocking(boolean block) throws IOException {
+        IOUtil.configureBlocking(fd, block);
+    }
+
+    public SocketOpts options() {
+        synchronized (stateLock) {
+            if (options == null) {
+                SocketOptsImpl.Dispatcher d
+                    = new SocketOptsImpl.Dispatcher() {
+                            int getInt(int opt) throws IOException {
+                                return Net.getIntOption(fd, opt);
+                            }
+                            void setInt(int opt, int arg) throws IOException {
+                                Net.setIntOption(fd, opt, arg);
+                            }
+                        };
+                options = new SocketOptsImpl.IP.TCP(d);
+            }
+            return options;
+        }
+    }
+
+    protected void implCloseSelectableChannel() throws IOException {
+        synchronized (stateLock) {
+            nd.preClose(fd);
+            long th = thread;
+            if (th != 0)
+                NativeThread.signal(th);
+            if (!isRegistered())
+                kill();
+        }
+    }
+
+    public void kill() throws IOException {
+        synchronized (stateLock) {
+            if (state == ST_KILLED)
+                return;
+            if (state == ST_UNINITIALIZED) {
+                state = ST_KILLED;
+                return;
+            }
+            assert !isOpen() && !isRegistered();
+            nd.close(fd);
+            state = ST_KILLED;
+        }
+    }
+
+    /**
+     * Translates native poll revent set into a ready operation set
+     */
+    public boolean translateReadyOps(int ops, int initialOps,
+                                     SelectionKeyImpl sk) {
+        int intOps = sk.nioInterestOps(); // Do this just once, it synchronizes
+        int oldOps = sk.nioReadyOps();
+        int newOps = initialOps;
+
+        if ((ops & PollArrayWrapper.POLLNVAL) != 0) {
+            // This should only happen if this channel is pre-closed while a
+            // selection operation is in progress
+            // ## Throw an error if this channel has not been pre-closed
+            return false;
+        }
+
+        if ((ops & (PollArrayWrapper.POLLERR
+                    | PollArrayWrapper.POLLHUP)) != 0) {
+            newOps = intOps;
+            sk.nioReadyOps(newOps);
+            return (newOps & ~oldOps) != 0;
+        }
+
+        if (((ops & PollArrayWrapper.POLLIN) != 0) &&
+            ((intOps & SelectionKey.OP_ACCEPT) != 0))
+                newOps |= SelectionKey.OP_ACCEPT;
+
+        sk.nioReadyOps(newOps);
+        return (newOps & ~oldOps) != 0;
+    }
+
+    public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl sk) {
+        return translateReadyOps(ops, sk.nioReadyOps(), sk);
+    }
+
+    public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl sk) {
+        return translateReadyOps(ops, 0, sk);
+    }
+
+    /**
+     * Translates an interest operation set into a native poll event set
+     */
+    public void translateAndSetInterestOps(int ops, SelectionKeyImpl sk) {
+        int newOps = 0;
+
+        // Translate ops
+        if ((ops & SelectionKey.OP_ACCEPT) != 0)
+            newOps |= PollArrayWrapper.POLLIN;
+        // Place ops into pollfd array
+        sk.selector.putEventOps(sk, newOps);
+    }
+
+    public FileDescriptor getFD() {
+        return fd;
+    }
+
+    public int getFDVal() {
+        return fdVal;
+    }
+
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(this.getClass().getName());
+        sb.append('[');
+        if (!isOpen())
+            sb.append("closed");
+        else {
+            synchronized (stateLock) {
+                if (localAddress() == null) {
+                    sb.append("unbound");
+                } else {
+                    sb.append(localAddress().toString());
+                }
+            }
+        }
+        sb.append(']');
+        return sb.toString();
+    }
+
+    // -- Native methods --
+
+    private static native void listen(FileDescriptor fd, int backlog)
+        throws IOException;
+
+    // Accepts a new connection, setting the given file descriptor to refer to
+    // the new socket and setting isaa[0] to the socket's remote address.
+    // Returns 1 on success, or IOStatus.UNAVAILABLE (if non-blocking and no
+    // connections are pending) or IOStatus.INTERRUPTED.
+    //
+    private native int accept0(FileDescriptor ssfd, FileDescriptor newfd,
+                               InetSocketAddress[] isaa)
+        throws IOException;
+
+    private static native void initIDs();
+
+    static {
+        Util.load();
+        initIDs();
+        nd = new SocketDispatcher();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SocketAdaptor.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SocketAdaptor.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SocketAdaptor.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SocketAdaptor.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,420 @@
+/*
+ * Copyright 2000-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+import java.lang.ref.*;
+import java.net.*;
+import java.nio.*;
+import java.nio.channels.*;
+import java.security.AccessController;
+import java.security.PrivilegedExceptionAction;
+import java.util.*;
+
+
+// Make a socket channel look like a socket.
+//
+// The only aspects of java.net.Socket-hood that we don't attempt to emulate
+// here are the interrupted-I/O exceptions (which our Solaris implementations
+// attempt to support) and the sending of urgent data.  Otherwise an adapted
+// socket should look enough like a real java.net.Socket to fool most of the
+// developers most of the time, right down to the exception message strings.
+//
+// The methods in this class are defined in exactly the same order as in
+// java.net.Socket so as to simplify tracking future changes to that class.
+//
+
+public class SocketAdaptor
+    extends Socket
+{
+
+    // The channel being adapted
+    private final SocketChannelImpl sc;
+
+    // Option adaptor object, created on demand
+    private volatile OptionAdaptor opts = null;
+
+    // Timeout "option" value for reads
+    private volatile int timeout = 0;
+
+    // Traffic-class/Type-of-service
+    private volatile int trafficClass = 0;
+
+
+    // ## super will create a useless impl
+    private SocketAdaptor(SocketChannelImpl sc) {
+        this.sc = sc;
+    }
+
+    public static Socket create(SocketChannelImpl sc) {
+        return new SocketAdaptor(sc);
+    }
+
+    public SocketChannel getChannel() {
+        return sc;
+    }
+
+    // Override this method just to protect against changes in the superclass
+    //
+    public void connect(SocketAddress remote) throws IOException {
+        connect(remote, 0);
+    }
+
+    public void connect(SocketAddress remote, int timeout) throws IOException {
+        if (remote == null)
+            throw new IllegalArgumentException("connect: The address can't be null");
+        if (timeout < 0)
+            throw new IllegalArgumentException("connect: timeout can't be negative");
+
+        synchronized (sc.blockingLock()) {
+            if (!sc.isBlocking())
+                throw new IllegalBlockingModeException();
+
+            try {
+
+                if (timeout == 0) {
+                    sc.connect(remote);
+                    return;
+                }
+
+                // Implement timeout with a selector
+                SelectionKey sk = null;
+                Selector sel = null;
+                sc.configureBlocking(false);
+                try {
+                    if (sc.connect(remote))
+                        return;
+                    sel = Util.getTemporarySelector(sc);
+                    sk = sc.register(sel, SelectionKey.OP_CONNECT);
+                    long to = timeout;
+                    for (;;) {
+                        if (!sc.isOpen())
+                            throw new ClosedChannelException();
+                        long st = System.currentTimeMillis();
+                        int ns = sel.select(to);
+                        if (ns > 0 &&
+                            sk.isConnectable() && sc.finishConnect())
+                            break;
+                        sel.selectedKeys().remove(sk);
+                        to -= System.currentTimeMillis() - st;
+                        if (to <= 0) {
+                            try {
+                                sc.close();
+                            } catch (IOException x) { }
+                            throw new SocketTimeoutException();
+                        }
+                    }
+                } finally {
+                    if (sk != null)
+                        sk.cancel();
+                    if (sc.isOpen())
+                        sc.configureBlocking(true);
+                    if (sel != null)
+                        Util.releaseTemporarySelector(sel);
+                }
+
+            } catch (Exception x) {
+                Net.translateException(x, true);
+            }
+        }
+
+    }
+
+    public void bind(SocketAddress local) throws IOException {
+        try {
+            if (local == null)
+                local = new InetSocketAddress(0);
+            sc.bind(local);
+        } catch (Exception x) {
+            Net.translateException(x);
+        }
+    }
+
+    public InetAddress getInetAddress() {
+        if (!sc.isConnected())
+            return null;
+        return Net.asInetSocketAddress(sc.remoteAddress()).getAddress();
+    }
+
+    public InetAddress getLocalAddress() {
+        if (!sc.isBound())
+            return new InetSocketAddress(0).getAddress();
+        return Net.asInetSocketAddress(sc.localAddress()).getAddress();
+    }
+
+    public int getPort() {
+        if (!sc.isConnected())
+            return 0;
+        return Net.asInetSocketAddress(sc.remoteAddress()).getPort();
+    }
+
+    public int getLocalPort() {
+        if (!sc.isBound())
+            return -1;
+        return Net.asInetSocketAddress(sc.localAddress()).getPort();
+    }
+
+    private class SocketInputStream
+        extends ChannelInputStream
+    {
+        private SocketInputStream() {
+            super(sc);
+        }
+
+        protected int read(ByteBuffer bb)
+            throws IOException
+        {
+            synchronized (sc.blockingLock()) {
+                if (!sc.isBlocking())
+                    throw new IllegalBlockingModeException();
+                if (timeout == 0)
+                    return sc.read(bb);
+
+                // Implement timeout with a selector
+                SelectionKey sk = null;
+                Selector sel = null;
+                sc.configureBlocking(false);
+                try {
+                    int n;
+                    if ((n = sc.read(bb)) != 0)
+                        return n;
+                    sel = Util.getTemporarySelector(sc);
+                    sk = sc.register(sel, SelectionKey.OP_READ);
+                    long to = timeout;
+                    for (;;) {
+                        if (!sc.isOpen())
+                            throw new ClosedChannelException();
+                        long st = System.currentTimeMillis();
+                        int ns = sel.select(to);
+                        if (ns > 0 && sk.isReadable()) {
+                            if ((n = sc.read(bb)) != 0)
+                                return n;
+                        }
+                        sel.selectedKeys().remove(sk);
+                        to -= System.currentTimeMillis() - st;
+                        if (to <= 0)
+                            throw new SocketTimeoutException();
+                    }
+                } finally {
+                    if (sk != null)
+                        sk.cancel();
+                    if (sc.isOpen())
+                        sc.configureBlocking(true);
+                    if (sel != null)
+                        Util.releaseTemporarySelector(sel);
+                }
+
+            }
+        }
+    }
+
+    private InputStream socketInputStream = null;
+
+    public InputStream getInputStream() throws IOException {
+        if (!sc.isOpen())
+            throw new SocketException("Socket is closed");
+        if (!sc.isConnected())
+            throw new SocketException("Socket is not connected");
+        if (!sc.isInputOpen())
+            throw new SocketException("Socket input is shutdown");
+        if (socketInputStream == null) {
+            try {
+                socketInputStream = (InputStream) AccessController.doPrivileged(
+                    new PrivilegedExceptionAction() {
+                        public Object run() throws IOException {
+                            return new SocketInputStream();
+                        }
+                    });
+            } catch (java.security.PrivilegedActionException e) {
+                throw (IOException)e.getException();
+            }
+        }
+        return socketInputStream;
+    }
+
+    public OutputStream getOutputStream() throws IOException {
+        if (!sc.isOpen())
+            throw new SocketException("Socket is closed");
+        if (!sc.isConnected())
+            throw new SocketException("Socket is not connected");
+        if (!sc.isOutputOpen())
+            throw new SocketException("Socket output is shutdown");
+        OutputStream os = null;
+        try {
+            os = (OutputStream)AccessController.doPrivileged(
+                new PrivilegedExceptionAction() {
+                    public Object run() throws IOException {
+                        return Channels.newOutputStream(sc);
+                    }
+                });
+        } catch (java.security.PrivilegedActionException e) {
+            throw (IOException)e.getException();
+        }
+        return os;
+    }
+
+    private OptionAdaptor opts() {
+        if (opts == null)
+            opts = new OptionAdaptor(sc);
+        return opts;
+    }
+
+    public void setTcpNoDelay(boolean on) throws SocketException {
+        opts().setTcpNoDelay(on);
+    }
+
+    public boolean getTcpNoDelay() throws SocketException {
+        return opts().getTcpNoDelay();
+    }
+
+    public void setSoLinger(boolean on, int linger) throws SocketException {
+        opts().setSoLinger(on, linger);
+    }
+
+    public int getSoLinger() throws SocketException {
+        return opts().getSoLinger();
+    }
+
+    public void sendUrgentData(int data) throws IOException {
+        throw new SocketException("Urgent data not supported");
+    }
+
+    public void setOOBInline(boolean on) throws SocketException {
+        opts().setOOBInline(on);
+    }
+
+    public boolean getOOBInline() throws SocketException {
+        return opts().getOOBInline();
+    }
+
+    public void setSoTimeout(int timeout) throws SocketException {
+        if (timeout < 0)
+            throw new IllegalArgumentException("timeout can't be negative");
+        this.timeout = timeout;
+    }
+
+    public int getSoTimeout() throws SocketException {
+        return timeout;
+    }
+
+    public void setSendBufferSize(int size) throws SocketException {
+        opts().setSendBufferSize(size);
+    }
+
+    public int getSendBufferSize() throws SocketException {
+        return opts().getSendBufferSize();
+    }
+
+    public void setReceiveBufferSize(int size) throws SocketException {
+        opts().setReceiveBufferSize(size);
+    }
+
+    public int getReceiveBufferSize() throws SocketException {
+        return opts().getReceiveBufferSize();
+    }
+
+    public void setKeepAlive(boolean on) throws SocketException {
+        opts().setKeepAlive(on);
+    }
+
+    public boolean getKeepAlive() throws SocketException {
+        return opts().getKeepAlive();
+    }
+
+    public void setTrafficClass(int tc) throws SocketException {
+        opts().setTrafficClass(tc);
+        trafficClass = tc;
+    }
+
+    public int getTrafficClass() throws SocketException {
+        int tc = opts().getTrafficClass();
+        if (tc < 0) {
+            tc = trafficClass;
+        }
+        return tc;
+    }
+
+    public void setReuseAddress(boolean on) throws SocketException {
+        opts().setReuseAddress(on);
+    }
+
+    public boolean getReuseAddress() throws SocketException {
+        return opts().getReuseAddress();
+    }
+
+    public void close() throws IOException {
+        try {
+            sc.close();
+        } catch (Exception x) {
+            Net.translateToSocketException(x);
+        }
+    }
+
+    public void shutdownInput() throws IOException {
+        try {
+            sc.shutdownInput();
+        } catch (Exception x) {
+            Net.translateException(x);
+        }
+    }
+
+    public void shutdownOutput() throws IOException {
+        try {
+            sc.shutdownOutput();
+        } catch (Exception x) {
+            Net.translateException(x);
+        }
+    }
+
+    public String toString() {
+        if (sc.isConnected())
+            return "Socket[addr=" + getInetAddress() +
+                ",port=" + getPort() +
+                ",localport=" + getLocalPort() + "]";
+        return "Socket[unconnected]";
+    }
+
+    public boolean isConnected() {
+        return sc.isConnected();
+    }
+
+    public boolean isBound() {
+        return sc.isBound();
+    }
+
+    public boolean isClosed() {
+        return !sc.isOpen();
+    }
+
+    public boolean isInputShutdown() {
+        return !sc.isInputOpen();
+    }
+
+    public boolean isOutputShutdown() {
+        return !sc.isOutputOpen();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SocketChannelImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SocketChannelImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SocketChannelImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SocketChannelImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,880 @@
+/*
+ * Copyright 2000-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.net.*;
+import java.nio.ByteBuffer;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+
+/**
+ * An implementation of SocketChannels
+ */
+
+class SocketChannelImpl
+    extends SocketChannel
+    implements SelChImpl
+{
+
+    // Used to make native read and write calls
+    private static NativeDispatcher nd;
+
+    // Our file descriptor object
+    private final FileDescriptor fd;
+
+    // fd value needed for dev/poll. This value will remain valid
+    // even after the value in the file descriptor object has been set to -1
+    private final int fdVal;
+
+    // IDs of native threads doing reads and writes, for signalling
+    private volatile long readerThread = 0;
+    private volatile long writerThread = 0;
+
+    // Lock held by current reading or connecting thread
+    private final Object readLock = new Object();
+
+    // Lock held by current writing or connecting thread
+    private final Object writeLock = new Object();
+
+    // Lock held by any thread that modifies the state fields declared below
+    // DO NOT invoke a blocking I/O operation while holding this lock!
+    private final Object stateLock = new Object();
+
+    // -- The following fields are protected by stateLock
+
+    // State, increases monotonically
+    private static final int ST_UNINITIALIZED = -1;
+    private static final int ST_UNCONNECTED = 0;
+    private static final int ST_PENDING = 1;
+    private static final int ST_CONNECTED = 2;
+    private static final int ST_KILLPENDING = 3;
+    private static final int ST_KILLED = 4;
+    private int state = ST_UNINITIALIZED;
+
+    // Binding
+    private SocketAddress localAddress = null;
+    private SocketAddress remoteAddress = null;
+
+    // Input/Output open
+    private boolean isInputOpen = true;
+    private boolean isOutputOpen = true;
+    private boolean readyToConnect = false;
+
+    // Options, created on demand
+    private SocketOpts.IP.TCP options = null;
+
+    // Socket adaptor, created on demand
+    private Socket socket = null;
+
+    // -- End of fields protected by stateLock
+
+
+    // Constructor for normal connecting sockets
+    //
+    SocketChannelImpl(SelectorProvider sp) throws IOException {
+        super(sp);
+        this.fd = Net.socket(true);
+        this.fdVal = IOUtil.fdVal(fd);
+        this.state = ST_UNCONNECTED;
+    }
+
+    // Constructor for sockets obtained from server sockets
+    //
+    SocketChannelImpl(SelectorProvider sp,
+                      FileDescriptor fd, InetSocketAddress remote)
+        throws IOException
+    {
+        super(sp);
+        this.fd = fd;
+        this.fdVal = IOUtil.fdVal(fd);
+        this.state = ST_CONNECTED;
+        this.remoteAddress = remote;
+    }
+
+    public Socket socket() {
+        synchronized (stateLock) {
+            if (socket == null)
+                socket = SocketAdaptor.create(this);
+            return socket;
+        }
+    }
+
+    private boolean ensureReadOpen() throws ClosedChannelException {
+        synchronized (stateLock) {
+            if (!isOpen())
+                throw new ClosedChannelException();
+            if (!isConnected())
+                throw new NotYetConnectedException();
+            if (!isInputOpen)
+                return false;
+            else
+                return true;
+        }
+    }
+
+    private void ensureWriteOpen() throws ClosedChannelException {
+        synchronized (stateLock) {
+            if (!isOpen())
+                throw new ClosedChannelException();
+            if (!isOutputOpen)
+                throw new ClosedChannelException();
+            if (!isConnected())
+                throw new NotYetConnectedException();
+        }
+    }
+
+    private void readerCleanup() throws IOException {
+        synchronized (stateLock) {
+            readerThread = 0;
+            if (state == ST_KILLPENDING)
+                kill();
+        }
+    }
+
+    private void writerCleanup() throws IOException {
+        synchronized (stateLock) {
+            writerThread = 0;
+            if (state == ST_KILLPENDING)
+                kill();
+        }
+    }
+
+    public int read(ByteBuffer buf) throws IOException {
+
+        if (buf == null)
+            throw new NullPointerException();
+
+        synchronized (readLock) {
+            if (!ensureReadOpen())
+                return -1;
+            int n = 0;
+            try {
+
+                // Set up the interruption machinery; see
+                // AbstractInterruptibleChannel for details
+                //
+                begin();
+
+                synchronized (stateLock) {
+                    if (!isOpen()) {
+                    // Either the current thread is already interrupted, so
+                    // begin() closed the channel, or another thread closed the
+                    // channel since we checked it a few bytecodes ago.  In
+                    // either case the value returned here is irrelevant since
+                    // the invocation of end() in the finally block will throw
+                    // an appropriate exception.
+                    //
+                        return 0;
+
+                    }
+
+                    // Save this thread so that it can be signalled on those
+                    // platforms that require it
+                    //
+                    readerThread = NativeThread.current();
+                }
+
+                // Between the previous test of isOpen() and the return of the
+                // IOUtil.read invocation below, this channel might be closed
+                // or this thread might be interrupted.  We rely upon the
+                // implicit synchronization point in the kernel read() call to
+                // make sure that the right thing happens.  In either case the
+                // implCloseSelectableChannel method is ultimately invoked in
+                // some other thread, so there are three possibilities:
+                //
+                //   - implCloseSelectableChannel() invokes nd.preClose()
+                //     before this thread invokes read(), in which case the
+                //     read returns immediately with either EOF or an error,
+                //     the latter of which will cause an IOException to be
+                //     thrown.
+                //
+                //   - implCloseSelectableChannel() invokes nd.preClose() after
+                //     this thread is blocked in read().  On some operating
+                //     systems (e.g., Solaris and Windows) this causes the read
+                //     to return immediately with either EOF or an error
+                //     indication.
+                //
+                //   - implCloseSelectableChannel() invokes nd.preClose() after
+                //     this thread is blocked in read() but the operating
+                //     system (e.g., Linux) doesn't support preemptive close,
+                //     so implCloseSelectableChannel() proceeds to signal this
+                //     thread, thereby causing the read to return immediately
+                //     with IOStatus.INTERRUPTED.
+                //
+                // In all three cases the invocation of end() in the finally
+                // clause will notice that the channel has been closed and
+                // throw an appropriate exception (AsynchronousCloseException
+                // or ClosedByInterruptException) if necessary.
+                //
+                // *There is A fourth possibility. implCloseSelectableChannel()
+                // invokes nd.preClose(), signals reader/writer thred and quickly
+                // moves on to nd.close() in kill(), which does a real close.
+                // Then a third thread accepts a new connection, opens file or
+                // whatever that causes the released "fd" to be recycled. All
+                // above happens just between our last isOpen() check and the
+                // next kernel read reached, with the recycled "fd". The solution
+                // is to postpone the real kill() if there is a reader or/and
+                // writer thread(s) over there "waiting", leave the cleanup/kill
+                // to the reader or writer thread. (the preClose() still happens
+                // so the connection gets cut off as usual).
+                //
+                // For socket channels there is the additional wrinkle that
+                // asynchronous shutdown works much like asynchronous close,
+                // except that the channel is shutdown rather than completely
+                // closed.  This is analogous to the first two cases above,
+                // except that the shutdown operation plays the role of
+                // nd.preClose().
+                for (;;) {
+                    n = IOUtil.read(fd, buf, -1, nd, readLock);
+                    if ((n == IOStatus.INTERRUPTED) && isOpen()) {
+                        // The system call was interrupted but the channel
+                        // is still open, so retry
+                        continue;
+                    }
+                    return IOStatus.normalize(n);
+                }
+
+            } finally {
+                readerCleanup();        // Clear reader thread
+                // The end method, which is defined in our superclass
+                // AbstractInterruptibleChannel, resets the interruption
+                // machinery.  If its argument is true then it returns
+                // normally; otherwise it checks the interrupt and open state
+                // of this channel and throws an appropriate exception if
+                // necessary.
+                //
+                // So, if we actually managed to do any I/O in the above try
+                // block then we pass true to the end method.  We also pass
+                // true if the channel was in non-blocking mode when the I/O
+                // operation was initiated but no data could be transferred;
+                // this prevents spurious exceptions from being thrown in the
+                // rare event that a channel is closed or a thread is
+                // interrupted at the exact moment that a non-blocking I/O
+                // request is made.
+                //
+                end(n > 0 || (n == IOStatus.UNAVAILABLE));
+
+                // Extra case for socket channels: Asynchronous shutdown
+                //
+                synchronized (stateLock) {
+                    if ((n <= 0) && (!isInputOpen))
+                        return IOStatus.EOF;
+                }
+
+                assert IOStatus.check(n);
+
+            }
+        }
+    }
+
+    private long read0(ByteBuffer[] bufs) throws IOException {
+        if (bufs == null)
+            throw new NullPointerException();
+        synchronized (readLock) {
+            if (!ensureReadOpen())
+                return -1;
+            long n = 0;
+            try {
+                begin();
+                synchronized (stateLock) {
+                    if (!isOpen())
+                        return 0;
+                    readerThread = NativeThread.current();
+                }
+
+                for (;;) {
+                    n = IOUtil.read(fd, bufs, nd);
+                    if ((n == IOStatus.INTERRUPTED) && isOpen())
+                        continue;
+                    return IOStatus.normalize(n);
+                }
+            } finally {
+                readerCleanup();
+                end(n > 0 || (n == IOStatus.UNAVAILABLE));
+                synchronized (stateLock) {
+                    if ((n <= 0) && (!isInputOpen))
+                        return IOStatus.EOF;
+                }
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    public long read(ByteBuffer[] dsts, int offset, int length)
+        throws IOException
+    {
+        if ((offset < 0) || (length < 0) || (offset > dsts.length - length))
+            throw new IndexOutOfBoundsException();
+        // ## Fix IOUtil.write so that we can avoid this array copy
+        return read0(Util.subsequence(dsts, offset, length));
+    }
+
+    public int write(ByteBuffer buf) throws IOException {
+        if (buf == null)
+            throw new NullPointerException();
+        synchronized (writeLock) {
+            ensureWriteOpen();
+            int n = 0;
+            try {
+                begin();
+                synchronized (stateLock) {
+                    if (!isOpen())
+                        return 0;
+                    writerThread = NativeThread.current();
+                }
+                for (;;) {
+                    n = IOUtil.write(fd, buf, -1, nd, writeLock);
+                    if ((n == IOStatus.INTERRUPTED) && isOpen())
+                        continue;
+                    return IOStatus.normalize(n);
+                }
+            } finally {
+                writerCleanup();
+                end(n > 0 || (n == IOStatus.UNAVAILABLE));
+                synchronized (stateLock) {
+                    if ((n <= 0) && (!isOutputOpen))
+                        throw new AsynchronousCloseException();
+                }
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    public long write0(ByteBuffer[] bufs) throws IOException {
+        if (bufs == null)
+            throw new NullPointerException();
+        synchronized (writeLock) {
+            ensureWriteOpen();
+            long n = 0;
+            try {
+                begin();
+                synchronized (stateLock) {
+                    if (!isOpen())
+                        return 0;
+                    writerThread = NativeThread.current();
+                }
+                for (;;) {
+                    n = IOUtil.write(fd, bufs, nd);
+                    if ((n == IOStatus.INTERRUPTED) && isOpen())
+                        continue;
+                    return IOStatus.normalize(n);
+                }
+            } finally {
+                writerCleanup();
+                end((n > 0) || (n == IOStatus.UNAVAILABLE));
+                synchronized (stateLock) {
+                    if ((n <= 0) && (!isOutputOpen))
+                        throw new AsynchronousCloseException();
+                }
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    public long write(ByteBuffer[] srcs, int offset, int length)
+        throws IOException
+    {
+        if ((offset < 0) || (length < 0) || (offset > srcs.length - length))
+            throw new IndexOutOfBoundsException();
+        // ## Fix IOUtil.write so that we can avoid this array copy
+        return write0(Util.subsequence(srcs, offset, length));
+    }
+
+    protected void implConfigureBlocking(boolean block) throws IOException {
+        IOUtil.configureBlocking(fd, block);
+    }
+
+    public SocketOpts options() {
+        synchronized (stateLock) {
+            if (options == null) {
+                SocketOptsImpl.Dispatcher d
+                    = new SocketOptsImpl.Dispatcher() {
+                            int getInt(int opt) throws IOException {
+                                return Net.getIntOption(fd, opt);
+                            }
+                            void setInt(int opt, int arg)
+                                throws IOException
+                            {
+                                Net.setIntOption(fd, opt, arg);
+                            }
+                        };
+                options = new SocketOptsImpl.IP.TCP(d);
+            }
+            return options;
+        }
+    }
+
+    public boolean isBound() {
+        synchronized (stateLock) {
+            if (state == ST_CONNECTED)
+                return true;
+            return localAddress != null;
+        }
+    }
+
+    public SocketAddress localAddress() {
+        synchronized (stateLock) {
+            if (state == ST_CONNECTED &&
+                (localAddress == null ||
+                 ((InetSocketAddress)localAddress).getAddress().isAnyLocalAddress())) {
+                    // Socket was not bound before connecting or
+                    // Socket was bound with an "anyLocalAddress"
+                    localAddress = Net.localAddress(fd);
+            }
+            return localAddress;
+        }
+    }
+
+    public SocketAddress remoteAddress() {
+        synchronized (stateLock) {
+            return remoteAddress;
+        }
+    }
+
+    public void bind(SocketAddress local) throws IOException {
+        synchronized (readLock) {
+            synchronized (writeLock) {
+                synchronized (stateLock) {
+                    ensureOpenAndUnconnected();
+                    if (localAddress != null)
+                        throw new AlreadyBoundException();
+                    InetSocketAddress isa = Net.checkAddress(local);
+                    Net.bind(fd, isa.getAddress(), isa.getPort());
+                    localAddress = Net.localAddress(fd);
+                }
+            }
+        }
+    }
+
+    public boolean isConnected() {
+        synchronized (stateLock) {
+            return (state == ST_CONNECTED);
+        }
+    }
+
+    public boolean isConnectionPending() {
+        synchronized (stateLock) {
+            return (state == ST_PENDING);
+        }
+    }
+
+    void ensureOpenAndUnconnected() throws IOException { // package-private
+        synchronized (stateLock) {
+            if (!isOpen())
+                throw new ClosedChannelException();
+            if (state == ST_CONNECTED)
+                throw new AlreadyConnectedException();
+            if (state == ST_PENDING)
+                throw new ConnectionPendingException();
+        }
+    }
+
+    public boolean connect(SocketAddress sa) throws IOException {
+        int trafficClass = 0;           // ## Pick up from options
+        int localPort = 0;
+
+        synchronized (readLock) {
+            synchronized (writeLock) {
+                ensureOpenAndUnconnected();
+                InetSocketAddress isa = Net.checkAddress(sa);
+                SecurityManager sm = System.getSecurityManager();
+                if (sm != null)
+                    sm.checkConnect(isa.getAddress().getHostAddress(),
+                                    isa.getPort());
+                synchronized (blockingLock()) {
+                    int n = 0;
+                    try {
+                        try {
+                            begin();
+                            synchronized (stateLock) {
+                                if (!isOpen()) {
+                                    return false;
+                                }
+                                readerThread = NativeThread.current();
+                            }
+                            for (;;) {
+                                InetAddress ia = isa.getAddress();
+                                if (ia.isAnyLocalAddress())
+                                    ia = InetAddress.getLocalHost();
+                                n = Net.connect(fd,
+                                                ia,
+                                                isa.getPort(),
+                                                trafficClass);
+                                if (  (n == IOStatus.INTERRUPTED)
+                                      && isOpen())
+                                    continue;
+                                break;
+                            }
+                        } finally {
+                            readerCleanup();
+                            end((n > 0) || (n == IOStatus.UNAVAILABLE));
+                            assert IOStatus.check(n);
+                        }
+                    } catch (IOException x) {
+                        // If an exception was thrown, close the channel after
+                        // invoking end() so as to avoid bogus
+                        // AsynchronousCloseExceptions
+                        close();
+                        throw x;
+                    }
+                    synchronized (stateLock) {
+                        remoteAddress = isa;
+                        if (n > 0) {
+
+                            // Connection succeeded; disallow further
+                            // invocation
+                            state = ST_CONNECTED;
+                            return true;
+                        }
+                        // If nonblocking and no exception then connection
+                        // pending; disallow another invocation
+                        if (!isBlocking())
+                            state = ST_PENDING;
+                        else
+                            assert false;
+                    }
+                }
+                return false;
+            }
+        }
+    }
+
+    public boolean finishConnect() throws IOException {
+        synchronized (readLock) {
+            synchronized (writeLock) {
+                synchronized (stateLock) {
+                    if (!isOpen())
+                        throw new ClosedChannelException();
+                    if (state == ST_CONNECTED)
+                        return true;
+                    if (state != ST_PENDING)
+                        throw new NoConnectionPendingException();
+                }
+                int n = 0;
+                try {
+                    try {
+                        begin();
+                        synchronized (blockingLock()) {
+                            synchronized (stateLock) {
+                                if (!isOpen()) {
+                                    return false;
+                                }
+                                readerThread = NativeThread.current();
+                            }
+                            if (!isBlocking()) {
+                                for (;;) {
+                                    n = checkConnect(fd, false,
+                                                     readyToConnect);
+                                    if (  (n == IOStatus.INTERRUPTED)
+                                          && isOpen())
+                                        continue;
+                                    break;
+                                }
+                            } else {
+                                for (;;) {
+                                    n = checkConnect(fd, true,
+                                                     readyToConnect);
+                                    if (n == 0) {
+                                        // Loop in case of
+                                        // spurious notifications
+                                        continue;
+                                    }
+                                    if (  (n == IOStatus.INTERRUPTED)
+                                          && isOpen())
+                                        continue;
+                                    break;
+                                }
+                            }
+                        }
+                    } finally {
+                        synchronized (stateLock) {
+                            readerThread = 0;
+                            if (state == ST_KILLPENDING) {
+                                kill();
+                                // poll()/getsockopt() does not report
+                                // error (throws exception, with n = 0)
+                                // on Linux platform after dup2 and
+                                // signal-wakeup. Force n to 0 so the
+                                // end() can throw appropriate exception
+                                n = 0;
+                            }
+                        }
+                        end((n > 0) || (n == IOStatus.UNAVAILABLE));
+                        assert IOStatus.check(n);
+                    }
+                } catch (IOException x) {
+                    // If an exception was thrown, close the channel after
+                    // invoking end() so as to avoid bogus
+                    // AsynchronousCloseExceptions
+                    close();
+                    throw x;
+                }
+                if (n > 0) {
+                    synchronized (stateLock) {
+                        state = ST_CONNECTED;
+                    }
+                    return true;
+                }
+                return false;
+            }
+        }
+    }
+
+    public final static int SHUT_RD = 0;
+    public final static int SHUT_WR = 1;
+    public final static int SHUT_RDWR = 2;
+
+    public void shutdownInput() throws IOException {
+        synchronized (stateLock) {
+            if (!isOpen())
+                throw new ClosedChannelException();
+            isInputOpen = false;
+            shutdown(fd, SHUT_RD);
+            if (readerThread != 0)
+                NativeThread.signal(readerThread);
+        }
+    }
+
+    public void shutdownOutput() throws IOException {
+        synchronized (stateLock) {
+            if (!isOpen())
+                throw new ClosedChannelException();
+            isOutputOpen = false;
+            shutdown(fd, SHUT_WR);
+            if (writerThread != 0)
+                NativeThread.signal(writerThread);
+        }
+    }
+
+    public boolean isInputOpen() {
+        synchronized (stateLock) {
+            return isInputOpen;
+        }
+    }
+
+    public boolean isOutputOpen() {
+        synchronized (stateLock) {
+            return isOutputOpen;
+        }
+    }
+
+    // AbstractInterruptibleChannel synchronizes invocations of this method
+    // using AbstractInterruptibleChannel.closeLock, and also ensures that this
+    // method is only ever invoked once.  Before we get to this method, isOpen
+    // (which is volatile) will have been set to false.
+    //
+    protected void implCloseSelectableChannel() throws IOException {
+        synchronized (stateLock) {
+            isInputOpen = false;
+            isOutputOpen = false;
+
+            // Close the underlying file descriptor and dup it to a known fd
+            // that's already closed.  This prevents other operations on this
+            // channel from using the old fd, which might be recycled in the
+            // meantime and allocated to an entirely different channel.
+            //
+            nd.preClose(fd);
+
+            // Signal native threads, if needed.  If a target thread is not
+            // currently blocked in an I/O operation then no harm is done since
+            // the signal handler doesn't actually do anything.
+            //
+            if (readerThread != 0)
+                NativeThread.signal(readerThread);
+
+            if (writerThread != 0)
+                NativeThread.signal(writerThread);
+
+            // If this channel is not registered then it's safe to close the fd
+            // immediately since we know at this point that no thread is
+            // blocked in an I/O operation upon the channel and, since the
+            // channel is marked closed, no thread will start another such
+            // operation.  If this channel is registered then we don't close
+            // the fd since it might be in use by a selector.  In that case
+            // closing this channel caused its keys to be cancelled, so the
+            // last selector to deregister a key for this channel will invoke
+            // kill() to close the fd.
+            //
+            if (!isRegistered())
+                kill();
+        }
+    }
+
+    public void kill() throws IOException {
+        synchronized (stateLock) {
+            if (state == ST_KILLED)
+                return;
+            if (state == ST_UNINITIALIZED) {
+                state = ST_KILLED;
+                return;
+            }
+            assert !isOpen() && !isRegistered();
+
+            // Postpone the kill if there is a waiting reader
+            // or writer thread. See the comments in read() for
+            // more detailed explanation.
+            if (readerThread == 0 && writerThread == 0) {
+                nd.close(fd);
+                state = ST_KILLED;
+            } else {
+                state = ST_KILLPENDING;
+            }
+        }
+    }
+
+    /**
+     * Translates native poll revent ops into a ready operation ops
+     */
+    public boolean translateReadyOps(int ops, int initialOps,
+                                     SelectionKeyImpl sk) {
+        int intOps = sk.nioInterestOps(); // Do this just once, it synchronizes
+        int oldOps = sk.nioReadyOps();
+        int newOps = initialOps;
+
+        if ((ops & PollArrayWrapper.POLLNVAL) != 0) {
+            // This should only happen if this channel is pre-closed while a
+            // selection operation is in progress
+            // ## Throw an error if this channel has not been pre-closed
+            return false;
+        }
+
+        if ((ops & (PollArrayWrapper.POLLERR
+                    | PollArrayWrapper.POLLHUP)) != 0) {
+            newOps = intOps;
+            sk.nioReadyOps(newOps);
+            // No need to poll again in checkConnect,
+            // the error will be detected there
+            readyToConnect = true;
+            return (newOps & ~oldOps) != 0;
+        }
+
+        if (((ops & PollArrayWrapper.POLLIN) != 0) &&
+            ((intOps & SelectionKey.OP_READ) != 0) &&
+            (state == ST_CONNECTED))
+            newOps |= SelectionKey.OP_READ;
+
+        if (((ops & PollArrayWrapper.POLLCONN) != 0) &&
+            ((intOps & SelectionKey.OP_CONNECT) != 0) &&
+            ((state == ST_UNCONNECTED) || (state == ST_PENDING))) {
+            newOps |= SelectionKey.OP_CONNECT;
+            readyToConnect = true;
+        }
+
+        if (((ops & PollArrayWrapper.POLLOUT) != 0) &&
+            ((intOps & SelectionKey.OP_WRITE) != 0) &&
+            (state == ST_CONNECTED))
+            newOps |= SelectionKey.OP_WRITE;
+
+        sk.nioReadyOps(newOps);
+        return (newOps & ~oldOps) != 0;
+    }
+
+    public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl sk) {
+        return translateReadyOps(ops, sk.nioReadyOps(), sk);
+    }
+
+    public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl sk) {
+        return translateReadyOps(ops, 0, sk);
+    }
+
+    /**
+     * Translates an interest operation set into a native poll event set
+     */
+    public void translateAndSetInterestOps(int ops, SelectionKeyImpl sk) {
+        int newOps = 0;
+        if ((ops & SelectionKey.OP_READ) != 0)
+            newOps |= PollArrayWrapper.POLLIN;
+        if ((ops & SelectionKey.OP_WRITE) != 0)
+            newOps |= PollArrayWrapper.POLLOUT;
+        if ((ops & SelectionKey.OP_CONNECT) != 0)
+            newOps |= PollArrayWrapper.POLLCONN;
+        sk.selector.putEventOps(sk, newOps);
+    }
+
+    public FileDescriptor getFD() {
+        return fd;
+    }
+
+    public int getFDVal() {
+        return fdVal;
+    }
+
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(this.getClass().getSuperclass().getName());
+        sb.append('[');
+        if (!isOpen())
+            sb.append("closed");
+        else {
+            synchronized (stateLock) {
+                switch (state) {
+                case ST_UNCONNECTED:
+                    sb.append("unconnected");
+                    break;
+                case ST_PENDING:
+                    sb.append("connection-pending");
+                    break;
+                case ST_CONNECTED:
+                    sb.append("connected");
+                    if (!isInputOpen)
+                        sb.append(" ishut");
+                    if (!isOutputOpen)
+                        sb.append(" oshut");
+                    break;
+                }
+                if (localAddress() != null) {
+                    sb.append(" local=");
+                    sb.append(localAddress().toString());
+                }
+                if (remoteAddress() != null) {
+                    sb.append(" remote=");
+                    sb.append(remoteAddress().toString());
+                }
+            }
+        }
+        sb.append(']');
+        return sb.toString();
+    }
+
+
+    // -- Native methods --
+
+    private static native int checkConnect(FileDescriptor fd,
+                                           boolean block, boolean ready)
+        throws IOException;
+
+    private static native void shutdown(FileDescriptor fd, int how)
+        throws IOException;
+
+    static {
+        Util.load();
+        nd = new SocketDispatcher();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SocketDispatcher.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SocketDispatcher.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SocketDispatcher.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SocketDispatcher.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,43 @@
+/*
+ * @(#)SocketDispatcher.java	1.11 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+package sun.nio.ch;
+
+import java.io.*;
+
+/**
+ * Allows different platforms to call different native methods
+ * for read and write operations.
+ */
+
+class SocketDispatcher extends NativeDispatcher
+{
+
+    int read(FileDescriptor fd, long address, int len) throws IOException {
+        return FileDispatcher.read0(fd, address, len);
+    }
+
+    long readv(FileDescriptor fd, long address, int len) throws IOException {
+        return FileDispatcher.readv0(fd, address, len);
+    }
+
+    int write(FileDescriptor fd, long address, int len) throws IOException {
+        return FileDispatcher.write0(fd, address, len);
+    }
+
+    long writev(FileDescriptor fd, long address, int len) throws IOException {
+        return FileDispatcher.writev0(fd, address, len);
+    }
+
+    void close(FileDescriptor fd) throws IOException {
+        FileDispatcher.close0(fd);
+    }
+
+    void preClose(FileDescriptor fd) throws IOException {
+        FileDispatcher.preClose0(fd);
+    }
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SocketOptsImpl.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SocketOptsImpl.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SocketOptsImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SocketOptsImpl.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,318 @@
+/*
+ * Copyright 2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.net.NetworkInterface;
+import java.net.SocketOptions;
+import java.nio.channels.*;
+
+
+class SocketOptsImpl
+    implements SocketOpts
+{
+
+    static abstract class Dispatcher {
+        abstract int getInt(int opt) throws IOException;
+        abstract void setInt(int opt, int arg) throws IOException;
+        // Others that pass addresses, etc., will come later
+    }
+
+    private final Dispatcher d;
+
+    SocketOptsImpl(Dispatcher d) {
+        this.d = d;
+    }
+
+    protected boolean getBoolean(int opt) throws IOException {
+        return d.getInt(opt) > 0;
+    }
+
+    protected void setBoolean(int opt, boolean b) throws IOException {
+        d.setInt(opt, b ? 1 : 0);
+    }
+
+    protected int getInt(int opt) throws IOException {
+        return d.getInt(opt);
+    }
+
+    protected void setInt(int opt, int n) throws IOException {
+        d.setInt(opt, n);
+    }
+
+    protected NetworkInterface getNetworkInterface(int opt)
+        throws IOException
+    {
+        throw new UnsupportedOperationException("NYI");
+    }
+
+    protected void setNetworkInterface(int opt, NetworkInterface ni)
+        throws IOException
+    {
+        throw new UnsupportedOperationException("NYI");
+    }
+
+    protected void addToString(StringBuffer sb, String s) {
+        char c = sb.charAt(sb.length() - 1);
+        if ((c != '[') && (c != '='))
+            sb.append(' ');
+        sb.append(s);
+    }
+
+    protected void addToString(StringBuffer sb, int n) {
+        addToString(sb, Integer.toString(n));
+    }
+
+
+    // SO_BROADCAST
+
+    public boolean broadcast() throws IOException {
+        return getBoolean(SocketOptions.SO_BROADCAST);
+    }
+
+    public SocketOpts broadcast(boolean b) throws IOException {
+        setBoolean(SocketOptions.SO_BROADCAST, b);
+        return this;
+    }
+
+
+    // SO_KEEPALIVE
+
+    public boolean keepAlive() throws IOException {
+        return getBoolean(SocketOptions.SO_KEEPALIVE);
+    }
+
+    public SocketOpts keepAlive(boolean b) throws IOException {
+        setBoolean(SocketOptions.SO_KEEPALIVE, b);
+        return this;
+    }
+
+
+    // SO_LINGER
+
+    public int linger() throws IOException {
+        return getInt(SocketOptions.SO_LINGER);
+    }
+
+    public SocketOpts linger(int n) throws IOException {
+        setInt(SocketOptions.SO_LINGER, n);
+        return this;
+    }
+
+
+    // SO_OOBINLINE
+
+    public boolean outOfBandInline() throws IOException {
+        return getBoolean(SocketOptions.SO_OOBINLINE);
+    }
+
+    public SocketOpts outOfBandInline(boolean b) throws IOException {
+        setBoolean(SocketOptions.SO_OOBINLINE, b);
+        return this;
+    }
+
+
+    // SO_RCVBUF
+
+    public int receiveBufferSize() throws IOException {
+        return getInt(SocketOptions.SO_RCVBUF);
+    }
+
+    public SocketOpts receiveBufferSize(int n) throws IOException {
+        if (n <= 0)
+            throw new IllegalArgumentException("Invalid receive size");
+        setInt(SocketOptions.SO_RCVBUF, n);
+        return this;
+    }
+
+
+    // SO_SNDBUF
+
+    public int sendBufferSize() throws IOException {
+        return getInt(SocketOptions.SO_SNDBUF);
+    }
+
+    public SocketOpts sendBufferSize(int n) throws IOException {
+        if (n <= 0)
+            throw new IllegalArgumentException("Invalid send size");
+        setInt(SocketOptions.SO_SNDBUF, n);
+        return this;
+    }
+
+
+    // SO_REUSEADDR
+
+    public boolean reuseAddress() throws IOException {
+        return getBoolean(SocketOptions.SO_REUSEADDR);
+    }
+
+    public SocketOpts reuseAddress(boolean b) throws IOException {
+        setBoolean(SocketOptions.SO_REUSEADDR, b);
+        return this;
+    }
+
+
+    // toString
+
+    protected void toString(StringBuffer sb) throws IOException {
+        int n;
+        if (broadcast())
+            addToString(sb, "broadcast");
+        if (keepAlive())
+            addToString(sb, "keepalive");
+        if ((n = linger()) > 0) {
+            addToString(sb, "linger=");
+            addToString(sb, n);
+        }
+        if (outOfBandInline())
+            addToString(sb, "oobinline");
+        if ((n = receiveBufferSize()) > 0) {
+            addToString(sb, "rcvbuf=");
+            addToString(sb, n);
+        }
+        if ((n = sendBufferSize()) > 0) {
+            addToString(sb, "sndbuf=");
+            addToString(sb, n);
+        }
+        if (reuseAddress())
+            addToString(sb, "reuseaddr");
+    }
+
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(this.getClass().getInterfaces()[0].getName());
+        sb.append('[');
+        int i = sb.length();
+        try {
+            toString(sb);
+        } catch (IOException x) {
+            sb.setLength(i);
+            sb.append("closed");
+        }
+        sb.append(']');
+        return sb.toString();
+    }
+
+
+    // IP-specific socket options
+
+    static class IP
+        extends SocketOptsImpl
+        implements SocketOpts.IP
+    {
+
+        IP(Dispatcher d) {
+            super(d);
+        }
+
+
+        // IP_MULTICAST_IF2
+        // ## Do we need IP_MULTICAST_IF also?
+
+        public NetworkInterface multicastInterface() throws IOException {
+            return getNetworkInterface(SocketOptions.IP_MULTICAST_IF2);
+        }
+
+        public SocketOpts.IP multicastInterface(NetworkInterface ni)
+            throws IOException
+        {
+            setNetworkInterface(SocketOptions.IP_MULTICAST_IF2, ni);
+            return this;
+        }
+
+
+        // IP_MULTICAST_LOOP
+
+        public boolean multicastLoop() throws IOException {
+            return getBoolean(SocketOptions.IP_MULTICAST_LOOP);
+        }
+
+        public SocketOpts.IP multicastLoop(boolean b) throws IOException {
+            setBoolean(SocketOptions.IP_MULTICAST_LOOP, b);
+            return this;
+        }
+
+
+        // IP_TOS
+
+        public int typeOfService() throws IOException {
+            return getInt(SocketOptions.IP_TOS);
+        }
+
+        public SocketOpts.IP typeOfService(int tos) throws IOException {
+            setInt(SocketOptions.IP_TOS, tos);
+            return this;
+        }
+
+
+        // toString
+
+        protected void toString(StringBuffer sb) throws IOException {
+            super.toString(sb);
+            int n;
+            if ((n = typeOfService()) > 0) {
+                addToString(sb, "tos=");
+                addToString(sb, n);
+            }
+        }
+
+
+        // TCP-specific IP options
+
+        public static class TCP
+            extends SocketOptsImpl.IP
+            implements SocketOpts.IP.TCP
+        {
+
+            TCP(Dispatcher d) {
+                super(d);
+            }
+
+            // TCP_NODELAY
+
+            public boolean noDelay() throws IOException {
+                return getBoolean(SocketOptions.TCP_NODELAY);
+            }
+
+            public SocketOpts.IP.TCP noDelay(boolean b) throws IOException {
+                setBoolean(SocketOptions.TCP_NODELAY, b);
+                return this;
+            }
+
+
+            // toString
+
+            protected void toString(StringBuffer sb) throws IOException {
+                super.toString(sb);
+                if (noDelay())
+                    addToString(sb, "nodelay");
+            }
+
+        }
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SocketOpts.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SocketOpts.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/SocketOpts.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/SocketOpts.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.*;
+import java.net.NetworkInterface;
+
+
+// Typical use:
+//
+//     sc.options()
+//         .noDelay(true)
+//         .typeOfService(SocketOpts.IP.TOS_RELIABILITY)
+//         .sendBufferSize(1024)
+//         .receiveBufferSize(1024)
+//         .keepAlive(true);
+//
+
+
+public interface SocketOpts {   // SocketOptions already used in java.net
+
+    // Options that apply to all kinds of sockets
+
+    // SO_BROADCAST
+    public abstract boolean broadcast() throws IOException;
+    public abstract SocketOpts broadcast(boolean b) throws IOException;
+
+    // SO_KEEPALIVE
+    public abstract boolean keepAlive() throws IOException;
+    public abstract SocketOpts keepAlive(boolean b) throws IOException;
+
+    // SO_LINGER
+    public abstract int linger() throws IOException;
+    public abstract SocketOpts linger(int n) throws IOException;
+
+    // SO_OOBINLINE
+    public abstract boolean outOfBandInline() throws IOException;
+    public abstract SocketOpts outOfBandInline(boolean b) throws IOException;
+
+    // SO_RCVBUF
+    public abstract int receiveBufferSize() throws IOException;
+    public abstract SocketOpts receiveBufferSize(int n) throws IOException;
+
+    // SO_SNDBUF
+    public abstract int sendBufferSize() throws IOException;
+    public abstract SocketOpts sendBufferSize(int n) throws IOException;
+
+    // SO_REUSEADDR
+    public abstract boolean reuseAddress() throws IOException;
+    public abstract SocketOpts reuseAddress(boolean b) throws IOException;
+
+
+    // IP-specific options
+
+    public static interface IP
+        extends SocketOpts
+    {
+
+        // IP_MULTICAST_IF2
+        public abstract NetworkInterface multicastInterface()
+            throws IOException;
+        public abstract IP multicastInterface(NetworkInterface ni)
+            throws IOException;
+
+        // IP_MULTICAST_LOOP
+        public abstract boolean multicastLoop() throws IOException;
+        public abstract IP multicastLoop(boolean b) throws IOException;
+
+        // IP_TOS
+        public static final int TOS_LOWDELAY = 0x10;
+        public static final int TOS_THROUGHPUT = 0x08;
+        public static final int TOS_RELIABILITY = 0x04;
+        public static final int TOS_MINCOST = 0x02;
+        public abstract int typeOfService() throws IOException;
+        public abstract IP typeOfService(int tos) throws IOException;
+
+
+        // TCP-specific options
+
+        public static interface TCP
+            extends IP
+        {
+            // TCP_NODELAY
+            public abstract boolean noDelay() throws IOException;
+            public abstract TCP noDelay(boolean b) throws IOException;
+
+        }
+
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/Util.java phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/Util.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/classes/sun/nio/ch/Util.java	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/classes/sun/nio/ch/Util.java	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,373 @@
+/*
+ * Copyright 2000-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.lang.ref.SoftReference;
+import java.lang.reflect.*;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.MappedByteBuffer;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.*;
+import sun.misc.Unsafe;
+import sun.misc.Cleaner;
+import sun.security.action.GetPropertyAction;
+
+
+class Util {
+
+
+    // -- Caches --
+
+    // The number of temp buffers in our pool
+    private static final int TEMP_BUF_POOL_SIZE = 3;
+
+    // Per-thread soft cache of the last temporary direct buffer
+    private static ThreadLocal[] bufferPool;
+
+//    @SuppressWarnings("unchecked")
+    static ThreadLocal[] createThreadLocalBufferPool() {
+        return new ThreadLocal[TEMP_BUF_POOL_SIZE];
+    }
+
+    static {
+        bufferPool = createThreadLocalBufferPool();
+        for (int i=0; i<TEMP_BUF_POOL_SIZE; i++)
+            bufferPool[i] = new ThreadLocal();
+    }
+
+    static ByteBuffer getTemporaryDirectBuffer(int size) {
+        ByteBuffer buf = null;
+        // Grab a buffer if available
+        for (int i=0; i<TEMP_BUF_POOL_SIZE; i++) {
+            SoftReference ref = (SoftReference)bufferPool[i].get();
+            if ((ref != null) && ((buf = (ByteBuffer)ref.get()) != null) &&
+                (buf.capacity() >= size)) {
+                buf.rewind();
+                buf.limit(size);
+                bufferPool[i].set(null);
+                return buf;
+            }
+        }
+
+        // Make a new one
+        return ByteBuffer.allocateDirect(size);
+    }
+
+    static void releaseTemporaryDirectBuffer(ByteBuffer buf) {
+        if (buf == null)
+            return;
+        // Put it in an empty slot if such exists
+        for (int i=0; i<TEMP_BUF_POOL_SIZE; i++) {
+            SoftReference ref = (SoftReference)bufferPool[i].get();
+            if ((ref == null) || (ref.get() == null)) {
+                bufferPool[i].set(new SoftReference(buf));
+                return;
+            }
+        }
+        // Otherwise replace a smaller one in the cache if such exists
+        for (int i=0; i<TEMP_BUF_POOL_SIZE; i++) {
+            SoftReference ref = (SoftReference)bufferPool[i].get();
+            ByteBuffer inCacheBuf = (ByteBuffer)ref.get();
+            if ((inCacheBuf == null) || (buf.capacity() > inCacheBuf.capacity())) {
+                bufferPool[i].set(new SoftReference(buf));
+                return;
+            }
+        }
+    }
+
+    private static class SelectorWrapper {
+        private Selector sel;
+        private SelectorWrapper (Selector sel) {
+            this.sel = sel;
+            Cleaner.create(this, new Closer(sel));
+        }
+        private static class Closer implements Runnable {
+            private Selector sel;
+            private Closer (Selector sel) {
+                this.sel = sel;
+            }
+            public void run () {
+                try {
+                    sel.close();
+                } catch (Throwable th) {
+                    throw new Error(th);
+                }
+            }
+        }
+        public Selector get() { return sel;}
+    }
+
+    // Per-thread cached selector
+    private static ThreadLocal localSelector
+        = new ThreadLocal();
+    // Hold a reference to the selWrapper object to prevent it from
+    // being cleaned when the temporary selector wrapped is on lease.
+    private static ThreadLocal localSelectorWrapper
+        = new ThreadLocal();
+
+    // When finished, invoker must ensure that selector is empty
+    // by cancelling any related keys and explicitly releasing
+    // the selector by invoking releaseTemporarySelector()
+    static Selector getTemporarySelector(SelectableChannel sc)
+        throws IOException
+    {
+        SoftReference ref = (SoftReference)localSelector.get();
+        SelectorWrapper selWrapper = null;
+        Selector sel = null;
+        if (ref == null
+            || ((selWrapper = (SelectorWrapper)ref.get()) == null)
+            || ((sel = selWrapper.get()) == null)
+            || (sel.provider() != sc.provider())) {
+            sel = sc.provider().openSelector();
+            selWrapper = new SelectorWrapper(sel);
+            localSelector.set(new SoftReference(selWrapper));
+        }
+        localSelectorWrapper.set(selWrapper);
+        return sel;
+    }
+
+    static void releaseTemporarySelector(Selector sel)
+        throws IOException
+    {
+        // Selector should be empty
+        sel.selectNow();                // Flush cancelled keys
+        assert sel.keys().isEmpty() : "Temporary selector not empty";
+        localSelectorWrapper.set(null);
+    }
+
+
+    // -- Random stuff --
+
+    static ByteBuffer[] subsequence(ByteBuffer[] bs, int offset, int length) {
+        if ((offset == 0) && (length == bs.length))
+            return bs;
+        int n = length;
+        ByteBuffer[] bs2 = new ByteBuffer[n];
+        for (int i = 0; i < n; i++)
+            bs2[i] = bs[offset + i];
+        return bs2;
+    }
+
+    static  Set ungrowableSet(final Set s) {
+        return new Set() {
+
+                public int size()                 { return s.size(); }
+                public boolean isEmpty()          { return s.isEmpty(); }
+                public boolean contains(Object o) { return s.contains(o); }
+                public Object[] toArray()         { return s.toArray(); }
+                public Object[] toArray(Object[] o)         { return s.toArray(); }
+                public String toString()          { return s.toString(); }
+                public Iterator iterator()     { return s.iterator(); }
+                public boolean equals(Object o)   { return s.equals(o); }
+                public int hashCode()             { return s.hashCode(); }
+                public void clear()               { s.clear(); }
+                public boolean remove(Object o)   { return s.remove(o); }
+
+                public boolean containsAll(Collection coll) {
+                    return s.containsAll(coll);
+                }
+                public boolean removeAll(Collection coll) {
+                    return s.removeAll(coll);
+                }
+                public boolean retainAll(Collection coll) {
+                    return s.retainAll(coll);
+                }
+
+                public boolean add(Object o){
+                    throw new UnsupportedOperationException();
+                }
+                public boolean addAll(Collection coll) {
+                    throw new UnsupportedOperationException();
+                }
+
+        };
+    }
+
+
+    // -- Unsafe access --
+
+    private static Unsafe unsafe = Unsafe.getUnsafe();
+
+    private static byte _get(long a) {
+        return unsafe.getByte(a);
+    }
+
+    private static void _put(long a, byte b) {
+        unsafe.putByte(a, b);
+    }
+
+    static void erase(ByteBuffer bb) {
+        unsafe.setMemory(((DirectBuffer)bb).address(), bb.capacity(), (byte)0);
+    }
+
+    static Unsafe unsafe() {
+        return unsafe;
+    }
+
+    private static int pageSize = -1;
+
+    static int pageSize() {
+        if (pageSize == -1)
+            pageSize = unsafe().pageSize();
+        return pageSize;
+    }
+
+    private static volatile Constructor directByteBufferConstructor = null;
+
+    private static void initDBBConstructor() {
+        AccessController.doPrivileged(new PrivilegedAction() {
+                public Object run() {
+                    try {
+                        Class cl = Class.forName("java.nio.DirectByteBuffer");
+                        Constructor ctor = cl.getDeclaredConstructor(
+                            new Class[] { int.class,
+                                          long.class,
+                                          Runnable.class });
+                        ctor.setAccessible(true);
+                        directByteBufferConstructor = ctor;
+                    } catch (ClassNotFoundException x) {
+                        throw new InternalError();
+                    } catch (NoSuchMethodException x) {
+                        throw new InternalError();
+                    } catch (IllegalArgumentException x) {
+                        throw new InternalError();
+                    } catch (ClassCastException x) {
+                        throw new InternalError();
+                    }
+                    return null;
+                }});
+    }
+
+    static MappedByteBuffer newMappedByteBuffer(int size, long addr,
+                                                Runnable unmapper)
+    {
+        MappedByteBuffer dbb;
+        if (directByteBufferConstructor == null)
+            initDBBConstructor();
+        try {
+            dbb = (MappedByteBuffer)directByteBufferConstructor.newInstance(
+              new Object[] { new Integer(size),
+                             new Long(addr),
+                             unmapper });
+        } catch (InstantiationException e) {
+            throw new InternalError();
+        } catch (IllegalAccessException e) {
+            throw new InternalError();
+        } catch (InvocationTargetException e) {
+            throw new InternalError();
+        }
+        return dbb;
+    }
+
+    private static volatile Constructor directByteBufferRConstructor = null;
+
+    private static void initDBBRConstructor() {
+        AccessController.doPrivileged(new PrivilegedAction() {
+                public Object run() {
+                    try {
+                        Class cl = Class.forName("java.nio.DirectByteBufferR");
+                        Constructor ctor = cl.getDeclaredConstructor(
+                            new Class[] { int.class,
+                                          long.class,
+                                          Runnable.class });
+                        ctor.setAccessible(true);
+                        directByteBufferRConstructor = ctor;
+                    } catch (ClassNotFoundException x) {
+                        throw new InternalError();
+                    } catch (NoSuchMethodException x) {
+                        throw new InternalError();
+                    } catch (IllegalArgumentException x) {
+                        throw new InternalError();
+                    } catch (ClassCastException x) {
+                        throw new InternalError();
+                    }
+                    return null;
+                }});
+    }
+
+    static MappedByteBuffer newMappedByteBufferR(int size, long addr,
+                                                 Runnable unmapper)
+    {
+        MappedByteBuffer dbb;
+        if (directByteBufferRConstructor == null)
+            initDBBRConstructor();
+        try {
+            dbb = (MappedByteBuffer)directByteBufferRConstructor.newInstance(
+              new Object[] { new Integer(size),
+                             new Long(addr),
+                             unmapper });
+        } catch (InstantiationException e) {
+            throw new InternalError();
+        } catch (IllegalAccessException e) {
+            throw new InternalError();
+        } catch (InvocationTargetException e) {
+            throw new InternalError();
+        }
+        return dbb;
+    }
+
+
+    // -- Bug compatibility --
+
+    private static volatile String bugLevel = null;
+
+    static boolean atBugLevel(String bl) {              // package-private
+        if (bugLevel == null) {
+//NARFLEX            if (!sun.misc.VM.isBooted())
+//NARFLEX              return false;
+            String value = (String)AccessController.doPrivileged(
+                new GetPropertyAction("sun.nio.ch.bugLevel"));
+            bugLevel = (value != null) ? value : "";
+        }
+        return bugLevel.equals(bl);
+    }
+
+
+
+    // -- Initialization --
+
+    private static boolean loaded = false;
+
+    static void load() {
+        synchronized (Util.class) {
+            if (loaded)
+                return;
+            loaded = true;
+            java.security.AccessController
+                .doPrivileged(new sun.security.action.LoadLibraryAction("net"));
+//            java.security.AccessController
+//                .doPrivileged(new sun.security.action.LoadLibraryAction("nio"));
+            // IOUtil must be initialized; Its native methods are called from
+            // other places in native nio code so they must be set up.
+            IOUtil.initIDs();
+        }
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/foundation/classes/java/io/RandomAccessFile.java phoneme_advanced-mr2-dev-b122/cdc/src/share/foundation/classes/java/io/RandomAccessFile.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/foundation/classes/java/io/RandomAccessFile.java	2009-07-06 18:37:19.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/foundation/classes/java/io/RandomAccessFile.java	2009-07-06 19:31:01.000000000 -0400
@@ -27,6 +27,9 @@
 
 package java.io;
 
+import java.nio.channels.FileChannel;
+import sun.nio.ch.FileChannelImpl;
+
 
 /**
  * Instances of this class support both reading and writing to a 
@@ -56,11 +59,15 @@
  * @since   JDK1.0
  */
 
-public class RandomAccessFile implements DataOutput, DataInput {
+public class RandomAccessFile implements DataOutput, DataInput, Closeable {
 
     private FileDescriptor fd;
+    private FileChannel channel = null;
     private boolean rw;
 
+    private Object closeLock = new Object();
+    private volatile boolean closed = false;
+
     private static final int O_RDONLY = 1;
     private static final int O_RDWR =   2;
     private static final int O_SYNC =   4;
@@ -91,9 +98,13 @@
      * @exception  IllegalArgumentException  if the mode argument is not equal
      *               to one of <tt>"r"</tt>, <tt>"rw"</tt>, <tt>"rws"</tt>, or
      *               <tt>"rwd"</tt>
-     * @exception  FileNotFoundException  if the file exists but is a directory
-     *                   rather than a regular file, or cannot be opened or
-     *                   created for any other reason
+     * @exception FileNotFoundException
+     *            if the mode is <tt>"r"</tt> but the given string does not
+     *            denote an existing regular file, or if the mode begins with
+     *            <tt>"rw"</tt> but the given string does not denote an
+     *            existing, writable regular file and a new regular file of
+     *            that name cannot be created, or if some other error occurs
+     *            while opening or creating the file
      * @exception  SecurityException         if a security manager exists and its
      *               <code>checkRead</code> method denies read access to the file
      *               or the mode is "rw" and the security manager's
@@ -105,7 +116,7 @@
      * @spec JSR-51
      */
     public RandomAccessFile(String name, String mode)
-	throws FileNotFoundException
+        throws FileNotFoundException
     {
         this(name != null ? new File(name) : null, mode);
     }
@@ -138,7 +149,11 @@
      *     synchronously to the underlying storage device. </td></tr>
      * </table></blockquote>
      *
-     * If
+     * The <tt>"rws"</tt> and <tt>"rwd"</tt> modes work much like the {@link
+     * java.nio.channels.FileChannel#force(boolean) force(boolean)} method of
+     * the {@link java.nio.channels.FileChannel} class, passing arguments of
+     * <tt>true</tt> and <tt>false</tt>, respectively, except that they always
+     * apply to every I/O operation and are therefore often more efficient.  If
      * the file resides on a local storage device then when an invocation of a
      * method of this class returns it is guaranteed that all changes made to
      * the file by that invocation will have been written to that device.  This
@@ -165,54 +180,60 @@
      * @exception  IllegalArgumentException  if the mode argument is not equal
      *               to one of <tt>"r"</tt>, <tt>"rw"</tt>, <tt>"rws"</tt>, or
      *               <tt>"rwd"</tt>
-     * @exception  FileNotFoundException  if the file exists but is a directory
-     *                   rather than a regular file, or cannot be opened or
-     *                   created for any other reason
+     * @exception FileNotFoundException
+     *            if the mode is <tt>"r"</tt> but the given file object does
+     *            not denote an existing regular file, or if the mode begins
+     *            with <tt>"rw"</tt> but the given file object does not denote
+     *            an existing, writable regular file and a new regular file of
+     *            that name cannot be created, or if some other error occurs
+     *            while opening or creating the file
      * @exception  SecurityException         if a security manager exists and its
      *               <code>checkRead</code> method denies read access to the file
      *               or the mode is "rw" and the security manager's
      *               <code>checkWrite</code> method denies write access to the file
      * @see        java.lang.SecurityManager#checkRead(java.lang.String)
      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+     * @see        java.nio.channels.FileChannel#force(boolean)
      * @revised 1.4
      * @spec JSR-51
      */
     public RandomAccessFile(File file, String mode)
-	throws FileNotFoundException
+        throws FileNotFoundException
     {
-	String name = (file != null ? file.getPath() : null);
-	int imode = -1;
-	if (mode.equals("r"))
-	    imode = O_RDONLY;
-	else if (mode.startsWith("rw")) {
-	    imode = O_RDWR;
-	    rw = true;
-	    if (mode.length() > 2) {
-		if (mode.equals("rws"))
-		    imode |= O_SYNC;
-		else if (mode.equals("rwd"))
-		    imode |= O_DSYNC;
-		else
-		    imode = -1;
-	    }
-	}
-	if (imode < 0)
-	    throw new IllegalArgumentException("Illegal mode \"" + mode
-					       + "\" must be one of "
-					       + "\"r\", \"rw\", \"rws\","
-					       + " or \"rwd\"");
-	SecurityManager security = System.getSecurityManager();
-	if (security != null) {
-	    security.checkRead(name);
-	    if (rw) {
-		security.checkWrite(name);
-	    }
-	}
+        String name = (file != null ? file.getPath() : null);
+        int imode = -1;
+        if (mode.equals("r"))
+            imode = O_RDONLY;
+        else if (mode.startsWith("rw")) {
+            imode = O_RDWR;
+            rw = true;
+            if (mode.length() > 2) {
+                if (mode.equals("rws"))
+                    imode |= O_SYNC;
+                else if (mode.equals("rwd"))
+                    imode |= O_DSYNC;
+                else
+                    imode = -1;
+            }
+        }
+        if (imode < 0)
+            throw new IllegalArgumentException("Illegal mode \"" + mode
+                                               + "\" must be one of "
+                                               + "\"r\", \"rw\", \"rws\","
+                                               + " or \"rwd\"");
+        SecurityManager security = System.getSecurityManager();
+        if (security != null) {
+            security.checkRead(name);
+            if (rw) {
+                security.checkWrite(name);
+            }
+        }
         if (name == null) {
             throw new NullPointerException();
         }
-	fd = new FileDescriptor();
-	open(name, imode);
+        fd = new FileDescriptor();
+        fd.incrementAndGetUseCount();
+        open(name, imode);
     }
 
     /**
@@ -224,8 +245,8 @@
      * @see        java.io.FileDescriptor
      */
     public final FileDescriptor getFD() throws IOException {
-	if (fd != null) return fd;
-	throw new IOException();
+        if (fd != null) return fd;
+        throw new IOException();
     }
 
     /**
@@ -246,20 +267,30 @@
      * @since 1.4
      * @spec JSR-51
      */
-    /* NOTE: No NIO in CDC
     public final FileChannel getChannel() {
-	synchronized (this) {
-	    if (channel == null)
-		channel = FileChannelImpl.open(fd, true, rw, this);
-	    return channel;
-	}
-    }
-    */ 
+        synchronized (this) {
+            if (channel == null) {
+                channel = FileChannelImpl.open(fd, true, rw, this);
+
+                /*
+                 * FileDescriptor could be shared by FileInputStream or
+                 * FileOutputStream.
+                 * Ensure that FD is GC'ed only when all the streams/channels
+                 * are done using it.
+                 * Increment fd's use count. Invoking the channel's close()
+                 * method will result in decrementing the use count set for
+                 * the channel.
+                 */
+                fd.incrementAndGetUseCount();
+            }
+            return channel;
+        }
+    }
 
     /**
-     * Opens a file and returns the file descriptor.  The file is 
-     * opened in read-write mode if writeable is true, else 
-     * the file is opened as read-only.
+     * Opens a file and returns the file descriptor.  The file is
+     * opened in read-write mode if the O_RDWR bit in <code>mode</code>
+     * is true, else the file is opened as read-only.
      * If the <code>name</code> refers to a directory, an IOException
      * is thrown.
      *
@@ -268,100 +299,110 @@
      *             defined above
      */
     private native void open(String name, int mode)
-	throws FileNotFoundException;
+        throws FileNotFoundException;
 
     // 'Read' primitives
 
     /**
-     * Reads a byte of data from this file. The byte is returned as an 
-     * integer in the range 0 to 255 (<code>0x00-0x0ff</code>). This 
-     * method blocks if no input is yet available. 
+     * Reads a byte of data from this file. The byte is returned as an
+     * integer in the range 0 to 255 (<code>0x00-0x0ff</code>). This
+     * method blocks if no input is yet available.
      * <p>
-     * Although <code>RandomAccessFile</code> is not a subclass of 
-     * <code>InputStream</code>, this method behaves in exactly the same 
-     * way as the {@link InputStream#read()} method of 
+     * Although <code>RandomAccessFile</code> is not a subclass of
+     * <code>InputStream</code>, this method behaves in exactly the same
+     * way as the {@link InputStream#read()} method of
      * <code>InputStream</code>.
      *
      * @return     the next byte of data, or <code>-1</code> if the end of the
      *             file has been reached.
-     * @exception  IOException  if an I/O error occurs. Not thrown if  
+     * @exception  IOException  if an I/O error occurs. Not thrown if
      *                          end-of-file has been reached.
      */
     public native int read() throws IOException;
 
     /**
-     * Reads a sub array as a sequence of bytes. 
-     * @param b the data to be written
-     * @param off the start offset in the data
-     * @param len the number of bytes that are written
+     * Reads a sub array as a sequence of bytes.
+     * @param b the buffer into which the data is read.
+     * @param off the start offset of the data.
+     * @param len the number of bytes to read.
      * @exception IOException If an I/O error has occurred.
      */
     private native int readBytes(byte b[], int off, int len) throws IOException;
 
     /**
-     * Reads up to <code>len</code> bytes of data from this file into an 
-     * array of bytes. This method blocks until at least one byte of input 
-     * is available. 
+     * Reads up to <code>len</code> bytes of data from this file into an
+     * array of bytes. This method blocks until at least one byte of input
+     * is available.
      * <p>
-     * Although <code>RandomAccessFile</code> is not a subclass of 
-     * <code>InputStream</code>, this method behaves in the exactly the 
-     * same way as the {@link InputStream#read(byte[], int, int)} method of 
+     * Although <code>RandomAccessFile</code> is not a subclass of
+     * <code>InputStream</code>, this method behaves in exactly the
+     * same way as the {@link InputStream#read(byte[], int, int)} method of
      * <code>InputStream</code>.
      *
      * @param      b     the buffer into which the data is read.
-     * @param      off   the start offset of the data.
+     * @param      off   the start offset in array <code>b</code>
+     *                   at which the data is written.
      * @param      len   the maximum number of bytes read.
      * @return     the total number of bytes read into the buffer, or
      *             <code>-1</code> if there is no more data because the end of
      *             the file has been reached.
-     * @exception  IOException  if an I/O error occurs.
+     * @exception  IOException If the first byte cannot be read for any reason
+     * other than end of file, or if the random access file has been closed, or if
+     * some other I/O error occurs.
+     * @exception  NullPointerException If <code>b</code> is <code>null</code>.
+     * @exception  IndexOutOfBoundsException If <code>off</code> is negative,
+     * <code>len</code> is negative, or <code>len</code> is greater than
+     * <code>b.length - off</code>
      */
     public int read(byte b[], int off, int len) throws IOException {
-	return readBytes(b, off, len);
+        return readBytes(b, off, len);
     }
 
     /**
-     * Reads up to <code>b.length</code> bytes of data from this file 
-     * into an array of bytes. This method blocks until at least one byte 
-     * of input is available. 
+     * Reads up to <code>b.length</code> bytes of data from this file
+     * into an array of bytes. This method blocks until at least one byte
+     * of input is available.
      * <p>
-     * Although <code>RandomAccessFile</code> is not a subclass of 
-     * <code>InputStream</code>, this method behaves in the exactly the 
-     * same way as the {@link InputStream#read(byte[])} method of 
+     * Although <code>RandomAccessFile</code> is not a subclass of
+     * <code>InputStream</code>, this method behaves in exactly the
+     * same way as the {@link InputStream#read(byte[])} method of
      * <code>InputStream</code>.
      *
      * @param      b   the buffer into which the data is read.
      * @return     the total number of bytes read into the buffer, or
      *             <code>-1</code> if there is no more data because the end of
      *             this file has been reached.
-     * @exception  IOException  if an I/O error occurs.
+     * @exception  IOException If the first byte cannot be read for any reason
+     * other than end of file, or if the random access file has been closed, or if
+     * some other I/O error occurs.
+     * @exception  NullPointerException If <code>b</code> is <code>null</code>.
      */
     public int read(byte b[]) throws IOException {
-	return readBytes(b, 0, b.length);
+        return readBytes(b, 0, b.length);
     }
 
     /**
-     * Reads <code>b.length</code> bytes from this file into the byte 
-     * array, starting at the current file pointer. This method reads 
-     * repeatedly from the file until the requested number of bytes are 
-     * read. This method blocks until the requested number of bytes are 
-     * read, the end of the stream is detected, or an exception is thrown. 
+     * Reads <code>b.length</code> bytes from this file into the byte
+     * array, starting at the current file pointer. This method reads
+     * repeatedly from the file until the requested number of bytes are
+     * read. This method blocks until the requested number of bytes are
+     * read, the end of the stream is detected, or an exception is thrown.
      *
      * @param      b   the buffer into which the data is read.
      * @exception  EOFException  if this file reaches the end before reading
      *               all the bytes.
-     * @exception  IOException   if an I/O error occurs.       
+     * @exception  IOException   if an I/O error occurs.
      */
     public final void readFully(byte b[]) throws IOException {
-	readFully(b, 0, b.length);
+        readFully(b, 0, b.length);
     }
 
     /**
-     * Reads exactly <code>len</code> bytes from this file into the byte 
-     * array, starting at the current file pointer. This method reads 
-     * repeatedly from the file until the requested number of bytes are 
-     * read. This method blocks until the requested number of bytes are 
-     * read, the end of the stream is detected, or an exception is thrown. 
+     * Reads exactly <code>len</code> bytes from this file into the byte
+     * array, starting at the current file pointer. This method reads
+     * repeatedly from the file until the requested number of bytes are
+     * read. This method blocks until the requested number of bytes are
+     * read, the end of the stream is detected, or an exception is thrown.
      *
      * @param      b     the buffer into which the data is read.
      * @param      off   the start offset of the data.
@@ -372,24 +413,24 @@
      */
     public final void readFully(byte b[], int off, int len) throws IOException {
         int n = 0;
-	do {
-	    int count = this.read(b, off + n, len - n);
-	    if (count < 0)
-		throw new EOFException();
-	    n += count;
-	} while (n < len);
+        do {
+            int count = this.read(b, off + n, len - n);
+            if (count < 0)
+                throw new EOFException();
+            n += count;
+        } while (n < len);
     }
 
     /**
-     * Attempts to skip over <code>n</code> bytes of input discarding the 
-     * skipped bytes. 
+     * Attempts to skip over <code>n</code> bytes of input discarding the
+     * skipped bytes.
      * <p>
-     * 
-     * This method may skip over some smaller number of bytes, possibly zero. 
-     * This may result from any of a number of conditions; reaching end of 
-     * file before <code>n</code> bytes have been skipped is only one 
-     * possibility. This method never throws an <code>EOFException</code>. 
-     * The actual number of bytes skipped is returned.  If <code>n</code> 
+     *
+     * This method may skip over some smaller number of bytes, possibly zero.
+     * This may result from any of a number of conditions; reaching end of
+     * file before <code>n</code> bytes have been skipped is only one
+     * possibility. This method never throws an <code>EOFException</code>.
+     * The actual number of bytes skipped is returned.  If <code>n</code>
      * is negative, no bytes are skipped.
      *
      * @param      n   the number of bytes to be skipped.
@@ -398,28 +439,28 @@
      */
     public int skipBytes(int n) throws IOException {
         long pos;
-	long len;
-	long newpos; 
+        long len;
+        long newpos;
 
-	if (n <= 0) {
-	    return 0;
-	}
-	pos = getFilePointer();
-	len = length();
-	newpos = pos + n;
-	if (newpos > len) {
-	    newpos = len;
-	}
-	seek(newpos);
+        if (n <= 0) {
+            return 0;
+        }
+        pos = getFilePointer();
+        len = length();
+        newpos = pos + n;
+        if (newpos > len) {
+            newpos = len;
+        }
+        seek(newpos);
 
-	/* return the actual number of bytes skipped */
-	return (int) (newpos - pos);
+        /* return the actual number of bytes skipped */
+        return (int) (newpos - pos);
     }
 
     // 'Write' primitives
 
     /**
-     * Writes the specified byte to this file. The write starts at 
+     * Writes the specified byte to this file. The write starts at
      * the current file pointer.
      *
      * @param      b   the <code>byte</code> to be written.
@@ -428,7 +469,7 @@
     public native void write(int b) throws IOException;
 
     /**
-     * Writes a sub array as a sequence of bytes. 
+     * Writes a sub array as a sequence of bytes.
      * @param b the data to be written
 
      * @param off the start offset in the data
@@ -438,19 +479,19 @@
     private native void writeBytes(byte b[], int off, int len) throws IOException;
 
     /**
-     * Writes <code>b.length</code> bytes from the specified byte array 
-     * to this file, starting at the current file pointer. 
+     * Writes <code>b.length</code> bytes from the specified byte array
+     * to this file, starting at the current file pointer.
      *
      * @param      b   the data.
      * @exception  IOException  if an I/O error occurs.
      */
     public void write(byte b[]) throws IOException {
-	writeBytes(b, 0, b.length); 
+        writeBytes(b, 0, b.length);
     }
 
     /**
-     * Writes <code>len</code> bytes from the specified byte array 
-     * starting at offset <code>off</code> to this file. 
+     * Writes <code>len</code> bytes from the specified byte array
+     * starting at offset <code>off</code> to this file.
      *
      * @param      b     the data.
      * @param      off   the start offset in the data.
@@ -458,13 +499,13 @@
      * @exception  IOException  if an I/O error occurs.
      */
     public void write(byte b[], int off, int len) throws IOException {
-	writeBytes(b, off, len);
+        writeBytes(b, off, len);
     }
 
     // 'Random access' stuff
 
     /**
-     * Returns the current offset in this file. 
+     * Returns the current offset in this file.
      *
      * @return     the offset from the beginning of the file, in bytes,
      *             at which the next read or write occurs.
@@ -473,17 +514,17 @@
     public native long getFilePointer() throws IOException;
 
     /**
-     * Sets the file-pointer offset, measured from the beginning of this 
-     * file, at which the next read or write occurs.  The offset may be 
-     * set beyond the end of the file. Setting the offset beyond the end 
-     * of the file does not change the file length.  The file length will 
-     * change only by writing after the offset has been set beyond the end 
-     * of the file. 
+     * Sets the file-pointer offset, measured from the beginning of this
+     * file, at which the next read or write occurs.  The offset may be
+     * set beyond the end of the file. Setting the offset beyond the end
+     * of the file does not change the file length.  The file length will
+     * change only by writing after the offset has been set beyond the end
+     * of the file.
      *
-     * @param      pos   the offset position, measured in bytes from the 
-     *                   beginning of the file, at which to set the file 
+     * @param      pos   the offset position, measured in bytes from the
+     *                   beginning of the file, at which to set the file
      *                   pointer.
-     * @exception  IOException  if <code>pos</code> is less than 
+     * @exception  IOException  if <code>pos</code> is less than
      *                          <code>0</code> or if an I/O error occurs.
      */
     public native void seek(long pos) throws IOException;
@@ -503,7 +544,7 @@
      * <code>length</code> method is greater than the <code>newLength</code>
      * argument then the file will be truncated.  In this case, if the file
      * offset as returned by the <code>getFilePointer</code> method is greater
-     * then <code>newLength</code> then after this method returns the offset
+     * than <code>newLength</code> then after this method returns the offset
      * will be equal to <code>newLength</code>.
      *
      * <p> If the present length of the file as returned by the
@@ -518,17 +559,41 @@
     public native void setLength(long newLength) throws IOException;
 
     /**
-     * Closes this random access file stream and releases any system 
-     * resources associated with the stream. A closed random access 
-     * file cannot perform input or output operations and cannot be 
+     * Closes this random access file stream and releases any system
+     * resources associated with the stream. A closed random access
+     * file cannot perform input or output operations and cannot be
      * reopened.
      *
+     * <p> If this file has an associated channel then the channel is closed
+     * as well.
+     *
      * @exception  IOException  if an I/O error occurs.
      *
      * @revised 1.4
      * @spec JSR-51
      */
     public void close() throws IOException {
+        synchronized (closeLock) {
+            if (closed) {
+                return;
+            }
+            closed = true;
+        }
+        if (channel != null) {
+            /*
+             * Decrement FD use count associated with the channel. The FD use
+             * count is incremented whenever a new channel is obtained from
+             * this stream.
+             */
+            fd.decrementAndGetUseCount();
+            channel.close();
+        }
+
+        /*
+         * Decrement FD use count associated with this stream.
+         * The count got incremented by FileDescriptor during its construction.
+         */
+        fd.decrementAndGetUseCount();
         close0();
     }
 
@@ -538,36 +603,36 @@
     //
 
     /**
-     * Reads a <code>boolean</code> from this file. This method reads a 
-     * single byte from the file, starting at the current file pointer. 
-     * A value of <code>0</code> represents 
-     * <code>false</code>. Any other value represents <code>true</code>. 
-     * This method blocks until the byte is read, the end of the stream 
-     * is detected, or an exception is thrown. 
+     * Reads a <code>boolean</code> from this file. This method reads a
+     * single byte from the file, starting at the current file pointer.
+     * A value of <code>0</code> represents
+     * <code>false</code>. Any other value represents <code>true</code>.
+     * This method blocks until the byte is read, the end of the stream
+     * is detected, or an exception is thrown.
      *
      * @return     the <code>boolean</code> value read.
      * @exception  EOFException  if this file has reached the end.
      * @exception  IOException   if an I/O error occurs.
      */
     public final boolean readBoolean() throws IOException {
-	int ch = this.read();
-	if (ch < 0)
-	    throw new EOFException();
-	return (ch != 0);
+        int ch = this.read();
+        if (ch < 0)
+            throw new EOFException();
+        return (ch != 0);
     }
 
     /**
-     * Reads a signed eight-bit value from this file. This method reads a 
-     * byte from the file, starting from the current file pointer. 
-     * If the byte read is <code>b</code>, where 
-     * <code>0&nbsp;&lt;=&nbsp;b&nbsp;&lt;=&nbsp;255</code>, 
+     * Reads a signed eight-bit value from this file. This method reads a
+     * byte from the file, starting from the current file pointer.
+     * If the byte read is <code>b</code>, where
+     * <code>0&nbsp;&lt;=&nbsp;b&nbsp;&lt;=&nbsp;255</code>,
      * then the result is:
      * <blockquote><pre>
      *     (byte)(b)
      * </pre></blockquote>
      * <p>
-     * This method blocks until the byte is read, the end of the stream 
-     * is detected, or an exception is thrown. 
+     * This method blocks until the byte is read, the end of the stream
+     * is detected, or an exception is thrown.
      *
      * @return     the next byte of this file as a signed eight-bit
      *             <code>byte</code>.
@@ -575,19 +640,19 @@
      * @exception  IOException   if an I/O error occurs.
      */
     public final byte readByte() throws IOException {
-	int ch = this.read();
-	if (ch < 0)
-	    throw new EOFException();
-	return (byte)(ch);
+        int ch = this.read();
+        if (ch < 0)
+            throw new EOFException();
+        return (byte)(ch);
     }
 
     /**
-     * Reads an unsigned eight-bit number from this file. This method reads 
-     * a byte from this file, starting at the current file pointer, 
-     * and returns that byte. 
+     * Reads an unsigned eight-bit number from this file. This method reads
+     * a byte from this file, starting at the current file pointer,
+     * and returns that byte.
      * <p>
-     * This method blocks until the byte is read, the end of the stream 
-     * is detected, or an exception is thrown. 
+     * This method blocks until the byte is read, the end of the stream
+     * is detected, or an exception is thrown.
      *
      * @return     the next byte of this file, interpreted as an unsigned
      *             eight-bit number.
@@ -595,25 +660,25 @@
      * @exception  IOException   if an I/O error occurs.
      */
     public final int readUnsignedByte() throws IOException {
-	int ch = this.read();
-	if (ch < 0)
-	    throw new EOFException();
-	return ch;
+        int ch = this.read();
+        if (ch < 0)
+            throw new EOFException();
+        return ch;
     }
 
     /**
-     * Reads a signed 16-bit number from this file. The method reads two 
-     * bytes from this file, starting at the current file pointer. 
-     * If the two bytes read, in order, are 
-     * <code>b1</code> and <code>b2</code>, where each of the two values is 
-     * between <code>0</code> and <code>255</code>, inclusive, then the 
+     * Reads a signed 16-bit number from this file. The method reads two
+     * bytes from this file, starting at the current file pointer.
+     * If the two bytes read, in order, are
+     * <code>b1</code> and <code>b2</code>, where each of the two values is
+     * between <code>0</code> and <code>255</code>, inclusive, then the
      * result is equal to:
      * <blockquote><pre>
      *     (short)((b1 &lt;&lt; 8) | b2)
      * </pre></blockquote>
      * <p>
-     * This method blocks until the two bytes are read, the end of the 
-     * stream is detected, or an exception is thrown. 
+     * This method blocks until the two bytes are read, the end of the
+     * stream is detected, or an exception is thrown.
      *
      * @return     the next two bytes of this file, interpreted as a signed
      *             16-bit number.
@@ -622,26 +687,26 @@
      * @exception  IOException   if an I/O error occurs.
      */
     public final short readShort() throws IOException {
-	int ch1 = this.read();
-	int ch2 = this.read();
-	if ((ch1 | ch2) < 0)
-	    throw new EOFException();
-	return (short)((ch1 << 8) + (ch2 << 0));
+        int ch1 = this.read();
+        int ch2 = this.read();
+        if ((ch1 | ch2) < 0)
+            throw new EOFException();
+        return (short)((ch1 << 8) + (ch2 << 0));
     }
 
     /**
-     * Reads an unsigned 16-bit number from this file. This method reads 
-     * two bytes from the file, starting at the current file pointer. 
-     * If the bytes read, in order, are 
-     * <code>b1</code> and <code>b2</code>, where 
-     * <code>0&nbsp;&lt;=&nbsp;b1, b2&nbsp;&lt;=&nbsp;255</code>, 
+     * Reads an unsigned 16-bit number from this file. This method reads
+     * two bytes from the file, starting at the current file pointer.
+     * If the bytes read, in order, are
+     * <code>b1</code> and <code>b2</code>, where
+     * <code>0&nbsp;&lt;=&nbsp;b1, b2&nbsp;&lt;=&nbsp;255</code>,
      * then the result is equal to:
      * <blockquote><pre>
      *     (b1 &lt;&lt; 8) | b2
      * </pre></blockquote>
      * <p>
-     * This method blocks until the two bytes are read, the end of the 
-     * stream is detected, or an exception is thrown. 
+     * This method blocks until the two bytes are read, the end of the
+     * stream is detected, or an exception is thrown.
      *
      * @return     the next two bytes of this file, interpreted as an unsigned
      *             16-bit integer.
@@ -650,53 +715,54 @@
      * @exception  IOException   if an I/O error occurs.
      */
     public final int readUnsignedShort() throws IOException {
-	int ch1 = this.read();
-	int ch2 = this.read();
-	if ((ch1 | ch2) < 0)
-	    throw new EOFException();
-	return (ch1 << 8) + (ch2 << 0);
+        int ch1 = this.read();
+        int ch2 = this.read();
+        if ((ch1 | ch2) < 0)
+            throw new EOFException();
+        return (ch1 << 8) + (ch2 << 0);
     }
 
     /**
-     * Reads a Unicode character from this file. This method reads two
-     * bytes from the file, starting at the current file pointer. 
-     * If the bytes read, in order, are 
-     * <code>b1</code> and <code>b2</code>, where 
-     * <code>0&nbsp;&lt;=&nbsp;b1,&nbsp;b2&nbsp;&lt;=&nbsp;255</code>, 
+     * Reads a character from this file. This method reads two
+     * bytes from the file, starting at the current file pointer.
+     * If the bytes read, in order, are
+     * <code>b1</code> and <code>b2</code>, where
+     * <code>0&nbsp;&lt;=&nbsp;b1,&nbsp;b2&nbsp;&lt;=&nbsp;255</code>,
      * then the result is equal to:
      * <blockquote><pre>
      *     (char)((b1 &lt;&lt; 8) | b2)
      * </pre></blockquote>
      * <p>
-     * This method blocks until the two bytes are read, the end of the 
-     * stream is detected, or an exception is thrown. 
+     * This method blocks until the two bytes are read, the end of the
+     * stream is detected, or an exception is thrown.
      *
-     * @return     the next two bytes of this file as a Unicode character.
+     * @return     the next two bytes of this file, interpreted as a
+     *                  <code>char</code>.
      * @exception  EOFException  if this file reaches the end before reading
      *               two bytes.
      * @exception  IOException   if an I/O error occurs.
      */
     public final char readChar() throws IOException {
-	int ch1 = this.read();
-	int ch2 = this.read();
-	if ((ch1 | ch2) < 0)
-	    throw new EOFException();
-	return (char)((ch1 << 8) + (ch2 << 0));
+        int ch1 = this.read();
+        int ch2 = this.read();
+        if ((ch1 | ch2) < 0)
+            throw new EOFException();
+        return (char)((ch1 << 8) + (ch2 << 0));
     }
 
     /**
-     * Reads a signed 32-bit integer from this file. This method reads 4 
-     * bytes from the file, starting at the current file pointer. 
+     * Reads a signed 32-bit integer from this file. This method reads 4
+     * bytes from the file, starting at the current file pointer.
      * If the bytes read, in order, are <code>b1</code>,
-     * <code>b2</code>, <code>b3</code>, and <code>b4</code>, where 
-     * <code>0&nbsp;&lt;=&nbsp;b1, b2, b3, b4&nbsp;&lt;=&nbsp;255</code>, 
+     * <code>b2</code>, <code>b3</code>, and <code>b4</code>, where
+     * <code>0&nbsp;&lt;=&nbsp;b1, b2, b3, b4&nbsp;&lt;=&nbsp;255</code>,
      * then the result is equal to:
      * <blockquote><pre>
      *     (b1 &lt;&lt; 24) | (b2 &lt;&lt; 16) + (b3 &lt;&lt; 8) + b4
      * </pre></blockquote>
      * <p>
-     * This method blocks until the four bytes are read, the end of the 
-     * stream is detected, or an exception is thrown. 
+     * This method blocks until the four bytes are read, the end of the
+     * stream is detected, or an exception is thrown.
      *
      * @return     the next four bytes of this file, interpreted as an
      *             <code>int</code>.
@@ -705,21 +771,21 @@
      * @exception  IOException   if an I/O error occurs.
      */
     public final int readInt() throws IOException {
-	int ch1 = this.read();
-	int ch2 = this.read();
-	int ch3 = this.read();
-	int ch4 = this.read();
-	if ((ch1 | ch2 | ch3 | ch4) < 0)
-	    throw new EOFException();
-	return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));
+        int ch1 = this.read();
+        int ch2 = this.read();
+        int ch3 = this.read();
+        int ch4 = this.read();
+        if ((ch1 | ch2 | ch3 | ch4) < 0)
+            throw new EOFException();
+        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));
     }
 
     /**
      * Reads a signed 64-bit integer from this file. This method reads eight
-     * bytes from the file, starting at the current file pointer. 
-     * If the bytes read, in order, are 
-     * <code>b1</code>, <code>b2</code>, <code>b3</code>, 
-     * <code>b4</code>, <code>b5</code>, <code>b6</code>, 
+     * bytes from the file, starting at the current file pointer.
+     * If the bytes read, in order, are
+     * <code>b1</code>, <code>b2</code>, <code>b3</code>,
+     * <code>b4</code>, <code>b5</code>, <code>b6</code>,
      * <code>b7</code>, and <code>b8,</code> where:
      * <blockquote><pre>
      *     0 &lt;= b1, b2, b3, b4, b5, b6, b7, b8 &lt;=255,
@@ -733,8 +799,8 @@
      *     + ((long)b7 &lt;&lt; 8) + b8
      * </pre></blockquote>
      * <p>
-     * This method blocks until the eight bytes are read, the end of the 
-     * stream is detected, or an exception is thrown. 
+     * This method blocks until the eight bytes are read, the end of the
+     * stream is detected, or an exception is thrown.
      *
      * @return     the next eight bytes of this file, interpreted as a
      *             <code>long</code>.
@@ -743,19 +809,19 @@
      * @exception  IOException   if an I/O error occurs.
      */
     public final long readLong() throws IOException {
-	return ((long)(readInt()) << 32) + (readInt() & 0xFFFFFFFFL);
+        return ((long)(readInt()) << 32) + (readInt() & 0xFFFFFFFFL);
     }
 
     /**
-     * Reads a <code>float</code> from this file. This method reads an 
-     * <code>int</code> value, starting at the current file pointer, 
-     * as if by the <code>readInt</code> method 
-     * and then converts that <code>int</code> to a <code>float</code> 
-     * using the <code>intBitsToFloat</code> method in class 
-     * <code>Float</code>. 
+     * Reads a <code>float</code> from this file. This method reads an
+     * <code>int</code> value, starting at the current file pointer,
+     * as if by the <code>readInt</code> method
+     * and then converts that <code>int</code> to a <code>float</code>
+     * using the <code>intBitsToFloat</code> method in class
+     * <code>Float</code>.
      * <p>
-     * This method blocks until the four bytes are read, the end of the 
-     * stream is detected, or an exception is thrown. 
+     * This method blocks until the four bytes are read, the end of the
+     * stream is detected, or an exception is thrown.
      *
      * @return     the next four bytes of this file, interpreted as a
      *             <code>float</code>.
@@ -766,19 +832,19 @@
      * @see        java.lang.Float#intBitsToFloat(int)
      */
     public final float readFloat() throws IOException {
-	return Float.intBitsToFloat(readInt());
+        return Float.intBitsToFloat(readInt());
     }
 
     /**
-     * Reads a <code>double</code> from this file. This method reads a 
-     * <code>long</code> value, starting at the current file pointer, 
-     * as if by the <code>readLong</code> method 
-     * and then converts that <code>long</code> to a <code>double</code> 
-     * using the <code>longBitsToDouble</code> method in 
+     * Reads a <code>double</code> from this file. This method reads a
+     * <code>long</code> value, starting at the current file pointer,
+     * as if by the <code>readLong</code> method
+     * and then converts that <code>long</code> to a <code>double</code>
+     * using the <code>longBitsToDouble</code> method in
      * class <code>Double</code>.
      * <p>
-     * This method blocks until the eight bytes are read, the end of the 
-     * stream is detected, or an exception is thrown. 
+     * This method blocks until the eight bytes are read, the end of the
+     * stream is detected, or an exception is thrown.
      *
      * @return     the next eight bytes of this file, interpreted as a
      *             <code>double</code>.
@@ -789,12 +855,12 @@
      * @see        java.lang.Double#longBitsToDouble(long)
      */
     public final double readDouble() throws IOException {
-	return Double.longBitsToDouble(readLong());
+        return Double.longBitsToDouble(readLong());
     }
 
     /**
      * Reads the next line of text from this file.  This method successively
-     * reads bytes from the file, starting at the current file pointer, 
+     * reads bytes from the file, starting at the current file pointer,
      * until it reaches a line terminator or the end
      * of the file.  Each byte is converted into a character by taking the
      * byte's value for the lower eight bits of the character and setting the
@@ -817,155 +883,157 @@
      */
 
     public final String readLine() throws IOException {
-	StringBuffer input = new StringBuffer();
-	int c = -1;
-	boolean eol = false;
-
-	while (!eol) {
-	    switch (c = read()) {
-	    case -1:
-	    case '\n':
-		eol = true;
-		break;
-	    case '\r':
-		eol = true;
-		long cur = getFilePointer();
-		if ((read()) != '\n') {
-		    seek(cur);
-		}
-		break;
-	    default:
-		input.append((char)c);
-		break;
-	    }
-	}
-
-	if ((c == -1) && (input.length() == 0)) {
-	    return null;
-	}
-	return input.toString();
+        StringBuffer input = new StringBuffer();
+        int c = -1;
+        boolean eol = false;
+
+        while (!eol) {
+            switch (c = read()) {
+            case -1:
+            case '\n':
+                eol = true;
+                break;
+            case '\r':
+                eol = true;
+                long cur = getFilePointer();
+                if ((read()) != '\n') {
+                    seek(cur);
+                }
+                break;
+            default:
+                input.append((char)c);
+                break;
+            }
+        }
+
+        if ((c == -1) && (input.length() == 0)) {
+            return null;
+        }
+        return input.toString();
     }
 
     /**
-     * Reads in a string from this file. The string has been encoded 
-     * using a modified UTF-8 format. 
+     * Reads in a string from this file. The string has been encoded
+     * using a
+     * <a href="DataInput.html#modified-utf-8">modified UTF-8</a>
+     * format.
      * <p>
-     * The first two bytes are read, starting from the current file 
-     * pointer, as if by 
-     * <code>readUnsignedShort</code>. This value gives the number of 
+     * The first two bytes are read, starting from the current file
+     * pointer, as if by
+     * <code>readUnsignedShort</code>. This value gives the number of
      * following bytes that are in the encoded string, not
-     * the length of the resulting string. The following bytes are then 
-     * interpreted as bytes encoding characters in the UTF-8 format 
-     * and are converted into characters. 
+     * the length of the resulting string. The following bytes are then
+     * interpreted as bytes encoding characters in the modified UTF-8 format
+     * and are converted into characters.
      * <p>
-     * This method blocks until all the bytes are read, the end of the 
-     * stream is detected, or an exception is thrown. 
+     * This method blocks until all the bytes are read, the end of the
+     * stream is detected, or an exception is thrown.
      *
      * @return     a Unicode string.
      * @exception  EOFException            if this file reaches the end before
      *               reading all the bytes.
      * @exception  IOException             if an I/O error occurs.
-     * @exception  UTFDataFormatException  if the bytes do not represent 
-     *               valid UTF-8 encoding of a Unicode string.
+     * @exception  UTFDataFormatException  if the bytes do not represent
+     *               valid modified UTF-8 encoding of a Unicode string.
      * @see        java.io.RandomAccessFile#readUnsignedShort()
      */
     public final String readUTF() throws IOException {
-	return DataInputStream.readUTF(this);
+        return DataInputStream.readUTF(this);
     }
 
     /**
-     * Writes a <code>boolean</code> to the file as a one-byte value. The 
-     * value <code>true</code> is written out as the value 
-     * <code>(byte)1</code>; the value <code>false</code> is written out 
-     * as the value <code>(byte)0</code>. The write starts at 
+     * Writes a <code>boolean</code> to the file as a one-byte value. The
+     * value <code>true</code> is written out as the value
+     * <code>(byte)1</code>; the value <code>false</code> is written out
+     * as the value <code>(byte)0</code>. The write starts at
      * the current position of the file pointer.
      *
      * @param      v   a <code>boolean</code> value to be written.
      * @exception  IOException  if an I/O error occurs.
      */
     public final void writeBoolean(boolean v) throws IOException {
-	write(v ? 1 : 0);
-	//written++;
+        write(v ? 1 : 0);
+        //written++;
     }
 
     /**
-     * Writes a <code>byte</code> to the file as a one-byte value. The 
+     * Writes a <code>byte</code> to the file as a one-byte value. The
      * write starts at the current position of the file pointer.
      *
      * @param      v   a <code>byte</code> value to be written.
      * @exception  IOException  if an I/O error occurs.
      */
     public final void writeByte(int v) throws IOException {
-	write(v);
-	//written++;
+        write(v);
+        //written++;
     }
 
     /**
-     * Writes a <code>short</code> to the file as two bytes, high byte first. 
+     * Writes a <code>short</code> to the file as two bytes, high byte first.
      * The write starts at the current position of the file pointer.
      *
      * @param      v   a <code>short</code> to be written.
      * @exception  IOException  if an I/O error occurs.
      */
     public final void writeShort(int v) throws IOException {
-	write((v >>> 8) & 0xFF);
-	write((v >>> 0) & 0xFF);
-	//written += 2;
+        write((v >>> 8) & 0xFF);
+        write((v >>> 0) & 0xFF);
+        //written += 2;
     }
 
     /**
      * Writes a <code>char</code> to the file as a two-byte value, high
-     * byte first. The write starts at the current position of the 
+     * byte first. The write starts at the current position of the
      * file pointer.
      *
      * @param      v   a <code>char</code> value to be written.
      * @exception  IOException  if an I/O error occurs.
      */
     public final void writeChar(int v) throws IOException {
-	write((v >>> 8) & 0xFF);
-	write((v >>> 0) & 0xFF);
-	//written += 2;
+        write((v >>> 8) & 0xFF);
+        write((v >>> 0) & 0xFF);
+        //written += 2;
     }
 
     /**
-     * Writes an <code>int</code> to the file as four bytes, high byte first. 
+     * Writes an <code>int</code> to the file as four bytes, high byte first.
      * The write starts at the current position of the file pointer.
      *
      * @param      v   an <code>int</code> to be written.
      * @exception  IOException  if an I/O error occurs.
      */
     public final void writeInt(int v) throws IOException {
-	write((v >>> 24) & 0xFF);
-	write((v >>> 16) & 0xFF);
-	write((v >>>  8) & 0xFF);
-	write((v >>>  0) & 0xFF);
-	//written += 4;
+        write((v >>> 24) & 0xFF);
+        write((v >>> 16) & 0xFF);
+        write((v >>>  8) & 0xFF);
+        write((v >>>  0) & 0xFF);
+        //written += 4;
     }
 
     /**
-     * Writes a <code>long</code> to the file as eight bytes, high byte first. 
+     * Writes a <code>long</code> to the file as eight bytes, high byte first.
      * The write starts at the current position of the file pointer.
      *
      * @param      v   a <code>long</code> to be written.
      * @exception  IOException  if an I/O error occurs.
      */
     public final void writeLong(long v) throws IOException {
-	write((int)(v >>> 56) & 0xFF);
-	write((int)(v >>> 48) & 0xFF);
-	write((int)(v >>> 40) & 0xFF);
-	write((int)(v >>> 32) & 0xFF);
-	write((int)(v >>> 24) & 0xFF);
-	write((int)(v >>> 16) & 0xFF);
-	write((int)(v >>>  8) & 0xFF);
-	write((int)(v >>>  0) & 0xFF);
-	//written += 8;
+        write((int)(v >>> 56) & 0xFF);
+        write((int)(v >>> 48) & 0xFF);
+        write((int)(v >>> 40) & 0xFF);
+        write((int)(v >>> 32) & 0xFF);
+        write((int)(v >>> 24) & 0xFF);
+        write((int)(v >>> 16) & 0xFF);
+        write((int)(v >>>  8) & 0xFF);
+        write((int)(v >>>  0) & 0xFF);
+        //written += 8;
     }
 
     /**
-     * Converts the float argument to an <code>int</code> using the 
-     * <code>floatToIntBits</code> method in class <code>Float</code>, 
-     * and then writes that <code>int</code> value to the file as a 
-     * four-byte quantity, high byte first. The write starts at the 
+     * Converts the float argument to an <code>int</code> using the
+     * <code>floatToIntBits</code> method in class <code>Float</code>,
+     * and then writes that <code>int</code> value to the file as a
+     * four-byte quantity, high byte first. The write starts at the
      * current position of the file pointer.
      *
      * @param      v   a <code>float</code> value to be written.
@@ -973,14 +1041,14 @@
      * @see        java.lang.Float#floatToIntBits(float)
      */
     public final void writeFloat(float v) throws IOException {
-	writeInt(Float.floatToIntBits(v));
+        writeInt(Float.floatToIntBits(v));
     }
 
     /**
-     * Converts the double argument to a <code>long</code> using the 
-     * <code>doubleToLongBits</code> method in class <code>Double</code>, 
-     * and then writes that <code>long</code> value to the file as an 
-     * eight-byte quantity, high byte first. The write starts at the current 
+     * Converts the double argument to a <code>long</code> using the
+     * <code>doubleToLongBits</code> method in class <code>Double</code>,
+     * and then writes that <code>long</code> value to the file as an
+     * eight-byte quantity, high byte first. The write starts at the current
      * position of the file pointer.
      *
      * @param      v   a <code>double</code> value to be written.
@@ -988,13 +1056,13 @@
      * @see        java.lang.Double#doubleToLongBits(double)
      */
     public final void writeDouble(double v) throws IOException {
-	writeLong(Double.doubleToLongBits(v));
+        writeLong(Double.doubleToLongBits(v));
     }
 
     /**
-     * Writes the string to the file as a sequence of bytes. Each 
-     * character in the string is written out, in sequence, by discarding 
-     * its high eight bits. The write starts at the current position of 
+     * Writes the string to the file as a sequence of bytes. Each
+     * character in the string is written out, in sequence, by discarding
+     * its high eight bits. The write starts at the current position of
      * the file pointer.
      *
      * @param      s   a string of bytes to be written.
@@ -1013,13 +1081,12 @@
         }
 
 	writeBytes(b, 0, len);
-
     }
 
     /**
-     * Writes a string to the file as a sequence of characters. Each 
-     * character is written to the data output stream as if by the 
-     * <code>writeChar</code> method. The write starts at the current 
+     * Writes a string to the file as a sequence of characters. Each
+     * character is written to the data output stream as if by the
+     * <code>writeChar</code> method. The write starts at the current
      * position of the file pointer.
      *
      * @param      s   a <code>String</code> value to be written.
@@ -1027,29 +1094,30 @@
      * @see        java.io.RandomAccessFile#writeChar(int)
      */
     public final void writeChars(String s) throws IOException {
-	int clen = s.length();
-	int blen = 2*clen;
-	byte[] b = new byte[blen];
-	char[] c = new char[clen];
-	s.getChars(0, clen, c, 0);
-	for (int i = 0, j = 0; i < clen; i++) {
-	    b[j++] = (byte)(c[i] >>> 8);
-	    b[j++] = (byte)(c[i] >>> 0);
-	}
-	writeBytes(b, 0, blen);
+        int clen = s.length();
+        int blen = 2*clen;
+        byte[] b = new byte[blen];
+        char[] c = new char[clen];
+        s.getChars(0, clen, c, 0);
+        for (int i = 0, j = 0; i < clen; i++) {
+            b[j++] = (byte)(c[i] >>> 8);
+            b[j++] = (byte)(c[i] >>> 0);
+        }
+        writeBytes(b, 0, blen);
     }
 
     /**
-     * Writes a string to the file using UTF-8 encoding in a 
-     * machine-independent manner. 
+     * Writes a string to the file using
+     * <a href="DataInput.html#modified-utf-8">modified UTF-8</a>
+     * encoding in a machine-independent manner.
      * <p>
-     * First, two bytes are written to the file, starting at the 
-     * current file pointer, as if by the 
-     * <code>writeShort</code> method giving the number of bytes to 
-     * follow. This value is the number of bytes actually written out, 
-     * not the length of the string. Following the length, each character 
-     * of the string is output, in sequence, using the UTF-8 encoding 
-     * for each character. 
+     * First, two bytes are written to the file, starting at the
+     * current file pointer, as if by the
+     * <code>writeShort</code> method giving the number of bytes to
+     * follow. This value is the number of bytes actually written out,
+     * not the length of the string. Following the length, each character
+     * of the string is output, in sequence, using the modified UTF-8 encoding
+     * for each character.
      *
      * @param      str   a string to be written.
      * @exception  IOException  if an I/O error occurs.
@@ -1063,7 +1131,6 @@
     private native void close0() throws IOException;
 
     static {
-	initIDs();
+        initIDs();
     }
-
 }
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/foundation/classes/java/io/RandomAccessFile.java.orig phoneme_advanced-mr2-dev-b122/cdc/src/share/foundation/classes/java/io/RandomAccessFile.java.orig
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/foundation/classes/java/io/RandomAccessFile.java.orig	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/foundation/classes/java/io/RandomAccessFile.java.orig	2009-07-06 18:37:19.000000000 -0400
@@ -0,0 +1,1069 @@
+/*
+ * @(#)RandomAccessFile.java	1.75 06/10/10
+ *
+ * Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.  
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+ *   
+ * This program is free software; you can redistribute it and/or  
+ * modify it under the terms of the GNU General Public License version  
+ * 2 only, as published by the Free Software Foundation.   
+ *   
+ * This program is distributed in the hope that it will be useful, but  
+ * WITHOUT ANY WARRANTY; without even the implied warranty of  
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+ * General Public License version 2 for more details (a copy is  
+ * included at /legal/license.txt).   
+ *   
+ * You should have received a copy of the GNU General Public License  
+ * version 2 along with this work; if not, write to the Free Software  
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+ * 02110-1301 USA   
+ *   
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+ * Clara, CA 95054 or visit www.sun.com if you need additional  
+ * information or have any questions. 
+ *
+ */
+
+package java.io;
+
+
+/**
+ * Instances of this class support both reading and writing to a 
+ * random access file. A random access file behaves like a large 
+ * array of bytes stored in the file system. There is a kind of cursor, 
+ * or index into the implied array, called the <em>file pointer</em>; 
+ * input operations read bytes starting at the file pointer and advance 
+ * the file pointer past the bytes read. If the random access file is 
+ * created in read/write mode, then output operations are also available; 
+ * output operations write bytes starting at the file pointer and advance 
+ * the file pointer past the bytes written. Output operations that write 
+ * past the current end of the implied array cause the array to be 
+ * extended. The file pointer can be read by the 
+ * <code>getFilePointer</code> method and set by the <code>seek</code> 
+ * method. 
+ * <p>
+ * It is generally true of all the reading routines in this class that 
+ * if end-of-file is reached before the desired number of bytes has been 
+ * read, an <code>EOFException</code> (which is a kind of 
+ * <code>IOException</code>) is thrown. If any byte cannot be read for 
+ * any reason other than end-of-file, an <code>IOException</code> other 
+ * than <code>EOFException</code> is thrown. In particular, an 
+ * <code>IOException</code> may be thrown if the stream has been closed.
+ *
+ * @author  unascribed
+ * @version 1.57, 05/03/00
+ * @since   JDK1.0
+ */
+
+public class RandomAccessFile implements DataOutput, DataInput {
+
+    private FileDescriptor fd;
+    private boolean rw;
+
+    private static final int O_RDONLY = 1;
+    private static final int O_RDWR =   2;
+    private static final int O_SYNC =   4;
+    private static final int O_DSYNC =  8;
+
+    /**
+     * Creates a random access file stream to read from, and optionally 
+     * to write to, a file with the specified name. A new 
+     * {@link FileDescriptor} object is created to represent the 
+     * connection to the file.
+     * 
+     * <p> The <tt>mode</tt> argument specifies the access mode with which the
+     * file is to be opened.  The permitted values and their meanings are as
+     * specified for the <a
+     * href="#mode"><tt>RandomAccessFile(File,String)</tt></a> constructor.
+     *
+     * <p>
+     * If there is a security manager, its <code>checkRead</code> method
+     * is called with the <code>name</code> argument
+     * as its argument to see if read access to the file is allowed.
+     * If the mode allows writing, the security manager's
+     * <code>checkWrite</code> method
+     * is also called with the <code>name</code> argument
+     * as its argument to see if write access to the file is allowed.
+     *
+     * @param      name   the system-dependent filename
+     * @param      mode   the access <a href="#mode">mode</a>
+     * @exception  IllegalArgumentException  if the mode argument is not equal
+     *               to one of <tt>"r"</tt>, <tt>"rw"</tt>, <tt>"rws"</tt>, or
+     *               <tt>"rwd"</tt>
+     * @exception  FileNotFoundException  if the file exists but is a directory
+     *                   rather than a regular file, or cannot be opened or
+     *                   created for any other reason
+     * @exception  SecurityException         if a security manager exists and its
+     *               <code>checkRead</code> method denies read access to the file
+     *               or the mode is "rw" and the security manager's
+     *               <code>checkWrite</code> method denies write access to the file
+     * @see        java.lang.SecurityException
+     * @see        java.lang.SecurityManager#checkRead(java.lang.String)
+     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+     * @revised 1.4
+     * @spec JSR-51
+     */
+    public RandomAccessFile(String name, String mode)
+	throws FileNotFoundException
+    {
+        this(name != null ? new File(name) : null, mode);
+    }
+
+    /**
+     * Creates a random access file stream to read from, and optionally to
+     * write to, the file specified by the {@link File} argument.  A new {@link
+     * FileDescriptor} object is created to represent this file connection.
+     *
+     * <a name="mode"><p> The <tt>mode</tt> argument specifies the access mode
+     * in which the file is to be opened.  The permitted values and their
+     * meanings are:
+     *
+     * <blockquote><table summary="Access mode permitted values and meanings">
+     * <tr><th><p align="left">Value</p></th><th><p align="left">Meaning</p></th></tr>
+     * <tr><td valign="top"><tt>"r"</tt></td>
+     *     <td> Open for reading only.  Invoking any of the <tt>write</tt>
+     *     methods of the resulting object will cause an {@link
+     *     java.io.IOException} to be thrown. </td></tr>
+     * <tr><td valign="top"><tt>"rw"</tt></td>
+     *     <td> Open for reading and writing.  If the file does not already
+     *     exist then an attempt will be made to create it. </td></tr>
+     * <tr><td valign="top"><tt>"rws"</tt></td>
+     *     <td> Open for reading and writing, as with <tt>"rw"</tt>, and also
+     *     require that every update to the file's content or metadata be
+     *     written synchronously to the underlying storage device.  </td></tr>
+     * <tr><td valign="top"><tt>"rwd"&nbsp;&nbsp;</tt></td>
+     *     <td> Open for reading and writing, as with <tt>"rw"</tt>, and also
+     *     require that every update to the file's content be written
+     *     synchronously to the underlying storage device. </td></tr>
+     * </table></blockquote>
+     *
+     * If
+     * the file resides on a local storage device then when an invocation of a
+     * method of this class returns it is guaranteed that all changes made to
+     * the file by that invocation will have been written to that device.  This
+     * is useful for ensuring that critical information is not lost in the
+     * event of a system crash.  If the file does not reside on a local device
+     * then no such guarantee is made.
+     *
+     * <p> The <tt>"rwd"</tt> mode can be used to reduce the number of I/O
+     * operations performed.  Using <tt>"rwd"</tt> only requires updates to the
+     * file's content to be written to storage; using <tt>"rws"</tt> requires
+     * updates to both the file's content and its metadata to be written, which
+     * generally requires at least one more low-level I/O operation.
+     *
+     * <p> If there is a security manager, its <code>checkRead</code> method is
+     * called with the pathname of the <code>file</code> argument as its
+     * argument to see if read access to the file is allowed.  If the mode
+     * allows writing, the security manager's <code>checkWrite</code> method is
+     * also called with the path argument to see if write access to the file is
+     * allowed.
+     *
+     * @param      file   the file object
+     * @param      mode   the access mode, as described
+     *                    <a href="#mode">above</a>
+     * @exception  IllegalArgumentException  if the mode argument is not equal
+     *               to one of <tt>"r"</tt>, <tt>"rw"</tt>, <tt>"rws"</tt>, or
+     *               <tt>"rwd"</tt>
+     * @exception  FileNotFoundException  if the file exists but is a directory
+     *                   rather than a regular file, or cannot be opened or
+     *                   created for any other reason
+     * @exception  SecurityException         if a security manager exists and its
+     *               <code>checkRead</code> method denies read access to the file
+     *               or the mode is "rw" and the security manager's
+     *               <code>checkWrite</code> method denies write access to the file
+     * @see        java.lang.SecurityManager#checkRead(java.lang.String)
+     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
+     * @revised 1.4
+     * @spec JSR-51
+     */
+    public RandomAccessFile(File file, String mode)
+	throws FileNotFoundException
+    {
+	String name = (file != null ? file.getPath() : null);
+	int imode = -1;
+	if (mode.equals("r"))
+	    imode = O_RDONLY;
+	else if (mode.startsWith("rw")) {
+	    imode = O_RDWR;
+	    rw = true;
+	    if (mode.length() > 2) {
+		if (mode.equals("rws"))
+		    imode |= O_SYNC;
+		else if (mode.equals("rwd"))
+		    imode |= O_DSYNC;
+		else
+		    imode = -1;
+	    }
+	}
+	if (imode < 0)
+	    throw new IllegalArgumentException("Illegal mode \"" + mode
+					       + "\" must be one of "
+					       + "\"r\", \"rw\", \"rws\","
+					       + " or \"rwd\"");
+	SecurityManager security = System.getSecurityManager();
+	if (security != null) {
+	    security.checkRead(name);
+	    if (rw) {
+		security.checkWrite(name);
+	    }
+	}
+        if (name == null) {
+            throw new NullPointerException();
+        }
+	fd = new FileDescriptor();
+	open(name, imode);
+    }
+
+    /**
+     * Returns the opaque file descriptor object associated with this
+     * stream. </p>
+     *
+     * @return     the file descriptor object associated with this stream.
+     * @exception  IOException  if an I/O error occurs.
+     * @see        java.io.FileDescriptor
+     */
+    public final FileDescriptor getFD() throws IOException {
+	if (fd != null) return fd;
+	throw new IOException();
+    }
+
+    /**
+     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
+     * object associated with this file.
+     *
+     * <p> The {@link java.nio.channels.FileChannel#position()
+     * </code>position<code>} of the returned channel will always be equal to
+     * this object's file-pointer offset as returned by the {@link
+     * #getFilePointer getFilePointer} method.  Changing this object's
+     * file-pointer offset, whether explicitly or by reading or writing bytes,
+     * will change the position of the channel, and vice versa.  Changing the
+     * file's length via this object will change the length seen via the file
+     * channel, and vice versa.
+     *
+     * @return  the file channel associated with this file
+     *
+     * @since 1.4
+     * @spec JSR-51
+     */
+    /* NOTE: No NIO in CDC
+    public final FileChannel getChannel() {
+	synchronized (this) {
+	    if (channel == null)
+		channel = FileChannelImpl.open(fd, true, rw, this);
+	    return channel;
+	}
+    }
+    */ 
+
+    /**
+     * Opens a file and returns the file descriptor.  The file is 
+     * opened in read-write mode if writeable is true, else 
+     * the file is opened as read-only.
+     * If the <code>name</code> refers to a directory, an IOException
+     * is thrown.
+     *
+     * @param name the name of the file
+     * @param mode the mode flags, a combination of the O_ constants
+     *             defined above
+     */
+    private native void open(String name, int mode)
+	throws FileNotFoundException;
+
+    // 'Read' primitives
+
+    /**
+     * Reads a byte of data from this file. The byte is returned as an 
+     * integer in the range 0 to 255 (<code>0x00-0x0ff</code>). This 
+     * method blocks if no input is yet available. 
+     * <p>
+     * Although <code>RandomAccessFile</code> is not a subclass of 
+     * <code>InputStream</code>, this method behaves in exactly the same 
+     * way as the {@link InputStream#read()} method of 
+     * <code>InputStream</code>.
+     *
+     * @return     the next byte of data, or <code>-1</code> if the end of the
+     *             file has been reached.
+     * @exception  IOException  if an I/O error occurs. Not thrown if  
+     *                          end-of-file has been reached.
+     */
+    public native int read() throws IOException;
+
+    /**
+     * Reads a sub array as a sequence of bytes. 
+     * @param b the data to be written
+     * @param off the start offset in the data
+     * @param len the number of bytes that are written
+     * @exception IOException If an I/O error has occurred.
+     */
+    private native int readBytes(byte b[], int off, int len) throws IOException;
+
+    /**
+     * Reads up to <code>len</code> bytes of data from this file into an 
+     * array of bytes. This method blocks until at least one byte of input 
+     * is available. 
+     * <p>
+     * Although <code>RandomAccessFile</code> is not a subclass of 
+     * <code>InputStream</code>, this method behaves in the exactly the 
+     * same way as the {@link InputStream#read(byte[], int, int)} method of 
+     * <code>InputStream</code>.
+     *
+     * @param      b     the buffer into which the data is read.
+     * @param      off   the start offset of the data.
+     * @param      len   the maximum number of bytes read.
+     * @return     the total number of bytes read into the buffer, or
+     *             <code>-1</code> if there is no more data because the end of
+     *             the file has been reached.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public int read(byte b[], int off, int len) throws IOException {
+	return readBytes(b, off, len);
+    }
+
+    /**
+     * Reads up to <code>b.length</code> bytes of data from this file 
+     * into an array of bytes. This method blocks until at least one byte 
+     * of input is available. 
+     * <p>
+     * Although <code>RandomAccessFile</code> is not a subclass of 
+     * <code>InputStream</code>, this method behaves in the exactly the 
+     * same way as the {@link InputStream#read(byte[])} method of 
+     * <code>InputStream</code>.
+     *
+     * @param      b   the buffer into which the data is read.
+     * @return     the total number of bytes read into the buffer, or
+     *             <code>-1</code> if there is no more data because the end of
+     *             this file has been reached.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public int read(byte b[]) throws IOException {
+	return readBytes(b, 0, b.length);
+    }
+
+    /**
+     * Reads <code>b.length</code> bytes from this file into the byte 
+     * array, starting at the current file pointer. This method reads 
+     * repeatedly from the file until the requested number of bytes are 
+     * read. This method blocks until the requested number of bytes are 
+     * read, the end of the stream is detected, or an exception is thrown. 
+     *
+     * @param      b   the buffer into which the data is read.
+     * @exception  EOFException  if this file reaches the end before reading
+     *               all the bytes.
+     * @exception  IOException   if an I/O error occurs.       
+     */
+    public final void readFully(byte b[]) throws IOException {
+	readFully(b, 0, b.length);
+    }
+
+    /**
+     * Reads exactly <code>len</code> bytes from this file into the byte 
+     * array, starting at the current file pointer. This method reads 
+     * repeatedly from the file until the requested number of bytes are 
+     * read. This method blocks until the requested number of bytes are 
+     * read, the end of the stream is detected, or an exception is thrown. 
+     *
+     * @param      b     the buffer into which the data is read.
+     * @param      off   the start offset of the data.
+     * @param      len   the number of bytes to read.
+     * @exception  EOFException  if this file reaches the end before reading
+     *               all the bytes.
+     * @exception  IOException   if an I/O error occurs.
+     */
+    public final void readFully(byte b[], int off, int len) throws IOException {
+        int n = 0;
+	do {
+	    int count = this.read(b, off + n, len - n);
+	    if (count < 0)
+		throw new EOFException();
+	    n += count;
+	} while (n < len);
+    }
+
+    /**
+     * Attempts to skip over <code>n</code> bytes of input discarding the 
+     * skipped bytes. 
+     * <p>
+     * 
+     * This method may skip over some smaller number of bytes, possibly zero. 
+     * This may result from any of a number of conditions; reaching end of 
+     * file before <code>n</code> bytes have been skipped is only one 
+     * possibility. This method never throws an <code>EOFException</code>. 
+     * The actual number of bytes skipped is returned.  If <code>n</code> 
+     * is negative, no bytes are skipped.
+     *
+     * @param      n   the number of bytes to be skipped.
+     * @return     the actual number of bytes skipped.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public int skipBytes(int n) throws IOException {
+        long pos;
+	long len;
+	long newpos; 
+
+	if (n <= 0) {
+	    return 0;
+	}
+	pos = getFilePointer();
+	len = length();
+	newpos = pos + n;
+	if (newpos > len) {
+	    newpos = len;
+	}
+	seek(newpos);
+
+	/* return the actual number of bytes skipped */
+	return (int) (newpos - pos);
+    }
+
+    // 'Write' primitives
+
+    /**
+     * Writes the specified byte to this file. The write starts at 
+     * the current file pointer.
+     *
+     * @param      b   the <code>byte</code> to be written.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public native void write(int b) throws IOException;
+
+    /**
+     * Writes a sub array as a sequence of bytes. 
+     * @param b the data to be written
+
+     * @param off the start offset in the data
+     * @param len the number of bytes that are written
+     * @exception IOException If an I/O error has occurred.
+     */
+    private native void writeBytes(byte b[], int off, int len) throws IOException;
+
+    /**
+     * Writes <code>b.length</code> bytes from the specified byte array 
+     * to this file, starting at the current file pointer. 
+     *
+     * @param      b   the data.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public void write(byte b[]) throws IOException {
+	writeBytes(b, 0, b.length); 
+    }
+
+    /**
+     * Writes <code>len</code> bytes from the specified byte array 
+     * starting at offset <code>off</code> to this file. 
+     *
+     * @param      b     the data.
+     * @param      off   the start offset in the data.
+     * @param      len   the number of bytes to write.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public void write(byte b[], int off, int len) throws IOException {
+	writeBytes(b, off, len);
+    }
+
+    // 'Random access' stuff
+
+    /**
+     * Returns the current offset in this file. 
+     *
+     * @return     the offset from the beginning of the file, in bytes,
+     *             at which the next read or write occurs.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public native long getFilePointer() throws IOException;
+
+    /**
+     * Sets the file-pointer offset, measured from the beginning of this 
+     * file, at which the next read or write occurs.  The offset may be 
+     * set beyond the end of the file. Setting the offset beyond the end 
+     * of the file does not change the file length.  The file length will 
+     * change only by writing after the offset has been set beyond the end 
+     * of the file. 
+     *
+     * @param      pos   the offset position, measured in bytes from the 
+     *                   beginning of the file, at which to set the file 
+     *                   pointer.
+     * @exception  IOException  if <code>pos</code> is less than 
+     *                          <code>0</code> or if an I/O error occurs.
+     */
+    public native void seek(long pos) throws IOException;
+
+    /**
+     * Returns the length of this file.
+     *
+     * @return     the length of this file, measured in bytes.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public native long length() throws IOException;
+
+    /**
+     * Sets the length of this file.
+     *
+     * <p> If the present length of the file as returned by the
+     * <code>length</code> method is greater than the <code>newLength</code>
+     * argument then the file will be truncated.  In this case, if the file
+     * offset as returned by the <code>getFilePointer</code> method is greater
+     * then <code>newLength</code> then after this method returns the offset
+     * will be equal to <code>newLength</code>.
+     *
+     * <p> If the present length of the file as returned by the
+     * <code>length</code> method is smaller than the <code>newLength</code>
+     * argument then the file will be extended.  In this case, the contents of
+     * the extended portion of the file are not defined.
+     *
+     * @param      newLength    The desired length of the file
+     * @exception  IOException  If an I/O error occurs
+     * @since      1.2
+     */
+    public native void setLength(long newLength) throws IOException;
+
+    /**
+     * Closes this random access file stream and releases any system 
+     * resources associated with the stream. A closed random access 
+     * file cannot perform input or output operations and cannot be 
+     * reopened.
+     *
+     * @exception  IOException  if an I/O error occurs.
+     *
+     * @revised 1.4
+     * @spec JSR-51
+     */
+    public void close() throws IOException {
+        close0();
+    }
+
+    //
+    //  Some "reading/writing Java data types" methods stolen from
+    //  DataInputStream and DataOutputStream.
+    //
+
+    /**
+     * Reads a <code>boolean</code> from this file. This method reads a 
+     * single byte from the file, starting at the current file pointer. 
+     * A value of <code>0</code> represents 
+     * <code>false</code>. Any other value represents <code>true</code>. 
+     * This method blocks until the byte is read, the end of the stream 
+     * is detected, or an exception is thrown. 
+     *
+     * @return     the <code>boolean</code> value read.
+     * @exception  EOFException  if this file has reached the end.
+     * @exception  IOException   if an I/O error occurs.
+     */
+    public final boolean readBoolean() throws IOException {
+	int ch = this.read();
+	if (ch < 0)
+	    throw new EOFException();
+	return (ch != 0);
+    }
+
+    /**
+     * Reads a signed eight-bit value from this file. This method reads a 
+     * byte from the file, starting from the current file pointer. 
+     * If the byte read is <code>b</code>, where 
+     * <code>0&nbsp;&lt;=&nbsp;b&nbsp;&lt;=&nbsp;255</code>, 
+     * then the result is:
+     * <blockquote><pre>
+     *     (byte)(b)
+     * </pre></blockquote>
+     * <p>
+     * This method blocks until the byte is read, the end of the stream 
+     * is detected, or an exception is thrown. 
+     *
+     * @return     the next byte of this file as a signed eight-bit
+     *             <code>byte</code>.
+     * @exception  EOFException  if this file has reached the end.
+     * @exception  IOException   if an I/O error occurs.
+     */
+    public final byte readByte() throws IOException {
+	int ch = this.read();
+	if (ch < 0)
+	    throw new EOFException();
+	return (byte)(ch);
+    }
+
+    /**
+     * Reads an unsigned eight-bit number from this file. This method reads 
+     * a byte from this file, starting at the current file pointer, 
+     * and returns that byte. 
+     * <p>
+     * This method blocks until the byte is read, the end of the stream 
+     * is detected, or an exception is thrown. 
+     *
+     * @return     the next byte of this file, interpreted as an unsigned
+     *             eight-bit number.
+     * @exception  EOFException  if this file has reached the end.
+     * @exception  IOException   if an I/O error occurs.
+     */
+    public final int readUnsignedByte() throws IOException {
+	int ch = this.read();
+	if (ch < 0)
+	    throw new EOFException();
+	return ch;
+    }
+
+    /**
+     * Reads a signed 16-bit number from this file. The method reads two 
+     * bytes from this file, starting at the current file pointer. 
+     * If the two bytes read, in order, are 
+     * <code>b1</code> and <code>b2</code>, where each of the two values is 
+     * between <code>0</code> and <code>255</code>, inclusive, then the 
+     * result is equal to:
+     * <blockquote><pre>
+     *     (short)((b1 &lt;&lt; 8) | b2)
+     * </pre></blockquote>
+     * <p>
+     * This method blocks until the two bytes are read, the end of the 
+     * stream is detected, or an exception is thrown. 
+     *
+     * @return     the next two bytes of this file, interpreted as a signed
+     *             16-bit number.
+     * @exception  EOFException  if this file reaches the end before reading
+     *               two bytes.
+     * @exception  IOException   if an I/O error occurs.
+     */
+    public final short readShort() throws IOException {
+	int ch1 = this.read();
+	int ch2 = this.read();
+	if ((ch1 | ch2) < 0)
+	    throw new EOFException();
+	return (short)((ch1 << 8) + (ch2 << 0));
+    }
+
+    /**
+     * Reads an unsigned 16-bit number from this file. This method reads 
+     * two bytes from the file, starting at the current file pointer. 
+     * If the bytes read, in order, are 
+     * <code>b1</code> and <code>b2</code>, where 
+     * <code>0&nbsp;&lt;=&nbsp;b1, b2&nbsp;&lt;=&nbsp;255</code>, 
+     * then the result is equal to:
+     * <blockquote><pre>
+     *     (b1 &lt;&lt; 8) | b2
+     * </pre></blockquote>
+     * <p>
+     * This method blocks until the two bytes are read, the end of the 
+     * stream is detected, or an exception is thrown. 
+     *
+     * @return     the next two bytes of this file, interpreted as an unsigned
+     *             16-bit integer.
+     * @exception  EOFException  if this file reaches the end before reading
+     *               two bytes.
+     * @exception  IOException   if an I/O error occurs.
+     */
+    public final int readUnsignedShort() throws IOException {
+	int ch1 = this.read();
+	int ch2 = this.read();
+	if ((ch1 | ch2) < 0)
+	    throw new EOFException();
+	return (ch1 << 8) + (ch2 << 0);
+    }
+
+    /**
+     * Reads a Unicode character from this file. This method reads two
+     * bytes from the file, starting at the current file pointer. 
+     * If the bytes read, in order, are 
+     * <code>b1</code> and <code>b2</code>, where 
+     * <code>0&nbsp;&lt;=&nbsp;b1,&nbsp;b2&nbsp;&lt;=&nbsp;255</code>, 
+     * then the result is equal to:
+     * <blockquote><pre>
+     *     (char)((b1 &lt;&lt; 8) | b2)
+     * </pre></blockquote>
+     * <p>
+     * This method blocks until the two bytes are read, the end of the 
+     * stream is detected, or an exception is thrown. 
+     *
+     * @return     the next two bytes of this file as a Unicode character.
+     * @exception  EOFException  if this file reaches the end before reading
+     *               two bytes.
+     * @exception  IOException   if an I/O error occurs.
+     */
+    public final char readChar() throws IOException {
+	int ch1 = this.read();
+	int ch2 = this.read();
+	if ((ch1 | ch2) < 0)
+	    throw new EOFException();
+	return (char)((ch1 << 8) + (ch2 << 0));
+    }
+
+    /**
+     * Reads a signed 32-bit integer from this file. This method reads 4 
+     * bytes from the file, starting at the current file pointer. 
+     * If the bytes read, in order, are <code>b1</code>,
+     * <code>b2</code>, <code>b3</code>, and <code>b4</code>, where 
+     * <code>0&nbsp;&lt;=&nbsp;b1, b2, b3, b4&nbsp;&lt;=&nbsp;255</code>, 
+     * then the result is equal to:
+     * <blockquote><pre>
+     *     (b1 &lt;&lt; 24) | (b2 &lt;&lt; 16) + (b3 &lt;&lt; 8) + b4
+     * </pre></blockquote>
+     * <p>
+     * This method blocks until the four bytes are read, the end of the 
+     * stream is detected, or an exception is thrown. 
+     *
+     * @return     the next four bytes of this file, interpreted as an
+     *             <code>int</code>.
+     * @exception  EOFException  if this file reaches the end before reading
+     *               four bytes.
+     * @exception  IOException   if an I/O error occurs.
+     */
+    public final int readInt() throws IOException {
+	int ch1 = this.read();
+	int ch2 = this.read();
+	int ch3 = this.read();
+	int ch4 = this.read();
+	if ((ch1 | ch2 | ch3 | ch4) < 0)
+	    throw new EOFException();
+	return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));
+    }
+
+    /**
+     * Reads a signed 64-bit integer from this file. This method reads eight
+     * bytes from the file, starting at the current file pointer. 
+     * If the bytes read, in order, are 
+     * <code>b1</code>, <code>b2</code>, <code>b3</code>, 
+     * <code>b4</code>, <code>b5</code>, <code>b6</code>, 
+     * <code>b7</code>, and <code>b8,</code> where:
+     * <blockquote><pre>
+     *     0 &lt;= b1, b2, b3, b4, b5, b6, b7, b8 &lt;=255,
+     * </pre></blockquote>
+     * <p>
+     * then the result is equal to:
+     * <p><blockquote><pre>
+     *     ((long)b1 &lt;&lt; 56) + ((long)b2 &lt;&lt; 48)
+     *     + ((long)b3 &lt;&lt; 40) + ((long)b4 &lt;&lt; 32)
+     *     + ((long)b5 &lt;&lt; 24) + ((long)b6 &lt;&lt; 16)
+     *     + ((long)b7 &lt;&lt; 8) + b8
+     * </pre></blockquote>
+     * <p>
+     * This method blocks until the eight bytes are read, the end of the 
+     * stream is detected, or an exception is thrown. 
+     *
+     * @return     the next eight bytes of this file, interpreted as a
+     *             <code>long</code>.
+     * @exception  EOFException  if this file reaches the end before reading
+     *               eight bytes.
+     * @exception  IOException   if an I/O error occurs.
+     */
+    public final long readLong() throws IOException {
+	return ((long)(readInt()) << 32) + (readInt() & 0xFFFFFFFFL);
+    }
+
+    /**
+     * Reads a <code>float</code> from this file. This method reads an 
+     * <code>int</code> value, starting at the current file pointer, 
+     * as if by the <code>readInt</code> method 
+     * and then converts that <code>int</code> to a <code>float</code> 
+     * using the <code>intBitsToFloat</code> method in class 
+     * <code>Float</code>. 
+     * <p>
+     * This method blocks until the four bytes are read, the end of the 
+     * stream is detected, or an exception is thrown. 
+     *
+     * @return     the next four bytes of this file, interpreted as a
+     *             <code>float</code>.
+     * @exception  EOFException  if this file reaches the end before reading
+     *             four bytes.
+     * @exception  IOException   if an I/O error occurs.
+     * @see        java.io.RandomAccessFile#readInt()
+     * @see        java.lang.Float#intBitsToFloat(int)
+     */
+    public final float readFloat() throws IOException {
+	return Float.intBitsToFloat(readInt());
+    }
+
+    /**
+     * Reads a <code>double</code> from this file. This method reads a 
+     * <code>long</code> value, starting at the current file pointer, 
+     * as if by the <code>readLong</code> method 
+     * and then converts that <code>long</code> to a <code>double</code> 
+     * using the <code>longBitsToDouble</code> method in 
+     * class <code>Double</code>.
+     * <p>
+     * This method blocks until the eight bytes are read, the end of the 
+     * stream is detected, or an exception is thrown. 
+     *
+     * @return     the next eight bytes of this file, interpreted as a
+     *             <code>double</code>.
+     * @exception  EOFException  if this file reaches the end before reading
+     *             eight bytes.
+     * @exception  IOException   if an I/O error occurs.
+     * @see        java.io.RandomAccessFile#readLong()
+     * @see        java.lang.Double#longBitsToDouble(long)
+     */
+    public final double readDouble() throws IOException {
+	return Double.longBitsToDouble(readLong());
+    }
+
+    /**
+     * Reads the next line of text from this file.  This method successively
+     * reads bytes from the file, starting at the current file pointer, 
+     * until it reaches a line terminator or the end
+     * of the file.  Each byte is converted into a character by taking the
+     * byte's value for the lower eight bits of the character and setting the
+     * high eight bits of the character to zero.  This method does not,
+     * therefore, support the full Unicode character set.
+     *
+     * <p> A line of text is terminated by a carriage-return character
+     * (<code>'&#92;r'</code>), a newline character (<code>'&#92;n'</code>), a
+     * carriage-return character immediately followed by a newline character,
+     * or the end of the file.  Line-terminating characters are discarded and
+     * are not included as part of the string returned.
+     *
+     * <p> This method blocks until a newline character is read, a carriage
+     * return and the byte following it are read (to see if it is a newline),
+     * the end of the file is reached, or an exception is thrown.
+     *
+     * @return     the next line of text from this file, or null if end
+     *             of file is encountered before even one byte is read.
+     * @exception  IOException  if an I/O error occurs.
+     */
+
+    public final String readLine() throws IOException {
+	StringBuffer input = new StringBuffer();
+	int c = -1;
+	boolean eol = false;
+
+	while (!eol) {
+	    switch (c = read()) {
+	    case -1:
+	    case '\n':
+		eol = true;
+		break;
+	    case '\r':
+		eol = true;
+		long cur = getFilePointer();
+		if ((read()) != '\n') {
+		    seek(cur);
+		}
+		break;
+	    default:
+		input.append((char)c);
+		break;
+	    }
+	}
+
+	if ((c == -1) && (input.length() == 0)) {
+	    return null;
+	}
+	return input.toString();
+    }
+
+    /**
+     * Reads in a string from this file. The string has been encoded 
+     * using a modified UTF-8 format. 
+     * <p>
+     * The first two bytes are read, starting from the current file 
+     * pointer, as if by 
+     * <code>readUnsignedShort</code>. This value gives the number of 
+     * following bytes that are in the encoded string, not
+     * the length of the resulting string. The following bytes are then 
+     * interpreted as bytes encoding characters in the UTF-8 format 
+     * and are converted into characters. 
+     * <p>
+     * This method blocks until all the bytes are read, the end of the 
+     * stream is detected, or an exception is thrown. 
+     *
+     * @return     a Unicode string.
+     * @exception  EOFException            if this file reaches the end before
+     *               reading all the bytes.
+     * @exception  IOException             if an I/O error occurs.
+     * @exception  UTFDataFormatException  if the bytes do not represent 
+     *               valid UTF-8 encoding of a Unicode string.
+     * @see        java.io.RandomAccessFile#readUnsignedShort()
+     */
+    public final String readUTF() throws IOException {
+	return DataInputStream.readUTF(this);
+    }
+
+    /**
+     * Writes a <code>boolean</code> to the file as a one-byte value. The 
+     * value <code>true</code> is written out as the value 
+     * <code>(byte)1</code>; the value <code>false</code> is written out 
+     * as the value <code>(byte)0</code>. The write starts at 
+     * the current position of the file pointer.
+     *
+     * @param      v   a <code>boolean</code> value to be written.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public final void writeBoolean(boolean v) throws IOException {
+	write(v ? 1 : 0);
+	//written++;
+    }
+
+    /**
+     * Writes a <code>byte</code> to the file as a one-byte value. The 
+     * write starts at the current position of the file pointer.
+     *
+     * @param      v   a <code>byte</code> value to be written.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public final void writeByte(int v) throws IOException {
+	write(v);
+	//written++;
+    }
+
+    /**
+     * Writes a <code>short</code> to the file as two bytes, high byte first. 
+     * The write starts at the current position of the file pointer.
+     *
+     * @param      v   a <code>short</code> to be written.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public final void writeShort(int v) throws IOException {
+	write((v >>> 8) & 0xFF);
+	write((v >>> 0) & 0xFF);
+	//written += 2;
+    }
+
+    /**
+     * Writes a <code>char</code> to the file as a two-byte value, high
+     * byte first. The write starts at the current position of the 
+     * file pointer.
+     *
+     * @param      v   a <code>char</code> value to be written.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public final void writeChar(int v) throws IOException {
+	write((v >>> 8) & 0xFF);
+	write((v >>> 0) & 0xFF);
+	//written += 2;
+    }
+
+    /**
+     * Writes an <code>int</code> to the file as four bytes, high byte first. 
+     * The write starts at the current position of the file pointer.
+     *
+     * @param      v   an <code>int</code> to be written.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public final void writeInt(int v) throws IOException {
+	write((v >>> 24) & 0xFF);
+	write((v >>> 16) & 0xFF);
+	write((v >>>  8) & 0xFF);
+	write((v >>>  0) & 0xFF);
+	//written += 4;
+    }
+
+    /**
+     * Writes a <code>long</code> to the file as eight bytes, high byte first. 
+     * The write starts at the current position of the file pointer.
+     *
+     * @param      v   a <code>long</code> to be written.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public final void writeLong(long v) throws IOException {
+	write((int)(v >>> 56) & 0xFF);
+	write((int)(v >>> 48) & 0xFF);
+	write((int)(v >>> 40) & 0xFF);
+	write((int)(v >>> 32) & 0xFF);
+	write((int)(v >>> 24) & 0xFF);
+	write((int)(v >>> 16) & 0xFF);
+	write((int)(v >>>  8) & 0xFF);
+	write((int)(v >>>  0) & 0xFF);
+	//written += 8;
+    }
+
+    /**
+     * Converts the float argument to an <code>int</code> using the 
+     * <code>floatToIntBits</code> method in class <code>Float</code>, 
+     * and then writes that <code>int</code> value to the file as a 
+     * four-byte quantity, high byte first. The write starts at the 
+     * current position of the file pointer.
+     *
+     * @param      v   a <code>float</code> value to be written.
+     * @exception  IOException  if an I/O error occurs.
+     * @see        java.lang.Float#floatToIntBits(float)
+     */
+    public final void writeFloat(float v) throws IOException {
+	writeInt(Float.floatToIntBits(v));
+    }
+
+    /**
+     * Converts the double argument to a <code>long</code> using the 
+     * <code>doubleToLongBits</code> method in class <code>Double</code>, 
+     * and then writes that <code>long</code> value to the file as an 
+     * eight-byte quantity, high byte first. The write starts at the current 
+     * position of the file pointer.
+     *
+     * @param      v   a <code>double</code> value to be written.
+     * @exception  IOException  if an I/O error occurs.
+     * @see        java.lang.Double#doubleToLongBits(double)
+     */
+    public final void writeDouble(double v) throws IOException {
+	writeLong(Double.doubleToLongBits(v));
+    }
+
+    /**
+     * Writes the string to the file as a sequence of bytes. Each 
+     * character in the string is written out, in sequence, by discarding 
+     * its high eight bits. The write starts at the current position of 
+     * the file pointer.
+     *
+     * @param      s   a string of bytes to be written.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public final void writeBytes(String s) throws IOException {
+	int len = s.length();
+
+	char[] val = new char[len];
+	s.getChars(0, len, val, 0);
+
+	byte[] b = new byte[len];
+
+        for (int i = 0; i < len; ++i) {
+            b[i] = (byte)val[i];
+        }
+
+	writeBytes(b, 0, len);
+
+    }
+
+    /**
+     * Writes a string to the file as a sequence of characters. Each 
+     * character is written to the data output stream as if by the 
+     * <code>writeChar</code> method. The write starts at the current 
+     * position of the file pointer.
+     *
+     * @param      s   a <code>String</code> value to be written.
+     * @exception  IOException  if an I/O error occurs.
+     * @see        java.io.RandomAccessFile#writeChar(int)
+     */
+    public final void writeChars(String s) throws IOException {
+	int clen = s.length();
+	int blen = 2*clen;
+	byte[] b = new byte[blen];
+	char[] c = new char[clen];
+	s.getChars(0, clen, c, 0);
+	for (int i = 0, j = 0; i < clen; i++) {
+	    b[j++] = (byte)(c[i] >>> 8);
+	    b[j++] = (byte)(c[i] >>> 0);
+	}
+	writeBytes(b, 0, blen);
+    }
+
+    /**
+     * Writes a string to the file using UTF-8 encoding in a 
+     * machine-independent manner. 
+     * <p>
+     * First, two bytes are written to the file, starting at the 
+     * current file pointer, as if by the 
+     * <code>writeShort</code> method giving the number of bytes to 
+     * follow. This value is the number of bytes actually written out, 
+     * not the length of the string. Following the length, each character 
+     * of the string is output, in sequence, using the UTF-8 encoding 
+     * for each character. 
+     *
+     * @param      str   a string to be written.
+     * @exception  IOException  if an I/O error occurs.
+     */
+    public final void writeUTF(String str) throws IOException {
+        DataOutputStream.writeUTF(str, this);
+    }
+
+    private static native void initIDs();
+
+    private native void close0() throws IOException;
+
+    static {
+	initIDs();
+    }
+
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/foundation/classes/java/io/RandomAccessFile.java.rej phoneme_advanced-mr2-dev-b122/cdc/src/share/foundation/classes/java/io/RandomAccessFile.java.rej
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/foundation/classes/java/io/RandomAccessFile.java.rej	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/foundation/classes/java/io/RandomAccessFile.java.rej	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,161 @@
+***************
+*** 1,77 ****
+  /*
+-  * @(#)RandomAccessFile.java	1.75 06/10/10
+   *
+-  * Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.  
+-  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+-  *   
+-  * This program is free software; you can redistribute it and/or  
+-  * modify it under the terms of the GNU General Public License version  
+-  * 2 only, as published by the Free Software Foundation.   
+-  *   
+-  * This program is distributed in the hope that it will be useful, but  
+-  * WITHOUT ANY WARRANTY; without even the implied warranty of  
+-  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+-  * General Public License version 2 for more details (a copy is  
+-  * included at /legal/license.txt).   
+-  *   
+-  * You should have received a copy of the GNU General Public License  
+-  * version 2 along with this work; if not, write to the Free Software  
+-  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+-  * 02110-1301 USA   
+-  *   
+-  * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+-  * Clara, CA 95054 or visit www.sun.com if you need additional  
+-  * information or have any questions. 
+   *
+   */
+  
+  package java.io;
+  
+  
+  /**
+-  * Instances of this class support both reading and writing to a 
+-  * random access file. A random access file behaves like a large 
+-  * array of bytes stored in the file system. There is a kind of cursor, 
+-  * or index into the implied array, called the <em>file pointer</em>; 
+-  * input operations read bytes starting at the file pointer and advance 
+-  * the file pointer past the bytes read. If the random access file is 
+-  * created in read/write mode, then output operations are also available; 
+-  * output operations write bytes starting at the file pointer and advance 
+-  * the file pointer past the bytes written. Output operations that write 
+-  * past the current end of the implied array cause the array to be 
+-  * extended. The file pointer can be read by the 
+-  * <code>getFilePointer</code> method and set by the <code>seek</code> 
+-  * method. 
+   * <p>
+-  * It is generally true of all the reading routines in this class that 
+-  * if end-of-file is reached before the desired number of bytes has been 
+-  * read, an <code>EOFException</code> (which is a kind of 
+-  * <code>IOException</code>) is thrown. If any byte cannot be read for 
+-  * any reason other than end-of-file, an <code>IOException</code> other 
+-  * than <code>EOFException</code> is thrown. In particular, an 
+   * <code>IOException</code> may be thrown if the stream has been closed.
+   *
+   * @author  unascribed
+-  * @version 1.57, 05/03/00
+   * @since   JDK1.0
+   */
+  
+- public class RandomAccessFile implements DataOutput, DataInput {
+  
+      private FileDescriptor fd;
+      private boolean rw;
+  
+      private static final int O_RDONLY = 1;
+      private static final int O_RDWR =   2;
+      private static final int O_SYNC =   4;
+      private static final int O_DSYNC =  8;
+  
+      /**
+-      * Creates a random access file stream to read from, and optionally 
+-      * to write to, a file with the specified name. A new 
+-      * {@link FileDescriptor} object is created to represent the 
+       * connection to the file.
+-      * 
+       * <p> The <tt>mode</tt> argument specifies the access mode with which the
+       * file is to be opened.  The permitted values and their meanings are as
+       * specified for the <a
+--- 1,81 ----
+  /*
++  * Copyright 1994-2007 Sun Microsystems, Inc.  All Rights Reserved.
++  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+   *
++  * This code is free software; you can redistribute it and/or modify it
++  * under the terms of the GNU General Public License version 2 only, as
++  * published by the Free Software Foundation.  Sun designates this
++  * particular file as subject to the "Classpath" exception as provided
++  * by Sun in the LICENSE file that accompanied this code.
+   *
++  * This code is distributed in the hope that it will be useful, but WITHOUT
++  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++  * version 2 for more details (a copy is included in the LICENSE file that
++  * accompanied this code).
++  *
++  * You should have received a copy of the GNU General Public License version
++  * 2 along with this work; if not, write to the Free Software Foundation,
++  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
++  *
++  * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
++  * CA 95054 USA or visit www.sun.com if you need additional information or
++  * have any questions.
+   */
+  
+  package java.io;
+  
++ import java.nio.channels.FileChannel;
++ import sun.nio.ch.FileChannelImpl;
++ 
+  
+  /**
++  * Instances of this class support both reading and writing to a
++  * random access file. A random access file behaves like a large
++  * array of bytes stored in the file system. There is a kind of cursor,
++  * or index into the implied array, called the <em>file pointer</em>;
++  * input operations read bytes starting at the file pointer and advance
++  * the file pointer past the bytes read. If the random access file is
++  * created in read/write mode, then output operations are also available;
++  * output operations write bytes starting at the file pointer and advance
++  * the file pointer past the bytes written. Output operations that write
++  * past the current end of the implied array cause the array to be
++  * extended. The file pointer can be read by the
++  * <code>getFilePointer</code> method and set by the <code>seek</code>
++  * method.
+   * <p>
++  * It is generally true of all the reading routines in this class that
++  * if end-of-file is reached before the desired number of bytes has been
++  * read, an <code>EOFException</code> (which is a kind of
++  * <code>IOException</code>) is thrown. If any byte cannot be read for
++  * any reason other than end-of-file, an <code>IOException</code> other
++  * than <code>EOFException</code> is thrown. In particular, an
+   * <code>IOException</code> may be thrown if the stream has been closed.
+   *
+   * @author  unascribed
+   * @since   JDK1.0
+   */
+  
++ public class RandomAccessFile implements DataOutput, DataInput, Closeable {
+  
+      private FileDescriptor fd;
++     private FileChannel channel = null;
+      private boolean rw;
+  
++     private Object closeLock = new Object();
++     private volatile boolean closed = false;
++ 
+      private static final int O_RDONLY = 1;
+      private static final int O_RDWR =   2;
+      private static final int O_SYNC =   4;
+      private static final int O_DSYNC =  8;
+  
+      /**
++      * Creates a random access file stream to read from, and optionally
++      * to write to, a file with the specified name. A new
++      * {@link FileDescriptor} object is created to represent the
+       * connection to the file.
++      *
+       * <p> The <tt>mode</tt> argument specifies the access mode with which the
+       * file is to be opened.  The permitted values and their meanings are as
+       * specified for the <a
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/javavm/classes/java/lang/ref/Reference.java phoneme_advanced-mr2-dev-b122/cdc/src/share/javavm/classes/java/lang/ref/Reference.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/javavm/classes/java/lang/ref/Reference.java	2009-07-06 18:37:08.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/javavm/classes/java/lang/ref/Reference.java	2009-07-06 19:25:13.000000000 -0400
@@ -29,6 +29,7 @@
 
 import sun.misc.ThreadRegistry;
 import sun.misc.CVM;
+import sun.misc.Cleaner;
 
 /**
  * Abstract base class for reference objects.  This class defines the
@@ -152,6 +153,12 @@
 		}
 		sun.misc.CVM.setThreadNoCompilationsFlag(false);
 
+                // Fast path for cleaners
+                if (r instanceof Cleaner) {
+                    ((Cleaner)r).clean();
+                    continue;
+                }
+
 		ReferenceQueue q = r.queue;
 		if (q != ReferenceQueue.NULL) q.enqueue(r);
 	    }
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/javavm/runtime/jni_impl.c phoneme_advanced-mr2-dev-b122/cdc/src/share/javavm/runtime/jni_impl.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/javavm/runtime/jni_impl.c	2009-07-06 18:37:01.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/javavm/runtime/jni_impl.c	2009-07-06 19:25:13.000000000 -0400
@@ -3493,10 +3493,8 @@
     for (i = 0; i < numClasses; i++) {
 	CVMClassBlock* cb = (CVMClassBlock*)classList[i];
 	CVMBool status;
-	/*
-	CVMconsolePrintf("Preparing to initialize %C\n",
-			 classList[i]);
-	*/
+/*	CVMconsolePrintf("Preparing to initialize %C\n",
+			 classList[i]); */
 	status = CVMclassInit(ee, cb);
 	if (!status) {
 	    CVMformatString(errorStrBuf, sizeofErrorStrBuf,
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/javavm/runtime/jni_impl.c.orig phoneme_advanced-mr2-dev-b122/cdc/src/share/javavm/runtime/jni_impl.c.orig
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/javavm/runtime/jni_impl.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/javavm/runtime/jni_impl.c.orig	2009-07-06 18:37:01.000000000 -0400
@@ -0,0 +1,5230 @@
+/*
+ * @(#)jni_impl.c	1.380 06/10/31
+ *
+ * Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.  
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
+ *   
+ * This program is free software; you can redistribute it and/or  
+ * modify it under the terms of the GNU General Public License version  
+ * 2 only, as published by the Free Software Foundation.   
+ *   
+ * This program is distributed in the hope that it will be useful, but  
+ * WITHOUT ANY WARRANTY; without even the implied warranty of  
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
+ * General Public License version 2 for more details (a copy is  
+ * included at /legal/license.txt).   
+ *   
+ * You should have received a copy of the GNU General Public License  
+ * version 2 along with this work; if not, write to the Free Software  
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+ * 02110-1301 USA   
+ *   
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
+ * Clara, CA 95054 or visit www.sun.com if you need additional  
+ * information or have any questions. 
+ *
+ */
+
+#define _JNI_IMPLEMENTATION_
+
+#include "javavm/include/defs.h"
+#include "javavm/include/objects.h"
+#include "javavm/include/classes.h"
+#include "javavm/include/interpreter.h"
+#include "javavm/include/stacks.h"
+#include "javavm/include/localroots.h"
+#include "javavm/include/globalroots.h"
+#include "javavm/include/indirectmem.h"
+#include "javavm/include/typeid.h"
+#include "javavm/include/jni_impl.h"
+#include "javavm/include/gc_common.h"
+#include "javavm/include/preloader.h"
+#include "javavm/include/basictypes.h"
+#include "javavm/include/common_exceptions.h"
+#include "javavm/include/utils.h"
+#include "javavm/include/timestamp.h"
+#include "javavm/include/stackwalk.h"
+#include "javavm/include/packages.h"
+#ifndef CDC_10
+#include "javavm/include/javaAssertions.h"
+#endif
+
+#include "generated/offsets/java_lang_Class.h"
+#include "generated/offsets/java_lang_String.h"
+#include "generated/offsets/java_lang_Thread.h"
+#include "generated/jni/java_lang_Thread.h"
+#include "generated/cni/sun_misc_CVM.h"
+
+#include "javavm/include/porting/time.h"
+#include "javavm/include/porting/threads.h"
+#include "javavm/include/porting/system.h"
+#include "javavm/include/porting/globals.h"
+#include "javavm/include/porting/ansi/stdarg.h"
+
+#include "javavm/export/jni.h"
+
+#ifdef CVM_XRUN
+#include "javavm/include/xrun.h"
+#endif
+#ifdef CVM_AGENTLIB
+#include "javavm/include/agentlib.h"
+#endif
+
+#ifdef CVM_CLASSLOADING
+#include "javavm/include/porting/java_props.h"
+#include "native/java/util/zip/zip_util.h"
+#include "javavm/include/porting/io.h"
+#include "javavm/include/porting/path.h"
+#endif
+
+#ifdef CVM_REFLECT
+#include "javavm/include/reflect.h"
+#endif
+
+#ifdef CVM_JVMTI
+#include "javavm/export/jvmti.h"
+#endif
+
+#ifdef CVM_JVMPI
+#include "javavm/include/jvmpi_impl.h"
+#endif
+
+#ifdef CVM_JIT
+#include "javavm/include/ccm_runtime.h"
+#include "javavm/include/porting/jit/ccm.h"
+#include "javavm/include/jit_common.h"
+#include "javavm/include/jit/jitstats.h"
+#include "javavm/include/jit/jitcodebuffer.h"
+#endif
+
+#ifdef CVM_DEBUG_ASSERTS
+#include "javavm/include/constantpool.h"
+#endif
+
+#ifdef CVM_EMBEDDED_HOOK
+#include "javavm/include/hook.h"
+#endif
+
+#ifdef CVM_HW
+#include "include/hw.h"
+#endif
+
+#undef MIN
+#define MIN(x,y) ((x) < (y) ? (x) : (y))
+
+/*
+ * If gc latency is of concern, you may want to reduce this buffer size.
+ * It will affect the maximum amount of time spent gc-unsafe while copying
+ * characters from the heap to a local buffer.
+ */
+#undef  MAX_CHARS_PER_ACCESS
+#define MAX_CHARS_PER_ACCESS	100
+
+/* %comment c006 */
+
+#define CVMjniNonNullICellPtrFor(jobj) \
+    CVMID_NonNullICellPtrFor(jobj)
+
+#ifdef CVM_JVMTI_IOVEC
+static CVMIOVector CVMioFuncs;
+#endif
+
+static CVMUint32
+CVMjniAvailableCapacity(CVMStack* stack, CVMJNIFrame* frame)
+{
+    if (!CVMaddressInStackChunk(frame, stack->currentStackChunk)) {
+        CVMStackChunk* chunk = stack->currentStackChunk;
+        CVMUint32 available = 0;
+       
+        while (!CVMaddressInStackChunk(frame, chunk)) {
+            available += (CVMUint32)(chunk->end_data - chunk->data);
+            chunk = chunk->prev;
+        }
+        CVMassert(CVMaddressInStackChunk(frame, chunk));
+        available += (((CVMUint32)chunk->end_data - 
+                     (CVMUint32)frame) / sizeof(CVMStackVal32)) -
+                    CVMJNIFrameCapacity - frame->inUse;
+        return available;
+    } else {
+	/* 
+	 * casting to the result type jint should be done after 
+	 * subtracting the addresses frame->topOfStack and frame
+	 * because jint can not hold a native pointer on 64 bit platforms
+	 */
+	return (jint)((((CVMAddr)((stack->currentStackChunk)->end_data) - 
+                    (CVMAddr)frame) / sizeof(CVMStackVal32)) - 
+                   CVMJNIFrameCapacity - frame->inUse);
+    }
+}
+
+
+/* private types */
+
+typedef char
+JNI_PushArguments_t(JNIEnv *env, CVMterseSigIterator  *terse_signature,
+                    CVMFrame *current_frame, const void *args);
+
+/* Forward declarations */
+
+static JNI_PushArguments_t CVMjniPushArgumentsVararg;
+static JNI_PushArguments_t CVMjniPushArgumentsArray;
+
+static void CVMjniInvoke(JNIEnv *env, jobject obj, jmethodID methodID,
+    JNI_PushArguments_t pushArguments, const void *args,
+    CVMUint16 info, jvalue *retValue);
+
+/* Definitions */
+
+
+void JNICALL
+CVMjniFatalError(JNIEnv *env, const char *msg)
+{
+    CVMconsolePrintf("JNI FATAL ERROR: %s\n", msg);
+#if defined(CVM_DEBUG) && defined(CVM_DEBUG_DUMPSTACK)
+    CVMdumpStack(&CVMjniEnv2ExecEnv(env)->interpreterStack,
+		 CVM_FALSE, CVM_FALSE, 100);
+#endif 
+    CVMexit(1);
+}
+
+#undef CVMjniGcUnsafeRef2Class
+#define CVMjniGcUnsafeRef2Class(ee, cl) CVMgcUnsafeClassRef2ClassBlock(ee, cl)
+
+#undef CVMjniGcSafeRef2Class
+#define CVMjniGcSafeRef2Class(ee, cl) CVMgcSafeClassRef2ClassBlock(ee, cl)
+
+
+
+/* 
+ * CreateLocalRef is used to create a local ref in the current frame of
+ * the specified thread.  It should check the free list first.
+ */
+CVMObjectICell*
+CVMjniCreateLocalRef0(CVMExecEnv *ee, CVMExecEnv *targetEE)
+{
+    CVMStack*      jniLocalsStack = &targetEE->interpreterStack;
+    CVMFrame*	   currentFrame   = jniLocalsStack->currentFrame;
+    CVMStackVal32* result         = NULL;
+
+    CVMassert(CVMframeIsJNI(currentFrame));
+
+    CVMframeAlloc(ee, jniLocalsStack, CVMgetJNIFrame(currentFrame), result);
+    if (result != NULL) {
+	return &result->ref;
+    } else {
+	/* The JNI spec says that if an attempt to allocate a localRef
+	 * fails, it's a fatal error since the caller really should have
+	 * called EnsureLocalCapacity() first. 
+	 */
+	CVMjniFatalError(CVMexecEnv2JniEnv(ee), 
+			 "Out of memory when expanding local ref "
+			 "table beyond capacity");
+	return NULL;
+    }
+}
+
+/* 
+ * CreateLocalRef is used to create a local ref in the current frame
+ * of the current thread.
+ */
+CVMObjectICell*
+CVMjniCreateLocalRef(CVMExecEnv *ee)
+{
+    return CVMjniCreateLocalRef0(ee, ee);
+}
+
+/* Version information */
+
+jint JNICALL
+CVMjniGetVersion(JNIEnv *env)
+{
+    return JNI_VERSION_1_4;
+}
+
+/* 
+ * NewLocalRef is used to create a local ref in the specified frame. It
+ * should check the free list first.
+ */
+jobject JNICALL
+CVMjniNewLocalRef(JNIEnv *env, jobject obj)
+{
+    CVMExecEnv*     currentEE      = CVMjniEnv2ExecEnv(env);
+    CVMObjectICell* resultCell     = NULL;
+
+    CVMassert(CVMframeIsJNI(CVMeeGetCurrentFrame(currentEE)));
+
+    if ((obj == NULL) || CVMID_icellIsNull(obj)) {
+	/*
+	 * If ref is NULL, or ref points to a cell containing a NULL
+	 * (a cleared weak global ref), return NULL.
+	 */
+	return NULL;
+    } else {
+	resultCell = CVMjniCreateLocalRef(currentEE);
+	if (resultCell == NULL) {
+	    return NULL;
+	}
+	CVMID_icellAssign(currentEE, resultCell, obj);
+	return resultCell;
+    }
+}
+
+/*
+ * Is a given ref in any of the chunks of 'frame'?
+ */
+static CVMBool
+CVMjniRefInFrame(CVMStackChunk* chunk, CVMFrame* frame, CVMStackVal32* ref)
+{
+    CVMJNIFrame*   jniFrame = CVMgetJNIFrame(frame);
+    CVMStackVal32* tos      = frame->topOfStack;
+    /*
+     * Traverse chunks from the last chunk of the frame to the first
+     */
+    while (!CVMaddressInStackChunk(frame, chunk)) {
+	if ((ref < tos) && (ref >= chunk->data)) {
+	    return CVM_TRUE;
+	}
+	chunk = chunk->prev;
+	tos = chunk->end_data;
+    }
+    /* Now we are looking at the first chunk of the frame.
+       Do a range check. */
+    if ((ref < tos) && (ref >= jniFrame->vals)) {
+	return CVM_TRUE;
+    } else {
+	return CVM_FALSE;
+    }
+}
+
+/* 
+ * DeleteLocalRef is used delete a JNI local ref in the specified frame.
+ */
+void JNICALL
+CVMjniDeleteLocalRef(JNIEnv *env, jobject obj)
+{
+    CVMExecEnv*    currentEE      = CVMjniEnv2ExecEnv(env);
+    CVMStack*      jniLocalsStack = &currentEE->interpreterStack;
+    CVMStackVal32* refToFree	  = (CVMStackVal32*)obj;
+    CVMFrame*      frame;
+    CVMFrame*      calleeFrame;
+    CVMStackChunk* chunk;
+    CVMStackWalkContext swc;
+
+    frame = jniLocalsStack->currentFrame;
+    CVMassert(frame != NULL);
+    CVMassert(CVMframeIsJNI(frame));
+    if (refToFree == NULL) {
+	return; /* Nothing to do */
+    }
+    /* 
+     * Walk the stack through all local roots and JNI frames. These
+     * may be PushLocalFrame frames, or the frame of a JNI
+     * method. If the local frame belongs to any one of these frames
+     * (each of which may span multiple stack chunks), return it to
+     * the right free list.  
+     */
+    CVMstackwalkInit(jniLocalsStack, &swc);
+    frame = swc.frame;
+    chunk = swc.chunk;
+    do {
+	if (CVMjniRefInFrame(chunk, frame, refToFree)) {
+	    CVMframeFree(CVMgetJNIFrame(frame), refToFree);
+	    return;
+	}
+	calleeFrame = frame;
+	CVMstackwalkPrev(&swc);
+	frame = swc.frame;
+	chunk = swc.chunk;
+	CVMassert(frame != NULL);
+    } while (CVMframeIsJNI(frame));
+    /*
+     * Well, we couldn't find where this ref belongs. Maybe it is an argument
+     * to this JNI function.
+     *
+     * At this point:
+     *    frame-        the caller of the JNI method
+     *    calleeFrame-  the frame of the JNI method
+     */
+    if (CVMframeIsInterpreter(frame)) {
+	/* We are now at the caller of the JNI method. Its top of stack is set
+	   to just above the arguments to the JNI method. See if refToFree
+	   was one of these arguments. */
+	CVMStackVal32* topOfArgs = frame->topOfStack;
+	if ((refToFree <  topOfArgs) &&
+	    (refToFree >= topOfArgs - CVMmbArgsSize(calleeFrame->mb))) {
+	    CVMID_icellSetNull(obj);
+	    return;
+	}
+    }
+    /*
+     * If we got here, this cannot be a valid ref. Just ignore -- we can't
+     * do anything useful with this.
+     */
+    CVMdebugPrintf(("Attempt to delete invalid local ref -- ignoring!\n"));
+}
+
+/*
+ * Ensure local refs capacity in frame (in number of words).
+ */
+jint JNICALL
+CVMjniEnsureLocalCapacity(JNIEnv *env, jint capacity)
+{
+    CVMExecEnv*    ee             = CVMjniEnv2ExecEnv(env);
+    CVMStack*      jniLocalsStack = &ee->interpreterStack;
+    CVMFrame*	   currentFrame   = jniLocalsStack->currentFrame;
+    CVMJNIFrame*   jniFrame;
+    CVMUint32      available;
+
+    CVMassert(CVMframeIsJNI(currentFrame));
+    jniFrame = CVMgetJNIFrame(currentFrame);
+    available = CVMjniAvailableCapacity(jniLocalsStack, jniFrame);
+
+    /* The 'capacity <= 0' is necessary if capacity is negative */
+    if (capacity <= 0 || capacity <= available) {
+	return JNI_OK; /* We have enough to satisfy the capacity request */
+    }
+
+    /* Now expand the stack */
+    capacity -= available; 
+    CVMD_gcUnsafeExec(ee, {
+	CVMexpandStack(ee, jniLocalsStack, capacity, CVM_TRUE, CVM_TRUE);
+    });
+    
+    if (CVMlocalExceptionOccurred(ee)) {
+	/* The JNI spec says to throw an OutOfMemoryError. However,
+	 * CVMexpandStack may have thrown a StackOverflowError
+	 * error instead.
+	 */
+	CVMclearLocalException(ee);
+	CVMthrowOutOfMemoryError(ee, NULL);
+	return JNI_ENOMEM;
+    } else {
+	return JNI_OK;
+    }
+}
+
+/*
+ * Push local frame that can accommodate 'capacity' local refs
+ */
+jint JNICALL
+CVMjniPushLocalFrame(JNIEnv *env, jint capacity)
+{
+    CVMExecEnv*    ee             = CVMjniEnv2ExecEnv(env);
+    CVMStack*      jniLocalsStack = &ee->interpreterStack;
+    CVMFrame*      currentFrame   = jniLocalsStack->currentFrame;
+
+    /* Make sure we have the room on the stack for the specified bytes. */
+    if (!CVMensureCapacity(ee, jniLocalsStack, 
+			   capacity + CVMJNIFrameCapacity)) {
+	/* The JNI spec says to throw an OutOfMemoryError. However,
+	 * CVMensureCapacity may have thrown a StackOverflowError
+	 * error instead.
+	 */
+	CVMclearLocalException(ee);
+	CVMthrowOutOfMemoryError(ee, NULL);
+	return JNI_ENOMEM;
+    }
+
+    /* We know this will succeed, since we've ensured larger capacity above */
+    CVMpushGCRootFrame(ee, jniLocalsStack, currentFrame,
+		       CVMJNIFrameCapacity, CVM_FRAMETYPE_JNI);
+    CVMjniFrameInit(CVMgetJNIFrame(currentFrame), CVM_TRUE);
+    /* Ready to go! */
+    return JNI_OK;
+}
+
+/*
+ * Pop local frame, and return a ref to the old frame
+ */
+jobject JNICALL
+CVMjniPopLocalFrame(JNIEnv *env, jobject resultArg)
+{
+    CVMExecEnv*    currentEE      = CVMjniEnv2ExecEnv(env);
+    CVMStack*      jniLocalsStack = &currentEE->interpreterStack;
+    CVMFrame*      currentFrame   = jniLocalsStack->currentFrame;
+    CVMJNIFrame*   jniFrame;
+    CVMStackVal32* returnVal;
+    CVMObjectICell* result;
+
+    CVMassert(CVMframeIsFreelist(currentFrame));
+    CVMassert(currentFrame->mb == NULL);
+
+    /* If the resultArg is NULL, we are not responsible for handing
+       the object reference to the previous stack frame. This is
+       important for making the JVMTI work. See the Java 1.2 JNI spec
+       additions. */
+    if (resultArg == NULL) {
+	CVMpopGCRootFrame(currentEE, jniLocalsStack, currentFrame);
+	/* It is not required that the previous frame be JNI, because
+           we're not going to try to get a "local ref" for the result
+           argument. */
+	return NULL;
+    } else {
+	result = CVMjniNonNullICellPtrFor(resultArg);
+	CVMID_localrootBegin(currentEE); {
+	    CVMID_localrootDeclare(CVMObjectICell, temp);
+
+	    /*
+	     * Hold the result in a temporary, so it doesn't get lost
+	     * when the locals frame is popped
+	     */
+	    CVMID_icellAssign(currentEE, temp, result);
+
+	    CVMpopGCRootFrame(currentEE, jniLocalsStack, currentFrame);
+
+	    if (!CVMframeIsJNI(currentFrame)) {
+		CVMjniFatalError(env, "can't return reference to "
+				 "non-JNI frame");
+	    }
+
+	    CVMassert(CVMframeIsJNI(currentFrame));
+	    jniFrame = CVMgetJNIFrame(currentFrame);
+
+	    /*
+	     * Now get a new slot for the result
+	     */
+	    CVMframeAlloc(currentEE, jniLocalsStack, jniFrame, returnVal);
+	    CVMID_icellAssign(currentEE, &returnVal->ref, temp);
+	} CVMID_localrootEnd();
+	/*
+	 * Don't return ICells containing NULL. 
+	 *
+	 * %comment: rt011
+	 */
+	if (CVMID_icellIsNull(&returnVal->ref)) {
+	    return NULL;
+	} else {
+	    return &returnVal->ref;
+	}
+    }
+}
+
+/*
+ * Make global ref, and make it point to the same object 'value' points to
+ */
+jobject JNICALL
+CVMjniNewGlobalRef(JNIEnv *env, jobject ref)
+{
+#if 0
+    /* This might break JNI code, but it is good for debugging
+       cvm code */
+#ifdef CVM_DEBUG_ASSERTS
+    CVMassert(!CVMlocalExceptionOccurred(CVMjniEnv2ExecEnv(env)));
+#endif
+#endif
+    if ((ref == NULL) || CVMID_icellIsNull(ref)) {
+	/*
+	 * If ref is NULL, or ref points to a cell containing a NULL
+	 * (a cleared weak global ref), return NULL.  
+	 */
+	return NULL;
+    } else {
+	CVMExecEnv* currentEE = CVMjniEnv2ExecEnv(env);
+	CVMObjectICell* cell = CVMID_getGlobalRoot(currentEE);
+	if (cell != NULL) {
+	    CVMID_icellAssign(currentEE, cell, ref);
+#ifdef CVM_JVMPI
+            if (CVMjvmpiEventJNIGlobalrefAllocIsEnabled()) {
+                CVMjvmpiPostJNIGlobalrefAllocEvent(currentEE, cell);
+            }
+#endif /* CVM_JVMPI */
+	} else {
+	    CVMthrowOutOfMemoryError(currentEE, NULL);
+	}
+	return cell;
+    }
+}
+
+/*
+ * Delete global ref
+ */
+void JNICALL
+CVMjniDeleteGlobalRef(JNIEnv *env, jobject ref)
+{
+    /* Apparently Sheng's book, which contains the revised JNI spec,
+       says that deleting a NULL global ref is a no-op */
+    /* %comment: rt012 */
+    if (ref != NULL) {
+	CVMExecEnv* currentEE = CVMjniEnv2ExecEnv(env);
+#ifdef CVM_JVMPI
+        if (CVMjvmpiEventJNIGlobalrefFreeIsEnabled()) {
+            CVMjvmpiPostJNIGlobalrefFreeEvent(currentEE, ref);
+        }
+#endif /* CVM_JVMPI */
+	CVMID_freeGlobalRoot(currentEE, ref);
+    }
+}
+
+/* Purpose: Allocates a weak global ref. */
+static jweak JNICALL
+CVMjniNewWeakGlobalRef(JNIEnv* env, jobject ref)
+{
+    if ((ref == NULL) || CVMID_icellIsNull(ref)) {
+	/*
+	 * If ref is NULL, or ref points to a cell containing a NULL
+	 * (a cleared weak global ref), return NULL.
+	 */
+	return NULL;
+    } else {
+	CVMExecEnv* currentEE = CVMjniEnv2ExecEnv(env);
+	CVMObjectICell* cell = CVMID_getWeakGlobalRoot(currentEE);
+	if (cell != NULL) {
+	    CVMID_icellAssign(currentEE, cell, ref);
+#ifdef CVM_JVMPI
+            if (CVMjvmpiEventJNIWeakGlobalrefAllocIsEnabled()) {
+                CVMjvmpiPostJNIWeakGlobalrefAllocEvent(currentEE, cell);
+            }
+#endif /* CVM_JVMPI */
+	} else {
+	    CVMthrowOutOfMemoryError(currentEE, NULL);
+	}
+	return cell;
+    }
+}
+
+/* Purpose: Releases the specified weak global ref. */
+static void JNICALL
+CVMjniDeleteWeakGlobalRef(JNIEnv* env, jweak ref)
+{
+    /* Apparently Sheng's book, which contains the revised JNI spec,
+       says that deleting a NULL global ref is a no-op */
+    /* %comment: rt012 */
+    if (ref != NULL) {
+	CVMExecEnv* currentEE = CVMjniEnv2ExecEnv(env);
+#ifdef CVM_JVMPI
+        if (CVMjvmpiEventJNIWeakGlobalrefFreeIsEnabled()) {
+            CVMjvmpiPostJNIWeakGlobalrefFreeEvent(currentEE, ref);
+        }
+#endif /* CVM_JVMPI */
+	CVMID_freeWeakGlobalRoot(currentEE, ref);
+    }
+}
+
+/*
+ * CVMjniDefineClass - define a class. Used by Classloader.defineClass.
+ */
+static jclass JNICALL
+CVMjniDefineClass(JNIEnv *env, const char *name, jobject loaderRef,
+		  const jbyte *buf, jsize bufLen)
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+    CVMClassICell* classRoot;
+
+    /* define the class */
+    classRoot =
+	CVMdefineClass(ee, name, loaderRef, (CVMUint8*)buf, bufLen, NULL,
+		       CVM_FALSE);
+    if (classRoot == NULL) {
+	return NULL;
+    }
+
+    /* load superclasses in a non-recursive way */
+    (*env)->CallVoidMethod(env, classRoot,
+			   CVMglobals.java_lang_Class_loadSuperClasses);
+    if (CVMexceptionOccurred(ee)) {
+	CVMjniDeleteLocalRef(env, classRoot);
+	return NULL;
+    }
+
+    return classRoot;
+}
+
+jclass JNICALL
+CVMjniFindClass(JNIEnv *env, const char *name)
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+
+    CVMClassLoaderICell* loader;
+
+    CVMClassBlock* callerCb = CVMgetCallerClass(ee, 0);
+
+    /*
+     * According to JNI spec, 'name' must be a fully-qualified class name,
+     * which is a package name, delimited by "/", followed by the class
+     * name. First check name and throw NoClassDefFoundError if it's not
+     * legal, instead of throwing the exception after the class is actually
+     * created.
+     */
+    if (strchr(name, '.') != NULL) {
+        CVMthrowNoClassDefFoundError(ee, "Bad class name %s", name);
+        return NULL;
+    }
+
+#ifdef CVM_CLASSLOADING
+    CVMassert(!CVMlocalExceptionOccurred(ee));
+
+    if (callerCb != NULL) {
+        /* Special handling to make sure JNI_OnLoad and JNI_OnUnload are
+	 * executed in the correct class context.
+	 */
+	if (callerCb == CVMsystemClass(java_lang_ClassLoader_NativeLibrary)) {
+	    jobject clazz;
+	    CVMMethodBlock* mb = 
+		CVMglobals.java_lang_ClassLoader_NativeLibrary_getFromClass;
+	    clazz = (*env)->CallStaticObjectMethod(env,
+						   CVMcbJavaInstance(callerCb),
+						   mb);
+	    if (CVMexceptionOccurred(ee)) {
+		return NULL;
+	    }
+	    callerCb = CVMgcSafeClassRef2ClassBlock(ee, clazz);
+	}
+	loader = CVMcbClassLoader(callerCb);
+    } else {
+	loader = CVMclassGetSystemClassLoader(ee);
+	if (loader == NULL) {
+	    return NULL;   /* exception already thrown */
+	}
+    }
+#else
+    loader = NULL;
+#endif /* CVM_CLASSLOADING */
+
+    CVMassert(!CVMlocalExceptionOccurred(ee));
+    {
+	CVMObjectICell* pd = callerCb ? CVMcbProtectionDomain(callerCb) : NULL;
+	CVMClassBlock* cb = 
+	    CVMclassLookupByNameFromClassLoader(ee, name, CVM_TRUE, 
+						loader, pd, CVM_TRUE);
+	if (cb != NULL) {
+	    return CVMjniNewLocalRef(env, CVMcbJavaInstance(cb));
+	}
+	return NULL;
+    }
+}
+
+/*
+ * Native Bootstrap
+ */
+
+jint JNICALL
+CVMjniRegisterNatives(JNIEnv *env, jclass clazz,
+		      const JNINativeMethod *methods, jint nMethods)
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+    CVMClassBlock *cb = CVMgcSafeClassRef2ClassBlock(ee, clazz);
+    CVMBool inROM = CVMcbIsInROM(cb);
+    int i;
+
+    for (i = 0; i < nMethods; ++i) {
+        struct CVMMethodBlock *mb;
+        char *name = methods[i].name;
+        char *sig = methods[i].signature;
+
+	mb = CVMclassGetDeclaredMethodBlock(ee, cb, name, sig);
+        if (mb == NULL || !CVMmbIs(mb, NATIVE)) {
+            CVMthrowNoSuchMethodError(ee, "%s", name);
+            return JNI_EINVAL;
+	}
+    }
+
+    /* %comment: rt013 */
+    for (i = 0; i < nMethods; ++i) {
+        struct CVMMethodBlock *mb;
+        const char *name = methods[i].name;
+        const char *sig = methods[i].signature;
+        void *nativeProc = methods[i].fnPtr;
+	int invoker;
+
+	mb = CVMclassGetDeclaredMethodBlock(ee, cb, name, sig);
+	CVMassert(mb != NULL && CVMmbIs(mb, NATIVE));
+#ifdef JDK12
+	if (verbose_jni) {
+	    jio_fprintf(stderr, "[Registering JNI native method %s.%s]\n",
+			cbName(mb->fb.clazz), mb->fb.name);
+	}
+#endif
+	invoker = CVMmbIs(mb, SYNCHRONIZED) ? CVM_INVOKE_JNI_SYNC_METHOD
+					    : CVM_INVOKE_JNI_METHOD;
+	if (inROM) {
+	    CVMassert(CVMmbInvokerIdx(mb) == invoker);
+	    CVMassert(CVMmbNativeCode(mb) == nativeProc);
+#ifdef CVM_JIT
+	    CVMassert(CVMmbJitInvoker(mb) == (void*)CVMCCMinvokeJNIMethod);
+#endif
+	} else {
+#ifdef CVM_JVMTI
+	    if (CVMjvmtiShouldPostNativeMethodBind()) {
+		CVMUint8* new_nativeCode = NULL;
+		CVMjvmtiPostNativeMethodBind(ee, mb, (CVMUint8*)nativeProc,
+					     &new_nativeCode);
+		if (new_nativeCode != NULL) {
+		    nativeProc = (void *)new_nativeCode;
+		}
+	    }
+#endif
+	    CVMmbSetInvokerIdx(mb, invoker);
+	    CVMmbNativeCode(mb) = (CVMUint8 *)nativeProc;
+#ifdef CVM_JIT
+	    CVMmbJitInvoker(mb) = (void*)CVMCCMinvokeJNIMethod;
+#endif
+	}
+    }
+
+    return JNI_OK;
+}
+
+jint JNICALL
+CVMjniUnregisterNatives(JNIEnv *env, jclass clazz)
+{
+#ifdef CVM_CLASSLOADING
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+    CVMClassBlock *cb = CVMgcSafeClassRef2ClassBlock(ee, clazz);
+    CVMBool inROM = CVMcbIsInROM(cb);
+    int i;
+
+    if (inROM) {
+	return JNI_OK;
+    }
+
+    /* %comment: rt013 */
+    for (i = 0; i < CVMcbMethodCount(cb); ++i) {
+        CVMMethodBlock* mb = CVMcbMethodSlot(cb, i);
+
+	if (CVMmbIs(mb, NATIVE)) {
+	    CVMmbSetInvokerIdx(mb, CVM_INVOKE_LAZY_JNI_METHOD);
+	    CVMmbNativeCode(mb) = NULL;
+#ifdef CVM_JIT
+	    CVMmbJitInvoker(mb) = (void*)CVMCCMletInterpreterDoInvoke;
+#endif
+	}
+    }
+    return JNI_OK;
+
+#else
+    return JNI_ERR;
+#endif
+}
+
+
+static jmethodID
+CVMjniGetXMethodID(JNIEnv *env,
+    jclass clazz, const char *name, const char *sig, jboolean isStatic)
+{
+    CVMExecEnv *    ee;
+    CVMClassBlock*  cb;
+    CVMMethodTypeID tid;
+    CVMMethodBlock* mb;
+
+    ee  = CVMjniEnv2ExecEnv(env);
+    cb  = CVMjniGcSafeRef2Class(ee, clazz);
+
+    if (!CVMclassInit(ee, cb)) {
+	return NULL;
+    }
+
+    /*
+     * We need to use the "new" function, because the "lookup" function
+     * is only valid when we know that the type already exists.
+     */
+    tid = CVMtypeidNewMethodIDFromNameAndSig(ee, name, sig);
+
+    if (tid != CVM_TYPEID_ERROR) {
+	/* never search superclasses for constructors */
+	mb  = CVMclassGetMethodBlock(cb, tid, isStatic);
+	CVMtypeidDisposeMethodID(ee, tid);
+    } else {
+	mb = NULL;
+	CVMclearLocalException(ee);
+    }
+
+    if (mb == NULL) {
+        CVMthrowNoSuchMethodError(ee, "%s", name);
+	return NULL;
+    }
+    return mb;
+}
+
+jmethodID JNICALL
+CVMjniGetStaticMethodID(JNIEnv *env,
+    jclass clazz, const char *name, const char *sig)
+{
+    return CVMjniGetXMethodID(env, clazz, name, sig, JNI_TRUE);
+}
+
+jmethodID JNICALL
+CVMjniGetMethodID(JNIEnv *env,
+    jclass clazz, const char *name, const char *sig)
+{
+    return CVMjniGetXMethodID(env, clazz, name, sig, JNI_FALSE);
+}
+
+static jfieldID
+CVMjniGetXFieldID(JNIEnv *env,
+    jclass clazz, const char *name, const char *sig, jboolean isStatic)
+{
+    CVMExecEnv *    ee;
+    CVMClassBlock*  cb;
+    CVMFieldTypeID       tid;
+    CVMFieldBlock*  fb;
+
+    ee  = CVMjniEnv2ExecEnv(env);
+    cb  = CVMjniGcSafeRef2Class(ee, clazz);
+
+    if (!CVMclassInit(ee, cb)) {
+	return NULL;
+    }
+
+    /*
+     * We need to use the "new" function, because the "lookup" function
+     * is only valid when we know that the type already exists.
+     */
+    tid = CVMtypeidNewFieldIDFromNameAndSig(ee, name, sig);
+
+    if (tid != CVM_TYPEID_ERROR) {
+	fb  = CVMclassGetFieldBlock(cb, tid, isStatic);
+	CVMtypeidDisposeFieldID(ee, tid);
+    } else {
+	fb = NULL;
+	CVMclearLocalException(ee);
+    }
+
+    if (fb == NULL || (CVMfbIs(fb, STATIC) != isStatic)) {
+        CVMthrowNoSuchFieldError(ee, "%s", name);
+	return NULL ;
+    }
+    return fb;
+}
+
+jfieldID JNICALL
+CVMjniGetStaticFieldID(JNIEnv *env,
+    jclass clazz, const char *name, const char *sig)
+{
+    return CVMjniGetXFieldID(env, clazz, name, sig, JNI_TRUE);
+}
+
+jfieldID JNICALL
+CVMjniGetFieldID(JNIEnv *env,
+    jclass clazz, const char *name, const char *sig)
+{
+    return CVMjniGetXFieldID(env, clazz, name, sig, JNI_FALSE);
+}
+
+/*
+ * Make sure we are accessing a real field
+ */
+#ifdef CVM_DEBUG
+static void 
+CVMjniSanityCheckFieldAccess(JNIEnv* env, jobject jobj, jfieldID jfb)
+{
+    CVMClassBlock* objCb;
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+
+    /* Simple checks */
+    CVMassert(jobj != NULL);
+    CVMassert(jfb != NULL);
+    CVMassert(!CVMfbIs(jfb, STATIC));
+    /* Also make sure that the object class is a subclass of the
+       field class */
+    CVMID_objectGetClass(ee, jobj, objCb);
+    CVMassert(CVMisSubclassOf(ee, objCb, CVMfbClassBlock(jfb)));
+}
+#else
+#define CVMjniSanityCheckFieldAccess(env, jobj, jfb)
+#endif
+
+#define CVM_DEFINE_JNI_FIELD_GETTER_AND_SETTER(jType_, elemType_,	\
+					       wideType_)		\
+jType_ JNICALL								\
+CVMjniGet##elemType_##Field(JNIEnv* env, jobject obj, jfieldID fid)	\
+{									\
+    CVMExecEnv* ee  = CVMjniEnv2ExecEnv(env);				\
+    jType_      retVal;							\
+									\
+    CVMjniSanityCheckFieldAccess(env, obj, fid);			\
+    CVMID_fieldRead##wideType_(ee, obj, CVMfbOffset(fid), retVal);     	\
+    return retVal;							\
+}									\
+									\
+void JNICALL								\
+CVMjniSet##elemType_##Field(JNIEnv* env, jobject obj, 			\
+			    jfieldID fid, jType_ rhs)			\
+{									\
+    CVMExecEnv* ee  = CVMjniEnv2ExecEnv(env);				\
+									\
+    CVMjniSanityCheckFieldAccess(env, obj, fid);			\
+    CVMID_fieldWrite##wideType_(ee, obj, CVMfbOffset(fid), rhs);       	\
+}
+
+CVM_DEFINE_JNI_FIELD_GETTER_AND_SETTER(jboolean, Boolean, Int)
+CVM_DEFINE_JNI_FIELD_GETTER_AND_SETTER(jchar,    Char,    Int)
+CVM_DEFINE_JNI_FIELD_GETTER_AND_SETTER(jshort,   Short,   Int)
+CVM_DEFINE_JNI_FIELD_GETTER_AND_SETTER(jfloat,   Float,   Float)
+CVM_DEFINE_JNI_FIELD_GETTER_AND_SETTER(jbyte,    Byte,    Int)
+CVM_DEFINE_JNI_FIELD_GETTER_AND_SETTER(jint,     Int,     Int)
+
+/*
+ * The reference version is slightly different, so don't use above
+ * macro.
+ */
+jobject JNICALL
+CVMjniGetObjectField(JNIEnv* env, jobject obj, jfieldID fid)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMObjectICell* resultCell = CVMjniCreateLocalRef(ee);
+    if (resultCell == NULL) {
+	return NULL;
+    }
+
+    CVMjniSanityCheckFieldAccess(env, obj, fid);
+    CVMID_fieldReadRef(ee, obj, CVMfbOffset(fid), resultCell);
+    /* Don't return ICells containing NULL */
+    if (CVMID_icellIsNull(resultCell)) {
+	CVMjniDeleteLocalRef(env, resultCell);
+	resultCell = NULL;
+    }
+    return resultCell;
+}
+
+void JNICALL
+CVMjniSetObjectField(JNIEnv* env, jobject obj, jfieldID fid, jobject rhs)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMjniSanityCheckFieldAccess(env, obj, fid);
+    CVMID_fieldWriteRef(ee, obj, CVMfbOffset(fid), 
+			CVMjniNonNullICellPtrFor(rhs));
+}
+
+#define CVM_DEFINE_JNI_64BIT_FIELD_GETTER_AND_SETTER(jType_, elemType_)	\
+									\
+jType_ JNICALL								\
+CVMjniGet##elemType_##Field(JNIEnv* env, jobject obj, jfieldID fid)	\
+{									\
+    CVMExecEnv* ee  = CVMjniEnv2ExecEnv(env);				\
+    jType_ v64;								\
+    CVMFieldBlock* fb = (CVMFieldBlock*)fid;				\
+									\
+    CVMjniSanityCheckFieldAccess(env, obj, fid);			\
+    if (CVMfbIs(fb, VOLATILE)) {					\
+	CVM_ACCESS_VOLATILE_LOCK(ee);					\
+    }									\
+    CVMID_fieldRead##elemType_(ee, obj, CVMfbOffset(fid), v64);		\
+    if (CVMfbIs(fb, VOLATILE)) {					\
+	CVM_ACCESS_VOLATILE_UNLOCK(ee);					\
+    }									\
+    return v64;								\
+}									\
+									\
+void JNICALL								\
+CVMjniSet##elemType_##Field(JNIEnv* env, jobject obj, 			\
+			    jfieldID fid, jType_ rhs)			\
+{									\
+    CVMExecEnv* ee  = CVMjniEnv2ExecEnv(env);				\
+    CVMFieldBlock* fb = (CVMFieldBlock*)fid;				\
+    CVMjniSanityCheckFieldAccess(env, obj, fid);			\
+    if (CVMfbIs(fb, VOLATILE)) {					\
+	CVM_ACCESS_VOLATILE_LOCK(ee);					\
+    }									\
+    CVMID_fieldWrite##elemType_(ee, obj, CVMfbOffset(fid), rhs);       	\
+    if (CVMfbIs(fb, VOLATILE)) {					\
+	CVM_ACCESS_VOLATILE_UNLOCK(ee);					\
+    }									\
+}
+
+CVM_DEFINE_JNI_64BIT_FIELD_GETTER_AND_SETTER(jlong,   Long)
+CVM_DEFINE_JNI_64BIT_FIELD_GETTER_AND_SETTER(jdouble, Double)
+
+/* Static fields */
+
+#ifdef CVM_DEBUG_ASSERTS
+static CVMBool 
+CVMisInnerClassOf(CVMExecEnv* ee, CVMClassBlock* icb, CVMClassBlock* fcb)
+{
+    CVMClassBlock* outerClassBlock;
+    CVMUint16 outerIdx = 0;
+    int i = 0;
+
+    if (CVMcbInnerClassesInfoCount(icb) == 0) {
+        return CVM_FALSE;
+    } else { 
+        CVMConstantPool* cp = CVMcbConstantPool(icb);
+        for (i=0; i<CVMcbInnerClassesInfoCount(icb); i++) {
+            outerIdx = CVMcbInnerClassInfo(icb, i)->outerClassIndex;
+            /* This cannot happen -- the outer class entry must
+	       be resolved */
+            CVMassert(CVMcpCheckResolvedAndGetTID(ee, icb, cp, 
+						  outerIdx, NULL));
+            outerClassBlock = CVMcpGetCb(cp, outerIdx);
+            if (outerClassBlock == fcb) {
+                return CVM_TRUE;
+            }
+        }
+    }
+    return CVM_FALSE;
+}
+#endif /* end of CVM_DEBUG_ASSERTS */
+
+/*
+ * Make sure we are accessing a real field
+ */
+#ifdef CVM_DEBUG_ASSERTS
+static void
+CVMjniSanityCheckStaticFieldAccess(JNIEnv* env, jclass clazz, jfieldID jfb)
+{
+    CVMClassBlock* cb;
+    CVMExecEnv* ee  = CVMjniEnv2ExecEnv(env);
+    CVMClassBlock* fcb = CVMfbClassBlock(jfb);
+    
+    /* Simple checks */
+    CVMassert(clazz != NULL);
+    CVMassert(jfb != NULL);
+    CVMassert(CVMfbIs(jfb, STATIC));
+
+    /* Also make sure that clazz is the same as or a subclass of the
+       field class or inner class of the field class */
+     cb = CVMjniGcSafeRef2Class(ee, clazz);
+     CVMassert(CVMisSubclassOf(ee, cb, fcb) || CVMisInnerClassOf(ee, cb, fcb));
+   
+}
+#else
+#define CVMjniSanityCheckStaticFieldAccess(env, jobj, jfb)
+#endif
+
+#define CVM_DEFINE_JNI_STATIC_GETTER_AND_SETTER(jType_, elemType_,	\
+					       unionField_)		\
+jType_ JNICALL								\
+CVMjniGetStatic##elemType_##Field(JNIEnv* env, 				\
+                                  jclass clazz, jfieldID fid)		\
+{									\
+    CVMExecEnv* ee  = CVMjniEnv2ExecEnv(env);				\
+    jType_ retVal;							\
+									\
+    CVMjniSanityCheckStaticFieldAccess(env, clazz, fid);		\
+    CVMD_gcUnsafeExec(ee, {						\
+        retVal = CVMfbStaticField(ee, fid).unionField_;			\
+    });									\
+    return retVal;							\
+}									\
+									\
+void JNICALL								\
+CVMjniSetStatic##elemType_##Field(JNIEnv* env, jclass clazz,		\
+			          jfieldID fid, jType_ rhs)		\
+{									\
+    CVMExecEnv* ee  = CVMjniEnv2ExecEnv(env);				\
+									\
+    CVMjniSanityCheckStaticFieldAccess(env, clazz, fid);		\
+    CVMD_gcUnsafeExec(ee, {						\
+        CVMfbStaticField(ee, fid).unionField_ = rhs;			\
+    });									\
+}
+
+CVM_DEFINE_JNI_STATIC_GETTER_AND_SETTER(jboolean, Boolean, i)
+CVM_DEFINE_JNI_STATIC_GETTER_AND_SETTER(jchar,    Char,    i)
+CVM_DEFINE_JNI_STATIC_GETTER_AND_SETTER(jshort,   Short,   i)
+CVM_DEFINE_JNI_STATIC_GETTER_AND_SETTER(jfloat,   Float,   f)
+CVM_DEFINE_JNI_STATIC_GETTER_AND_SETTER(jbyte,    Byte,    i)
+CVM_DEFINE_JNI_STATIC_GETTER_AND_SETTER(jint,     Int,     i)
+
+/*
+ * The reference versions are slightly different, so don't use above
+ * macro.
+ */
+jobject JNICALL
+CVMjniGetStaticObjectField(JNIEnv* env, jclass clazz, jfieldID fid)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMObjectICell* resultCell;
+
+
+    CVMjniSanityCheckStaticFieldAccess(env, clazz, fid);
+
+    /* Don't return ICells containing NULL */
+    if (CVMID_icellIsNull(&CVMfbStaticField(ee, fid).r)) {
+	return NULL;
+    }
+
+    resultCell = CVMjniCreateLocalRef(ee);
+    if (resultCell == NULL) {
+	return NULL;
+    }
+
+    CVMD_gcUnsafeExec(ee, {
+        CVMID_icellAssignDirect(ee,
+				resultCell,
+				&CVMfbStaticField(ee, fid).r);
+    });
+    return resultCell;
+}
+
+void JNICALL
+CVMjniSetStaticObjectField(JNIEnv* env, jclass clazz, jfieldID fid,
+			   jobject rhs)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMjniSanityCheckStaticFieldAccess(env, clazz, fid);
+    CVMD_gcUnsafeExec(ee, {
+        CVMID_icellAssignDirect(ee,
+				&CVMfbStaticField(ee, fid).r,
+				CVMjniNonNullICellPtrFor(rhs));
+    });
+}
+
+#define CVM_DEFINE_JNI_64BIT_STATIC_GETTER_AND_SETTER(jType_, 		\
+                                                     elemType_,		\
+                                                     elemType2_)	\
+jType_ JNICALL								\
+CVMjniGetStatic##elemType_##Field(JNIEnv* env, 				\
+                                  jclass clazz, jfieldID fid)		\
+{									\
+    CVMExecEnv* ee  = CVMjniEnv2ExecEnv(env);				\
+    jType_ v64;								\
+									\
+    CVMjniSanityCheckStaticFieldAccess(env, clazz, fid);		\
+    CVMD_gcUnsafeExec(ee, {						\
+        CVMFieldBlock* fb = (CVMFieldBlock*)fid;			\
+	if (CVMfbIs(fb, VOLATILE)) {				        \
+	    CVM_ACCESS_VOLATILE_LOCK(ee);				\
+	}								\
+	v64 = CVMjvm2##elemType_(&CVMfbStaticField(ee, fid).raw);	\
+	if (CVMfbIs(fb, VOLATILE)) {					\
+	    CVM_ACCESS_VOLATILE_UNLOCK(ee);				\
+	}								\
+    });									\
+    return v64;								\
+}									\
+									\
+void JNICALL								\
+CVMjniSetStatic##elemType_##Field(JNIEnv* env, jclass clazz,		\
+			          jfieldID fid, jType_ rhs)		\
+{									\
+    CVMExecEnv* ee  = CVMjniEnv2ExecEnv(env);				\
+    CVMjniSanityCheckStaticFieldAccess(env, clazz, fid);		\
+    CVMD_gcUnsafeExec(ee, {						\
+	CVMFieldBlock* fb = (CVMFieldBlock*)fid;			\
+	if (CVMfbIs(fb, VOLATILE)) {				        \
+	    CVM_ACCESS_VOLATILE_LOCK(ee);				\
+	}								\
+	CVM##elemType2_##2Jvm(&CVMfbStaticField(ee, fid).raw, rhs);	\
+	if (CVMfbIs(fb, VOLATILE)) {					\
+	    CVM_ACCESS_VOLATILE_UNLOCK(ee);				\
+	}								\
+    });									\
+}
+
+CVM_DEFINE_JNI_64BIT_STATIC_GETTER_AND_SETTER(jlong,   Long,   long)
+CVM_DEFINE_JNI_64BIT_STATIC_GETTER_AND_SETTER(jdouble, Double, double)
+
+jobject JNICALL
+CVMjniAllocObject(JNIEnv *env, jclass clazz)
+{
+    CVMExecEnv*     ee = CVMjniEnv2ExecEnv(env);
+    CVMObjectICell* resultCell;
+    CVMClassBlock*  cb = CVMjniGcSafeRef2Class(ee, clazz);
+
+    resultCell = CVMjniCreateLocalRef(ee);
+    if (resultCell == NULL) {
+	return NULL;
+    }
+
+    if (CVMcbIs(cb,INTERFACE) || CVMcbIs(cb,ABSTRACT)) {
+	CVMthrowInstantiationException(ee, "%C", cb);
+    } else if (!CVMcbCheckRuntimeFlag(cb, LINKED) &&
+	       !CVMclassLink(ee,cb, CVM_FALSE)) {
+	/* exception already thrown */
+    } else {
+	CVMD_gcUnsafeExec(ee, {
+	    CVMObject* obj = NULL;
+	    obj = CVMgcAllocNewInstance(ee, cb);
+	    if (obj == NULL) {
+		CVMthrowOutOfMemoryError(ee, NULL);
+	    } else {
+		CVMID_icellSetDirect(ee, resultCell, obj);
+	    }
+	});
+    }
+    
+    /* Free the localref if we didn't allocate an object. */
+    if (CVMID_icellIsNull(resultCell)) {
+	CVMjniDeleteLocalRef(env, resultCell);
+	resultCell = NULL;
+    }
+    return resultCell;
+}
+
+static jobject
+CVMjniConstruct(JNIEnv *env, jclass clazz, jmethodID methodID,
+	        JNI_PushArguments_t pushArguments, const void *args)
+{
+#ifndef JAVASE
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+#endif
+    jobject result;
+    CVMMethodBlock *mb = methodID;
+
+    result = CVMjniAllocObject(env, clazz);
+
+    if (result == NULL) {
+        return NULL;
+    }
+
+    if (!CVMtypeidIsConstructor(CVMmbNameAndTypeID(mb))) {
+        CVMjniFatalError(env, "a non-constructor passed to NewObject");
+    }
+#ifndef JAVASE
+    if (CVMmbClassBlock(mb) != CVMjniGcSafeRef2Class(ee, clazz)) {
+	CVMjniFatalError(env, "wrong method ID passed to NewObject");
+    }
+#endif
+
+#ifdef JDK12
+    CVMjniInvoke(env, result, methodID, pushArguments, args,
+		 CVM_INVOKE_VIRTUAL | CVM_TYPEID_VOID, NULL);
+#else
+    CVMjniInvoke(env, result, methodID, pushArguments, args,
+		 CVM_INVOKE_NONVIRTUAL | CVM_TYPEID_VOID, NULL);
+#endif
+
+    if (CVMjniExceptionCheck(env)) {
+	CVMjniDeleteLocalRef(env, result);
+	return NULL;
+    }
+    return result;
+}
+
+typedef struct {
+    va_list args;
+} CVMVaList;
+
+jobject JNICALL
+CVMjniNewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...)
+{
+    jobject result;
+    CVMVaList v;
+    va_start(v.args, methodID);
+    result = CVMjniConstruct(env, clazz, methodID, CVMjniPushArgumentsVararg,
+			     &v);
+    va_end(v.args);
+    return result;
+}
+
+jobject JNICALL
+CVMjniNewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID,
+		 const jvalue *args)
+{
+    return CVMjniConstruct(env, clazz, methodID, CVMjniPushArgumentsArray,
+			   args);
+}
+
+jobject JNICALL
+CVMjniNewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args)
+{
+    CVMVaList v;
+    jobject result;
+    va_copy(v.args, args);
+    result = CVMjniConstruct(env, clazz, methodID, CVMjniPushArgumentsVararg,
+			    &v);
+    va_end(v.args);
+    return result;
+}
+
+
+jclass JNICALL
+CVMjniGetObjectClass(JNIEnv *env, jobject obj)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMClassBlock *cb;
+    CVMID_objectGetClass(ee, obj, cb);
+    return CVMjniNewLocalRef(env, CVMcbJavaInstance(cb));
+}
+
+jboolean JNICALL
+CVMjniIsSameObject(JNIEnv *env, jobject ref1, jobject ref2)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    jboolean res;
+    jobject nonnullRef1 = CVMjniNonNullICellPtrFor(ref1);
+    jobject nonnullRef2 = CVMjniNonNullICellPtrFor(ref2);
+    CVMID_icellSameObject(ee, nonnullRef1, nonnullRef2, res);
+    return res;
+}
+
+jboolean JNICALL
+CVMjniIsInstanceOf(JNIEnv* env, jobject obj, jclass clazz)
+{
+    if (obj == NULL) {
+	return JNI_TRUE;
+    } else {
+	CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+	CVMBool     retVal;
+	CVMD_gcUnsafeExec(ee, {
+	    CVMClassBlock* cb = CVMjniGcUnsafeRef2Class(ee, clazz);
+	    CVMObject* directObj = CVMID_icellDirect(ee, obj);
+	    retVal = CVMgcUnsafeIsInstanceOf(ee, directObj, cb);
+	});
+	return retVal;
+    }
+}
+
+/*
+ * Array related operations
+ *
+ * Define CVMjni{Get,Set}<PrimitiveType>ArrayRegion() functions 
+ * (16 total)
+ */
+#define CVM_DEFINE_JNI_ARRAY_REGION_ACCESSORS(arrType, jelemType, nativeType) \
+void JNICALL								   \
+CVMjniGet##jelemType##ArrayRegion(JNIEnv *env, arrType array, jsize start, \
+				  jsize len, nativeType *buf)		   \
+{									   \
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);				   \
+    CVMD_gcUnsafeExec(ee, {						   \
+	CVMArrayOf##jelemType* directArray =				   \
+	    (CVMArrayOf##jelemType*)CVMID_icellDirect(ee, array);	   \
+	CVMUint32 arrLen = CVMD_arrayGetLength(directArray);		   \
+									   \
+	/*								   \
+	 * Make sure the java-side array and the passed in buffer    	   \
+	 * have the same size elements.					   \
+	 */								   \
+        /* NOTE:							   \
+	 * In case of 64 bit the following assert can not be used          \
+	 * because for jlong the arrayElemSize is 16 and sizeof jlong is   \
+	 * 8 byte.                                                         \
+	 */								   \
+	CVMassert(CVMarrayElemSize(CVMobjectGetClass(directArray)) == 	   \
+		  sizeof(nativeType));					   \
+	/* Check for bounds and copy */					   \
+	if ((start >= 0) && (len >= 0) && 				   \
+	    ((CVMUint32)start + (CVMUint32)len <= arrLen)) {		   \
+            CVMD_arrayReadBody##jelemType(buf, directArray, start, len);   \
+	} else {							   \
+	    CVMthrowArrayIndexOutOfBoundsException(ee, NULL);		   \
+	}								   \
+    });									   \
+}									   \
+void JNICALL								   \
+CVMjniSet##jelemType##ArrayRegion(JNIEnv *env, arrType array, jsize start, \
+				 jsize len, const nativeType *buf)	   \
+{									   \
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);				   \
+    CVMD_gcUnsafeExec(ee, {						   \
+	CVMArrayOf##jelemType* directArray =				   \
+	    (CVMArrayOf##jelemType*)CVMID_icellDirect(ee, array);	   \
+	CVMUint32 arrLen = CVMD_arrayGetLength(directArray);		   \
+									   \
+	/*								   \
+	 * Make sure the java-side array and the passed in buffer    	   \
+	 * have the same size elements.					   \
+	 */								   \
+        /* NOTE:                                                           \
+	 * In case of 64 bit the following assert can not be used          \
+	 * because for jlong the arrayElemSize is 16 and sizeof jlong is   \
+	 * 8 byte.                                                         \
+	 */                                                                \
+	CVMassert(CVMarrayElemSize(CVMobjectGetClass(directArray)) == 	   \
+		  sizeof(nativeType));					   \
+	/* Check for bounds and copy */					   \
+	if ((start >= 0) && (len >= 0) && 				   \
+	    ((CVMUint32)start + (CVMUint32)len <= arrLen)) {		   \
+            CVMD_arrayWriteBody##jelemType(buf, directArray, start, len);  \
+	} else {							   \
+	    CVMthrowArrayIndexOutOfBoundsException(ee, NULL);		   \
+	}								   \
+    });									   \
+}									   \
+
+CVM_DEFINE_JNI_ARRAY_REGION_ACCESSORS(jbooleanArray, Boolean, jboolean)
+CVM_DEFINE_JNI_ARRAY_REGION_ACCESSORS(jbyteArray,    Byte,    jbyte)
+CVM_DEFINE_JNI_ARRAY_REGION_ACCESSORS(jcharArray,    Char,    jchar)
+CVM_DEFINE_JNI_ARRAY_REGION_ACCESSORS(jshortArray,   Short,   jshort)
+CVM_DEFINE_JNI_ARRAY_REGION_ACCESSORS(jintArray,     Int,     jint)
+CVM_DEFINE_JNI_ARRAY_REGION_ACCESSORS(jfloatArray,   Float,   jfloat)
+CVM_DEFINE_JNI_ARRAY_REGION_ACCESSORS(jlongArray,    Long,    jlong)
+CVM_DEFINE_JNI_ARRAY_REGION_ACCESSORS(jdoubleArray,  Double,  jdouble)
+
+#define CVM_DEFINE_JNI_ARRAY_ELEMENTS_ACCESSORS(arrType, jelemType, nativeType) \
+nativeType* JNICALL							   \
+CVMjniGet##jelemType##ArrayElements(JNIEnv *env, arrType array,		   \
+                                    jboolean *isCopy)			   \
+{									   \
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);				   \
+    CVMJavaInt  arrLen;							   \
+    nativeType* buf;							   \
+    CVMArrayOf##jelemType##ICell* arrayCell = 				   \
+        (CVMArrayOf##jelemType##ICell*)array;				   \
+									   \
+    CVMID_arrayGetLength(ee, arrayCell, arrLen);			   \
+    buf = (nativeType*)malloc(arrLen * sizeof(nativeType));		   \
+    if (buf == NULL) {							   \
+	CVMthrowOutOfMemoryError(ee, NULL);    				   \
+        return NULL;							   \
+    }									   \
+    if (isCopy != NULL) {						   \
+        *isCopy = JNI_TRUE;						   \
+    }								   	   \
+    CVMD_gcUnsafeExec(ee, {						   \
+	CVMArrayOf##jelemType* directArray =				   \
+	    (CVMArrayOf##jelemType*)CVMID_icellDirect(ee, array);	   \
+									   \
+	/*								   \
+	 * Make sure the java-side array and the passed in buffer    	   \
+	 * have the same size elements.					   \
+	 */								   \
+        /* NOTE:							   \
+	 * In case of 64 bit the following assert can not be used          \
+	 * because for jlong the arrayElemSize is 16 and sizeof jlong is   \
+	 * 8 byte.                                                         \
+	 */                                                                \
+	CVMassert(CVMarrayElemSize(CVMobjectGetClass(directArray)) ==      \
+		  sizeof(nativeType));					   \
+        CVMD_arrayReadBody##jelemType(buf, directArray, 0, arrLen);	   \
+    });									   \
+    return buf;								   \
+}									   \
+									   \
+void JNICALL							   	   \
+CVMjniRelease##jelemType##ArrayElements(JNIEnv *env, arrType array,	   \
+                                        nativeType* buf, jint mode)   	   \
+{									   \
+    CVMExecEnv* ee;							   \
+    if (mode == JNI_ABORT) {						   \
+        free(buf);						   	   \
+	return;								   \
+    }									   \
+    ee = CVMjniEnv2ExecEnv(env);				   	   \
+    CVMD_gcUnsafeExec(ee, {						   \
+	CVMArrayOf##jelemType* directArray =				   \
+	    (CVMArrayOf##jelemType*)CVMID_icellDirect(ee, array);	   \
+	CVMUint32 arrLen = CVMD_arrayGetLength(directArray);		   \
+									   \
+	/*								   \
+	 * Make sure the java-side array and the passed in buffer    	   \
+	 * have the same size elements.					   \
+	 */								   \
+        /* NOTE:                                                           \
+	 * in case of 64 bit the following assert can not be used          \
+	 * because for jlong the arrayElemSize is 16 and sizeof jlong is   \
+	 * 8 byte.                                                         \
+	 */                                                                \
+	CVMassert(CVMarrayElemSize(CVMobjectGetClass(directArray)) == \
+		  sizeof(nativeType));					   \
+        CVMD_arrayWriteBody##jelemType(buf, directArray, 0, arrLen);	   \
+    });									   \
+    if (mode != JNI_COMMIT) {						   \
+        CVMassert(mode == 0);						   \
+        free(buf);						   	   \
+    }									   \
+}									   \
+
+CVM_DEFINE_JNI_ARRAY_ELEMENTS_ACCESSORS(jbooleanArray, Boolean, jboolean)
+CVM_DEFINE_JNI_ARRAY_ELEMENTS_ACCESSORS(jbyteArray,    Byte,    jbyte)
+CVM_DEFINE_JNI_ARRAY_ELEMENTS_ACCESSORS(jcharArray,    Char,    jchar)
+CVM_DEFINE_JNI_ARRAY_ELEMENTS_ACCESSORS(jshortArray,   Short,   jshort)
+CVM_DEFINE_JNI_ARRAY_ELEMENTS_ACCESSORS(jintArray,     Int,     jint)
+CVM_DEFINE_JNI_ARRAY_ELEMENTS_ACCESSORS(jfloatArray,   Float,   jfloat)
+CVM_DEFINE_JNI_ARRAY_ELEMENTS_ACCESSORS(jlongArray,    Long,    jlong)
+CVM_DEFINE_JNI_ARRAY_ELEMENTS_ACCESSORS(jdoubleArray,  Double,  jdouble)
+
+/*
+ * The conditionally copying versions of
+ * CVMjni{Get,Release}PrimitiveArrayCritical().
+ */
+
+static CVMBool
+mustCopy(CVMBasicType base)
+{
+#ifdef CVMGC_HAS_NONREF_BARRIERS
+    return CVM_TRUE;   /* always copy if there are gc barriers */
+#else
+#ifndef CAN_DO_UNALIGNED_DOUBLE_ACCESS
+    if (base == CVM_T_DOUBLE) {
+	return CVM_TRUE; /* copy if we can't do unaligned double access */
+    }
+#endif
+#ifndef CAN_DO_UNALIGNED_INT64_ACCESS
+    if (base == CVM_T_LONG) {
+	return CVM_TRUE; /* copy if we can't do unaligned long long access */
+    }
+#endif
+    return CVM_FALSE;
+#endif
+}
+
+void* JNICALL
+CVMjniGetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy)
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+    CVMJavaInt  arrLen;
+    void*       buf = NULL;  /* avoid compiler warning */
+    CVMClassBlock*       arrayCb;
+    CVMBasicType         base;
+    CVMArrayOfAnyType*  directArray;
+
+    /*
+     * Become gcUnsafe and stay that way until outermost 
+     * CVMjniReleasePrimitiveArrayCritical call is made.
+     */
+    CVMD_gcEnterCriticalRegion(ee);
+
+    directArray = (CVMArrayOfAnyType*)CVMID_icellDirect(ee, array);
+    arrayCb = CVMobjectGetClass((CVMObject*)directArray);
+    arrLen = CVMD_arrayGetLength(directArray);
+    base = CVMarrayBaseType(arrayCb);
+
+    /*
+     * This had better be an array of primitives
+     */
+    CVMassert(base != CVM_T_CLASS);
+    CVMassert(CVMarrayDepth(arrayCb) == 1);
+
+    /*
+     * If there is no requirement that we copy the array, then just return
+     * the pointer to it.
+     */
+    if (!mustCopy(base)) {
+	buf = (void*)&directArray->elems;
+	if (isCopy != NULL) {
+	    *isCopy = JNI_FALSE;
+	}
+	return buf;
+    }
+
+    /*
+     * The rest of this function is only needed if there is a possible case
+     * that will require copying the array.
+     */  
+#if defined(CVMGC_HAS_NONREF_BARRIERS) ||	\
+    !defined(CAN_DO_UNALIGNED_DOUBLE_ACCESS) ||	\
+    !defined(CAN_DO_UNALIGNED_INT64_ACCESS)
+
+    buf = malloc(arrLen * CVMarrayElemSize(arrayCb));
+    if (buf == NULL) {
+	CVMD_gcExitCriticalRegion(ee);
+	CVMthrowOutOfMemoryError(ee, NULL);
+        return NULL;
+    }
+    if (isCopy != NULL) {
+	*isCopy = JNI_TRUE;
+    }
+
+    /* %comment rt015 */
+    switch(base) {
+#ifdef CVMGC_HAS_NONREF_BARRIERS
+        case CVM_T_BOOLEAN: {
+	    CVMArrayOfBoolean* dirArr = (CVMArrayOfBoolean*)directArray;
+	    CVMD_arrayReadBodyBoolean(buf, dirArr, 0, arrLen);
+	    break;
+	}
+        case CVM_T_INT: {
+	    CVMArrayOfInt* dirArr = (CVMArrayOfInt*)directArray;
+	    CVMD_arrayReadBodyInt(buf, dirArr, 0, arrLen);
+	    break;
+	}
+        case CVM_T_FLOAT: {
+	    CVMArrayOfFloat* dirArr = (CVMArrayOfFloat*)directArray;
+	    CVMD_arrayReadBodyFloat(buf, dirArr, 0, arrLen);
+	    break;
+	}
+        case CVM_T_BYTE: {
+	    CVMArrayOfByte* dirArr = (CVMArrayOfByte*)directArray;
+	    CVMD_arrayReadBodyByte(buf, dirArr, 0, arrLen);
+	    break;
+	}
+        case CVM_T_CHAR: {
+	    CVMArrayOfChar* dirArr = (CVMArrayOfChar*)directArray;
+	    CVMD_arrayReadBodyChar(buf, dirArr, 0, arrLen);
+	    break;
+	}
+        case CVM_T_SHORT: {
+	    CVMArrayOfShort* dirArr = (CVMArrayOfShort*)directArray;
+	    CVMD_arrayReadBodyShort(buf, dirArr, 0, arrLen);
+	    break;
+	}
+#endif
+#if defined(CVMGC_HAS_NONREF_BARRIERS) || \
+    !defined(CAN_DO_UNALIGNED_INT64_ACCESS)
+        case CVM_T_LONG: {
+	    CVMArrayOfLong* dirArr = (CVMArrayOfLong*)directArray;
+	    CVMD_arrayReadBodyLong(buf, dirArr, 0, arrLen);
+	    break;
+	}
+#endif
+#if defined(CVMGC_HAS_NONREF_BARRIERS) || \
+    !defined(CAN_DO_UNALIGNED_DOUBLE_ACCESS)
+        case CVM_T_DOUBLE: {
+	    CVMArrayOfDouble* dirArr = (CVMArrayOfDouble*)directArray;
+	    CVMD_arrayReadBodyDouble(buf, dirArr, 0, arrLen);
+	    break;
+	}
+#endif
+        default: CVMassert(CVM_FALSE); /* can't happen */
+    }
+#endif
+    CVMassert(buf != NULL);
+    return buf;
+}
+
+void JNICALL
+CVMjniReleasePrimitiveArrayCritical(JNIEnv *env, jarray array,
+				    void* buf, jint mode)
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+    CVMJavaInt  arrLen;
+    CVMClassBlock*       arrayCb;
+    CVMBasicType         base;
+    CVMArrayOfAnyType*  directArray;
+
+    directArray = (CVMArrayOfAnyType*)CVMID_icellDirect(ee, array);
+    arrayCb = CVMobjectGetClass((CVMObject*)directArray);
+    arrLen = CVMD_arrayGetLength(directArray);
+    base = CVMarrayBaseType(arrayCb);
+
+    /*
+     * This had better be an array of primitives
+     */
+    CVMassert(base != CVM_T_CLASS);
+    CVMassert(CVMarrayDepth(arrayCb) == 1);
+
+    if (!mustCopy(base)) {
+	if (mode != JNI_COMMIT) {
+	    /* become gcSafe again if this is the outmost call */
+	    CVMD_gcExitCriticalRegion(ee);
+	}
+	return;
+    }
+
+    /*
+     * The following is only needed if there is a possible case
+     * that will require copying the array.
+     */  
+#if defined(CVMGC_HAS_NONREF_BARRIERS) ||	\
+    !defined(CAN_DO_UNALIGNED_DOUBLE_ACCESS) ||	\
+    !defined(CAN_DO_UNALIGNED_INT64_ACCESS)
+
+    if (mode == JNI_ABORT) {
+	free(buf);
+	/* become gcSafe again if this is the outmost call */
+	CVMD_gcExitCriticalRegion(ee);
+	return;
+    }
+
+    /* %comment rt015 */
+    switch(base) {
+#ifdef CVMGC_HAS_NONREF_BARRIERS
+        case CVM_T_BOOLEAN: {
+	    CVMArrayOfBoolean* dirArr = (CVMArrayOfBoolean*)directArray;
+	    CVMD_arrayWriteBodyBoolean(buf, dirArr, 0, arrLen);
+	    break;
+	}
+        case CVM_T_INT: {
+	    CVMArrayOfInt* dirArr = (CVMArrayOfInt*)directArray;
+	    CVMD_arrayWriteBodyInt(buf, dirArr, 0, arrLen);
+	    break;
+	}
+        case CVM_T_FLOAT: {
+	    CVMArrayOfFloat* dirArr = (CVMArrayOfFloat*)directArray;
+	    CVMD_arrayWriteBodyFloat(buf, dirArr, 0, arrLen);
+	    break;
+	}
+        case CVM_T_BYTE: {
+	    CVMArrayOfByte* dirArr = (CVMArrayOfByte*)directArray;
+	    CVMD_arrayWriteBodyByte(buf, dirArr, 0, arrLen);
+	    break;
+	}
+        case CVM_T_CHAR: {
+	    CVMArrayOfChar* dirArr = (CVMArrayOfChar*)directArray;
+	    CVMD_arrayWriteBodyChar(buf, dirArr, 0, arrLen);
+	    break;
+	}
+        case CVM_T_SHORT: {
+	    CVMArrayOfShort* dirArr = (CVMArrayOfShort*)directArray;
+	    CVMD_arrayWriteBodyShort(buf, dirArr, 0, arrLen);
+	    break;
+	}
+#endif
+#if defined(CVMGC_HAS_NONREF_BARRIERS) || \
+    !defined(CAN_DO_UNALIGNED_INT64_ACCESS)
+        case CVM_T_LONG: {
+	    CVMArrayOfLong* dirArr = (CVMArrayOfLong*)directArray;
+	    CVMD_arrayWriteBodyLong(buf, dirArr, 0, arrLen);
+	    break;
+	}
+#endif
+#if defined(CVMGC_HAS_NONREF_BARRIERS) || \
+    !defined(CAN_DO_UNALIGNED_DOUBLE_ACCESS)
+        case CVM_T_DOUBLE: {
+	    CVMArrayOfDouble* dirArr = (CVMArrayOfDouble*)directArray;
+	    CVMD_arrayWriteBodyDouble(buf, dirArr, 0, arrLen);
+	    break;
+	}
+#endif
+        default: CVMassert(CVM_FALSE); /* can't happen */
+    }
+
+    if (mode != JNI_COMMIT) {
+        CVMassert(mode == 0);
+	free(buf);
+	/* become gcSafe again if this is the outmost call */
+	CVMD_gcExitCriticalRegion(ee);
+    }
+#endif
+}
+
+#define CVM_DEFINE_JNI_ARRAY_ALLOCATOR(jType_, typeName_, typeCode_)	\
+jType_ JNICALL								\
+CVMjniNew##typeName_##Array(JNIEnv* env, jsize length)			\
+{									\
+    CVMExecEnv*     ee         = CVMjniEnv2ExecEnv(env);		\
+    CVMObjectICell* resultCell = CVMjniCreateLocalRef(ee);		\
+    CVMClassBlock*  arrayCb;						\
+									\
+    if (resultCell == NULL) {						\
+	return NULL;							\
+    }									\
+									\
+    arrayCb = (CVMClassBlock*)CVMbasicTypeArrayClassblocks[typeCode_];	\
+    CVMID_allocNewArray(ee, typeCode_, arrayCb, length, resultCell);	\
+    if (CVMID_icellIsNull(resultCell)) {				\
+        CVMjniDeleteLocalRef(env, resultCell);				\
+	CVMthrowOutOfMemoryError(ee, NULL);    				\
+	return NULL;							\
+    } else {								\
+	return resultCell;						\
+    }									\
+}									\
+
+CVM_DEFINE_JNI_ARRAY_ALLOCATOR(jbooleanArray, Boolean, CVM_T_BOOLEAN)
+CVM_DEFINE_JNI_ARRAY_ALLOCATOR(jbyteArray,    Byte,    CVM_T_BYTE)
+CVM_DEFINE_JNI_ARRAY_ALLOCATOR(jcharArray,    Char,    CVM_T_CHAR)
+CVM_DEFINE_JNI_ARRAY_ALLOCATOR(jshortArray,   Short,   CVM_T_SHORT)
+CVM_DEFINE_JNI_ARRAY_ALLOCATOR(jintArray,     Int,     CVM_T_INT)
+CVM_DEFINE_JNI_ARRAY_ALLOCATOR(jfloatArray,   Float,   CVM_T_FLOAT)
+CVM_DEFINE_JNI_ARRAY_ALLOCATOR(jlongArray,    Long,    CVM_T_LONG)
+CVM_DEFINE_JNI_ARRAY_ALLOCATOR(jdoubleArray,  Double,  CVM_T_DOUBLE)
+
+jobject JNICALL
+CVMjniGetObjectArrayElement(JNIEnv* env, jarray arrArg, jsize index)
+{
+    CVMExecEnv*     ee         = CVMjniEnv2ExecEnv(env);
+    CVMObjectICell* resultCell;
+    CVMArrayOfAnyTypeICell* array   = (CVMArrayOfAnyTypeICell*)arrArg;
+    jsize arrayLen;
+
+    CVMassert(array != NULL);
+    CVMassert(!CVMID_icellIsNull(array));
+
+    CVMID_arrayGetLength(ee, array, arrayLen);
+    if ((CVMUint32)index >= (CVMUint32)arrayLen) {
+	CVMthrowArrayIndexOutOfBoundsException(ee, NULL);
+	return NULL;
+    }
+
+    resultCell = CVMjniCreateLocalRef(ee);
+    if (resultCell == NULL) {
+	return NULL;
+    }
+
+    CVMID_arrayReadRef(ee, array, index, resultCell);
+    if (CVMID_icellIsNull(resultCell)) {
+	CVMjniDeleteLocalRef(env, resultCell);
+	return NULL;
+    } else {
+	return resultCell;
+    }
+}
+
+/*
+ * Just like 'aastore'
+ */
+void JNICALL
+CVMjniSetObjectArrayElement(JNIEnv* env, jarray arrArg,
+			    jsize index, jobject value)
+{
+    CVMExecEnv*     ee         = CVMjniEnv2ExecEnv(env);
+    CVMArrayOfAnyTypeICell* array   = (CVMArrayOfAnyTypeICell*)arrArg;
+    jsize arrayLen;
+
+    CVMassert(array != NULL);
+    CVMassert(!CVMID_icellIsNull(array));
+
+    CVMID_arrayGetLength(ee, array, arrayLen);
+    if ((CVMUint32)index >= (CVMUint32)arrayLen) {
+	CVMthrowArrayIndexOutOfBoundsException(ee, NULL);
+	return;
+    }
+
+    if ((value != NULL) && !CVMID_icellIsNull(value)) {
+	CVMBool assignmentOk;
+	CVMD_gcUnsafeExec(ee, {
+	    /* Check assignability of 'value' into 'array' */
+	    CVMClassBlock* arrayType = 
+		CVMobjectGetClass(CVMID_icellDirect(ee, array));
+	    CVMClassBlock* elemType =
+		CVMarrayElementCb(arrayType);
+	    CVMClassBlock* rhsType =
+		CVMobjectGetClass(CVMID_icellDirect(ee, value));
+
+	    if (rhsType != elemType) { /* Try a quick check first */
+		assignmentOk = CVMisAssignable(ee, rhsType, elemType);
+	    } else {
+		assignmentOk = CVM_TRUE;
+	    }
+	});
+	if (!assignmentOk) {
+	    if (!CVMlocalExceptionOccurred(ee)) {
+		CVMthrowArrayStoreException(ee, NULL);
+	    }
+	    return;
+	}
+    }
+    CVMID_arrayWriteRef(ee, array, index, CVMjniNonNullICellPtrFor(value));
+}
+
+/*
+ * Just like anewarray, except for the initialization part.
+ */
+jarray JNICALL
+CVMjniNewObjectArray(JNIEnv* env, jsize length,
+		     jclass elementClass, jobject initialElement)
+{
+    CVMExecEnv*     ee         = CVMjniEnv2ExecEnv(env);
+    CVMObjectICell* resultCell;
+    CVMClassBlock*  arrayCb;
+    CVMClassBlock*  elementClassCb = CVMjniGcSafeRef2Class(ee, elementClass);
+    
+    if (!CVMcbCheckRuntimeFlag(elementClassCb, LINKED) &&
+	!CVMclassLink(ee,elementClassCb, CVM_FALSE)) {
+	return NULL; /* exception already thrown */
+    }
+
+    arrayCb = CVMclassGetArrayOf(ee, elementClassCb);
+    if (arrayCb == NULL) {
+	return NULL; /* exception already thrown */
+    }
+
+    resultCell = CVMjniCreateLocalRef(ee);
+    if (resultCell == NULL) {
+	return NULL;
+    }
+
+    CVMID_allocNewArray(ee, CVM_T_CLASS, arrayCb, length, resultCell);
+    if (CVMID_icellIsNull(resultCell)) {
+	CVMjniDeleteLocalRef(env, resultCell);
+        CVMthrowOutOfMemoryError(ee, NULL);
+	return NULL;
+    }
+    if ((initialElement == NULL) ||
+	CVMID_icellIsNull(initialElement)) {
+	/* No need to initialize to NULL. The allocation already did that */
+	return resultCell;
+    } else {
+	/* Check for assignability before initialization */
+	CVMBool assignmentOk = CVM_TRUE;
+	CVMD_gcUnsafeExec(ee, {
+	    CVMObject* directInitObj = CVMID_icellDirect(ee, initialElement);
+	    CVMClassBlock*   rhsType = CVMobjectGetClass(directInitObj);
+	    
+	    if (rhsType != elementClassCb) { /* Try a quick check first */
+		assignmentOk = CVMisAssignable(ee, rhsType, elementClassCb);
+	    } else {
+		assignmentOk = CVM_TRUE;
+	    }
+	    if (assignmentOk) {
+		CVMArrayOfRef* refArray =
+		    (CVMArrayOfRef*)CVMID_icellDirect(ee, resultCell);
+		int i;
+
+		/* %comment: rt016 */
+		for (i = 0; i < length; i++) {
+		    CVMD_arrayWriteRef(refArray, i, directInitObj);
+		}
+	    } else {
+		CVMjniDeleteLocalRef(env, resultCell);
+		resultCell = NULL;
+		if (!CVMlocalExceptionOccurred(ee)) {
+		    CVMthrowArrayStoreException(ee, NULL);
+		}
+	    }
+	});
+	return resultCell;
+    }
+}
+
+jsize JNICALL
+CVMjniGetArrayLength(JNIEnv* env, jarray arrArg)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMArrayOfAnyTypeICell* array   = (CVMArrayOfAnyTypeICell*)arrArg;
+    jsize arrayLen;
+
+    CVMID_arrayGetLength(ee, array, arrayLen);
+    return arrayLen;
+}
+
+/*
+ * Class operations
+ */
+jclass JNICALL
+CVMjniGetSuperclass(JNIEnv* env, jclass clazz)
+{
+    CVMExecEnv*    ee = CVMjniEnv2ExecEnv(env);
+    CVMClassBlock* cb = CVMjniGcSafeRef2Class(ee, clazz);
+    CVMClassBlock* superCb;
+
+    if (CVMcbIs(cb, INTERFACE)) {
+	return NULL;
+    }
+    superCb = CVMcbSuperclass(cb);
+    if (superCb == NULL) {
+	return NULL;
+    }
+    return CVMjniNewLocalRef(env, CVMcbJavaInstance(superCb));
+}
+
+
+jboolean JNICALL
+CVMjniIsAssignableFrom(JNIEnv* env, jclass clazz1, jclass clazz2)
+{
+    CVMExecEnv*    ee = CVMjniEnv2ExecEnv(env);
+    CVMClassBlock* srcCb;
+    CVMClassBlock* dstCb;
+
+    CVMD_gcUnsafeExec(ee, {
+	srcCb = CVMjniGcUnsafeRef2Class(ee, clazz1);
+	dstCb = CVMjniGcUnsafeRef2Class(ee, clazz2);
+    });
+    return CVMisAssignable(ee, srcCb, dstCb);
+}
+
+/*
+ * Reflection operations
+ */
+
+/*
+ * NOTE: The following routines are conditionally compiled:
+ * CVMjniToReflectedMethod
+ * CVMjniToReflectedField
+ * CVMjniFromReflectedMethod
+ * CVMjniFromReflectedField
+ */
+
+#ifdef CVM_REFLECT
+
+jobject JNICALL
+CVMjniToReflectedMethod(JNIEnv *env, jclass clazz,
+			jmethodID methodID, jboolean isStatic)
+{
+    CVMExecEnv*     ee = CVMjniEnv2ExecEnv(env);
+    CVMMethodBlock* mb = (CVMMethodBlock *)methodID;
+    CVMObjectICell* resultCell; /* The resulting java.lang.reflect.Method */
+
+    resultCell = CVMjniCreateLocalRef(ee);
+    if (resultCell != NULL) {
+	CVMreflectMethodBlockToNewJavaMethod(ee, mb, resultCell);
+    }
+    return resultCell; /* Exception already thrown if resultCell == 0 */
+}
+
+jobject JNICALL
+CVMjniToReflectedField(JNIEnv *env, jclass clazz, jfieldID fieldID,
+		       jboolean isStatic)
+{
+    CVMExecEnv*     ee = CVMjniEnv2ExecEnv(env);
+    CVMFieldBlock*  fb = (CVMFieldBlock *)fieldID;
+    CVMObjectICell* resultCell; /* The resulting java.lang.reflect.Field */
+
+    resultCell = CVMjniCreateLocalRef(ee);
+    if (resultCell != NULL) {
+	CVMreflectNewJavaLangReflectField(ee, fb, resultCell);
+    }
+    return resultCell; /* Exception already thrown if resultCell == 0 */
+}
+
+jmethodID JNICALL
+CVMjniFromReflectedMethod(JNIEnv* env, jobject method)
+{
+    CVMExecEnv*     ee = CVMjniEnv2ExecEnv(env);
+    return CVMreflectGCSafeGetMethodBlock(ee, method, NULL);
+}
+
+jfieldID JNICALL
+CVMjniFromReflectedField(JNIEnv* env, jobject field)
+{
+    CVMExecEnv*     ee = CVMjniEnv2ExecEnv(env);
+    return CVMreflectGCSafeGetFieldBlock(ee, field);
+}
+
+#else
+# define CVMjniToReflectedMethod NULL
+# define CVMjniToReflectedField NULL
+# define CVMjniFromReflectedMethod NULL
+# define CVMjniFromReflectedField NULL
+#endif /* CVM_REFLECT */
+
+/*
+ * String operations
+ */
+#ifdef CVM_DEBUG
+static void
+CVMjniSanityCheckStringAccess(CVMExecEnv* ee, jstring string)
+{
+    CVMClassBlock* cb;
+    CVMassert(string != NULL);
+    CVMID_objectGetClass(ee, string, cb);
+    CVMassert(cb == CVMsystemClass(java_lang_String));
+}
+#else
+#define CVMjniSanityCheckStringAccess(ee, string)
+#endif
+
+jsize JNICALL
+CVMjniGetStringLength(JNIEnv* env, jstring string)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    jsize strLen;
+
+    CVMjniSanityCheckStringAccess(ee, string);
+    CVMID_fieldReadInt(ee, string, 
+		       CVMoffsetOfjava_lang_String_count,
+		       strLen);
+    return strLen;
+}
+
+jstring JNICALL
+CVMjniNewString(JNIEnv *env, const jchar* unicodeChars, jsize len)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMStringICell* stringICell = CVMjniCreateLocalRef(ee);
+    if (stringICell == NULL) {
+	return NULL;
+    }
+
+    CVMnewString(ee, stringICell, unicodeChars, len);
+    if (CVMID_icellIsNull(stringICell)) {
+	CVMjniDeleteLocalRef(env, stringICell);
+	CVMthrowOutOfMemoryError(ee, NULL);
+	return NULL;
+    } else {
+	return stringICell;
+    }
+}
+
+jsize JNICALL
+CVMjniGetStringUTFLength(JNIEnv *env, jstring string)
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+    jsize length;
+
+    CVMjniSanityCheckStringAccess(ee, string);
+
+    CVMID_localrootBegin(ee); {
+	CVMID_localrootDeclare(CVMArrayOfCharICell, valueICellPtr);
+	CVMObjectICell *valueAsObject = (CVMObjectICell *)valueICellPtr;
+	CVMJavaChar c;
+	CVMInt32 i, offset, len, readLen;
+
+	CVMID_fieldReadRef(ee, string, 
+			   CVMoffsetOfjava_lang_String_value,
+			   valueAsObject);
+	CVMID_fieldReadInt(ee, string, 
+			   CVMoffsetOfjava_lang_String_offset,
+			   offset);
+	CVMID_fieldReadInt(ee, string, 
+			   CVMoffsetOfjava_lang_String_count,
+			   len);
+	/*
+	 * The repeated entries to CVMD_gcUnsafeExec are
+	 * somewhat slow, but give GC a chance to
+	 * run for very long strings.
+	 */
+	length = 0;
+	while ( len > 0 ){
+	    readLen = MIN( len, MAX_CHARS_PER_ACCESS );
+	    CVMD_gcUnsafeExec(ee,{
+		CVMArrayOfChar* theChars;
+		theChars = CVMID_icellDirect(ee, valueICellPtr);
+		for ( i = 0; i < readLen; i++ ){
+		    CVMD_arrayReadChar( theChars, offset, c );
+		    /*
+		     * Because CVMunicodeChar2UtfLength is such a
+		     * trivial function (a macro actually), I don't
+		     * feel too bad about invoking it within this
+		     * unsafe section. The alternative is to copy into an
+		     * array and then iterate over it with the length
+		     * function.
+		     */
+		    length += CVMunicodeChar2UtfLength(c);
+		    offset++;
+		}
+
+	    });
+	    len -= readLen;
+	}
+    } CVMID_localrootEnd();
+    return length;
+}
+
+void JNICALL
+CVMjniGetStringRegion(JNIEnv *env,
+		      jstring string, jsize start, jsize len, jchar *buf)
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+
+    CVMjniSanityCheckStringAccess(ee, string);
+
+    CVMID_localrootBegin(ee); {
+	CVMID_localrootDeclare(CVMArrayOfCharICell, valueICellPtr);
+	CVMObjectICell *valueAsObject = (CVMObjectICell *)valueICellPtr;
+	CVMInt32 offset, str_len;
+
+	CVMID_fieldReadRef(ee, string, 
+			   CVMoffsetOfjava_lang_String_value,
+			   valueAsObject);
+	CVMID_fieldReadInt(ee, string, 
+			   CVMoffsetOfjava_lang_String_offset,
+			   offset);
+	CVMID_fieldReadInt(ee, string, 
+			   CVMoffsetOfjava_lang_String_count,
+			   str_len);
+
+	if ((start >= 0) && (len >= 0) &&
+	    ((CVMUint32)start + (CVMUint32)len <= (CVMUint32)str_len)) {
+	    CVMD_gcUnsafeExec(ee, {
+		CVMArrayOfChar* charArray =
+		    (CVMArrayOfChar*)CVMID_icellDirect(ee, valueAsObject);
+		CVMD_arrayReadBodyChar(buf, charArray, offset + start, len);
+	    });
+	} else {
+	    CVMthrowStringIndexOutOfBoundsException(ee, NULL);
+	}
+    } CVMID_localrootEnd();
+}
+
+void JNICALL
+CVMjniGetStringUTFRegion(JNIEnv *env,
+			 jstring string, jsize start, jsize len, char *buf)
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+
+    CVMjniSanityCheckStringAccess(ee, string);
+
+    CVMID_localrootBegin(ee); {
+	CVMID_localrootDeclare(CVMArrayOfCharICell, valueICellPtr);
+	CVMObjectICell *valueAsObject = (CVMObjectICell *)valueICellPtr;
+	CVMJavaChar charBuffer[MAX_CHARS_PER_ACCESS];
+	CVMInt32 offset, str_len, bufferLen;
+
+	CVMID_fieldReadRef(ee, string, 
+			   CVMoffsetOfjava_lang_String_value,
+			   valueAsObject);
+	CVMID_fieldReadInt(ee, string, 
+			   CVMoffsetOfjava_lang_String_offset,
+			   offset);
+	CVMID_fieldReadInt(ee, string, 
+			   CVMoffsetOfjava_lang_String_count,
+			   str_len);
+
+	if ((start >= 0) && (len >= 0) &&
+	    ((CVMUint32)start + (CVMUint32)len <= (CVMUint32)str_len)) {
+	    /*
+	     * This is somewhat slow, but gives GC a chance to
+	     * run for very long strings.
+	     */
+	    offset += start;
+	    while ( len > 0 ){
+		bufferLen = MIN( len, MAX_CHARS_PER_ACCESS );
+		CVMD_gcUnsafeExec(ee,{
+		    CVMArrayOfChar* theChars;
+
+		    theChars = CVMID_icellDirect(ee, valueICellPtr);
+		    CVMD_arrayReadBodyChar( charBuffer, theChars, offset, bufferLen );
+
+		});
+		buf = CVMutfCopyFromCharArray(charBuffer, buf, bufferLen);
+		len -= bufferLen;
+		offset += bufferLen;
+	    }
+	    *buf = '\0';
+	} else {
+	    CVMthrowStringIndexOutOfBoundsException(ee, NULL);
+	}
+    } CVMID_localrootEnd();
+}
+
+const char* JNICALL
+CVMjniGetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy)
+{
+    char *utf;
+    jsize strLen = CVMjniGetStringLength(env, string);
+    jsize utfLen = CVMjniGetStringUTFLength(env, string);
+
+    utf = (char *)malloc(utfLen + 1);
+    if (utf == NULL) {
+        CVMthrowOutOfMemoryError(CVMjniEnv2ExecEnv(env), NULL);
+	return NULL;
+    }
+    CVMjniGetStringUTFRegion(env, string, 0, strLen, utf);
+    if (isCopy) {
+        *isCopy = JNI_TRUE;
+    }
+    return (const char*)utf;
+}
+
+void JNICALL
+CVMjniReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars)
+{
+    free((void *)chars);
+}
+
+const jchar* JNICALL
+CVMjniGetStringChars(JNIEnv *env, jstring string, jboolean *isCopy)
+{
+    jchar *chars;
+    jsize strLen = CVMjniGetStringLength(env, string);
+    size_t allocLen = strLen;
+
+    /* Fix for 5071855. Never do malloc(0) */
+    if (allocLen == 0) {
+	allocLen = 1;
+    }
+
+    chars = (jchar *)malloc(sizeof(jchar) * allocLen);
+    if (chars == NULL) {
+        CVMthrowOutOfMemoryError(CVMjniEnv2ExecEnv(env), NULL);
+	return NULL;
+    }
+    CVMjniGetStringRegion(env, string, 0, strLen, chars);
+    if (isCopy) {
+        *isCopy = JNI_TRUE;
+    }
+    return (const jchar*)chars;
+}
+
+void JNICALL
+CVMjniReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars)
+{
+    free((void *)chars);
+}
+
+/*
+ * Constructs a new java.lang.String object from an array of UTF-8 characters. 
+ *
+ * We could avoid the temporary buffer if we copied directly into the
+ * char[], but that would require going through the indirect layer.
+ */
+jstring JNICALL
+CVMjniNewStringUTF(JNIEnv* env, const char* utf8Bytes)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMStringICell* stringICell = CVMjniCreateLocalRef(ee);
+    if (stringICell == NULL) {
+	return NULL;
+    }
+
+    CVMnewStringUTF(ee, stringICell, utf8Bytes);
+    if (CVMID_icellIsNull(stringICell)) {
+	CVMjniDeleteLocalRef(env, stringICell);
+	CVMthrowOutOfMemoryError(ee, NULL);
+	return NULL;
+    } else {
+	return stringICell;
+    }
+}
+
+jint JNICALL
+CVMjniThrow(JNIEnv *env, jthrowable obj)
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+    CVMBool     isThrowable;
+
+    CVMD_gcUnsafeExec(ee, {
+	isThrowable = CVMgcUnsafeIsInstanceOf(
+             ee, CVMID_icellDirect(ee, obj), 
+	     CVMsystemClass(java_lang_Throwable));
+    });
+    if (!isThrowable) {
+	CVMjniFatalError(env, 
+	    "throw an object that is not an instance of java/lang/Throwable");
+    }
+
+    CVMgcSafeThrowLocalException(CVMjniEnv2ExecEnv(env), obj);
+    return JNI_OK;
+}
+
+jint JNICALL
+CVMjniThrowNew(JNIEnv *env, jclass clazz, const char *message)
+{
+    jint result;
+    jstring msg = NULL;
+    jobject obj = NULL;
+    jmethodID methodID;
+
+    if (CVMjniEnsureLocalCapacity(env, 2) != JNI_OK) {
+        return JNI_ENOMEM;
+    }
+
+    methodID = CVMjniGetMethodID(env, clazz,
+				 "<init>", "(Ljava/lang/String;)V");
+
+    if (methodID == NULL) {
+	/* Exception already thrown */
+	result = JNI_ERR;
+	goto done;
+    }
+
+    if (message != NULL) {
+	msg = CVMjniNewStringUTF(env, message);
+	if (msg == NULL) {
+	    result = JNI_ERR;
+	    goto done;
+	}
+    } else {
+	msg = NULL;
+    }
+
+    obj = CVMjniNewObject(env, clazz, methodID, msg);
+    if (obj == NULL) {
+        result = JNI_ERR;
+	goto done;
+    }
+
+    result = CVMjniThrow(env, obj);
+
+done:
+    if (msg != NULL) {
+	CVMjniDeleteLocalRef(env, msg);
+    }
+    if (obj != NULL) {
+	CVMjniDeleteLocalRef(env, obj);
+    }
+    return result;
+}
+
+jthrowable JNICALL
+CVMjniExceptionOccurred(JNIEnv *env)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMThrowableICell* exceptionICell = NULL;
+
+    if (CVMlocalExceptionOccurred(ee)) {
+	exceptionICell = CVMlocalExceptionICell(ee);
+    } else if (CVMremoteExceptionOccurred(ee)) {
+	exceptionICell = CVMremoteExceptionICell(ee);
+    }
+
+    if (exceptionICell != NULL) {
+        /* turn into local ref */
+        return CVMjniNewLocalRef(env, exceptionICell);
+    } else {
+	return NULL;
+    }
+
+}
+
+jboolean JNICALL
+CVMjniExceptionCheck(JNIEnv *env)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+
+    if (CVMexceptionOccurred(ee)) {
+	return JNI_TRUE;
+    } else {
+	return JNI_FALSE;
+    }
+}
+
+void JNICALL
+CVMjniExceptionClear(JNIEnv *env)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    /* %comment: rt017 */
+    CVMclearLocalException(ee);
+    CVMclearRemoteException(ee);
+}
+
+/* NOTE:  If we decide later to get rid of the prototypes just
+   added to jni_impl.h, we will need to forward declare
+   CVMjniCallVoidMethod here because CVMjniExceptionDescribe uses it
+   before it's defined in this file. */
+
+void JNICALL
+CVMjniExceptionDescribe(JNIEnv *env)
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+    jobject throwable = NULL;
+    jclass clazz;
+    jmethodID method;
+
+    if ((!CVMexceptionOccurred(ee))) {
+	return;
+    }
+
+    if (CVMjniEnsureLocalCapacity(env, 3) != JNI_OK) {
+        return;
+    }
+
+    if (CVMlocalExceptionOccurred(ee)) {
+	throwable =
+	    (*env)->NewLocalRef(env, CVMlocalExceptionICell(ee));
+    } else if (CVMremoteExceptionOccurred(ee)) {
+	throwable =
+	    (*env)->NewLocalRef(env, CVMremoteExceptionICell(ee));
+    }
+    if (throwable == NULL) {
+	return;
+    }
+    
+    CVMclearLocalException(ee);
+    /* We might want to preserve the remote exception if we
+       are recognizing the local exception, but for now we clear
+       both for compatibility with JDK */
+    CVMclearRemoteException(ee);
+
+    clazz = CVMjniGetObjectClass(env, throwable);
+    CVMassert(clazz != NULL);
+    method = CVMjniGetMethodID(env, clazz, "printStackTrace", "()V");
+    CVMjniDeleteLocalRef(env, clazz);
+    CVMassert(method != NULL);
+    CVMjniCallVoidMethod(env, throwable, method);
+
+    /* If printStackTrace threw an exception, then print a message. */
+    if (CVMlocalExceptionOccurred(ee)) {
+	/* NOTE: this has happened in the past because of static
+           initializers failing to get run, causing the system class
+           not to be initialized and System.out being NULL, causing a
+           NullPointerException while printing the stack trace. */
+	CVMconsolePrintf("CVMjniExceptionDescribe failed: "
+			 "couldn't print stack trace.\n");
+	CVMconsolePrintf("Using brute force method to print stack trace.\n");
+	CVMID_icellAssign(ee, CVMlocalExceptionICell(ee), throwable);
+	CVMdumpException(ee); 
+    }
+
+    CVMjniDeleteLocalRef(env, throwable);
+}
+
+/*
+ * Methods calls
+ */
+
+#undef SAFE_COUNT
+#define SAFE_COUNT 32	/* number of arguments to push between GC checkpoint */ 
+
+static char
+CVMjniPushArgumentsVararg(JNIEnv *env,
+			  CVMterseSigIterator *terse_signature,
+			  CVMFrame *current_frame, const void *a)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMStackVal32 *topOfStack = current_frame->topOfStack;
+    int safeCount = SAFE_COUNT;
+    CVMVaList *v = (CVMVaList *)a;
+    va_list *args = &v->args;
+    int typeSyllable;
+
+    while ((typeSyllable=CVM_TERSE_ITER_NEXT(*terse_signature))!=CVM_TYPEID_ENDFUNC) {
+	/* Perform GC checkpoint every so often */
+	if (safeCount-- == 0) {
+	    CVMD_gcSafeCheckPoint(ee, {
+		current_frame->topOfStack = topOfStack;
+	    }, {});
+	    safeCount = SAFE_COUNT;
+	}
+
+        switch (typeSyllable) {
+	case CVM_TYPEID_BOOLEAN:
+	case CVM_TYPEID_SHORT:
+	case CVM_TYPEID_BYTE:
+	case CVM_TYPEID_CHAR:
+	case CVM_TYPEID_INT:
+            (topOfStack++)->j.i = va_arg(*args, jint);
+            continue;
+	case CVM_TYPEID_FLOAT:
+            (topOfStack++)->j.f = va_arg(*args, jdouble);
+            continue;
+        case CVM_TYPEID_OBJ: {
+	    jobject obj = va_arg(*args, jobject);
+	    CVMID_icellAssignDirect(ee, &topOfStack->j.r,
+		CVMjniNonNullICellPtrFor(obj));
+	    topOfStack++;
+	    continue;
+	}
+	case CVM_TYPEID_LONG: {
+	    jlong l = va_arg(*args, jlong);
+	    CVMlong2Jvm(&topOfStack->j.raw, l);
+            topOfStack += 2;
+            continue;
+	}
+	case CVM_TYPEID_DOUBLE: {
+	    jdouble d = va_arg(*args, jdouble);
+	    CVMdouble2Jvm(&topOfStack->j.raw, d);
+            topOfStack += 2;
+            continue;
+	}
+	default:
+	    /* This should never happen */
+	    CVMassert(CVM_FALSE);
+	    return 0;
+        }
+    }
+    /* fell out of while loop. Return return type */
+    current_frame->topOfStack = topOfStack;
+    return CVM_TERSE_ITER_RETURNTYPE(*terse_signature);
+}
+
+static char
+CVMjniPushArgumentsArray(JNIEnv *env,
+			 CVMterseSigIterator *terse_signature,
+			 CVMFrame *current_frame, const void *a)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMStackVal32 *topOfStack = current_frame->topOfStack;
+    int safeCount = SAFE_COUNT;
+    jvalue *args = (jvalue *)a;
+    int typeSyllable;
+    
+    while ((typeSyllable=CVM_TERSE_ITER_NEXT(*terse_signature))!=CVM_TYPEID_ENDFUNC) {
+	/* Perform GC checkpoint every so often */
+	if (safeCount-- == 0) {
+	    CVMD_gcSafeCheckPoint(ee, {
+		current_frame->topOfStack = topOfStack;
+	    }, {});
+	    safeCount = SAFE_COUNT;
+	}
+
+        switch (typeSyllable) {
+	case CVM_TYPEID_BOOLEAN:
+            (topOfStack++)->j.i = (*args++).z;
+            continue;
+	case CVM_TYPEID_SHORT:
+            (topOfStack++)->j.i = (*args++).s;
+            continue;
+	case CVM_TYPEID_BYTE:
+            (topOfStack++)->j.i = (*args++).b;
+            continue;
+	case CVM_TYPEID_CHAR:
+            (topOfStack++)->j.i = (*args++).c;
+            continue;
+	case CVM_TYPEID_INT:
+            (topOfStack++)->j.i = (*args++).i;
+            continue;
+	case CVM_TYPEID_FLOAT:
+	    (topOfStack++)->j.f = (*args++).f;
+            continue;
+	case CVM_TYPEID_OBJ: {
+	    jobject obj = (*args++).l;
+	    CVMID_icellAssignDirect(ee, &topOfStack->j.r,
+		CVMjniNonNullICellPtrFor(obj));
+	    topOfStack++;
+	    continue;
+	}
+	case CVM_TYPEID_LONG: {
+	    jlong l = (*args++).j;
+	    CVMlong2Jvm(&topOfStack->j.raw, l);
+            topOfStack += 2;
+            continue;
+	}
+	case CVM_TYPEID_DOUBLE: {
+	    jdouble d = (*args++).d;
+	    CVMdouble2Jvm(&topOfStack->j.raw, d);
+            topOfStack += 2;
+            continue;
+	}
+	default:
+            CVMassert(CVM_FALSE);
+	    return 0;
+        }
+    }
+    /* fell out of loop. return return type */
+    current_frame->topOfStack = topOfStack;
+    return CVM_TERSE_ITER_RETURNTYPE(*terse_signature);
+}
+
+static void
+CVMjniInvoke(JNIEnv *env, jobject obj, jmethodID methodID,
+    JNI_PushArguments_t pushArguments, const void *args,
+    CVMUint16 info, jvalue *retValue)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMClassBlock *cb;
+    CVMFrame*     frame;
+    CVMInt32 invokeType = (info & CVM_INVOKE_TYPE_MASK);
+    char retType = (info & CVM_INVOKE_RETTYPE_MASK);
+    CVMBool isStatic = (invokeType == CVM_INVOKE_STATIC);
+    CVMBool isVirtual = (invokeType == CVM_INVOKE_VIRTUAL);
+    
+    CVMassert(CVMframeIsFreelist(CVMeeGetCurrentFrame(ee)));
+
+    /* %comment hideya003 */
+    if (CVMlocalExceptionOccurred(ee)) {
+#ifdef CVM_DEBUG
+	CVMconsolePrintf("Pending exception entering CVMjniInvoke!\n");
+	CVMjniExceptionDescribe(env);
+#endif
+#ifdef CVM_DEBUG_ASSERTS
+        CVMassertHook(__FILE__, __LINE__,
+                      "Pending exception entering CVMjniInvoke!\n");
+#endif
+	return;
+    }
+
+    if (retType == CVM_TYPEID_OBJ) {
+	/* Caller should have ensured capacity */
+	retValue->l = CVMjniCreateLocalRef(ee);
+	/* We should never reach here if the ref creation fails */
+	CVMassert(retValue->l != NULL);
+    }
+
+    /* Create the transition frame.*/
+    CVMD_gcUnsafeExec(ee, {
+	if (isStatic) {
+	    cb = CVMjniGcUnsafeRef2Class(ee, obj);
+	} else {
+	    cb = CVMobjectGetClass(CVMID_icellDirect(ee, obj));
+	}
+	frame = (CVMFrame*)CVMpushTransitionFrame(ee, methodID);
+    });
+    if (frame == NULL) {
+	if (retType == CVM_TYPEID_OBJ) {
+	    CVMjniDeleteLocalRef(env, retValue->l);
+	    retValue->l = NULL;
+	}
+	CVMassert(CVMexceptionOccurred(ee));
+	return;  /* exception already thrown */
+    }
+
+    CVMassert(!CVMlocalExceptionOccurred(ee));
+
+    /* Push arguments and invoke the method. */
+    CVMD_gcUnsafeExec(ee, {
+	CVMBool resultIsNullObjectRef = CVM_FALSE;
+	/* Push the "this" argument if the method is not static. */
+	if (!isStatic) {
+	    CVMID_icellAssignDirect(ee, &frame->topOfStack->j.r, obj);
+	    frame->topOfStack++;
+	}
+
+	/* Push the all the other arguments. */
+	{
+	    CVMterseSigIterator terseSig;
+	    char       	methodRetType;
+	    CVMMethodBlock *mb = methodID;
+
+	    CVMtypeidGetTerseSignatureIterator(CVMmbNameAndTypeID(mb), 
+					       &terseSig);
+
+	    methodRetType = (*pushArguments)(env, &terseSig, frame, args);
+	    if (methodRetType != retType) {
+		CVMjniFatalError(env, "Native code expects wrong return type"
+				 "from Java callback");
+	    }
+	}
+
+	CVMassert(!CVMlocalExceptionOccurred(ee));
+
+	/* Call the java method. */
+	(*CVMglobals.CVMgcUnsafeExecuteJavaMethodProcPtr)(ee,
+							  methodID,
+							  isStatic,
+							  isVirtual);
+
+	/* 
+	 * Copy the result. frame->topOfStack will point after the result.
+	 */
+	if (!CVMlocalExceptionOccurred(ee)) {
+	    switch (retType) {
+	    case CVM_TYPEID_VOID:
+		break;
+	    case CVM_TYPEID_BOOLEAN:
+		retValue->z = frame->topOfStack[-1].j.i;
+		break;
+	    case CVM_TYPEID_BYTE:
+		retValue->b = frame->topOfStack[-1].j.i;
+		break;
+	    case CVM_TYPEID_CHAR:
+		retValue->c = frame->topOfStack[-1].j.i;
+		break;
+	    case CVM_TYPEID_SHORT:
+		retValue->s = frame->topOfStack[-1].j.i;
+		break;
+	    case CVM_TYPEID_INT:
+		retValue->i = frame->topOfStack[-1].j.i;
+		break;
+	    case CVM_TYPEID_LONG: {
+		retValue->j = CVMjvm2Long(&frame->topOfStack[-2].j.raw);
+		break;
+	    }
+	    case CVM_TYPEID_FLOAT:
+		retValue->f = (jfloat)frame->topOfStack[-1].j.f;
+		break;
+	    case CVM_TYPEID_DOUBLE: {
+		retValue->d = CVMjvm2Double(&frame->topOfStack[-2].j.raw);
+		break;
+	    }
+	    case CVM_TYPEID_OBJ:
+		CVMID_icellAssignDirect(ee, retValue->l,
+					&frame->topOfStack[-1].j.r);
+		break;
+	    }
+	}
+
+	/* Regardless of whether an exception occurred, we must not
+	   allow an ICell containing NULL to escape to the caller. */
+	if ((retType == CVM_TYPEID_OBJ) &&
+	    CVMID_icellIsNull(retValue->l)) {
+	    resultIsNullObjectRef = CVM_TRUE;
+	}
+
+	/* Pop the transition frame. */
+	CVMpopFrame(&ee->interpreterStack,
+		    ee->interpreterStack.currentFrame);
+	/* Do not delete the local ref until the transition frame is
+           popped! */
+	if (resultIsNullObjectRef) {
+	    CVMjniDeleteLocalRef(env, retValue->l);
+	    retValue->l = NULL;
+	}
+    });
+}
+
+#undef CONCAT
+#undef EVALCONCAT
+#undef CONCAT3
+#define CONCAT(x,y)		x##y
+#define EVALCONCAT(x,y)		C(x,y)
+#define CONCAT3(a,b,c)		a##b##c
+#undef N_NONVIRTUAL
+#undef N_VIRTUAL
+#undef N_STATIC
+#define N_NONVIRTUAL	CVMjniCallNonvirtual
+#define N_VIRTUAL	CVMjniCall
+#define N_STATIC	CVMjniCallStatic
+#undef SIG_NONVIRTUAL
+#undef SIG_VIRTUAL
+#undef SIG_STATIC
+#define SIG_NONVIRTUAL	jobject obj, jclass clazz
+#define SIG_VIRTUAL	jobject obj
+#define SIG_STATIC	jclass clazz
+#undef OBJ_NONVIRTUAL
+#undef OBJ_VIRTUAL
+#undef OBJ_STATIC
+#define OBJ_NONVIRTUAL	obj
+#define OBJ_VIRTUAL	obj
+#define OBJ_STATIC	clazz
+#undef IF_Yes
+#undef IF_No
+#undef IF1_Yes
+#undef IF1_No
+#undef IF0_Yes
+#undef IF0_No
+#undef IF
+#define IF_Yes(x,y)	x
+#define IF_No(x,y)	y
+#define IF1_Yes(x)	x
+#define IF1_No(x)
+#define IF0_No(x)	x
+#define IF0_Yes(x)
+#define IF(YN,x,y)	CONCAT(IF_,YN)(x,y)
+#define IFY(YN,x)	CONCAT(IF1_,YN)(x)
+#define IFN(YN,x)	CONCAT(IF0_,YN)(x)
+#undef CALL_NAME_DOTDOTDOT
+#undef CALL_NAME_VA_LIST
+#undef CALL_NAME_JVALUE_ARRAY
+#define CALL_NAME_DOTDOTDOT	Method
+#define CALL_NAME_VA_LIST	MethodV
+#define CALL_NAME_JVALUE_ARRAY	MethodA
+#undef ARGS_DOTDOTDOT
+#undef ARGS_VA_LIST
+#undef ARGS_JVALUE_ARRAY
+#define ARGS_DOTDOTDOT		&v
+#define ARGS_VA_LIST		&v
+#define ARGS_JVALUE_ARRAY	args
+#undef PUSHARGSFUNC_DOTDOTDOT
+#undef PUSHARGSFUNC_VA_LIST
+#undef PUSHARGSFUNC_JVALUE_ARRAY
+#define PUSHARGSFUNC_DOTDOTDOT		CVMjniPushArgumentsVararg
+#define PUSHARGSFUNC_VA_LIST		CVMjniPushArgumentsVararg
+#define PUSHARGSFUNC_JVALUE_ARRAY	CVMjniPushArgumentsArray
+#undef ARG_DECL_DOTDOTDOT
+#undef ARG_DECL_VA_LIST
+#undef ARG_DECL_JVALUE_ARRAY
+#define ARG_DECL_DOTDOTDOT	...
+#define ARG_DECL_VA_LIST	va_list args
+#define ARG_DECL_JVALUE_ARRAY	const jvalue *args
+#undef IS_DOTDOTDOT_DOTDOTDOT
+#undef IS_DOTDOTDOT_VA_LIST
+#undef IS_DOTDOTDOT_JVALUE_ARRAY
+#define IS_DOTDOTDOT_DOTDOTDOT		Yes
+#define IS_DOTDOTDOT_VA_LIST		No
+#define IS_DOTDOTDOT_JVALUE_ARRAY	No
+#undef IS_JVALUE_ARRAY_DOTDOTDOT
+#undef IS_JVALUE_ARRAY_VA_LIST
+#undef IS_JVALUE_ARRAY_JVALUE_ARRAY
+#define IS_JVALUE_ARRAY_DOTDOTDOT	No
+#define IS_JVALUE_ARRAY_VA_LIST		No
+#define IS_JVALUE_ARRAY_JVALUE_ARRAY	Yes
+#undef IS_VA_LIST_DOTDOTDOT
+#undef IS_VA_LIST_VA_LIST
+#undef IS_VA_LIST_JVALUE_ARRAY
+#define IS_VA_LIST_DOTDOTDOT	No
+#define IS_VA_LIST_VA_LIST	Yes
+#define IS_VA_LIST_JVALUE_ARRAY	No
+
+#define NAME(a,b,c)	CONCAT3(a,b,c)
+
+#undef DEFINE_CALLMETHODXY
+#define DEFINE_CALLMETHODXY(MethodType,					    \
+			    ResultType, Result, unionType,		    \
+			    ReturnCode,					    \
+			    isValue, argType)				    \
+									    \
+ResultType JNICALL							    \
+NAME(N_##MethodType,Result,CALL_NAME_##argType)(JNIEnv *env,	    	    \
+			 SIG_##MethodType,				    \
+			 jmethodID methodID, ARG_DECL_##argType)	    \
+{									    \
+    IFY(isValue,jvalue result;)						    \
+    IFN(IS_JVALUE_ARRAY_##argType,CVMVaList v;)				    \
+									    \
+    IFY(IS_DOTDOTDOT_##argType,va_start(v.args, methodID));		    \
+    IFY(IS_VA_LIST_##argType,va_copy(v.args, args));			    \
+									    \
+    CVMjniInvoke(env, OBJ_##MethodType, methodID,			    \
+		 PUSHARGSFUNC_##argType,				    \
+		 ARGS_##argType,					    \
+		 ReturnCode | CVM_INVOKE_##MethodType,			    \
+		 IF(isValue,&result,0));				    \
+    IFN(IS_JVALUE_ARRAY_##argType,va_end(v.args));			    \
+    IF(isValue,return result.unionType,return);				    \
+}									    \
+
+#undef DEFINE_CALLMETHODX
+#define DEFINE_CALLMETHODX(MT, RT, R, UT, RC, VD)			    \
+DEFINE_CALLMETHODXY(MT,RT,R,UT,RC,VD,DOTDOTDOT)	/* ... */		    \
+DEFINE_CALLMETHODXY(MT,RT,R,UT,RC,VD,VA_LIST) 	/* va_list args */	    \
+DEFINE_CALLMETHODXY(MT,RT,R,UT,RC,VD,JVALUE_ARRAY)	/* jvalue *args */
+
+#undef DEFINE_CALLMETHOD
+#define DEFINE_CALLMETHOD(RT, R, UT, RC, VD)				    \
+DEFINE_CALLMETHODX(NONVIRTUAL,RT,R,UT,RC,VD)	/* Nonvirtual */	    \
+DEFINE_CALLMETHODX(VIRTUAL,RT,R,UT,RC,VD)	/* Virtual */		    \
+DEFINE_CALLMETHODX(STATIC,RT,R,UT,RC,VD)	/* Static */
+
+DEFINE_CALLMETHOD(jobject,Object,l,CVM_TYPEID_OBJ,Yes)		/* Object */
+DEFINE_CALLMETHOD(jboolean,Boolean,z,CVM_TYPEID_BOOLEAN,Yes)	/* Boolean */
+DEFINE_CALLMETHOD(jbyte,Byte,b,CVM_TYPEID_BYTE,Yes)		/* Byte */
+DEFINE_CALLMETHOD(jchar,Char,c,CVM_TYPEID_CHAR,Yes)		/* Char */
+DEFINE_CALLMETHOD(jshort,Short,s,CVM_TYPEID_SHORT,Yes)		/* Short */
+DEFINE_CALLMETHOD(jint,Int,i,CVM_TYPEID_INT,Yes)			/* Int */
+DEFINE_CALLMETHOD(jlong,Long,j,CVM_TYPEID_LONG,Yes)		/* Long */
+DEFINE_CALLMETHOD(jfloat,Float,f,CVM_TYPEID_FLOAT,Yes)		/* Float */
+DEFINE_CALLMETHOD(jdouble,Double,d,CVM_TYPEID_DOUBLE,Yes)	/* Double */
+DEFINE_CALLMETHOD(void,Void,X,CVM_TYPEID_VOID,No)		/* Void */
+
+jint JNICALL
+CVMjniMonitorEnter(JNIEnv *env, jobject obj)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMBool ok = CVMgcSafeObjectLock(ee, obj);
+    if (!ok) {
+        CVMthrowOutOfMemoryError(ee, "Couldn't allocate memory for monitor");
+    }
+    return ok ? JNI_OK : JNI_ERR;
+}
+
+jint JNICALL
+CVMjniMonitorExit(JNIEnv *env, jobject obj)
+{
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMBool ok = CVMgcSafeObjectUnlock(ee, obj);
+    if (!ok) {
+        CVMthrowIllegalMonitorStateException(ee, "current thread not owner");
+    }
+    return ok ? JNI_OK : JNI_ERR;
+}
+
+jint JNICALL
+CVMjniGetJavaVM(JNIEnv *env, JavaVM **p_jvm)
+{
+    *p_jvm = &CVMglobals.javaVM.vector;
+    return JNI_OK;
+}
+
+
+/* NOTE: These lookups are done with the NULL (bootstrap) ClassLoader to 
+ *  circumvent any security checks that would be done by jni_FindClass.
+ */
+static jboolean
+CVMjniLookupDirectBufferClasses(JNIEnv* env)
+{
+    CVMJNIJavaVM *vm = &CVMglobals.javaVM;
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+    CVMClassBlock *cb;
+
+    /* Note: For the class lookups below, use the NULL classloader, and NULL
+       protection domain. 
+
+       Note that the JNI spec does not say that any exceptions will be thrown
+       for NewDirectByteBuffer(), GetDirectBufferAddress(), and
+       GetDirectBufferCapacity(), except for NewDirectByteBuffer() which can
+       throw an OutOfMemoryError.  Hence, we also suppress
+       CVMclassLookupByNameFromClassLoader from throwing exceptions.
+
+       Note: In the following, the class lookup may fail.  When that happens,
+       we may have already allocated some of the global refs.  Normally, we
+       would clean up any allocations due to failed initialization.  But in
+       this case, the global refs will be cleaned up automatically anyway when
+       the VM shuts down.  The only cost is that we can waste up to 2 global
+       refs.  However, the amount of memory wasted for this (2 words) is less
+       than the amount of code it will take to clean it up.  So, we'll live
+       with the potential waste of 2 global refs in the event of an
+       initialization failure.
+    */
+    cb = CVMclassLookupByNameFromClassLoader(ee, "java/nio/Buffer",
+					     CVM_TRUE, NULL, NULL, CVM_FALSE);
+    if (cb == NULL) {
+	return CVM_FALSE;
+    }
+    vm->bufferClass = (jclass) CVMjniNewGlobalRef(env, CVMcbJavaInstance(cb));
+
+    cb = CVMclassLookupByNameFromClassLoader(ee, "sun/nio/ch/DirectBuffer",
+					     CVM_TRUE, NULL, NULL, CVM_FALSE);
+    if (cb == NULL) {
+        CVMjniExceptionClear(env);
+        /* Try again with the JSR-239 implementation class */
+        cb = CVMclassLookupByNameFromClassLoader(ee, "java/nio/DirectBuffer",
+                                                 CVM_TRUE, NULL, NULL, CVM_FALSE);
+    }
+    if (cb == NULL) {
+	return CVM_FALSE;
+    }
+    vm->directBufferClass =
+	(jclass) CVMjniNewGlobalRef(env, CVMcbJavaInstance(cb));
+
+    cb = CVMclassLookupByNameFromClassLoader(ee, "java/nio/DirectByteBuffer",
+					     CVM_TRUE, NULL, NULL, CVM_FALSE);
+    if (cb == NULL) {
+	return CVM_FALSE;
+    }
+    vm->directByteBufferClass =
+	(jclass) CVMjniNewGlobalRef(env, CVMcbJavaInstance(cb));
+
+    return CVM_TRUE;
+}
+
+
+static jboolean 
+CVMjniInitializeDirectBufferSupport(JNIEnv* env)
+{
+    CVMJNIJavaVM *vm = &CVMglobals.javaVM;
+    CVMExecEnv *ee = CVMjniEnv2ExecEnv(env);
+
+    CVMassert(CVMD_isgcSafe(ee));
+
+    /* If we've already attempted initialization and failed, there's no need
+       to retry it: */
+    if (vm->directBufferSupportInitializeFailed) {
+	return CVM_FALSE;
+    }
+
+    /* Note that lookupDirectBufferClasses() does lookups on the NULL
+       classloader.  This means that it can lock the nullClassLoaderLock.
+       Hence, we cannot use a sysMutex of higher rank than the
+       nullClassLoaderLock to synchronize this initialization.  Hence,
+       the nullClassLoaderLock is used.
+    */
+    CVMsysMutexLock(ee, &CVMglobals.nullClassLoaderLock);
+
+    /* If another thread beat us to initializing this, then there's nothing
+       to do: */
+    if (vm->directBufferSupportInitialized) {
+	goto done;
+    }
+
+    /* Check for presence of needed classes: */
+    if (!CVMjniLookupDirectBufferClasses(env)) {
+	vm->directBufferSupportInitializeFailed = CVM_TRUE;
+	goto done;
+    }
+
+    /*  Get needed field and method IDs */
+    vm->directByteBufferLongConstructor =
+	CVMjniGetMethodID(env, vm->directByteBufferClass, "<init>", "(JI)V");
+    if (vm->directByteBufferLongConstructor == NULL) {
+        CVMjniExceptionClear(env);
+        /* JSR-239 code path */
+        vm->directByteBufferIntConstructor =
+            CVMjniGetMethodID(env, vm->directByteBufferClass, "<init>", "(I[BI)V");
+    }
+    vm->directBufferAddressLongField =
+	CVMjniGetFieldID(env, vm->bufferClass, "address", "J");
+    if (vm->directBufferAddressLongField == NULL) {
+        CVMjniExceptionClear(env);
+        /* JSR-239 code path */
+        vm->directBufferAddressIntField =
+            CVMjniGetFieldID(env, vm->bufferClass, "arrayOffset", "I");
+    }
+    vm->bufferCapacityField =
+	CVMjniGetFieldID(env, vm->bufferClass, "capacity", "I");
+
+    if (((vm->directByteBufferLongConstructor == NULL) &&
+         (vm->directByteBufferIntConstructor  == NULL))  ||
+	((vm->directBufferAddressLongField  == NULL) &&
+         (vm->directBufferAddressIntField   == NULL))    ||
+	(vm->bufferCapacityField == NULL)) {
+	vm->directBufferSupportInitializeFailed = CVM_TRUE;
+	goto done;
+    }
+
+    vm->directBufferSupportInitialized = CVM_TRUE;
+
+done:
+    CVMsysMutexUnlock(ee, &CVMglobals.nullClassLoaderLock);
+    return !vm->directBufferSupportInitializeFailed;
+}
+
+jobject JNICALL
+CVMjniNewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity)
+{
+    CVMJNIJavaVM *vm = &CVMglobals.javaVM;
+    jlong addr;
+    jint  cap;
+    jobject buffer = NULL;
+
+    /* Initialize the direct buffer support if not inited yet: */
+    if (!vm->directBufferSupportInitialized) {
+	if (!CVMjniInitializeDirectBufferSupport(env)) {
+	    return NULL;
+	}
+    }
+
+    addr = CVMvoidPtr2Long(address);
+
+    /*  
+     * NOTE that package-private DirectByteBuffer constructor currently 
+     *  takes int capacity.
+     */
+    cap  = CVMlong2Int(capacity);
+    if (vm->directByteBufferLongConstructor != NULL) {
+        buffer = CVMjniNewObject(env, vm->directByteBufferClass,
+                                 vm->directByteBufferLongConstructor, addr, cap);
+    } else if (vm->directByteBufferIntConstructor != NULL) {
+        /* JSR-239 variant */
+        buffer = CVMjniNewObject(env, vm->directByteBufferClass,
+                                 vm->directByteBufferIntConstructor, cap, NULL, CVMlong2Int(addr));
+    }
+    return buffer;
+}
+
+
+void* JNICALL
+CVMjniGetDirectBufferAddress(JNIEnv *env, jobject buf)
+{
+    CVMJNIJavaVM *vm = &CVMglobals.javaVM;
+    jlong lresult = 0;
+
+    /* Initialize the direct buffer support if not inited yet: */
+    if (!vm->directBufferSupportInitialized) {
+	if (!CVMjniInitializeDirectBufferSupport(env)) {
+	    return NULL;
+	}
+    }
+
+    if ((buf != NULL) &&
+	(!CVMjniIsInstanceOf(env, buf, vm->directBufferClass))) {
+	return NULL;
+    }
+
+    if (vm->directBufferAddressLongField != NULL) {
+        lresult = CVMjniGetLongField(env, buf, vm->directBufferAddressLongField);
+    } else if (vm->directBufferAddressIntField != NULL) {
+        lresult = CVMint2Long(CVMjniGetIntField(env, buf, vm->directBufferAddressIntField));
+    }
+    return CVMlong2VoidPtr(lresult);
+}
+
+jlong JNICALL
+CVMjniGetDirectBufferCapacity(JNIEnv *env, jobject buf)
+{
+    CVMJNIJavaVM *vm = &CVMglobals.javaVM;
+    jint capacity;
+    jlong failedResult = CVMint2Long(-1);
+
+    /* Initialize the direct buffer support if not inited yet: */
+    if (!vm->directBufferSupportInitialized) {
+	if (!CVMjniInitializeDirectBufferSupport(env)) {
+	    /* NOTE: The JavaSE library implementation is expecting a failure
+	       to initialize condition to return 0 here instead of -1.  Hence,
+	       we return the same value to be consistent. 
+
+	       The ideal solution is probably to return -1 if the failure is
+	       due to needed classes not beig available, and a 0 if due to
+	       a low memory condition.  The low memory condition can allow
+	       a retry to init later.
+	    */
+	    return CVMlongConstZero();
+	}
+    }
+
+    if (buf == NULL) {
+	return failedResult;
+    }
+
+    if (!CVMjniIsInstanceOf(env, buf, vm->directBufferClass)) {
+	return failedResult;
+    }
+
+    /*  NOTE that capacity is currently an int in the implementation */
+    capacity = CVMjniGetIntField(env, buf, vm->bufferCapacityField);
+    return CVMint2Long(capacity);
+}
+
+
+/* NOTE: This can not be made const any more, because the JVMTI
+   will instrument it if necessary, and the "checked" version of the
+   JNI may do so also if we add that later. */
+
+static
+#ifndef CVM_JVMTI
+const
+#endif
+struct JNINativeInterface CVMmainJNIfuncs =
+{
+    NULL,
+    NULL,
+    NULL,
+
+    NULL,
+
+    CVMjniGetVersion,
+
+    CVMjniDefineClass,
+    CVMjniFindClass,
+
+    CVMjniFromReflectedMethod,
+    CVMjniFromReflectedField,
+
+    CVMjniToReflectedMethod,
+
+    CVMjniGetSuperclass,
+    CVMjniIsAssignableFrom,
+
+    CVMjniToReflectedField,
+
+    CVMjniThrow,
+    CVMjniThrowNew,
+    CVMjniExceptionOccurred,
+    CVMjniExceptionDescribe,
+    CVMjniExceptionClear,
+    CVMjniFatalError,
+
+    CVMjniPushLocalFrame,
+    CVMjniPopLocalFrame,
+
+    CVMjniNewGlobalRef,
+    CVMjniDeleteGlobalRef,
+    CVMjniDeleteLocalRef,
+    CVMjniIsSameObject,
+
+    CVMjniNewLocalRef,
+    CVMjniEnsureLocalCapacity,
+
+    CVMjniAllocObject,
+    CVMjniNewObject,
+    CVMjniNewObjectV,
+    CVMjniNewObjectA,
+
+    CVMjniGetObjectClass,
+    CVMjniIsInstanceOf,
+
+    CVMjniGetMethodID,
+
+    CVMjniCallObjectMethod,
+    CVMjniCallObjectMethodV,
+    CVMjniCallObjectMethodA,
+    CVMjniCallBooleanMethod,
+    CVMjniCallBooleanMethodV,
+    CVMjniCallBooleanMethodA,
+    CVMjniCallByteMethod,
+    CVMjniCallByteMethodV,
+    CVMjniCallByteMethodA,
+    CVMjniCallCharMethod,
+    CVMjniCallCharMethodV,
+    CVMjniCallCharMethodA,
+    CVMjniCallShortMethod,
+    CVMjniCallShortMethodV,
+    CVMjniCallShortMethodA,
+    CVMjniCallIntMethod,
+    CVMjniCallIntMethodV,
+    CVMjniCallIntMethodA,
+    CVMjniCallLongMethod,
+    CVMjniCallLongMethodV,
+    CVMjniCallLongMethodA,
+    CVMjniCallFloatMethod,
+    CVMjniCallFloatMethodV,
+    CVMjniCallFloatMethodA,
+    CVMjniCallDoubleMethod,
+    CVMjniCallDoubleMethodV,
+    CVMjniCallDoubleMethodA,
+    CVMjniCallVoidMethod,
+    CVMjniCallVoidMethodV,
+    CVMjniCallVoidMethodA,
+
+    CVMjniCallNonvirtualObjectMethod,
+    CVMjniCallNonvirtualObjectMethodV,
+    CVMjniCallNonvirtualObjectMethodA,
+    CVMjniCallNonvirtualBooleanMethod,
+    CVMjniCallNonvirtualBooleanMethodV,
+    CVMjniCallNonvirtualBooleanMethodA,
+    CVMjniCallNonvirtualByteMethod,
+    CVMjniCallNonvirtualByteMethodV,
+    CVMjniCallNonvirtualByteMethodA,
+    CVMjniCallNonvirtualCharMethod,
+    CVMjniCallNonvirtualCharMethodV,
+    CVMjniCallNonvirtualCharMethodA,
+    CVMjniCallNonvirtualShortMethod,
+    CVMjniCallNonvirtualShortMethodV,
+    CVMjniCallNonvirtualShortMethodA,
+    CVMjniCallNonvirtualIntMethod,
+    CVMjniCallNonvirtualIntMethodV,
+    CVMjniCallNonvirtualIntMethodA,
+    CVMjniCallNonvirtualLongMethod,
+    CVMjniCallNonvirtualLongMethodV,
+    CVMjniCallNonvirtualLongMethodA,
+    CVMjniCallNonvirtualFloatMethod,
+    CVMjniCallNonvirtualFloatMethodV,
+    CVMjniCallNonvirtualFloatMethodA,
+    CVMjniCallNonvirtualDoubleMethod,
+    CVMjniCallNonvirtualDoubleMethodV,
+    CVMjniCallNonvirtualDoubleMethodA,
+    CVMjniCallNonvirtualVoidMethod,
+    CVMjniCallNonvirtualVoidMethodV,
+    CVMjniCallNonvirtualVoidMethodA,
+
+    CVMjniGetFieldID,
+
+    CVMjniGetObjectField,
+    CVMjniGetBooleanField,
+    CVMjniGetByteField,
+    CVMjniGetCharField,
+    CVMjniGetShortField,
+    CVMjniGetIntField,
+    CVMjniGetLongField,
+    CVMjniGetFloatField,
+    CVMjniGetDoubleField,
+
+    CVMjniSetObjectField,
+    CVMjniSetBooleanField,
+    CVMjniSetByteField,
+    CVMjniSetCharField,
+    CVMjniSetShortField,
+    CVMjniSetIntField,
+    CVMjniSetLongField,
+    CVMjniSetFloatField,
+    CVMjniSetDoubleField,
+
+    CVMjniGetStaticMethodID,
+
+    CVMjniCallStaticObjectMethod,
+    CVMjniCallStaticObjectMethodV,
+    CVMjniCallStaticObjectMethodA,
+    CVMjniCallStaticBooleanMethod,
+    CVMjniCallStaticBooleanMethodV,
+    CVMjniCallStaticBooleanMethodA,
+    CVMjniCallStaticByteMethod,
+    CVMjniCallStaticByteMethodV,
+    CVMjniCallStaticByteMethodA,
+    CVMjniCallStaticCharMethod,
+    CVMjniCallStaticCharMethodV,
+    CVMjniCallStaticCharMethodA,
+    CVMjniCallStaticShortMethod,
+    CVMjniCallStaticShortMethodV,
+    CVMjniCallStaticShortMethodA,
+    CVMjniCallStaticIntMethod,
+    CVMjniCallStaticIntMethodV,
+    CVMjniCallStaticIntMethodA,
+    CVMjniCallStaticLongMethod,
+    CVMjniCallStaticLongMethodV,
+    CVMjniCallStaticLongMethodA,
+    CVMjniCallStaticFloatMethod,
+    CVMjniCallStaticFloatMethodV,
+    CVMjniCallStaticFloatMethodA,
+    CVMjniCallStaticDoubleMethod,
+    CVMjniCallStaticDoubleMethodV,
+    CVMjniCallStaticDoubleMethodA,
+    CVMjniCallStaticVoidMethod,
+    CVMjniCallStaticVoidMethodV,
+    CVMjniCallStaticVoidMethodA,
+
+    CVMjniGetStaticFieldID,
+
+    CVMjniGetStaticObjectField,
+    CVMjniGetStaticBooleanField,
+    CVMjniGetStaticByteField,
+    CVMjniGetStaticCharField,
+    CVMjniGetStaticShortField,
+    CVMjniGetStaticIntField,
+    CVMjniGetStaticLongField,
+    CVMjniGetStaticFloatField,
+    CVMjniGetStaticDoubleField,
+
+    CVMjniSetStaticObjectField,
+    CVMjniSetStaticBooleanField,
+    CVMjniSetStaticByteField,
+    CVMjniSetStaticCharField,
+    CVMjniSetStaticShortField,
+    CVMjniSetStaticIntField,
+    CVMjniSetStaticLongField,
+    CVMjniSetStaticFloatField,
+    CVMjniSetStaticDoubleField,
+
+    CVMjniNewString,
+    CVMjniGetStringLength,
+    CVMjniGetStringChars,
+    CVMjniReleaseStringChars,
+
+    CVMjniNewStringUTF,
+    CVMjniGetStringUTFLength,
+    CVMjniGetStringUTFChars,
+    CVMjniReleaseStringUTFChars,
+
+    CVMjniGetArrayLength,
+ 
+    CVMjniNewObjectArray,
+    CVMjniGetObjectArrayElement,
+    CVMjniSetObjectArrayElement,
+
+    CVMjniNewBooleanArray,
+    CVMjniNewByteArray,
+    CVMjniNewCharArray,
+    CVMjniNewShortArray,
+    CVMjniNewIntArray,
+    CVMjniNewLongArray,
+    CVMjniNewFloatArray,
+    CVMjniNewDoubleArray,
+
+    CVMjniGetBooleanArrayElements,
+    CVMjniGetByteArrayElements,
+    CVMjniGetCharArrayElements,
+    CVMjniGetShortArrayElements,
+    CVMjniGetIntArrayElements,
+    CVMjniGetLongArrayElements,
+    CVMjniGetFloatArrayElements,
+    CVMjniGetDoubleArrayElements,
+
+    CVMjniReleaseBooleanArrayElements,
+    CVMjniReleaseByteArrayElements,
+    CVMjniReleaseCharArrayElements,
+    CVMjniReleaseShortArrayElements,
+    CVMjniReleaseIntArrayElements,
+    CVMjniReleaseLongArrayElements,
+    CVMjniReleaseFloatArrayElements,
+    CVMjniReleaseDoubleArrayElements,
+
+    CVMjniGetBooleanArrayRegion,
+    CVMjniGetByteArrayRegion,
+    CVMjniGetCharArrayRegion,
+    CVMjniGetShortArrayRegion,
+    CVMjniGetIntArrayRegion,
+    CVMjniGetLongArrayRegion,
+    CVMjniGetFloatArrayRegion,
+    CVMjniGetDoubleArrayRegion,
+
+    CVMjniSetBooleanArrayRegion,
+    CVMjniSetByteArrayRegion,
+    CVMjniSetCharArrayRegion,
+    CVMjniSetShortArrayRegion,
+    CVMjniSetIntArrayRegion,
+    CVMjniSetLongArrayRegion,
+    CVMjniSetFloatArrayRegion,
+    CVMjniSetDoubleArrayRegion,
+
+    CVMjniRegisterNatives,
+    CVMjniUnregisterNatives,
+
+    CVMjniMonitorEnter,
+    CVMjniMonitorExit,
+
+    CVMjniGetJavaVM,
+
+    CVMjniGetStringRegion,
+    CVMjniGetStringUTFRegion,
+
+    CVMjniGetPrimitiveArrayCritical,
+    CVMjniReleasePrimitiveArrayCritical,
+
+    CVMjniGetStringChars,     /* CVMjniGetStringCritical */
+    CVMjniReleaseStringChars, /* CVMjniReleaseStringCritical */
+
+    CVMjniNewWeakGlobalRef,
+    CVMjniDeleteWeakGlobalRef,
+
+    CVMjniExceptionCheck,
+
+    /* JNI_VERSION_1_4 additions: */
+    CVMjniNewDirectByteBuffer,
+    CVMjniGetDirectBufferAddress,
+    CVMjniGetDirectBufferCapacity
+};
+
+
+JNIEXPORT jint JNICALL
+JNI_GetDefaultJavaVMInitArgs(void *args_)
+{
+    return JNI_ERR;
+}
+
+static int numJVMs;
+
+/* 
+ * The classes to be initialized.
+ */
+const CVMClassBlock * classInitList[] = {
+    CVMsystemClass(java_lang_Class),
+    CVMsystemClass(java_lang_Float),
+    CVMsystemClass(java_lang_String),
+    CVMsystemClass(sun_misc_ThreadRegistry),
+    CVMsystemClass(java_lang_Shutdown),
+    CVMsystemClass(java_lang_ClassLoader),
+    CVMsystemClass(java_lang_ClassLoader_NativeLibrary),
+    CVMsystemClass(java_lang_Thread),
+};
+
+static const int classInitListLen = sizeof classInitList / sizeof classInitList[0];
+
+static CVMBool initializeClassList(CVMExecEnv* ee,
+				   char* errorStrBuf, 
+				   CVMInt32 sizeofErrorStrBuf,
+				   const CVMClassBlock** classList,
+				   const int numClasses)
+{
+    int i;
+    
+    for (i = 0; i < numClasses; i++) {
+	CVMClassBlock* cb = (CVMClassBlock*)classList[i];
+	CVMBool status;
+	/*
+	CVMconsolePrintf("Preparing to initialize %C\n",
+			 classList[i]);
+	*/
+	status = CVMclassInit(ee, cb);
+	if (!status) {
+	    CVMformatString(errorStrBuf, sizeofErrorStrBuf,
+			    "class initialization failed for %C", cb);
+	    return CVM_FALSE;
+	}
+    }
+    return CVM_TRUE;
+}
+
+static char*
+initializeSystemClass(JNIEnv* env)
+{
+    {
+	/* Call System.initializeSystemClass() via the JNI. This sets
+	   up the global properties table which
+	   CVM.parseCommandLineOptions(), below, will modify with
+	   user-defined property definitions. This was at one point
+	   called from a method called CVM.initialize() via
+	   reflection, but we have to be able to configure without 
+	   reflection. */
+	jclass systemClass;
+	jmethodID initMethodID;
+
+	systemClass = CVMcbJavaInstance(CVMsystemClass(java_lang_System));
+	initMethodID = (*env)->GetStaticMethodID(env, systemClass,
+						 "initializeSystemClass",
+						 "()V");
+	if (initMethodID == NULL) {
+	    return "can't find method "
+		"\"void java.lang.System.initializeSystemClass()\"";
+	}
+	(*env)->CallStaticVoidMethod(env, systemClass, initMethodID);
+	
+	if ((*env)->ExceptionCheck(env)) {
+	    (*env)->ExceptionDescribe(env);
+	    return "error during System.initializeSystemClass())\n";
+	}
+    }
+    return NULL;
+}
+
+static char*
+initializeThreadObjects(JNIEnv* env)
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+    
+    /*
+     * Create system ThreadGroup, main ThreadGroup, and main Thread object.
+     * These are all done in Thread.initMainThread().
+     */
+    jclass threadClass =
+	CVMcbJavaInstance(CVMsystemClass(java_lang_Thread));
+    jlong eetop = CVMvoidPtr2Long(ee);
+
+    CVMjniCallStaticVoidMethod(
+	    env, threadClass,
+	    CVMglobals.java_lang_Thread_initMainThread,
+	    java_lang_Thread_NORM_PRIORITY, eetop);
+
+    /* 
+     * An exception may occur during the main thread initialization phase. 
+     */ 
+    if (CVMexceptionOccurred(ee)) {
+	return "initialization of main thread failed";
+    }
+    return NULL; /* success */
+}
+
+#ifdef CVM_CLASSLOADING
+#define CVM_CLASSLOADING_OPTIONS \
+    "[-Xbootclasspath[/a | /p]:<path>] [-Xverify[:{all | remote | none}] "
+#else
+#define CVM_CLASSLOADING_OPTIONS
+#endif
+
+#ifdef CVM_SPLIT_VERIFY
+#define CVM_SPLIT_VERIFY_OPTIONS "[-XsplitVerify={true|false}] "
+#else
+#define CVM_SPLIT_VERIFY_OPTIONS
+#endif
+
+#ifdef CVM_DEBUG
+#define CVM_DEBUG_OPTIONS "[-Xtrace:<val>] "
+#else
+#define CVM_DEBUG_OPTIONS
+#endif
+
+#ifdef CVM_JVMTI
+#define CVM_JVMTI_OPTIONS "[-agentlib | -agentpath] "
+    /* XRUN_OPTIONS is setup below */
+#else
+#define CVM_JVMTI_OPTIONS
+#endif
+
+#ifdef CVM_JVMPI
+#define CVM_JVMPI_OPTIONS "[-Xrunhprof] [-Xrunjcov] "
+/* XRUN_OPTIONS is setup below */
+#else
+#define CVM_JVMPI_OPTIONS
+#endif
+
+#ifdef CVM_XRUN
+#define CVM_XRUN_OPTIONS "[-Xrun<lib>[:<options>]] "
+#else
+#define CVM_XRUN_OPTIONS
+#endif
+
+#ifndef CVM_JIT
+#define CVM_JIT_OPTIONS
+#endif
+
+#ifdef CVM_MTASK
+#define CVM_MTASK_OPTIONS "[-Xserver[:<portNumber>]] "
+#else
+#define CVM_MTASK_OPTIONS
+#endif
+
+#ifndef CDC_10
+#define CVM_JAVA_ASSERTION_OPTIONS \
+        "-ea[:<packagename>...|:<classname>] " \
+        "-enableassertions[:<packagename>...|:<classname>] " \
+        "-da[:<packagename>...|:<classname>] " \
+        "-disableassertions[:<packagename>...|:<classname>] " \
+        "-esa -enablesystemassertions -dsa -disablesystemassertions "
+#else
+#define CVM_JAVA_ASSERTION_OPTIONS
+#endif
+
+#define CVM_NATIVE_OPTIONS \
+        CVM_MTASK_OPTIONS \
+	CVM_JAVA_ASSERTION_OPTIONS \
+	CVM_CLASSLOADING_OPTIONS \
+	CVM_SPLIT_VERIFY_OPTIONS \
+	CVM_JVMTI_OPTIONS \
+	CVM_JVMPI_OPTIONS \
+	CVM_XRUN_OPTIONS \
+	"[-XfullShutdown] " \
+	"[-XunlimitedGCRoots] " \
+	"[-XtimeStamping] " \
+	CVM_GC_OPTIONS \
+	"[-Xms<size>] " \
+	"[-Xmn<size>] " \
+	"[-Xmx<size>] " \
+	"[-Xss<size>] " \
+	"[-Xopt:[<option>[,<option>]...]] " \
+	CVM_JIT_OPTIONS \
+	CVM_DEBUG_OPTIONS
+
+/* Allocate an array of Strings and pass it as argument to
+   CVM.parseCommandLineOptions(), which will add any user-defined
+   properties to the global properties table and optionally find
+   the main class name and arguments.
+   
+   %comment: rt024
+   
+   NOTE we skip any options that were recognized in the first phase
+   of initialization
+*/
+char*
+CVMparseCommandLineOptions(JNIEnv* env, JavaVMInitArgs* initArgs, 
+			   CVMInt32 numUnrecognizedOptions)
+{
+    jarray jInitArgs;
+    CVMInt32 i, index;
+    jclass cvmClass;
+    jmethodID initMethodID;
+    jint result;
+    jstring nativeOptions = NULL;
+    
+    jInitArgs = (*env)->NewObjectArray(
+            env, numUnrecognizedOptions,
+	    CVMcbJavaInstance(CVMsystemClass(java_lang_String)),
+	    NULL);
+    if (jInitArgs == NULL) {
+	return "out of memory while allocating jInitArgs";
+    }
+    index = 0;
+    for (i = 0; i < initArgs->nOptions; i++) {
+	/* Unrecognized options have optionString != NULL. */
+	if (initArgs->options[i].optionString != NULL) {
+	    jobject jstr =
+		(*env)->NewStringUTF(env,
+				     initArgs->options[i].optionString);
+	    if (jstr == NULL) {
+		return "out of memory while allocating jInitArgs";
+	    }
+	    (*env)->SetObjectArrayElement(env, jInitArgs, index, jstr);
+	    ++index;
+	    (*env)->DeleteLocalRef(env, jstr);
+	}
+    }
+    CVMassert(index == numUnrecognizedOptions);
+    
+    nativeOptions = (*env)->NewStringUTF(env, CVM_NATIVE_OPTIONS);
+    if (nativeOptions == NULL) {
+	return "out of memory while allocating nativeOptions";
+    }
+    
+    cvmClass = CVMcbJavaInstance(CVMsystemClass(sun_misc_CVM));
+    initMethodID = (*env)->GetStaticMethodID(
+            env, cvmClass,
+	    "parseCommandLineOptions",
+	    "([Ljava/lang/String;Ljava/lang/String;Z)I");
+    CVMassert(initMethodID != NULL);
+    result = (*env)->CallStaticIntMethod(env, cvmClass, initMethodID,
+					     jInitArgs, nativeOptions,
+					     initArgs->ignoreUnrecognized);
+    if ((*env)->ExceptionCheck(env)) {
+	/*
+	 * If an exception occurs, the result from the JNI call
+	 * cannot be trusted. Make it an error.  
+	 */
+	(*env)->ExceptionDescribe(env);
+	return "exception during sun.misc.CVM.parseCommandLineOptions()";
+    }
+    if (result == sun_misc_CVM_ARG_PARSE_ERR ||
+	result == sun_misc_CVM_ARG_PARSE_USAGE) {
+	    CVMoptPrintUsage();
+#ifdef CVM_JIT
+	    CVMjitPrintUsage();
+#endif
+    }
+    switch(result) {
+    case sun_misc_CVM_ARG_PARSE_ERR:
+	return ""; /* Usage already printed out */
+    case sun_misc_CVM_ARG_PARSE_USAGE:
+    case sun_misc_CVM_ARG_PARSE_EXITVM:
+#ifdef CVM_CLASSLOADING
+	/* to make sure we can exit */
+	if (!CVMclassClassPathInit(env)) { 
+	    return "Failed to initialize app classpath";
+	}
+#endif /* CVM_CLASSLOADING */
+	break;
+    default:
+	CVMassert(result == sun_misc_CVM_ARG_PARSE_OK);
+    }
+    
+    (*env)->DeleteLocalRef(env, nativeOptions);
+    (*env)->DeleteLocalRef(env, jInitArgs);
+    return NULL;
+}
+
+#ifdef CVM_MTASK
+void
+CVMmtaskServerCommSocket(JNIEnv* env, CVMInt32 commSocket)
+{
+    CVMglobals.commFd = commSocket;
+}
+
+static void
+mtaskJvmtiInit(JNIEnv* env)
+{
+#ifdef CVM_JVMTI
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+    if (CVMjvmtiIsEnabled()) {
+	CVMjvmtiPostVmInitEvent(ee);    
+
+	/*
+	 * The debugger event hook might have thrown an exception
+	 */
+	if ((*env)->ExceptionCheck(env)) {
+	    (*env)->ExceptionDescribe(env);
+	    fprintf(stderr, "Error during JVMTI_EVENT_VM_INIT handling");
+	    exit(1);
+	} else {
+	    CVMjvmtiDebugEventsEnabled(ee) = CVM_TRUE;
+	}
+	
+	if (CVMjvmtiShouldPostThreadLife()) {
+	    CVMjvmtiPostThreadStartEvent(ee, CVMcurrentThreadICell(ee));
+	}
+	/*
+	 * The debugger event hook might have thrown an exception
+	 */
+	if ((*env)->ExceptionCheck(env)) {
+	    (*env)->ExceptionDescribe(env);
+	    fprintf(stderr, "Error during JVMTI_EVENT_THREAD_START handling");
+	    exit(1);
+	}
+    }
+#endif
+}
+
+static void
+mtaskJvmpiInit(JNIEnv* env)
+{
+#ifdef CVM_JVMPI
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+
+    CVMjvmpiPostStartUpEvents(ee);
+
+    if ((*env)->ExceptionCheck(env)) {
+	(*env)->ExceptionDescribe(env);
+	fprintf(stderr, "Error during JVMPI VM startup events handling");
+	exit(1);
+    }
+
+#ifdef CVM_JVMPI_PROFILER
+    /*
+     * If we are including JVMPI support for a specific profiler, then
+     * do the profiler specific initialization.
+     */
+    CVMJVMPIprofilerInit(ee);
+    if ((*env)->ExceptionCheck(env)) {
+	(*env)->ExceptionDescribe(env);
+	fprintf(stderr, "Error during JVMPI profiler init");
+	exit(1);
+    }
+#endif
+#endif
+}
+
+void
+CVMmtaskReinitializeChildVM(JNIEnv* env, CVMInt32 clientId)
+{
+    CVMglobals.clientId = clientId;
+
+    if (clientId != 0) {
+#ifdef CVM_JIT
+        /*
+         * Set CVMglobals.jit.isPrecompiling to false to allow
+         * patch enabled code being generated in child process.
+         */
+        CVMglobals.jit.isPrecompiling = CVM_FALSE;
+#endif
+
+        mtaskJvmtiInit(env);
+
+        mtaskJvmpiInit(env);
+    }
+}
+
+void
+CVMmtaskServerPort(JNIEnv* env, CVMInt32 serverPort)
+{
+    CVMglobals.serverPort = serverPort;
+}
+
+
+
+#ifdef CVM_TIMESTAMPING
+jboolean
+CVMmtaskTimeStampReinitialize(JNIEnv* env) 
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+
+    if (!CVMtimeStampFinishup(ee)) {
+	return JNI_FALSE;
+    }
+    CVMtimeStampWallClkInit();
+    if (!CVMtimeStampStart(ee)) {
+	return JNI_FALSE;
+    }
+
+    return JNI_TRUE;
+}
+
+jboolean
+CVMmtaskTimeStampRecord(JNIEnv* env, const char* loc, int pos) 
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+
+    return CVMtimeStampRecord(ee, loc, pos);
+}    
+#endif
+
+#if defined(CVM_HAVE_DEPRECATED) || defined(CVM_THREAD_SUSPENSION)
+extern void
+CVMmtaskHandleSuspendChecker()
+{
+    if (CVMglobals.suspendCheckerInitialized) {
+	CVMconsolePrintf("Suspend checker shutting down\n");
+	CVMsuspendCheckerDestroy();	    
+	CVMglobals.suspendCheckerInitialized = CVM_FALSE;
+    }
+}
+#endif
+#endif
+
+/*
+ * Returns error string on failure, NULL on success
+ */
+static char*
+initializeSystemClasses(JNIEnv* env,
+			char* errorStrBuf,
+			CVMInt32 sizeofErrorStrBuf,
+			JavaVMInitArgs* initArgs, 
+			CVMInt32 numUnrecognizedOptions)
+{
+    CVMExecEnv* ee = CVMjniEnv2ExecEnv(env);
+    char* errorStr;
+
+#ifdef CVM_CLASSLOADING
+    /* init bootclasspath before doing System.initializeSystemClass()*/
+    if (!CVMclassBootClassPathInit(env)) {
+	return "Failed to initialize bootclasspath";
+    }
+#endif
+
+    /* First ensure that we have no clinit for sun_misc_CVM before proceeding
+       with class initialization of system classes: */
+    if (CVMclassGetMethodBlock(CVMsystemClass(sun_misc_CVM),
+			       CVMglobals.clinitTid, CVM_TRUE) != NULL) {
+	CVMconsolePrintf("WARNING: sun.misc.CVM has a static initializer!\n");
+    }
+
+    /* 
+     * Set initialization flag for sun_misc_CVM to prevent executing
+     * its clinit. This is a work around for bug 4645152 in JDK 1.4
+     * javac, which incorrectly inserts <clinit> in class files when
+     * -g is specified. When 4645152 is fixed in javac, we can replace
+     * the work around with an assert:
+     * CVMassert(CVMclassGetMethodBlock(CVMsystemClass(sun_misc_CVM),
+     *     CVMglobals.clinitTid, CVM_TRUE) == NULL);
+     */
+    CVMcbSetROMClassInitializationFlag(ee, CVMsystemClass(sun_misc_CVM));
+
+    /* First do the initialization that doesn't require thread support */
+    if (!initializeClassList(ee, errorStrBuf, sizeofErrorStrBuf,
+			     classInitList, classInitListLen)) {
+	errorStr = errorStrBuf;
+	return errorStr;
+    }
+    
+    /* Prepare for thread creation */
+    if ((errorStr = initializeThreadObjects(env)) != NULL) {
+	return errorStr;
+    }
+    
+#ifdef CVM_LVM /* %begin lvm */
+    /* Now we can finish up CVMglobals.lvm initialization.
+     * This creates the main (primordial) LogicalVM object. */
+    if (!CVMLVMglobalsInitPhase2(ee, &CVMglobals.lvm)) {
+	errorStr = "out of memory during LVM initialization";
+        return errorStr;
+    }
+#endif /* %end lvm */
+
+    /* Initialize java.lang.System */
+    if ((errorStr = initializeSystemClass(env)) != NULL) {
+	return errorStr;
+    }
+    
+    /* Parse the command line options that are passed in 
+       (mostly done in sun.misc.CVM) */
+    errorStr = CVMparseCommandLineOptions(env, initArgs, 
+					  numUnrecognizedOptions);
+    if (errorStr != NULL) {
+	return errorStr;
+    }
+    
+    /* Now that we've parsed command line options, we can set up the
+       app class path as well. */
+#ifdef CVM_CLASSLOADING
+    if (!CVMclassClassPathInit(env)) { 
+	return "Failed to initialize app classpath";
+    }
+#endif /* CVM_CLASSLOADING */
+
+#ifdef CVM_MTASK
+    if (CVMglobals.isServer) {
+	/* Any server-only functions go in here */
+    }
+#endif
+    
+    return NULL;
+}
+
+/* Purpose: Prints a message about the erroneous use of the specified memory
+            sizing option. */
+static void printMemorySizeSpecificationError(const char *option)
+{
+    CVMconsolePrintf("Illegal %s option: no size specified\n"
+		     "\tUsage: %s<size> e.g. %s1m\n"
+		     "\tNote: Do not insert spaces between %s and the size.\n",
+		     option, option, option, option);
+}
+
+JNIEXPORT jint JNICALL
+JNI_CreateJavaVM(JavaVM **p_jvm, void **p_env, void *args)
+{
+    CVMExecEnv *ee = NULL;
+    JNIEnv *env;
+    int argCtr;
+    const CVMProperties *sprops;
+    CVMOptions options;
+    JavaVMInitArgs* initArgs = (JavaVMInitArgs*) args;
+    CVMInt32 numUnrecognizedOptions = 0;
+
+    char *errorStr = NULL;
+    char errorStrBuf[256];
+    int  errorNo = JNI_OK;
+#ifdef CVM_AGENTLIB
+    CVMInt32 numAgentlibArguments = 0;
+#endif
+#ifdef CVM_XRUN
+    CVMInt32 numXrunArguments = 0;
+    char **xrunArguments = NULL;
+#endif
+#ifdef CVM_CLASSLOADING
+    char *xbootclasspath = NULL;
+#endif
+    CVMBool userHomePropSpecified = CVM_FALSE; /* -Duser.home specified */
+    CVMBool userNamePropSpecified = CVM_FALSE; /* -Duser.name specified */
+    CVMpathInfo pathInfo;
+    const char *sunlibrarypathStr = NULL;
+
+    /*
+     * If the current system time is set to be before January 1, 1970,
+     * a NullPointerException would be thrown when running the static
+     * initializer of java.lang.System during the main thread
+     * initialization phase later. So we just check the time here.
+     */
+    if (CVMtimeMillis() <= 0) {
+        errorStr = "current system time before January 1, 1970 ";
+        errorNo = JNI_ERR;
+        goto done; 
+    }
+
+    if (initArgs == NULL) {
+	errorStr = "arguments passed via Invocation API were NULL";
+	errorNo = JNI_EINVAL;
+	goto done;
+    }
+
+    memset(&options, 0, sizeof options);
+    memset(&pathInfo, 0, sizeof pathInfo);
+
+#ifndef CDC_10
+    /* assertions are off by default */
+    options.javaAssertionsUserDefault = CVM_FALSE;
+    options.javaAssertionsSysDefault = CVM_FALSE;
+#endif
+
+    /* %comment: rt021 */
+    if (numJVMs == 0) {
+	if (!CVMinitStaticState(&pathInfo)) {
+	    errorStr = "CVMinitStaticState failed";
+	    errorNo = JNI_ENOMEM;
+	    goto done;
+	}
+    }
+
+    /*
+     * Get the default platform dependent value for bootclasspath,
+     * etc.
+     */ 
+    sprops = CVMgetProperties();
+
+#ifdef CVM_CLASSLOADING
+#ifndef NO_JDK_COMPATABILITY
+    /*
+     * The default value of java.class.path
+     * If NO_JDK_COMPATABILITY is not set, the default value of
+     * our class path is ., unless one is explicitly indicated.
+     *
+     */
+    options.appclasspathStr = ".";
+#endif
+
+    /*
+     * The default verification mode is CVM_VERIFY_REMOTE
+     */
+    options.classVerificationLevel = CVM_VERIFY_REMOTE;
+
+#ifdef CVM_SPLIT_VERIFY
+    options.splitVerify = CVM_TRUE;
+#endif
+#endif
+
+    for (argCtr = 0; argCtr < initArgs->nOptions; argCtr++) {
+
+	const char *str = initArgs->options[argCtr].optionString;
+	if (!strncmp(str, "-Xms", 4)) {
+	    options.startHeapSizeStr = str + 4;
+	    if (options.startHeapSizeStr[0] == '\0') {
+		printMemorySizeSpecificationError("-Xms");
+		errorNo = JNI_EINVAL;
+		goto done;
+	    }
+	} else if (!strncmp(str, "-Xmn", 4)) {
+	    options.minHeapSizeStr = str + 4;
+	    if (options.minHeapSizeStr[0] == '\0') {
+		printMemorySizeSpecificationError("-Xmn");
+		errorNo = JNI_EINVAL;
+		goto done;
+	    }
+	} else if (!strncmp(str, "-Xmx", 4)) {
+	    options.maxHeapSizeStr = str + 4;
+	    if (options.maxHeapSizeStr[0] == '\0') {
+		printMemorySizeSpecificationError("-Xmx");
+		errorNo = JNI_EINVAL;
+		goto done;
+	    }
+	} else if (!strncmp(str, "-Xss", 4)) {
+	    options.nativeStackSizeStr = str + 4;
+	    if (options.nativeStackSizeStr[0] == '\0') {
+		printMemorySizeSpecificationError("-Xss");
+		errorNo = JNI_EINVAL;
+		goto done;
+	    }
+#ifdef CVM_MTASK
+	} else if (!strncmp(str, "-Xserver", 8)) {
+	    options.isServer = CVM_TRUE;
+#endif
+	} else if (!strncmp(str, "-Xopt:", 6)) {
+	    if (options.optAttributesStr != NULL) {
+		CVMconsolePrintf("Previous -Xopt:%s ignored.\n",
+				 options.optAttributesStr);
+	    }
+	    options.optAttributesStr = str + 6;
+	} else if (!strncmp(str, "-Xgc:", 5)) {
+	    if (options.gcAttributesStr != NULL) {
+		CVMconsolePrintf("Previous -Xgc:%s ignored.\n",
+				 options.gcAttributesStr);
+	    }
+	    options.gcAttributesStr = str + 5;
+#ifdef CVM_JIT
+	} else if (!strncmp(str, "-Xjit:", 6)) {
+	    if (options.jitAttributesStr != NULL) {
+		CVMconsolePrintf("Previous -Xjit:%s ignored.\n",
+				 options.jitAttributesStr);
+	    }
+	    options.jitAttributesStr = str + 6;
+#endif
+	}
+#ifdef CVM_CLASSLOADING
+	else if (!strcmp(str, "-Xverify")) {
+	    options.classVerificationLevel = CVM_VERIFY_ALL;
+	} else if (!strncmp(str, "-Xverify:", 9)) {
+	    char* kind = (char*)str + 9;
+	    int verification = CVMclassVerificationSpecToEncoding(kind);
+	    if (verification != CVM_VERIFY_UNRECOGNIZED) {
+		options.classVerificationLevel = verification;
+	    } else {
+		CVMconsolePrintf("Illegal -Xverify option: \"%s\"\n",
+				 kind);
+		errorNo = JNI_EINVAL;
+		goto done;
+	    }	    
+#ifdef CVM_SPLIT_VERIFY
+	} else if (!strncmp(str, "-XsplitVerify=", 14)) {
+	    char* value = (char*)str + 14;
+            if (!strcmp(value, "true")) {
+                options.splitVerify = CVM_TRUE;
+            } else if (!strcmp(value, "false")) {
+                options.splitVerify = CVM_FALSE;
+	    } else {
+		CVMconsolePrintf("Illegal -XsplitVerify option: \"%s\"\n",
+				 value);
+		errorNo = JNI_EINVAL;
+		goto done;
+	    }	    
+#endif
+	}
+        else if (!strncmp(str, "-Xbootclasspath=", 16) ||
+                 !strncmp(str, "-Xbootclasspath:", 16)) {
+            options.bootclasspathStr = str + 16;
+            /* user has set bootclasspath, it overrides any
+             * -Xbootclasspath/a or /p
+             */
+            if (pathInfo.preBootclasspath != NULL) {
+                free(pathInfo.preBootclasspath);
+                pathInfo.preBootclasspath = NULL;
+            }
+            if (pathInfo.postBootclasspath != NULL) {
+                free(pathInfo.postBootclasspath);
+                pathInfo.postBootclasspath = NULL;
+            }
+        }
+        else if (!strncmp(str, "-Xbootclasspath/a=", 18) ||
+                 !strncmp(str, "-Xbootclasspath/a:", 18)) {
+            const char* p = str + 18;
+            char* tmp = pathInfo.postBootclasspath;
+            pathInfo.postBootclasspath = (char *)
+                malloc(strlen(p) +
+                       (tmp == NULL ? 0 : strlen(tmp)) +
+                       strlen(CVM_PATH_CLASSPATH_SEPARATOR) + 1);
+            if (pathInfo.postBootclasspath == NULL) {
+                errorStr = "out of memory while parsing -Xbootclasspath";
+		errorNo = JNI_ENOMEM;
+		goto done;
+            }
+            if (tmp != NULL) {
+                sprintf(pathInfo.postBootclasspath, "%s%s%s", 
+                        tmp, CVM_PATH_CLASSPATH_SEPARATOR, p);
+                free(tmp);
+            } else {
+                pathInfo.postBootclasspath = strdup(p);
+            }
+        }
+        else if (!strncmp(str, "-Xbootclasspath/p=", 18) ||
+                 !strncmp(str, "-Xbootclasspath/p:", 18)) {
+            const char* p = str + 18;
+            char* tmp = pathInfo.preBootclasspath;
+            pathInfo.preBootclasspath = (char *)
+                malloc(strlen(p) +
+                       (tmp == NULL ?
+                        0 : strlen(tmp)) +
+                       strlen(CVM_PATH_CLASSPATH_SEPARATOR) + 1);
+            if (pathInfo.preBootclasspath == NULL) {
+                errorStr = "out of memory while parsing -Xbootclasspath";
+                errorNo = JNI_ENOMEM;
+                goto done;
+            }
+            if (tmp != NULL) {
+                sprintf(pathInfo.preBootclasspath, "%s%s%s", 
+                        p, CVM_PATH_CLASSPATH_SEPARATOR, tmp);
+                free(tmp);
+            } else {
+                pathInfo.preBootclasspath = strdup(p);
+            }
+        }
+#ifdef NO_JDK_COMPATABILITY
+        else if (!strncmp(str, "-Dsun.boot.class.path=", 22)) { 
+            if (xbootclasspath != NULL) {
+                free(xbootclasspath);
+            }
+            options.bootclasspathStr = str + 22;
+        }
+#endif
+        else if (!strncmp(str, "-Djava.class.path=", 18)) {
+            options.appclasspathStr = str + 18;
+	    /* This class path value will be extracted and put into
+	       the system property java.class.path by
+	       JVM_InitProperties(). So we don't pass it into
+	       CVM.parseCommandLineOptions(). */
+        }
+#endif                   
+        else if (!strncmp(str, "-Duser.home=", 12)) {
+           /* CR 6246485 We merely want to record that this has
+              been set, but not consume it, so that it can be passed
+              to CVM.java */
+            userHomePropSpecified = CVM_TRUE;
+            ++numUnrecognizedOptions;
+            continue;
+         }
+         else if (!strncmp(str, "-Duser.name=", 12)) {
+           /* CR 6246485 We merely want to record that this has
+              been set, but not consume it, so that it can be passed
+              to CVM.java */
+            userNamePropSpecified = CVM_TRUE;
+            ++numUnrecognizedOptions;
+            continue;
+         }
+        else if (!strncmp(str, "-Xcp=", 5)) {
+            options.appclasspathStr = str + 5;
+
+            /* pass this to CVM.java still, so we can free up the memory 
+               later on */
+            ++numUnrecognizedOptions;
+            continue;
+        }
+
+        else if (!strncmp(str, "-Xjar=", 6)) {
+          options.appclasspathStr = str + 6;
+          /* Note: The code below is so that the -jar value can be passed
+             up to CVM.parseCommandOptions(). Please do not remove. */                
+          ++numUnrecognizedOptions;
+	  continue;
+        } 
+
+#ifndef CDC_10
+	/* java assertion handling */
+	else if (!strncmp(str, "-ea:", 4)) {
+	    CVMBool success = CVMJavaAssertions_addOption(
+		str + 4, CVM_TRUE,
+		&options.javaAssertionsClasses,
+		&options.javaAssertionsPackages);
+	    if (!success) goto addOption_failed;
+	} else if (!strncmp(str, "-enableassertions:", 18)) {
+	    CVMBool success = CVMJavaAssertions_addOption(
+                str + 18, CVM_TRUE,
+		&options.javaAssertionsClasses,
+		&options.javaAssertionsPackages);
+	    if (!success) goto addOption_failed;
+	} else if (!strncmp(str, "-da:", 4)) {
+	    CVMBool success = CVMJavaAssertions_addOption(
+                str + 4, CVM_FALSE,
+		&options.javaAssertionsClasses,
+		&options.javaAssertionsPackages);
+	    if (!success) goto addOption_failed;
+	} else if (!strncmp(str, "-disableassertions:", 18)) {
+	    CVMBool success;
+	    success = CVMJavaAssertions_addOption(
+                str + 19, CVM_FALSE,
+		&options.javaAssertionsClasses,
+		&options.javaAssertionsPackages);
+            if (!success) {
+	addOption_failed:
+                errorStr = "out of memory while parsing assertion option";
+		errorNo = JNI_ENOMEM;
+		goto done;
+            }
+	} else if (!strcmp(str, "-ea") |
+		   !strcmp(str, "-enableassertions")) {
+	    options.javaAssertionsUserDefault = CVM_TRUE;
+	} else if (!strcmp(str, "-da") |
+		   !strcmp(str, "-disableassertions")) {
+	    options.javaAssertionsUserDefault = CVM_FALSE;
+	} else if (!strcmp(str, "-esa") |
+		   !strcmp(str, "-enablesystemassertions")) {
+	    options.javaAssertionsSysDefault = CVM_TRUE;
+	} else if (!strcmp(str, "-dsa") |
+		   !strcmp(str, "-disablesystemassertions")) {
+	    options.javaAssertionsSysDefault = CVM_FALSE;
+	}
+#endif
+
+	/* NOTE that -Xdebug must currently be handled before
+           CVMpreloaderGenerateAllStackmaps() is called */
+	else if (!strcmp(str, "-Xdebug")) {
+#ifdef CVM_JVMTI
+	    options.debugging = CVM_TRUE;
+#else
+	    errorStr =
+		"-Xdebug specified, but debugging support not compiled in";
+	    errorNo = JNI_EINVAL;
+	    goto done;
+#endif
+#ifdef CVM_TRACE_ENABLED
+	} else if (!strncmp(str, "-Xtrace:", 8)) {
+	    options.traceFlagsStr = str + 8;
+#endif
+	} else if (!strcmp(str, "vfprintf")) {
+	    options.vfprintfHook = initArgs->options[argCtr].extraInfo;
+	} else if (!strcmp(str, "exit")) {
+	    options.exitHook = initArgs->options[argCtr].extraInfo;
+	} else if (!strcmp(str, "abort")) {
+	    options.abortHook = initArgs->options[argCtr].extraInfo;
+	} else if (!strcmp(str, "_safeExit")) {
+	    options.safeExitHook = initArgs->options[argCtr].extraInfo;
+	} else if (!strcmp(str, "-XtimeStamping")) {
+#ifdef CVM_TIMESTAMPING
+	    options.timeStampEnabled = CVM_TRUE;
+#else
+	    errorStr =
+		"-XtimeStamping specified, but timestamping support not compiled in";
+	    errorNo = JNI_EINVAL;
+	    goto done;
+#endif
+	} else if (!strcmp(str, "-XfullShutdown")) {
+#ifdef CVM_HAVE_PROCESS_MODEL
+	    options.fullShutdownFlag = CVM_TRUE;
+#endif
+	} else if (!strcmp(str, "-XunlimitedGCRoots")) {
+            options.unlimitedGCRoots = CVM_TRUE;
+#ifdef CVM_AGENTLIB
+	} else if (!strncmp(str, "-agentlib:", 10) ||
+               !strncmp(str, "-agentpath:", 11)) {
+	    ++numAgentlibArguments;
+	    if (numAgentlibArguments > 1) {
+		/* currently only support one agent connection
+		 * At some point in the future we will support multiple
+		 * agent connections.
+		 */
+		CVMconsolePrintf("WARNING: Only one agent connection supported!\n");
+	    }
+
+	    /* Don't set the optionString to NULL, so we can take care
+           of this on the next pass */
+	    continue;
+#endif
+#ifdef CVM_XRUN
+	} else if (!strncmp(str, "-Xrun", 5)) {
+	    ++numXrunArguments;
+	    /* Don't set the optionString to NULL, so we can take care
+               of this on the next pass */
+	    continue;
+#endif
+	} else if (!strncmp(str, "-Dsun.boot.library.path=", 24)) {
+            sunlibrarypathStr = str + 24;
+            ++numUnrecognizedOptions;
+            continue;
+	} else {
+	    /* Unrecognized option, pass to Java */
+	    ++numUnrecognizedOptions;
+	    continue;
+	}
+
+	/* Recognized options fall through to here */
+	initArgs->options[argCtr].optionString = NULL;
+    }
+
+#ifdef CVM_XRUN
+    /* Now snag -Xrun arguments so we can run them after initializing
+       the VM */
+    if (numXrunArguments > 0) {
+	int i = 0;
+	xrunArguments = malloc(numXrunArguments * sizeof(char *));
+	if (xrunArguments == NULL) {
+	    errorStr = "out of memory parsing -Xrun arguments";
+	    errorNo = JNI_ENOMEM;
+	    goto done;
+	}
+	for (argCtr = 0; argCtr < initArgs->nOptions; argCtr++) {
+	    const char *str = initArgs->options[argCtr].optionString;
+	    if ((str != NULL) && (!strncmp(str, "-Xrun", 5))) {
+		xrunArguments[i] = (char *) str;
+		initArgs->options[argCtr].optionString = NULL;		
+		++i;
+	    }
+	}
+	CVMassert(i == numXrunArguments);
+    }
+#endif
+
+    if (sunlibrarypathStr != NULL) {
+        if (pathInfo.dllPath != NULL) {
+            free(pathInfo.dllPath);
+        }
+        pathInfo.dllPath = strdup(sunlibrarypathStr);
+    }
+
+    {
+        if (!CVMinitPathValues((void *)CVMgetProperties(), &pathInfo,
+                               (char **)&options.bootclasspathStr)) {
+            errorStr = "CVMinitPathValues failed";
+            errorNo = JNI_ERR;
+            goto done;
+        }
+    }
+
+    if (!CVMinitVMGlobalState(&CVMglobals, &options)) {
+	/* <tbd> - CVMinitVMGlobalState() should return the proper
+	 * JNI error code and have always already printed the error message.
+	 * Currently it does not, so we need to print out a message here.
+	 * See RFE #4680415
+	 */
+        errorStr = "CVMinitVMGlobalState failed";
+	errorNo = JNI_ERR;
+	goto done;
+    }
+
+    ee = &CVMglobals.mainEE;
+    CVMglobals.userHomePropSpecified = userHomePropSpecified;
+    CVMglobals.userNamePropSpecified = userNamePropSpecified;
+
+    *p_jvm = &CVMglobals.javaVM.vector;
+    env = CVMexecEnv2JniEnv(ee);
+    *p_env = (void *)env;
+
+#ifdef CVM_HW
+    CVMhwInit();
+#endif
+
+#ifdef CVM_JVMTI
+    CVMjvmtiEnterOnloadPhase();
+    CVMtimeThreadCpuClockInit(&ee->threadInfo);
+#endif
+
+#ifdef CVM_JVMTI_IOVEC
+    CVMinitIOVector(&CVMioFuncs);
+#endif
+    /* Run agents */
+    /* Agents run before VM is fully initialized */
+#ifdef CVM_AGENTLIB
+    /* Grab -agentlib arguments so we can run them */
+    /*
+     * NOTE: at this point we should go through the Xrun args
+     * to see if any could be converted to agentlib type
+     */
+    if (numAgentlibArguments > 0) {
+#ifdef CVM_DYNAMIC_LINKING
+      CVMAgentlibArg_t agentlibArgument;
+      /* Initialize unload list */
+      if (!CVMAgentInitTable(&CVMglobals.agentTable,
+                             numAgentlibArguments)) {
+	    errorStr = "CVMAgentInitTable() failed";
+	    errorNo = JNI_ENOMEM;
+	    goto done;
+      }
+      for (argCtr = 0; argCtr < initArgs->nOptions; argCtr++) {
+	    const char *str = initArgs->options[argCtr].optionString;
+	    if ((str != NULL)) {
+          agentlibArgument.is_absolute = CVM_FALSE;
+          if (!strncmp(str, "-agentlib:", 10) ||
+              !strncmp(str, "-agentpath:", 11)) {
+            agentlibArgument.str = (char *) str;
+            initArgs->options[argCtr].optionString = NULL;
+            if (!strncmp(str, "-agentpath:", 11)) {
+              agentlibArgument.is_absolute = CVM_TRUE;
+            }
+            if (!CVMAgentHandleArgument(&CVMglobals.agentTable, env,
+                                        &agentlibArgument)) {
+              CVMconsolePrintf("Cannot start VM "
+                "(error handling -agentlib or -agentpath argument %s)\n",
+                               agentlibArgument.str);
+              errorNo = JNI_ERR;
+              goto done;
+            } else {
+		/* loaded one agent, that's all we support right now */
+		break;
+	    }
+          }
+        }
+      }
+#ifdef CVM_JVMTI
+      CVMjvmtiEnterPrimordialPhase();
+#endif
+#else
+      errorStr = "-agentlib, -agentpath not supported - dynamic linking not built into VM";
+      errorNo = JNI_EINVAL;
+      goto done;
+#endif
+    }
+#endif
+
+#ifdef CVM_INSTRUCTION_COUNTING
+    /*
+     * Initialize byte-code statistics gathering
+     */
+    CVMinitStats();
+#endif /* CVM_INSTRUCTION_COUNTING */
+
+    /* record time-stamp at the VM beginning */
+#ifdef CVM_TIMESTAMPING
+    if (!CVMtimeStampStart(ee)) {
+        errorStr = "CVMtimeStampStart failed";
+	errorNo = JNI_ERR;
+	goto done;
+    }
+#endif
+
+    if (!CVMpreloaderDisambiguateAllMethods(ee)) {
+	errorStr = "method disambiguation failed";
+	errorNo = JNI_ERR;
+	goto done;
+    }
+
+    /* Initialize system classes, classpaths, and command line options */
+    if ((errorStr = initializeSystemClasses(env, 
+					    errorStrBuf,
+					    sizeof(errorStrBuf),
+					    initArgs, 
+					    numUnrecognizedOptions)) != NULL) {
+	errorNo = JNI_ERR;
+	goto done;
+    }
+
+#ifdef CVM_XRUN
+    /* Now that the VM is initialized, may need to handle "helper"
+       libraries for JVMTI/PI */
+    if (xrunArguments != NULL) {
+#ifdef CVM_DYNAMIC_LINKING
+        /* Initialize Xrun list */
+        if (!CVMXrunInitTable(&CVMglobals.onUnloadTable, numXrunArguments)) {
+	    errorStr = "CVMXrunInitTable() failed";
+	    errorNo = JNI_ENOMEM;
+	    goto done;
+	}
+ 	for (argCtr = 0; argCtr < numXrunArguments; argCtr++) {
+	    if (!CVMXrunHandleArgument(&CVMglobals.onUnloadTable, env,
+				       xrunArguments[argCtr])) {
+		CVMconsolePrintf("Cannot start VM "
+				 "(error handling -Xrun argument %s)\n",
+				 xrunArguments[argCtr]);
+		if ((*env)->ExceptionCheck(env)) {
+		    (*env)->ExceptionDescribe(env);
+		}
+		errorNo = JNI_ERR;
+		goto done;
+	    }
+	}
+#else
+	errorStr = "-Xrun not supported - dynamic linking not built into VM";
+	errorNo = JNI_EINVAL;
+	goto done;
+#endif
+    }
+#endif /* CVM_XRUN */
+
+#if defined(CVM_AOT) && !defined(CVM_MTASK)
+#ifdef CVM_JVMTI
+    if (!CVMjvmtiIsInDebugMode())
+#endif
+    {
+        if (!CVMjitCompileAOTCode(ee)) {
+	    errorStr = "error during AOT compilation";
+            errorNo = JNI_ERR;
+            goto done;
+        }
+    }
+#endif
+    
+#ifdef CVM_LVM /* %begin lvm */
+    /* Finish-up the main LVM bootstrapping after the VM gets 
+     * fully initialized */
+    if (!CVMLVMfinishUpBootstrapping(ee)) {
+	errorStr = "error during LVM initialization";
+	errorNo = JNI_ERR;
+	goto done;
+    }
+#endif /* %end lvm */
+
+#ifdef CVM_JVMTI
+    CVMjvmtiEnterPrimordialPhase();
+    if (CVMjvmtiIsEnabled()) {
+	/* This thread was not fully initialized */
+	jthread thread = CVMcurrentThreadICell(ee);
+	if (CVMjvmtiFindThread(ee, thread) == NULL) {
+	    CVMjvmtiInsertThread(ee, thread);
+	}
+    }
+    CVMjvmtiDebugEventsEnabled(ee) = CVM_TRUE;
+    CVMjvmtiEnterStartPhase();
+    CVMjvmtiPostVmStartEvent(ee);    
+    CVMjvmtiEnterLivePhase();
+    CVMjvmtiPostVmInitEvent(ee);
+
+    /*
+     * The debugger event hook might have thrown an exception
+     */
+    if ((*env)->ExceptionCheck(env)) {
+	(*env)->ExceptionDescribe(env);
+	errorStr = "error during JVMTI_EVENT_VM_INIT handling";
+	errorNo = JNI_ERR;
+	goto done;
+    }
+    if (CVMjvmtiIsEnabled()) {
+	CVMjvmtiPostStartUpEvents(ee);
+    }
+    /*
+     * The debugger event hook might have thrown an exception
+     */
+    if ((*env)->ExceptionCheck(env)) {
+	CVMjvmtiDebugEventsEnabled(ee) = CVM_FALSE;
+	(*env)->ExceptionDescribe(env);
+	errorStr = "error during JVMTI_EVENT_THREAD_START handling";
+	errorNo = JNI_ERR;
+	goto done;
+    }
+#endif
+
+#ifdef CVM_JVMPI
+    CVMjvmpiPostStartUpEvents(ee);
+    if ((*env)->ExceptionCheck(env)) {
+        errorStr = "error during JVMPI VM startup events handling";
+        errorNo = JNI_ERR;
+        goto done;
+    }
+
+    /*
+     * If we are including JVMPI support for a specific profiler, then
+     * do the profiler specific initialization.
+     */
+#ifdef CVM_JVMPI_PROFILER
+    CVMJVMPIprofilerInit(ee);
+    if ((*env)->ExceptionCheck(env)) {
+        errorStr = "error during JVMPI profiler init";
+        errorNo = JNI_ERR;
+        goto done;
+    }
+#endif
+
+#endif /* CVM_JVMPI */
+
+
+    /* In the future JVMPI will need to get a VM init event here as
+       well */
+
+#ifdef CVM_JVMTI
+
+#endif
+
+#ifdef CVM_EMBEDDED_HOOK
+    CVMhookVMStart(ee);
+#endif
+
+    /* In the future JVMPI will need to get a thread start event here
+       as well */
+
+    ++numJVMs;
+
+     /* record time-stamp at VM creation*/
+#ifdef CVM_TIMESTAMPING
+    CVMtimeStampRecord(ee, "VM Created", -1);
+    if (CVMlocalExceptionOccurred(ee)) {
+        errorStr = "CVMtimeStampRecord failed";
+	errorNo = JNI_ERR;
+	goto done;
+    }
+#endif
+
+#ifdef CVM_JIT_ESTIMATE_COMPILATION_SPEED
+    /* The estimation compiles the preloaded classes.  Hence, we should only
+       do this after disambiguating the preloaded classes.
+       Only do this estimation once.  Only doing it for the first VM instance
+       being created should do the trick.  This is a nice point in time
+       when the application isn't running yet and therefore won't interfere
+       with the estimation:
+    */
+    if (numJVMs == 1) {
+        CVMjitEstimateCompilationSpeed(ee);
+    }
+#endif
+
+ done:
+#ifdef CVM_CLASSLOADING
+    if (xbootclasspath != NULL) {
+	free(xbootclasspath);
+    }
+#endif
+#ifdef CVM_XRUN
+    if (xrunArguments != NULL) {
+	free(xrunArguments);
+    }
+#endif
+
+    CVMdestroyPathInfo(&pathInfo);
+
+    if (errorStr != NULL) {
+        CVMconsolePrintf("Cannot start VM (%s)\n", errorStr);
+	if (ee != NULL && CVMlocalExceptionOccurred(ee)) {
+	    CVMconsolePrintf("Exception during VM startup:\n", errorStr);
+	    CVMdumpException(ee);
+	}
+    }
+    return errorNo;
+}
+
+JNIEXPORT jint JNICALL
+JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs)
+{
+#ifdef JDK12
+    if (VM_created) {
+	if (numVMs)
+	    *numVMs = 1;
+	if (bufLen > 0)
+	    *vm_buf = (JavaVM *)(&main_vm);
+    } else
+	*numVMs = 0;
+    return JNI_OK;
+#else
+    if (numJVMs > 0) {
+	if (numVMs != NULL) {
+	    *numVMs = 1;
+	}
+	if (bufLen > 0) {
+	    *vm_buf = &CVMglobals.javaVM.vector;
+	}
+    } else {
+	if (numVMs != NULL) {
+	    *numVMs = 0;
+	}
+    }
+    return JNI_OK;
+#endif
+}
+
+static void
+CVMunlinkNativeLibraries(CVMExecEnv *ee)
+{
+        CVMFieldTypeID systemNativeLibrariesTID =
+            CVMtypeidLookupFieldIDFromNameAndSig(ee, "systemNativeLibraries",
+                                                 "Ljava/util/Vector;");
+        CVMFieldTypeID xrunNativeLibrariesTID =
+            CVMtypeidLookupFieldIDFromNameAndSig(ee, "xrunNativeLibraries",
+                                                 "Ljava/util/Vector;");
+        const CVMClassBlock *cb = CVMsystemClass(java_lang_ClassLoader);
+        CVMFieldBlock *systemNativeLibrariesFB = 
+            CVMclassGetStaticFieldBlock(cb, systemNativeLibrariesTID);
+        CVMFieldBlock *xrunNativeLibrariesFB = 
+            CVMclassGetStaticFieldBlock(cb, xrunNativeLibrariesTID);
+        CVMfbStaticField(ee, systemNativeLibrariesFB).raw = 0;
+        CVMfbStaticField(ee, xrunNativeLibrariesFB).raw = 0;
+}
+
+static jint JNICALL
+CVMjniDestroyJavaVM(JavaVM *vm)
+{
+    JNIEnv *env;
+    void *envV;
+    CVMExecEnv *ee;
+    jint res;
+
+    /* %comment: rt026 */
+    res = (*vm)->AttachCurrentThread(vm, &envV, NULL);
+    if (res < 0) {
+	return res;
+    }
+    env = (JNIEnv *)envV;
+    ee = CVMjniEnv2ExecEnv(env);
+
+#ifdef CVM_EMBEDDED_HOOK
+    CVMhookVMShutdown(ee);
+#endif
+
+    /* %comment d001 */
+    /* Wait for all the user threads exit and call the shutdown hooks 
+     * by invoking java.lang.Shutdown.shutdown() */
+    CVMjniCallStaticVoidMethod(env,
+	CVMcbJavaInstance(CVMsystemClass(java_lang_Shutdown)),
+	CVMglobals.java_lang_Shutdown_waitAllUserThreadsExitAndShutdown);
+
+    if (CVMlocalExceptionOccurred(ee)) {
+	/*
+	 * Ignore and clear the exception
+	 */
+	CVMconsolePrintf("Exception occurred during Shutdown.shutdown()\n");
+	CVMjniExceptionDescribe(env);
+	CVMclearLocalException(ee);
+    }
+
+    CVMprepareToExit();
+
+    CVMpostThreadExitEvents(ee);
+#ifdef CVM_JVMTI
+    if (CVMjvmtiIsEnabled()) {
+	CVMjvmtiPostVmExitEvent(ee);    
+	CVMjvmtiDebugEventsEnabled(ee) = CVM_FALSE;
+    }
+#endif
+
+    if (CVMglobals.fullShutdown) {
+	ee->threadExiting = CVM_TRUE;
+	/*
+	 * Disbale any remote exception during the shutdown process 
+	 */
+	CVMdisableRemoteExceptions(ee);
+
+	/*
+	 * Free nativeLibrary object refs and call JVM_onUnload
+	 * function for each if any.
+	 * We do this before calling ThreadRegistry.waitAllSystemThreadsExit()
+	 * because some system threads (like those created by the debugger 
+	 * agent) won't exit until JVM_OnUnload is called.
+	 */
+#ifdef CVM_XRUN
+	CVMXrunProcessTable(&CVMglobals.onUnloadTable, env, vm);
+#endif
+#ifdef CVM_AGENTLIB
+	CVMAgentProcessTableUnload(&CVMglobals.agentTable, env, vm);
+#endif
+
+	/*
+	 * Call sun.misc.ThreadRegistry.waitAllSystemThreadsExit()
+	 * to shutdown system threads
+	 */
+	CVMjniCallStaticVoidMethod(env,
+	    CVMcbJavaInstance(CVMsystemClass(sun_misc_ThreadRegistry)),
+	    CVMglobals.sun_misc_ThreadRegistry_waitAllSystemThreadsExit);
+
+	if (CVMlocalExceptionOccurred(ee)) {
+	    /*
+	     * Ignore and clear the exception
+	     */
+	    CVMconsolePrintf("Exception occurred during "
+			     "ThreadRegistry.waitAllSystemThreadsExit()\n");
+	    CVMjniExceptionDescribe(env);
+	    CVMclearLocalException(ee);
+	}
+	CVMwaitForAllThreads(ee);
+	/* Nullify the references to the native libraries.  This will allow GC
+	 * to finalize and collect the NativeLibrary objects, thereby unloading
+	 * them.  We can only safely do this after all threads have exited.
+	 */
+	CVMunlinkNativeLibraries(ee);
+
+    }
+
+
+#ifdef CVM_INSTRUCTION_COUNTING
+    /*
+     * We are at the end of the VM run. Dump byte-code stats.
+     */
+    CVMdumpStats();
+#endif
+
+#ifdef CVM_JIT
+#ifdef CVM_JIT_PROFILE
+     CVMJITcodeCacheDumpProfileData();
+#endif
+     CVMjitReportCompilationSpeed();
+     CVMJITstatsDumpGlobalStats();
+#ifdef CVM_GLOBAL_MICROLOCK_CONTENTION_STATS
+     {
+	 extern CVMUint32 slowMlockimplCount;
+	 extern CVMUint32 fastMlockimplCount;
+	 CVMconsolePrintf("SLOW m-LOCK COUNT = %d\n",
+			  slowMlockimplCount);
+	 CVMconsolePrintf("FAST m-LOCK COUNT = %d\n",
+			  fastMlockimplCount);
+     }     
+#endif
+#ifdef CVM_FASTALLOC_STATS
+     {
+	 extern CVMUint32 fastLockCount;
+	 extern CVMUint32 slowLockCount;
+	 extern CVMUint32 verySlowLockCount;
+	 CVMconsolePrintf("FASTCOUNT=%d, SLOWCOUNT=%d, VERYSLOWCOUNT=%d\n", 
+			  fastLockCount,
+			  slowLockCount,
+			  verySlowLockCount);
+     }
+#endif
+#endif
+
+#ifdef CVM_USE_MEM_MGR
+    CVMmemManagerDumpStats();
+#endif
+
+    /* record time-stamp at VM termination */
+#ifdef CVM_TIMESTAMPING
+    if (!CVMtimeStampFinishup(ee)) {
+        CVMconsolePrintf("CVMtimeStampFinishup failed\n");
+    }
+#endif
+
+#ifdef CVMJIT_COUNT_VIRTUAL_INLINE_STATS
+    /* See jitgrammarrules.jcs for details */
+    {
+        extern void CVMJITprintVirtualInlineHitMiss();
+        CVMJITprintVirtualInlineHitMiss();
+    }
+#endif
+
+    /*
+     * If we have a process model, then we cannot destroy the VM data
+     * structures, otherwise the daemon threads may crash.
+     */
+    /* %comment d002 */
+
+    if (CVMglobals.fullShutdown) {
+	CVMunloadApplicationclasses(ee);
+
+#ifdef CVM_CLASSLOADING
+	CVMclassBootClassPathDestroy(ee);
+	CVMclassClassPathDestroy(ee);
+	CVMpackagesDestroy();
+#endif
+	CVMdestroyVMGlobalState(ee, &CVMglobals);
+ 
+	/* 
+	 * We should probably call DetachCurrentThread, but
+         * CVMdestroyVMGlobalState has already destroyed the EE,
+         * so free it here.
+	 */
+
+	if (ee != &CVMglobals.mainEE) {
+	    free(ee);
+#ifdef CVM_DEBUG
+	    ee = NULL;
+#endif
+	}
+
+
+	/* %comment: rt028 */
+	if (numJVMs == 1) {
+	    CVMdestroyStaticState();
+	}
+
+    }
+
+#ifdef CVM_JIT
+    CVMCCMstatsDumpStats();
+#endif
+
+    --numJVMs;
+
+    return JNI_OK;
+}
+
+static jint JNICALL
+attachCurrentThread(JavaVM *vm, void **penv, void *_args, CVMBool isDaemon)
+{
+    JavaVMAttachArgs *args = (JavaVMAttachArgs *)_args;
+    /* %comment: rt029 */
+    CVMExecEnv *ee = CVMgetEE();
+    JNIEnv *env;
+
+    if (ee != NULL) {
+	/* already attached */
+        env = CVMexecEnv2JniEnv(ee);
+        *(JNIEnv **)penv = env;
+	/* %comment: rt030 */
+	return JNI_OK;
+    } else {
+	ee = (CVMExecEnv *)calloc(1, sizeof *ee);
+	if (ee == NULL) {
+	    return JNI_ERR;
+	}
+	if (!CVMinitExecEnv(ee, ee, NULL)) {
+	    free(ee);
+	    return JNI_ERR;
+	}
+	/* attach thread */
+	if (!CVMattachExecEnv(ee, CVM_TRUE)) {
+	    CVMdestroyExecEnv(ee);
+	    free(ee);
+	    return JNI_ERR;
+	}
+    
+	CVMaddThread(ee, !isDaemon);
+
+        env = CVMexecEnv2JniEnv(ee);
+        *(JNIEnv **)penv = env;
+
+	{
+	    /* allocate thread object */
+	    jclass threadClass =
+		CVMcbJavaInstance(CVMsystemClass(java_lang_Thread));
+	    jobject threadGroup = NULL;
+	    jobject threadName = NULL;
+	    jobject thread = NULL;
+	    jlong eetop;
+
+	    eetop = CVMvoidPtr2Long(ee);
+	    if (args && args->version >= JNI_VERSION_1_2) {
+		if (args->group != NULL) {
+		    threadGroup = args->group;
+		}
+		if (args->name != NULL) {
+		    threadName = CVMjniNewStringUTF(env, args->name);
+		    if (threadName == NULL) {
+			goto handleException;
+		    }
+		}
+	    }
+
+	    /* If the user doesn't supply a thread name, then create one now.
+	     * It's not safe to let Thread.initAttachedThread() do this,
+	     * since it relies on calling on java code that will result
+	     * in a NullPointerException when the current thread is not
+	     * yet set.
+	     */
+	    if (threadName == NULL) {
+		char buf[20];
+		jint threadNum = CVMjniCallStaticIntMethod(env, threadClass,
+		    CVMglobals.java_lang_Thread_nextThreadNum);
+		if (CVMexceptionOccurred(ee)) {
+		    goto handleException;
+		}
+		sprintf(buf, "Thread-%d", threadNum);
+		threadName = CVMjniNewStringUTF(env, buf);
+		if (threadName == NULL) {
+		    goto handleException;
+		}
+	    }
+
+	    /* Initialize Thread object of this attached thread */
+	    thread = CVMjniCallStaticObjectMethod(env, threadClass,
+		CVMglobals.java_lang_Thread_initAttachedThread,
+		threadGroup, threadName,
+		java_lang_Thread_NORM_PRIORITY, eetop, isDaemon);
+
+	handleException:
+	    if (CVMexceptionOccurred(ee)) {
+		CVMdumpException(ee);
+		CVMjniExceptionClear(env);
+		CVMdetachExecEnv(ee);
+		CVMdestroyExecEnv(ee);
+		CVMremoveThread(ee, ee->userThread);
+		free(ee);
+                return JNI_ERR;
+            }
+
+	    CVMassert(thread != NULL);
+
+	    CVMID_icellAssign(ee, CVMcurrentThreadICell(ee), thread);
+	    CVMjniDeleteLocalRef(env, thread);
+	}
+
+#ifdef CVM_JVMTI
+	if (CVMjvmtiIsEnabled()) {
+	    CVMjvmtiDebugEventsEnabled(ee) = CVM_TRUE;
+	}
+#endif
+	CVMpostThreadStartEvents(ee);
+
+#if defined(CVM_DEBUG) && defined(CVM_LVM) /* %begin lvm */
+	CVMLVMtraceAttachThread(ee);
+#endif /* %end lvm */
+
+	return JNI_OK;
+    }
+}
+
+static jint JNICALL
+CVMjniAttachCurrentThread(JavaVM *vm, void **penv, void *_args)
+{
+    return attachCurrentThread(vm, penv, _args, CVM_FALSE);
+}
+
+static jint JNICALL
+CVMjniDetachCurrentThread(JavaVM *vm)
+{
+    CVMExecEnv *ee = CVMgetEE();
+    if (ee == NULL) {
+	return JNI_EDETACHED;
+    } else {
+	/* %comment: rt031 */
+	JNIEnv *env = CVMexecEnv2JniEnv(ee);
+	jclass threadClass =
+	    CVMcbJavaInstance(CVMsystemClass(java_lang_Thread));
+	jobject thread = CVMcurrentThreadICell(ee);
+	jobject throwable = CVMjniExceptionOccurred(env);
+	CVMFrameIterator iter;
+	CVMFrame *frame;
+
+	/* Can't detach a thread with an active Java frame on it */
+	frame = CVMeeGetCurrentFrame(ee);
+	CVMframeIterateInit(&iter, frame);
+	while (CVMframeIterateNextReflection(&iter, CVM_FALSE)) {
+	    frame = CVMframeIterateGetFrame(&iter);
+	    if (CVMframeIsJava(frame) 
+#ifdef CVM_JIT
+		|| CVMframeIsCompiled(frame)
+#endif
+	    ) {
+		return JNI_ERR;
+	    }
+	}
+
+	CVMjniExceptionClear(env);
+
+	CVMpostThreadExitEvents(ee);
+#ifdef CVM_JVMTI
+	if (CVMjvmtiIsEnabled()) {
+	    CVMjvmtiDebugEventsEnabled(ee) = CVM_FALSE;
+	}
+#endif
+
+	CVMjniCallNonvirtualVoidMethod(
+            env, thread, threadClass,
+	    CVMglobals.java_lang_Thread_exit, throwable);
+
+#if defined(CVM_DEBUG) && defined(CVM_LVM) /* %begin lvm */
+	CVMLVMtraceDetachThread(ee);
+#endif /* %end lvm */
+
+	CVMjniDeleteLocalRef(env, throwable);
+
+	CVMdetachExecEnv(ee);
+	CVMdestroyExecEnv(ee);
+	CVMremoveThread(ee, ee->userThread);
+	if (ee != &CVMglobals.mainEE) {
+	    free(ee);
+	}
+	return JNI_OK;
+    }
+}
+
+
+static jint JNICALL
+CVMjniGetEnv(JavaVM *vm, void **penv, jint version)
+{
+    CVMExecEnv *ee = CVMgetEE();
+    if (ee != NULL) {
+	if (version == JNI_VERSION_1_1 || version == JNI_VERSION_1_2 ||
+	    version == JNI_VERSION_1_4) {
+	    *penv = (void *)CVMexecEnv2JniEnv(ee);
+	    return JNI_OK;
+#ifdef CVM_JVMPI
+        } else if (version == JVMPI_VERSION_1 ||
+                   version == JVMPI_VERSION_1_1) {
+            *penv = (void *)CVMjvmpiGetInterface1();
+            return JNI_OK;
+#endif /* CVM_JVMPI */
+
+#ifdef CVM_JVMTI
+        } else if (version == JVMTI_VERSION_1) {
+            return CVMjvmtiGetInterface(vm, penv);
+#endif /* CVM_JVMTI */
+#ifdef CVM_JVMTI_IOVEC
+        } else if (version == JVMIOVEC_VERSION_1) {
+            *penv = (void *)&CVMioFuncs;
+            return JNI_OK;
+#endif
+        } else {
+	    *penv = NULL;
+	    return JNI_EVERSION;
+        }
+    } else {
+	*penv = NULL;
+        return JNI_EDETACHED;
+    }
+}
+
+static jint JNICALL
+CVMjniAttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args)
+{
+    return attachCurrentThread(vm, penv, _args, CVM_TRUE);
+}
+
+static const struct JNIInvokeInterface CVMmainJVMfuncs = {
+    NULL,
+    NULL,
+    NULL,
+
+    CVMjniDestroyJavaVM,
+    CVMjniAttachCurrentThread,
+    CVMjniDetachCurrentThread,
+    CVMjniGetEnv,
+    /* JNI_VERSION_1_4 additions: */
+    CVMjniAttachCurrentThreadAsDaemon,
+};
+
+void
+CVMinitJNIEnv(CVMJNIEnv *p_env)
+{
+    p_env->vector = &CVMmainJNIfuncs;
+}
+
+void
+CVMdestroyJNIEnv(CVMJNIEnv *p_env)
+{
+}
+
+#ifdef CVM_JVMTI
+
+struct JNINativeInterface *
+CVMjniGetInstrumentableJNINativeInterface()
+{
+    return &CVMmainJNIfuncs;
+}
+
+#endif /* CVM_JVMTI */
+
+void
+CVMinitJNIJavaVM(CVMJNIJavaVM *p_javaVM)
+{
+    p_javaVM->vector = &CVMmainJVMfuncs;
+}
+
+void
+CVMdestroyJNIJavaVM(CVMJNIJavaVM *p_javaVM)
+{
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/javavm/test/Test.java phoneme_advanced-mr2-dev-b122/cdc/src/share/javavm/test/Test.java
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/javavm/test/Test.java	2009-07-06 18:36:55.000000000 -0400
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/javavm/test/Test.java	2009-07-06 19:25:13.000000000 -0400
@@ -664,6 +664,10 @@
 	assert0( Float.floatToIntBits(Float.MAX_VALUE) == expectedFloatMaxIntBits,
 	    "testFloatBits: Float.MAX_VALUE as int bits");
 
+	System.out.println("int bits "+Float.floatToIntBits(Float.MIN_VALUE));
+	System.out.println("float value "+Float.intBitsToFloat(1));
+	System.out.println("float value "+Float.intBitsToFloat(0x80000000));
+
 	assert0( Float.intBitsToFloat(Float.floatToIntBits(Float.MIN_VALUE))
 		== Float.MIN_VALUE, "FloatMIN (the two-way transformation)" );
 	assert0( Float.intBitsToFloat(Float.floatToIntBits(Float.MAX_VALUE))
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/native/java/nio/Bits.c phoneme_advanced-mr2-dev-b122/cdc/src/share/native/java/nio/Bits.c
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/native/java/nio/Bits.c	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/native/java/nio/Bits.c	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,427 @@
+/*
+ * Copyright 2002-2003 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jlong.h"
+#include <string.h>
+
+/*
+ * WARNING:
+ *
+ * Do not replace instances of:
+ *
+ *   if (length > MBYTE)
+ *     size = MBYTE;
+ *   else
+ *     size = length;
+ *
+ * with
+ *
+ *   size = (length > MBYTE ? MBYTE : length);
+ *
+ * This expression causes a c compiler assertion failure when compiling on
+ * 32-bit sparc.
+ */
+
+#define MBYTE 1048576
+
+#define GETCRITICAL(bytes, env, obj) { \
+    bytes = (*env)->GetPrimitiveArrayCritical(env, obj, NULL); \
+    if (bytes == NULL) \
+        JNU_ThrowInternalError(env, "Unable to get array"); \
+}
+
+#define RELEASECRITICAL(bytes, env, obj, mode) { \
+    (*env)->ReleasePrimitiveArrayCritical(env, obj, bytes, mode); \
+}
+
+#define SWAPSHORT(x) ((jshort)(((x) << 8) | (((x) >> 8) & 0xff)))
+#define SWAPINT(x)   ((jint)((SWAPSHORT((jshort)(x)) << 16) | \
+                            (SWAPSHORT((jshort)((x) >> 16)) & 0xffff)))
+#define SWAPLONG(x)  ((jlong)(((jlong)SWAPINT((jint)(x)) << 32) | \
+                              ((jlong)SWAPINT((jint)((x) >> 32)) & 0xffffffff)))
+
+JNIEXPORT void JNICALL
+Java_java_nio_Bits_copyFromByteArray(JNIEnv *env, jobject this, jobject src,
+                                     jlong srcPos, jlong dstAddr, jlong length)
+{
+    jbyte *bytes;
+    size_t size;
+
+    while (length > 0) {
+        size = (length > MBYTE ? MBYTE : length);
+
+        GETCRITICAL(bytes, env, src);
+        memcpy((void *)dstAddr, bytes + srcPos, size);
+        RELEASECRITICAL(bytes, env, src, JNI_ABORT);
+
+        length -= size;
+        dstAddr += size;
+        srcPos += size;
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_java_nio_Bits_copyToByteArray(JNIEnv *env, jobject this, jlong srcAddr,
+                                   jobject dst, jlong dstPos, jlong length)
+{
+    jbyte *bytes;
+    size_t size;
+
+    while (length > 0) {
+        size = (length > MBYTE ? MBYTE : length);
+
+        GETCRITICAL(bytes, env, dst);
+        memcpy(bytes + dstPos, (void *)srcAddr, size);
+        RELEASECRITICAL(bytes, env, dst, 0);
+
+        length -= size;
+        srcAddr += size;
+        dstPos += size;
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_java_nio_Bits_copyFromShortArray(JNIEnv *env, jobject this, jobject src,
+                                      jlong srcPos, jlong dstAddr, jlong length)
+{
+    jbyte *bytes;
+    size_t i, size;
+    jshort *srcShort, *dstShort, *endShort;
+    jshort tmpShort;
+
+    dstShort = (jshort *)jlong_to_ptr(dstAddr);
+
+    while (length > 0) {
+        /* do not change this if-else statement, see WARNING above */
+        if (length > MBYTE)
+            size = MBYTE;
+        else
+            size = length;
+
+        GETCRITICAL(bytes, env, src);
+
+        srcShort = (jshort *)(bytes + srcPos);
+        endShort = srcShort + (size / sizeof(jshort));
+        while (srcShort < endShort) {
+          tmpShort = *srcShort++;
+          *dstShort++ = SWAPSHORT(tmpShort);
+        }
+
+        RELEASECRITICAL(bytes, env, src, JNI_ABORT);
+
+        length -= size;
+        dstAddr += size;
+        srcPos += size;
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_java_nio_Bits_copyToShortArray(JNIEnv *env, jobject this, jlong srcAddr,
+                                    jobject dst, jlong dstPos, jlong length)
+{
+    jbyte *bytes;
+    size_t i, size;
+    jshort *srcShort, *dstShort, *endShort;
+    jshort tmpShort;
+
+    srcShort = (jshort *)jlong_to_ptr(srcAddr);
+
+    while (length > 0) {
+        /* do not change this if-else statement, see WARNING above */
+        if (length > MBYTE)
+            size = MBYTE;
+        else
+            size = length;
+
+        GETCRITICAL(bytes, env, dst);
+
+        dstShort = (jshort *)(bytes + dstPos);
+        endShort = srcShort + (size / sizeof(jshort));
+        while (srcShort < endShort) {
+            tmpShort = *srcShort++;
+            *dstShort++ = SWAPSHORT(tmpShort);
+        }
+
+        RELEASECRITICAL(bytes, env, dst, 0);
+
+        length -= size;
+        srcAddr += size;
+        dstPos += size;
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_java_nio_Bits_copyFromIntArray(JNIEnv *env, jobject this, jobject src,
+                                    jlong srcPos, jlong dstAddr, jlong length)
+{
+    jbyte *bytes;
+    size_t i, size;
+    jint *srcInt, *dstInt, *endInt;
+    jint tmpInt;
+
+    dstInt = (jint *)jlong_to_ptr(dstAddr);
+
+    while (length > 0) {
+        /* do not change this code, see WARNING above */
+        if (length > MBYTE)
+            size = MBYTE;
+        else
+            size = length;
+
+        GETCRITICAL(bytes, env, src);
+
+        srcInt = (jint *)(bytes + srcPos);
+        endInt = srcInt + (size / sizeof(jint));
+        while (srcInt < endInt) {
+            tmpInt = *srcInt++;
+            *dstInt++ = SWAPINT(tmpInt);
+        }
+
+        RELEASECRITICAL(bytes, env, src, JNI_ABORT);
+
+        length -= size;
+        dstAddr += size;
+        srcPos += size;
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_java_nio_Bits_copyToIntArray(JNIEnv *env, jobject this, jlong srcAddr,
+                                  jobject dst, jlong dstPos, jlong length)
+{
+    jbyte *bytes;
+    size_t i, size;
+    jint *srcInt, *dstInt, *endInt;
+    jint tmpInt;
+
+    srcInt = (jint *)jlong_to_ptr(srcAddr);
+
+    while (length > 0) {
+        /* do not change this code, see WARNING above */
+        if (length > MBYTE)
+            size = MBYTE;
+        else
+            size = length;
+
+        GETCRITICAL(bytes, env, dst);
+
+        dstInt = (jint *)(bytes + dstPos);
+        endInt = srcInt + (size / sizeof(jint));
+        while (srcInt < endInt) {
+            tmpInt = *srcInt++;
+            *dstInt++ = SWAPINT(tmpInt);
+        }
+
+        RELEASECRITICAL(bytes, env, dst, 0);
+
+        length -= size;
+        srcAddr += size;
+        dstPos += size;
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_java_nio_Bits_copyFromLongArray(JNIEnv *env, jobject this, jobject src,
+                                     jlong srcPos, jlong dstAddr, jlong length)
+{
+    jbyte *bytes;
+    size_t i, size;
+    jlong *srcLong, *dstLong, *endLong;
+    jlong tmpLong;
+
+    dstLong = (jlong *)jlong_to_ptr(dstAddr);
+
+    while (length > 0) {
+        /* do not change this code, see WARNING above */
+        if (length > MBYTE)
+            size = MBYTE;
+        else
+            size = length;
+
+        GETCRITICAL(bytes, env, src);
+
+        srcLong = (jlong *)(bytes + srcPos);
+        endLong = srcLong + (size / sizeof(jlong));
+        while (srcLong < endLong) {
+            tmpLong = *srcLong++;
+            *dstLong++ = SWAPLONG(tmpLong);
+        }
+
+        RELEASECRITICAL(bytes, env, src, JNI_ABORT);
+
+        length -= size;
+        dstAddr += size;
+        srcPos += size;
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_java_nio_Bits_copyToLongArray(JNIEnv *env, jobject this, jlong srcAddr,
+                                   jobject dst, jlong dstPos, jlong length)
+{
+    jbyte *bytes;
+    size_t i, size;
+    jlong *srcLong, *dstLong, *endLong;
+    jlong tmpLong;
+
+    srcLong = (jlong *)jlong_to_ptr(srcAddr);
+
+    while (length > 0) {
+        /* do not change this code, see WARNING above */
+        if (length > MBYTE)
+            size = MBYTE;
+        else
+            size = length;
+
+        GETCRITICAL(bytes, env, dst);
+
+        dstLong = (jlong *)(bytes + dstPos);
+        endLong = srcLong + (size / sizeof(jlong));
+        while (srcLong < endLong) {
+            tmpLong = *srcLong++;
+            *dstLong++ = SWAPLONG(tmpLong);
+        }
+
+        RELEASECRITICAL(bytes, env, dst, 0);
+
+        length -= size;
+        srcAddr += size;
+        dstPos += size;
+    }
+}
+
+JNIEXPORT jbyte JNICALL
+Java_sun_misc_Unsafe_getByte(JNIEnv *env, jobject this, jlong addr)
+{
+    return *((jbyte *)addr);
+}
+
+JNIEXPORT void JNICALL
+Java_sun_misc_Unsafe_putByte(JNIEnv *env, jobject this, jlong addr, jbyte x)
+{
+    *((jbyte *)addr)=x;
+}
+
+JNIEXPORT jshort JNICALL
+Java_sun_misc_Unsafe_getShort(JNIEnv *env, jobject this, jlong addr)
+{
+    return *((jshort *)addr);
+}
+
+JNIEXPORT void JNICALL
+Java_sun_misc_Unsafe_putShort(JNIEnv *env, jobject this, jlong addr, jshort x)
+{
+    *((jshort *)addr)=x;
+}
+
+JNIEXPORT jchar JNICALL
+Java_sun_misc_Unsafe_getChar(JNIEnv *env, jobject this, jlong addr)
+{
+    return *((jchar *)addr);
+}
+
+JNIEXPORT void JNICALL
+Java_sun_misc_Unsafe_putChar(JNIEnv *env, jobject this, jlong addr, jchar x)
+{
+    *((jchar *)addr)=x;
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_misc_Unsafe_getInt(JNIEnv *env, jobject this, jlong addr)
+{
+    return *((jint *)addr);
+}
+
+JNIEXPORT void JNICALL
+Java_sun_misc_Unsafe_putInt(JNIEnv *env, jobject this, jlong addr, jint x)
+{
+    *((jint *)addr)=x;
+}
+
+JNIEXPORT jlong JNICALL
+Java_sun_misc_Unsafe_getLong(JNIEnv *env, jobject this, jlong addr)
+{
+    return *((jlong *)addr);
+}
+
+JNIEXPORT void JNICALL
+Java_sun_misc_Unsafe_putLong(JNIEnv *env, jobject this, jlong addr, jlong x)
+{
+    *((jlong *)addr)=x;
+}
+
+JNIEXPORT jlong JNICALL
+Java_sun_misc_Unsafe_allocateMemory(JNIEnv *env, jobject this, jlong bytes)
+{
+    jlong output;
+    output=malloc(bytes);
+    if(output==0)
+    {
+        (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed allocating memory");
+        return output;
+    }
+    return output;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_misc_Unsafe_setMemory(JNIEnv *env, jobject this, jlong address, jlong bytes, jbyte value)
+{
+    memset(address, value, bytes);
+}
+
+JNIEXPORT void JNICALL
+Java_sun_misc_Unsafe_copyMemory(JNIEnv *env, jobject this, jlong src, jlong dst, jlong bytes)
+{
+    memcpy(dst, src, bytes);
+}
+
+JNIEXPORT void JNICALL
+Java_sun_misc_Unsafe_freeMemory(JNIEnv *env, jobject this, jlong addr)
+{
+    free(addr);
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_misc_Unsafe_addressSize(JNIEnv *env, jobject this)
+{
+    return 4;
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_misc_Unsafe_pageSize(JNIEnv *env, jobject this)
+{
+    return 4096;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_misc_Unsafe_registerNatives(JNIEnv *env, jclass c)
+{
+    return;
+}
diff -x '*.zip' -Naur phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/native/sun/nio/ch/nio.h phoneme_advanced-mr2-dev-b122/cdc/src/share/native/sun/nio/ch/nio.h
--- phoneme_advanced-mr2-dev-b122-ori/cdc/src/share/native/sun/nio/ch/nio.h	1969-12-31 19:00:00.000000000 -0500
+++ phoneme_advanced-mr2-dev-b122/cdc/src/share/native/sun/nio/ch/nio.h	2009-07-06 19:25:13.000000000 -0400
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2002-2003 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "sun_nio_ch_IOStatus.h"
+
+#define IOS_EOF              (sun_nio_ch_IOStatus_EOF)
+#define IOS_UNAVAILABLE      (sun_nio_ch_IOStatus_UNAVAILABLE)
+#define IOS_INTERRUPTED      (sun_nio_ch_IOStatus_INTERRUPTED)
+#define IOS_UNSUPPORTED      (sun_nio_ch_IOStatus_UNSUPPORTED)
+#define IOS_THROWN           (sun_nio_ch_IOStatus_THROWN)
+#define IOS_UNSUPPORTED_CASE (sun_nio_ch_IOStatus_UNSUPPORTED_CASE)
